
obj/net/ns:     file format elf32-i386

Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 03 08 00 00       	call   800834 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
	...

00800040 <put_buffer>:

	return va;
}

static void
put_buffer(void *va) {
  800040:	55                   	push   %ebp
  800041:	89 e5                	mov    %esp,%ebp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  800043:	2d 00 b0 fe 0f       	sub    $0xffeb000,%eax
  800048:	c1 e8 0c             	shr    $0xc,%eax
  80004b:	c7 04 85 80 83 81 00 	movl   $0x0,0x818380(,%eax,4)
  800052:	00 00 00 00 
}
  800056:	5d                   	pop    %ebp
  800057:	c3                   	ret    

00800058 <umain>:
	serve();
}

void
umain(void)
{
  800058:	55                   	push   %ebp
  800059:	89 e5                	mov    %esp,%ebp
  80005b:	53                   	push   %ebx
  80005c:	83 ec 14             	sub    $0x14,%esp
	envid_t ns_envid = sys_getenvid();
  80005f:	e8 49 17 00 00       	call   8017ad <sys_getenvid>
  800064:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800066:	c7 05 00 80 81 00 80 	movl   $0x812080,0x818000
  80006d:	20 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800070:	e8 14 1c 00 00       	call   801c89 <fork>
  800075:	a3 64 83 81 00       	mov    %eax,0x818364
	if (timer_envid < 0)
  80007a:	85 c0                	test   %eax,%eax
  80007c:	79 1c                	jns    80009a <umain+0x42>
		panic("error forking");
  80007e:	c7 44 24 08 83 20 81 	movl   $0x812083,0x8(%esp)
  800085:	00 
  800086:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  80008d:	00 
  80008e:	c7 04 24 91 20 81 00 	movl   $0x812091,(%esp)
  800095:	e8 12 08 00 00       	call   8008ac <_panic>
	else if (timer_envid == 0) {
  80009a:	85 c0                	test   %eax,%eax
  80009c:	75 15                	jne    8000b3 <umain+0x5b>
		timer(ns_envid, TIMER_INTERVAL);
  80009e:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  8000a5:	00 
  8000a6:	89 1c 24             	mov    %ebx,(%esp)
  8000a9:	e8 d2 06 00 00       	call   800780 <timer>
  8000ae:	e9 a3 00 00 00       	jmp    800156 <umain+0xfe>
		return;
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8000b3:	e8 d1 1b 00 00       	call   801c89 <fork>
  8000b8:	a3 68 83 81 00       	mov    %eax,0x818368
	if (input_envid < 0)
  8000bd:	85 c0                	test   %eax,%eax
  8000bf:	79 1c                	jns    8000dd <umain+0x85>
		panic("error forking");
  8000c1:	c7 44 24 08 83 20 81 	movl   $0x812083,0x8(%esp)
  8000c8:	00 
  8000c9:	c7 44 24 04 4d 01 00 	movl   $0x14d,0x4(%esp)
  8000d0:	00 
  8000d1:	c7 04 24 91 20 81 00 	movl   $0x812091,(%esp)
  8000d8:	e8 cf 07 00 00       	call   8008ac <_panic>
	else if (input_envid == 0) {
  8000dd:	85 c0                	test   %eax,%eax
  8000df:	75 0a                	jne    8000eb <umain+0x93>
		input(ns_envid);
  8000e1:	89 1c 24             	mov    %ebx,(%esp)
  8000e4:	e8 2b 07 00 00       	call   800814 <input>
  8000e9:	eb 6b                	jmp    800156 <umain+0xfe>
		return;
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8000eb:	90                   	nop    
  8000ec:	8d 74 26 00          	lea    0x0(%esi),%esi
  8000f0:	e8 94 1b 00 00       	call   801c89 <fork>
  8000f5:	a3 6c 83 81 00       	mov    %eax,0x81836c
	if (output_envid < 0)
  8000fa:	85 c0                	test   %eax,%eax
  8000fc:	79 1c                	jns    80011a <umain+0xc2>
		panic("error forking");
  8000fe:	c7 44 24 08 83 20 81 	movl   $0x812083,0x8(%esp)
  800105:	00 
  800106:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
  80010d:	00 
  80010e:	c7 04 24 91 20 81 00 	movl   $0x812091,(%esp)
  800115:	e8 92 07 00 00       	call   8008ac <_panic>
	else if (output_envid == 0) {
  80011a:	85 c0                	test   %eax,%eax
  80011c:	75 0a                	jne    800128 <umain+0xd0>
		output(ns_envid);
  80011e:	89 1c 24             	mov    %ebx,(%esp)
  800121:	e8 fe 06 00 00       	call   800824 <output>
  800126:	eb 2e                	jmp    800156 <umain+0xfe>
		return;
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization. 
	thread_init();
  800128:	e8 23 d9 00 00       	call   80da50 <thread_init>
	thread_create(0, "main", tmain, 0);
  80012d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800134:	00 
  800135:	c7 44 24 08 0d 07 80 	movl   $0x80070d,0x8(%esp)
  80013c:	00 
  80013d:	c7 44 24 04 9c 20 81 	movl   $0x81209c,0x4(%esp)
  800144:	00 
  800145:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80014c:	e8 e3 da 00 00       	call   80dc34 <thread_create>
	thread_yield();
  800151:	e8 a2 d9 00 00       	call   80daf8 <thread_yield>
	// never coming here!
}
  800156:	83 c4 14             	add    $0x14,%esp
  800159:	5b                   	pop    %ebx
  80015a:	5d                   	pop    %ebp
  80015b:	c3                   	ret    

0080015c <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  80015c:	55                   	push   %ebp
  80015d:	89 e5                	mov    %esp,%ebp
  80015f:	57                   	push   %edi
  800160:	56                   	push   %esi
  800161:	53                   	push   %ebx
  800162:	83 ec 2c             	sub    $0x2c,%esp
  800165:	bb 00 00 00 00       	mov    $0x0,%ebx
  80016a:	eb 08                	jmp    800174 <serve+0x18>
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();
  80016c:	e8 87 d9 00 00       	call   80daf8 <thread_yield>
	
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800171:	83 c3 01             	add    $0x1,%ebx
  800174:	e8 28 d9 00 00       	call   80daa1 <thread_wakeups_pending>
  800179:	85 c0                	test   %eax,%eax
  80017b:	74 05                	je     800182 <serve+0x26>
  80017d:	83 fb 1f             	cmp    $0x1f,%ebx
  800180:	7e ea                	jle    80016c <serve+0x10>
			thread_yield();

		perm = 0;
  800182:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  800189:	ba 00 00 00 00       	mov    $0x0,%edx
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
		if (!buse[i]) break;
  80018e:	83 3c 95 80 83 81 00 	cmpl   $0x0,0x818380(,%edx,4)
  800195:	00 
  800196:	74 0a                	je     8001a2 <serve+0x46>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  800198:	83 c2 01             	add    $0x1,%edx
  80019b:	83 fa 14             	cmp    $0x14,%edx
  80019e:	74 07                	je     8001a7 <serve+0x4b>
  8001a0:	eb ec                	jmp    80018e <serve+0x32>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  8001a2:	83 fa 14             	cmp    $0x14,%edx
  8001a5:	75 1c                	jne    8001c3 <serve+0x67>
		panic("NS: buffer overflow");
  8001a7:	c7 44 24 08 a1 20 81 	movl   $0x8120a1,0x8(%esp)
  8001ae:	00 
  8001af:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%esp)
  8001b6:	00 
  8001b7:	c7 04 24 91 20 81 00 	movl   $0x812091,(%esp)
  8001be:	e8 e9 06 00 00       	call   8008ac <_panic>
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  8001c3:	89 d0                	mov    %edx,%eax
  8001c5:	c1 e0 0c             	shl    $0xc,%eax
  8001c8:	8d b0 00 b0 fe 0f    	lea    0xffeb000(%eax),%esi
	buse[i] = 1;
  8001ce:	c7 04 95 80 83 81 00 	movl   $0x1,0x818380(,%edx,4)
  8001d5:	01 00 00 00 
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8001d9:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8001dc:	89 44 24 08          	mov    %eax,0x8(%esp)
  8001e0:	89 74 24 04          	mov    %esi,0x4(%esp)
  8001e4:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8001e7:	89 04 24             	mov    %eax,(%esp)
  8001ea:	e8 55 1c 00 00       	call   801e44 <ipc_recv>
  8001ef:	89 c3                	mov    %eax,%ebx
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  8001f1:	83 f8 0c             	cmp    $0xc,%eax
  8001f4:	75 69                	jne    80025f <serve+0x103>
			process_timer(whom);
  8001f6:	8b 5d f0             	mov    -0x10(%ebp),%ebx

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  8001f9:	3b 1d 64 83 81 00    	cmp    0x818364,%ebx
  8001ff:	74 12                	je     800213 <serve+0xb7>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800201:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  800205:	c7 04 24 30 21 81 00 	movl   $0x812130,(%esp)
  80020c:	e8 68 07 00 00       	call   800979 <cprintf>
  800211:	eb 3b                	jmp    80024e <serve+0xf2>
		return;
	}

	start = sys_time_msec();
  800213:	e8 63 12 00 00       	call   80147b <sys_time_msec>
  800218:	89 c7                	mov    %eax,%edi
	thread_yield();
  80021a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  800220:	e8 d3 d8 00 00       	call   80daf8 <thread_yield>
	now = sys_time_msec();
  800225:	e8 51 12 00 00       	call   80147b <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  80022a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800231:	00 
  800232:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800239:	00 
  80023a:	29 c7                	sub    %eax,%edi
  80023c:	8d 87 fa 00 00 00    	lea    0xfa(%edi),%eax
  800242:	89 44 24 04          	mov    %eax,0x4(%esp)
  800246:	89 1c 24             	mov    %ebx,(%esp)
  800249:	e8 42 1b 00 00       	call   801d90 <ipc_send>
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
  80024e:	89 f0                	mov    %esi,%eax
  800250:	e8 eb fd ff ff       	call   800040 <put_buffer>
  800255:	bb 00 00 00 00       	mov    $0x0,%ebx
  80025a:	e9 15 ff ff ff       	jmp    800174 <serve+0x18>
			continue;
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  80025f:	f6 45 ec 01          	testb  $0x1,-0x14(%ebp)
  800263:	75 1d                	jne    800282 <serve+0x126>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800265:	8b 45 f0             	mov    -0x10(%ebp),%eax
  800268:	89 44 24 04          	mov    %eax,0x4(%esp)
  80026c:	c7 04 24 6c 21 81 00 	movl   $0x81216c,(%esp)
  800273:	e8 01 07 00 00       	call   800979 <cprintf>
  800278:	bb 00 00 00 00       	mov    $0x0,%ebx
  80027d:	e9 f2 fe ff ff       	jmp    800174 <serve+0x18>
			continue; // just leave it hanging...
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  800282:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  800289:	e8 26 2b 00 00       	call   802db4 <malloc>
  80028e:	89 c2                	mov    %eax,%edx
		if (!args)
  800290:	85 c0                	test   %eax,%eax
  800292:	75 1c                	jne    8002b0 <serve+0x154>
			panic("could not allocate thread args structure");
  800294:	c7 44 24 08 9c 21 81 	movl   $0x81219c,0x8(%esp)
  80029b:	00 
  80029c:	c7 44 24 04 26 01 00 	movl   $0x126,0x4(%esp)
  8002a3:	00 
  8002a4:	c7 04 24 91 20 81 00 	movl   $0x812091,(%esp)
  8002ab:	e8 fc 05 00 00       	call   8008ac <_panic>

		args->reqno = reqno;
  8002b0:	89 18                	mov    %ebx,(%eax)
		args->whom = whom;
  8002b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8002b5:	89 42 04             	mov    %eax,0x4(%edx)
		args->req = va;
  8002b8:	89 72 08             	mov    %esi,0x8(%edx)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8002bb:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8002bf:	c7 44 24 08 ea 02 80 	movl   $0x8002ea,0x8(%esp)
  8002c6:	00 
  8002c7:	c7 44 24 04 b5 20 81 	movl   $0x8120b5,0x4(%esp)
  8002ce:	00 
  8002cf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8002d6:	e8 59 d9 00 00       	call   80dc34 <thread_create>
		thread_yield(); // let the thread created run
  8002db:	e8 18 d8 00 00       	call   80daf8 <thread_yield>
  8002e0:	bb 00 00 00 00       	mov    $0x0,%ebx
  8002e5:	e9 8a fe ff ff       	jmp    800174 <serve+0x18>

008002ea <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8002ea:	55                   	push   %ebp
  8002eb:	89 e5                	mov    %esp,%ebp
  8002ed:	81 ec 98 00 00 00    	sub    $0x98,%esp
  8002f3:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8002f6:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8002f9:	89 7d fc             	mov    %edi,-0x4(%ebp)
	struct st_args *args = (struct st_args *)a;
  8002fc:	8b 7d 08             	mov    0x8(%ebp),%edi
	union Nsipc *req = args->req;
  8002ff:	8b 77 08             	mov    0x8(%edi),%esi
	int r;

	switch (args->reqno) {
  800302:	83 3f 0a             	cmpl   $0xa,(%edi)
  800305:	0f 87 34 01 00 00    	ja     80043f <serve_thread+0x155>
  80030b:	8b 07                	mov    (%edi),%eax
  80030d:	ff 24 85 68 22 81 00 	jmp    *0x812268(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  800314:	8d 45 a0             	lea    -0x60(%ebp),%eax
  800317:	89 44 24 08          	mov    %eax,0x8(%esp)
  80031b:	8d 45 90             	lea    -0x70(%ebp),%eax
  80031e:	89 44 24 04          	mov    %eax,0x4(%esp)
  800322:	8b 06                	mov    (%esi),%eax
  800324:	89 04 24             	mov    %eax,(%esp)
  800327:	e8 a6 45 00 00       	call   8048d2 <lwip_accept>
  80032c:	89 c3                	mov    %eax,%ebx
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  80032e:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  800335:	00 
  800336:	8d 45 90             	lea    -0x70(%ebp),%eax
  800339:	89 44 24 04          	mov    %eax,0x4(%esp)
  80033d:	89 34 24             	mov    %esi,(%esp)
  800340:	e8 a3 0e 00 00       	call   8011e8 <memmove>
  800345:	e9 13 01 00 00       	jmp    80045d <serve_thread+0x173>
		break;
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  80034a:	8b 46 14             	mov    0x14(%esi),%eax
  80034d:	89 44 24 08          	mov    %eax,0x8(%esp)
  800351:	8d 46 04             	lea    0x4(%esi),%eax
  800354:	89 44 24 04          	mov    %eax,0x4(%esp)
  800358:	8b 06                	mov    (%esi),%eax
  80035a:	89 04 24             	mov    %eax,(%esp)
  80035d:	e8 b7 44 00 00       	call   804819 <lwip_bind>
  800362:	89 c3                	mov    %eax,%ebx
  800364:	e9 f4 00 00 00       	jmp    80045d <serve_thread+0x173>
			      req->bind.req_namelen);
		break;
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800369:	8b 46 04             	mov    0x4(%esi),%eax
  80036c:	89 44 24 04          	mov    %eax,0x4(%esp)
  800370:	8b 06                	mov    (%esi),%eax
  800372:	89 04 24             	mov    %eax,(%esp)
  800375:	e8 49 43 00 00       	call   8046c3 <lwip_shutdown>
  80037a:	89 c3                	mov    %eax,%ebx
  80037c:	e9 dc 00 00 00       	jmp    80045d <serve_thread+0x173>
		break;
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  800381:	8b 06                	mov    (%esi),%eax
  800383:	89 04 24             	mov    %eax,(%esp)
  800386:	e8 bc 42 00 00       	call   804647 <lwip_close>
  80038b:	89 c3                	mov    %eax,%ebx
  80038d:	e9 cb 00 00 00       	jmp    80045d <serve_thread+0x173>
		break;
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  800392:	8b 46 14             	mov    0x14(%esi),%eax
  800395:	89 44 24 08          	mov    %eax,0x8(%esp)
  800399:	8d 46 04             	lea    0x4(%esi),%eax
  80039c:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003a0:	8b 06                	mov    (%esi),%eax
  8003a2:	89 04 24             	mov    %eax,(%esp)
  8003a5:	e8 b6 43 00 00       	call   804760 <lwip_connect>
  8003aa:	89 c3                	mov    %eax,%ebx
  8003ac:	e9 ac 00 00 00       	jmp    80045d <serve_thread+0x173>
				 req->connect.req_namelen);
		break;
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8003b1:	8b 46 04             	mov    0x4(%esi),%eax
  8003b4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003b8:	8b 06                	mov    (%esi),%eax
  8003ba:	89 04 24             	mov    %eax,(%esp)
  8003bd:	e8 14 43 00 00       	call   8046d6 <lwip_listen>
  8003c2:	89 c3                	mov    %eax,%ebx
  8003c4:	e9 94 00 00 00       	jmp    80045d <serve_thread+0x173>
		break;
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8003c9:	8b 46 08             	mov    0x8(%esi),%eax
  8003cc:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003d0:	8b 46 04             	mov    0x4(%esi),%eax
  8003d3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003d7:	89 74 24 04          	mov    %esi,0x4(%esp)
  8003db:	8b 06                	mov    (%esi),%eax
  8003dd:	89 04 24             	mov    %eax,(%esp)
  8003e0:	e8 f1 41 00 00       	call   8045d6 <lwip_recv>
  8003e5:	89 c3                	mov    %eax,%ebx
  8003e7:	eb 74                	jmp    80045d <serve_thread+0x173>
			      req->recv.req_len, req->recv.req_flags);
		break;
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8003e9:	8b 46 08             	mov    0x8(%esi),%eax
  8003ec:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003f0:	8b 46 04             	mov    0x4(%esi),%eax
  8003f3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003f7:	8d 46 0c             	lea    0xc(%esi),%eax
  8003fa:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003fe:	8b 06                	mov    (%esi),%eax
  800400:	89 04 24             	mov    %eax,(%esp)
  800403:	e8 34 3d 00 00       	call   80413c <lwip_send>
  800408:	89 c3                	mov    %eax,%ebx
  80040a:	eb 51                	jmp    80045d <serve_thread+0x173>
			      req->send.req_size, req->send.req_flags);
		break;
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  80040c:	8b 46 08             	mov    0x8(%esi),%eax
  80040f:	89 44 24 08          	mov    %eax,0x8(%esp)
  800413:	8b 46 04             	mov    0x4(%esi),%eax
  800416:	89 44 24 04          	mov    %eax,0x4(%esp)
  80041a:	8b 06                	mov    (%esi),%eax
  80041c:	89 04 24             	mov    %eax,(%esp)
  80041f:	e8 2e 3c 00 00       	call   804052 <lwip_socket>
  800424:	89 c3                	mov    %eax,%ebx
  800426:	eb 35                	jmp    80045d <serve_thread+0x173>
				req->socket.req_protocol);
		break;
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  800428:	89 74 24 04          	mov    %esi,0x4(%esp)
  80042c:	c7 04 24 80 e5 b3 00 	movl   $0xb3e580,(%esp)
  800433:	e8 49 dc 00 00       	call   80e081 <jif_input>
  800438:	bb 00 00 00 00       	mov    $0x0,%ebx
  80043d:	eb 4c                	jmp    80048b <serve_thread+0x1a1>
		r = 0;
		break;
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80043f:	89 74 24 08          	mov    %esi,0x8(%esp)
  800443:	8b 47 04             	mov    0x4(%edi),%eax
  800446:	89 44 24 04          	mov    %eax,0x4(%esp)
  80044a:	c7 04 24 c8 21 81 00 	movl   $0x8121c8,(%esp)
  800451:	e8 23 05 00 00       	call   800979 <cprintf>
  800456:	bb fd ff ff ff       	mov    $0xfffffffd,%ebx
  80045b:	eb 2e                	jmp    80048b <serve_thread+0x1a1>
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  80045d:	83 fb ff             	cmp    $0xffffffff,%ebx
  800460:	75 29                	jne    80048b <serve_thread+0x1a1>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800462:	8b 07                	mov    (%edi),%eax
  800464:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800468:	c7 44 24 08 c2 20 81 	movl   $0x8120c2,0x8(%esp)
  80046f:	00 
  800470:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  800477:	00 
  800478:	8d 75 90             	lea    -0x70(%ebp),%esi
  80047b:	89 34 24             	mov    %esi,(%esp)
  80047e:	e8 b7 0a 00 00       	call   800f3a <snprintf>
		perror(buf);
  800483:	89 34 24             	mov    %esi,(%esp)
  800486:	e8 bc d9 00 00       	call   80de47 <perror>
	}

	if (args->reqno != NSREQ_INPUT)
  80048b:	83 3f 0a             	cmpl   $0xa,(%edi)
  80048e:	74 1f                	je     8004af <serve_thread+0x1c5>
		ipc_send(args->whom, r, 0, 0);
  800490:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800497:	00 
  800498:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80049f:	00 
  8004a0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8004a4:	8b 47 04             	mov    0x4(%edi),%eax
  8004a7:	89 04 24             	mov    %eax,(%esp)
  8004aa:	e8 e1 18 00 00       	call   801d90 <ipc_send>

	put_buffer(args->req);
  8004af:	8b 47 08             	mov    0x8(%edi),%eax
  8004b2:	e8 89 fb ff ff       	call   800040 <put_buffer>
	sys_page_unmap(0, (void*) args->req);
  8004b7:	8b 47 08             	mov    0x8(%edi),%eax
  8004ba:	89 44 24 04          	mov    %eax,0x4(%esp)
  8004be:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8004c5:	e8 94 11 00 00       	call   80165e <sys_page_unmap>
	free(args);
  8004ca:	89 3c 24             	mov    %edi,(%esp)
  8004cd:	e8 0e 28 00 00       	call   802ce0 <free>
}
  8004d2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8004d5:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8004d8:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8004db:	89 ec                	mov    %ebp,%esp
  8004dd:	5d                   	pop    %ebp
  8004de:	c3                   	ret    

008004df <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  8004df:	55                   	push   %ebp
  8004e0:	89 e5                	mov    %esp,%ebp
  8004e2:	56                   	push   %esi
  8004e3:	53                   	push   %ebx
  8004e4:	83 ec 10             	sub    $0x10,%esp
	struct timer_thread *t = (struct timer_thread *) arg;
  8004e7:	8b 75 08             	mov    0x8(%ebp),%esi

	for (;;) {
		uint32_t cur = sys_time_msec();
  8004ea:	e8 8c 0f 00 00       	call   80147b <sys_time_msec>
  8004ef:	89 c3                	mov    %eax,%ebx

		lwip_core_lock();
  8004f1:	e8 80 cc 00 00       	call   80d176 <lwip_core_lock>
		t->func();
  8004f6:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8004f9:	e8 7d cc 00 00       	call   80d17b <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  8004fe:	89 d8                	mov    %ebx,%eax
  800500:	03 06                	add    (%esi),%eax
  800502:	89 44 24 08          	mov    %eax,0x8(%esp)
  800506:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80050d:	00 
  80050e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800515:	e8 64 d8 00 00       	call   80dd7e <thread_wait>
  80051a:	eb ce                	jmp    8004ea <net_timer+0xb>

0080051c <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  80051c:	55                   	push   %ebp
  80051d:	89 e5                	mov    %esp,%ebp
  80051f:	53                   	push   %ebx
  800520:	83 ec 14             	sub    $0x14,%esp
	t->msec = msec;
  800523:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800526:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800528:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  80052b:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80052e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800532:	c7 44 24 08 df 04 80 	movl   $0x8004df,0x8(%esp)
  800539:	00 
  80053a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80053e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800545:	e8 ea d6 00 00       	call   80dc34 <thread_create>
	if (r < 0)
  80054a:	85 c0                	test   %eax,%eax
  80054c:	79 28                	jns    800576 <start_timer+0x5a>
		panic("cannot create timer thread: %s", e2s(r));
  80054e:	89 04 24             	mov    %eax,(%esp)
  800551:	e8 e2 d8 00 00       	call   80de38 <e2s>
  800556:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80055a:	c7 44 24 08 ec 21 81 	movl   $0x8121ec,0x8(%esp)
  800561:	00 
  800562:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  800569:	00 
  80056a:	c7 04 24 91 20 81 00 	movl   $0x812091,(%esp)
  800571:	e8 36 03 00 00       	call   8008ac <_panic>
}
  800576:	83 c4 14             	add    $0x14,%esp
  800579:	5b                   	pop    %ebx
  80057a:	5d                   	pop    %ebp
  80057b:	c3                   	ret    

0080057c <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  80057c:	55                   	push   %ebp
  80057d:	89 e5                	mov    %esp,%ebp
  80057f:	57                   	push   %edi
  800580:	56                   	push   %esi
  800581:	53                   	push   %ebx
  800582:	83 ec 3c             	sub    $0x3c,%esp
  800585:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  800588:	e8 e9 cb 00 00       	call   80d176 <lwip_core_lock>

	uint32_t done = 0;
  80058d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800594:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  800597:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80059b:	c7 04 24 60 07 80 00 	movl   $0x800760,(%esp)
  8005a2:	e8 2c 45 00 00       	call   804ad3 <tcpip_init>
	lwip_core_unlock();
  8005a7:	e8 cf cb 00 00       	call   80d17b <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8005ac:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  8005b3:	ff 
  8005b4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8005bb:	00 
  8005bc:	89 1c 24             	mov    %ebx,(%esp)
  8005bf:	e8 ba d7 00 00       	call   80dd7e <thread_wait>
	lwip_core_lock();
  8005c4:	e8 ad cb 00 00       	call   80d176 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  8005c9:	89 75 ec             	mov    %esi,-0x14(%ebp)
	netmask.addr = init_mask;
  8005cc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8005cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	gateway.addr = init_gw;
  8005d2:	8b 45 10             	mov    0x10(%ebp),%eax
  8005d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8005d8:	c7 44 24 18 6e 97 80 	movl   $0x80976e,0x18(%esp)
  8005df:	00 
  8005e0:	c7 44 24 14 80 de 80 	movl   $0x80de80,0x14(%esp)
  8005e7:	00 
  8005e8:	c7 44 24 10 6c 83 81 	movl   $0x81836c,0x10(%esp)
  8005ef:	00 
  8005f0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8005f3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8005f7:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8005fa:	89 44 24 08          	mov    %eax,0x8(%esp)
  8005fe:	8d 45 ec             	lea    -0x14(%ebp),%eax
  800601:	89 44 24 04          	mov    %eax,0x4(%esp)
  800605:	c7 04 24 80 e5 b3 00 	movl   $0xb3e580,(%esp)
  80060c:	e8 8c 6f 00 00       	call   80759d <netif_add>
  800611:	85 c0                	test   %eax,%eax
  800613:	75 1c                	jne    800631 <serve_init+0xb5>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  800615:	c7 44 24 08 0c 22 81 	movl   $0x81220c,0x8(%esp)
  80061c:	00 
  80061d:	c7 44 24 04 5c 00 00 	movl   $0x5c,0x4(%esp)
  800624:	00 
  800625:	c7 04 24 91 20 81 00 	movl   $0x812091,(%esp)
  80062c:	e8 7b 02 00 00       	call   8008ac <_panic>

	netif_set_default(nif);
  800631:	c7 04 24 80 e5 b3 00 	movl   $0xb3e580,(%esp)
  800638:	e8 e7 6d 00 00       	call   807424 <netif_set_default>
	netif_set_up(nif);
  80063d:	c7 04 24 80 e5 b3 00 	movl   $0xb3e580,(%esp)
  800644:	e8 64 6e 00 00       	call   8074ad <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  800649:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800650:	b9 d1 20 81 00       	mov    $0x8120d1,%ecx
  800655:	ba ca cd 80 00       	mov    $0x80cdca,%edx
  80065a:	b8 40 83 81 00       	mov    $0x818340,%eax
  80065f:	e8 b8 fe ff ff       	call   80051c <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800664:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80066b:	b9 db 20 81 00       	mov    $0x8120db,%ecx
  800670:	ba 38 85 80 00       	mov    $0x808538,%edx
  800675:	b8 4c 83 81 00       	mov    $0x81834c,%eax
  80067a:	e8 9d fe ff ff       	call   80051c <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  80067f:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  800686:	b9 e7 20 81 00       	mov    $0x8120e7,%ecx
  80068b:	ba 6d 8e 80 00       	mov    $0x808e6d,%edx
  800690:	b8 58 83 81 00       	mov    $0x818358,%eax
  800695:	e8 82 fe ff ff       	call   80051c <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x" 
  80069a:	89 34 24             	mov    %esi,(%esp)
  80069d:	e8 3e a1 00 00       	call   80a7e0 <inet_ntoa>
  8006a2:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  8006a6:	0f b6 15 aa e5 b3 00 	movzbl 0xb3e5aa,%edx
  8006ad:	0f b6 0d a9 e5 b3 00 	movzbl 0xb3e5a9,%ecx
  8006b4:	0f b6 1d a8 e5 b3 00 	movzbl 0xb3e5a8,%ebx
  8006bb:	0f b6 35 a7 e5 b3 00 	movzbl 0xb3e5a7,%esi
  8006c2:	0f b6 3d a6 e5 b3 00 	movzbl 0xb3e5a6,%edi
  8006c9:	0f b6 05 a5 e5 b3 00 	movzbl 0xb3e5a5,%eax
  8006d0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8006d4:	89 54 24 18          	mov    %edx,0x18(%esp)
  8006d8:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  8006dc:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  8006e0:	89 74 24 0c          	mov    %esi,0xc(%esp)
  8006e4:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8006e8:	c7 04 24 2c 22 81 00 	movl   $0x81222c,(%esp)
  8006ef:	e8 85 02 00 00       	call   800979 <cprintf>
		" bound to static IP %s\n", 
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  8006f4:	e8 82 ca 00 00       	call   80d17b <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  8006f9:	c7 04 24 f3 20 81 00 	movl   $0x8120f3,(%esp)
  800700:	e8 74 02 00 00       	call   800979 <cprintf>
}
  800705:	83 c4 3c             	add    $0x3c,%esp
  800708:	5b                   	pop    %ebx
  800709:	5e                   	pop    %esi
  80070a:	5f                   	pop    %edi
  80070b:	5d                   	pop    %ebp
  80070c:	c3                   	ret    

0080070d <tmain>:
		thread_yield(); // let the thread created run
	}
}

static void
tmain(uint32_t arg) {
  80070d:	55                   	push   %ebp
  80070e:	89 e5                	mov    %esp,%ebp
  800710:	83 ec 18             	sub    $0x18,%esp
  800713:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  800716:	89 75 fc             	mov    %esi,-0x4(%ebp)
	serve_init(inet_addr(IP),
  800719:	c7 04 24 0c 21 81 00 	movl   $0x81210c,(%esp)
  800720:	e8 a9 a3 00 00       	call   80aace <inet_addr>
  800725:	89 c6                	mov    %eax,%esi
  800727:	c7 04 24 15 21 81 00 	movl   $0x812115,(%esp)
  80072e:	e8 9b a3 00 00       	call   80aace <inet_addr>
  800733:	89 c3                	mov    %eax,%ebx
  800735:	c7 04 24 23 21 81 00 	movl   $0x812123,(%esp)
  80073c:	e8 8d a3 00 00       	call   80aace <inet_addr>
  800741:	89 74 24 08          	mov    %esi,0x8(%esp)
  800745:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  800749:	89 04 24             	mov    %eax,(%esp)
  80074c:	e8 2b fe ff ff       	call   80057c <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800751:	e8 06 fa ff ff       	call   80015c <serve>
}
  800756:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  800759:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80075c:	89 ec                	mov    %ebp,%esp
  80075e:	5d                   	pop    %ebp
  80075f:	c3                   	ret    

00800760 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800760:	55                   	push   %ebp
  800761:	89 e5                	mov    %esp,%ebp
  800763:	83 ec 08             	sub    $0x8,%esp
  800766:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  800769:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  80076f:	89 04 24             	mov    %eax,(%esp)
  800772:	e8 08 d3 00 00       	call   80da7f <thread_wakeup>
}
  800777:	c9                   	leave  
  800778:	c3                   	ret    
  800779:	00 00                	add    %al,(%eax)
  80077b:	00 00                	add    %al,(%eax)
  80077d:	00 00                	add    %al,(%eax)
	...

00800780 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800780:	55                   	push   %ebp
  800781:	89 e5                	mov    %esp,%ebp
  800783:	57                   	push   %edi
  800784:	56                   	push   %esi
  800785:	53                   	push   %ebx
  800786:	83 ec 2c             	sub    $0x2c,%esp
  800789:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint32_t stop = sys_time_msec() + initial_to;
  80078c:	e8 ea 0c 00 00       	call   80147b <sys_time_msec>
  800791:	89 c3                	mov    %eax,%ebx
  800793:	03 5d 0c             	add    0xc(%ebp),%ebx

	binaryname = "ns_timer";
  800796:	c7 05 00 80 81 00 94 	movl   $0x812294,0x818000
  80079d:	22 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007a0:	8d 75 f0             	lea    -0x10(%ebp),%esi
  8007a3:	eb 05                	jmp    8007aa <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while(sys_time_msec() < stop) {
			sys_yield();
  8007a5:	e8 cf 0f 00 00       	call   801779 <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while(sys_time_msec() < stop) {
  8007aa:	e8 cc 0c 00 00       	call   80147b <sys_time_msec>
  8007af:	39 c3                	cmp    %eax,%ebx
  8007b1:	77 f2                	ja     8007a5 <timer+0x25>
			sys_yield();
		}

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8007b3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8007ba:	00 
  8007bb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007c2:	00 
  8007c3:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  8007ca:	00 
  8007cb:	89 3c 24             	mov    %edi,(%esp)
  8007ce:	e8 bd 15 00 00       	call   801d90 <ipc_send>

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007d3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007da:	00 
  8007db:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8007e2:	00 
  8007e3:	89 34 24             	mov    %esi,(%esp)
  8007e6:	e8 59 16 00 00       	call   801e44 <ipc_recv>
  8007eb:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8007ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8007f0:	39 c7                	cmp    %eax,%edi
  8007f2:	74 12                	je     800806 <timer+0x86>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8007f4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8007f8:	c7 04 24 a0 22 81 00 	movl   $0x8122a0,(%esp)
  8007ff:	e8 75 01 00 00       	call   800979 <cprintf>
  800804:	eb cd                	jmp    8007d3 <timer+0x53>
				continue;
			}

			stop = sys_time_msec() + to;
  800806:	e8 70 0c 00 00       	call   80147b <sys_time_msec>
  80080b:	01 c3                	add    %eax,%ebx
  80080d:	8d 76 00             	lea    0x0(%esi),%esi
  800810:	eb 98                	jmp    8007aa <timer+0x2a>
	...

00800814 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  800814:	55                   	push   %ebp
  800815:	89 e5                	mov    %esp,%ebp
	binaryname = "ns_input";
  800817:	c7 05 00 80 81 00 db 	movl   $0x8122db,0x818000
  80081e:	22 81 00 
	// 	- read a packet from the device driver
	//	- send it to the network server
	// Hint: When you IPC a page to the network server, it will be
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
}
  800821:	5d                   	pop    %ebp
  800822:	c3                   	ret    
	...

00800824 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  800824:	55                   	push   %ebp
  800825:	89 e5                	mov    %esp,%ebp
	binaryname = "ns_output";
  800827:	c7 05 00 80 81 00 e4 	movl   $0x8122e4,0x818000
  80082e:	22 81 00 

	// LAB 6: Your code here:
	// 	- read a packet from the network server
	//	- send the packet to the device driver
}
  800831:	5d                   	pop    %ebp
  800832:	c3                   	ret    
	...

00800834 <libmain>:
volatile struct Env *env;
char *binaryname = "(PROGRAM NAME UNKNOWN)";

void
libmain(int argc, char **argv)
{
  800834:	55                   	push   %ebp
  800835:	89 e5                	mov    %esp,%ebp
  800837:	83 ec 18             	sub    $0x18,%esp
  80083a:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80083d:	89 75 fc             	mov    %esi,-0x4(%ebp)
  800840:	8b 75 08             	mov    0x8(%ebp),%esi
  800843:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	// set env to point at our env structure in envs[].
	// LAB 3: Your code here.
	env = 0;
  800846:	c7 05 b4 e5 b3 00 00 	movl   $0x0,0xb3e5b4
  80084d:	00 00 00 
	env = &envs[ENVX(sys_getenvid())];
  800850:	e8 58 0f 00 00       	call   8017ad <sys_getenvid>
  800855:	25 ff 03 00 00       	and    $0x3ff,%eax
  80085a:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80085d:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  800862:	a3 b4 e5 b3 00       	mov    %eax,0xb3e5b4
	// save the name of the program so that panic() can use it
	if (argc > 0)
  800867:	85 f6                	test   %esi,%esi
  800869:	7e 07                	jle    800872 <libmain+0x3e>
		binaryname = argv[0];
  80086b:	8b 03                	mov    (%ebx),%eax
  80086d:	a3 00 80 81 00       	mov    %eax,0x818000

	// call user main routine
	umain(argc, argv);
  800872:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  800876:	89 34 24             	mov    %esi,(%esp)
  800879:	e8 da f7 ff ff       	call   800058 <umain>

	// exit gracefully
	exit();
  80087e:	e8 0d 00 00 00       	call   800890 <exit>
}
  800883:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  800886:	8b 75 fc             	mov    -0x4(%ebp),%esi
  800889:	89 ec                	mov    %ebp,%esp
  80088b:	5d                   	pop    %ebp
  80088c:	c3                   	ret    
  80088d:	00 00                	add    %al,(%eax)
	...

00800890 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  800890:	55                   	push   %ebp
  800891:	89 e5                	mov    %esp,%ebp
  800893:	83 ec 08             	sub    $0x8,%esp
	close_all();
  800896:	e8 85 1c 00 00       	call   802520 <close_all>
	sys_env_destroy(0);
  80089b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8008a2:	e8 3a 0f 00 00       	call   8017e1 <sys_env_destroy>
}
  8008a7:	c9                   	leave  
  8008a8:	c3                   	ret    
  8008a9:	00 00                	add    %al,(%eax)
	...

008008ac <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  8008ac:	55                   	push   %ebp
  8008ad:	89 e5                	mov    %esp,%ebp
  8008af:	83 ec 28             	sub    $0x28,%esp
	va_list ap;

	va_start(ap, fmt);
  8008b2:	8d 45 14             	lea    0x14(%ebp),%eax
  8008b5:	89 45 fc             	mov    %eax,-0x4(%ebp)

	// Print the panic message
	if (argv0)
  8008b8:	a1 b8 e5 b3 00       	mov    0xb3e5b8,%eax
  8008bd:	85 c0                	test   %eax,%eax
  8008bf:	74 10                	je     8008d1 <_panic+0x25>
		cprintf("%s: ", argv0);
  8008c1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8008c5:	c7 04 24 05 23 81 00 	movl   $0x812305,(%esp)
  8008cc:	e8 a8 00 00 00       	call   800979 <cprintf>
	cprintf("user panic in %s at %s:%d: ", binaryname, file, line);
  8008d1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8008d4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8008d8:	8b 45 08             	mov    0x8(%ebp),%eax
  8008db:	89 44 24 08          	mov    %eax,0x8(%esp)
  8008df:	a1 00 80 81 00       	mov    0x818000,%eax
  8008e4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8008e8:	c7 04 24 0a 23 81 00 	movl   $0x81230a,(%esp)
  8008ef:	e8 85 00 00 00       	call   800979 <cprintf>
	vcprintf(fmt, ap);
  8008f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  8008f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8008fb:	8b 45 10             	mov    0x10(%ebp),%eax
  8008fe:	89 04 24             	mov    %eax,(%esp)
  800901:	e8 12 00 00 00       	call   800918 <vcprintf>
	cprintf("\n");
  800906:	c7 04 24 0a 21 81 00 	movl   $0x81210a,(%esp)
  80090d:	e8 67 00 00 00       	call   800979 <cprintf>

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  800912:	cc                   	int3   
  800913:	eb fd                	jmp    800912 <_panic+0x66>
  800915:	00 00                	add    %al,(%eax)
	...

00800918 <vcprintf>:
	b->cnt++;
}

int
vcprintf(const char *fmt, va_list ap)
{
  800918:	55                   	push   %ebp
  800919:	89 e5                	mov    %esp,%ebp
  80091b:	81 ec 28 01 00 00    	sub    $0x128,%esp
	struct printbuf b;

	b.idx = 0;
  800921:	c7 85 f8 fe ff ff 00 	movl   $0x0,-0x108(%ebp)
  800928:	00 00 00 
	b.cnt = 0;
  80092b:	c7 85 fc fe ff ff 00 	movl   $0x0,-0x104(%ebp)
  800932:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  800935:	8b 45 0c             	mov    0xc(%ebp),%eax
  800938:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80093c:	8b 45 08             	mov    0x8(%ebp),%eax
  80093f:	89 44 24 08          	mov    %eax,0x8(%esp)
  800943:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  800949:	89 44 24 04          	mov    %eax,0x4(%esp)
  80094d:	c7 04 24 96 09 80 00 	movl   $0x800996,(%esp)
  800954:	e8 cc 01 00 00       	call   800b25 <vprintfmt>
	sys_cputs(b.buf, b.idx);
  800959:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
  80095f:	89 44 24 04          	mov    %eax,0x4(%esp)
  800963:	8d 85 00 ff ff ff    	lea    -0x100(%ebp),%eax
  800969:	89 04 24             	mov    %eax,(%esp)
  80096c:	e8 d7 0a 00 00       	call   801448 <sys_cputs>
  800971:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax

	return b.cnt;
}
  800977:	c9                   	leave  
  800978:	c3                   	ret    

00800979 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  800979:	55                   	push   %ebp
  80097a:	89 e5                	mov    %esp,%ebp
  80097c:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80097f:	8d 45 0c             	lea    0xc(%ebp),%eax
  800982:	89 45 fc             	mov    %eax,-0x4(%ebp)
	cnt = vcprintf(fmt, ap);
  800985:	89 44 24 04          	mov    %eax,0x4(%esp)
  800989:	8b 45 08             	mov    0x8(%ebp),%eax
  80098c:	89 04 24             	mov    %eax,(%esp)
  80098f:	e8 84 ff ff ff       	call   800918 <vcprintf>
	va_end(ap);

	return cnt;
}
  800994:	c9                   	leave  
  800995:	c3                   	ret    

00800996 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  800996:	55                   	push   %ebp
  800997:	89 e5                	mov    %esp,%ebp
  800999:	53                   	push   %ebx
  80099a:	83 ec 14             	sub    $0x14,%esp
  80099d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  8009a0:	8b 03                	mov    (%ebx),%eax
  8009a2:	8b 55 08             	mov    0x8(%ebp),%edx
  8009a5:	88 54 03 08          	mov    %dl,0x8(%ebx,%eax,1)
  8009a9:	83 c0 01             	add    $0x1,%eax
  8009ac:	89 03                	mov    %eax,(%ebx)
	if (b->idx == 256-1) {
  8009ae:	3d ff 00 00 00       	cmp    $0xff,%eax
  8009b3:	75 19                	jne    8009ce <putch+0x38>
		sys_cputs(b->buf, b->idx);
  8009b5:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  8009bc:	00 
  8009bd:	8d 43 08             	lea    0x8(%ebx),%eax
  8009c0:	89 04 24             	mov    %eax,(%esp)
  8009c3:	e8 80 0a 00 00       	call   801448 <sys_cputs>
		b->idx = 0;
  8009c8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	}
	b->cnt++;
  8009ce:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  8009d2:	83 c4 14             	add    $0x14,%esp
  8009d5:	5b                   	pop    %ebx
  8009d6:	5d                   	pop    %ebp
  8009d7:	c3                   	ret    
	...

008009e0 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  8009e0:	55                   	push   %ebp
  8009e1:	89 e5                	mov    %esp,%ebp
  8009e3:	57                   	push   %edi
  8009e4:	56                   	push   %esi
  8009e5:	53                   	push   %ebx
  8009e6:	83 ec 3c             	sub    $0x3c,%esp
  8009e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8009ec:	89 d7                	mov    %edx,%edi
  8009ee:	8b 45 08             	mov    0x8(%ebp),%eax
  8009f1:	8b 55 0c             	mov    0xc(%ebp),%edx
  8009f4:	89 45 d8             	mov    %eax,-0x28(%ebp)
  8009f7:	89 55 dc             	mov    %edx,-0x24(%ebp)
  8009fa:	8b 55 10             	mov    0x10(%ebp),%edx
  8009fd:	8b 75 18             	mov    0x18(%ebp),%esi
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800a00:	89 55 e8             	mov    %edx,-0x18(%ebp)
  800a03:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  800a0a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  800a0d:	39 45 ec             	cmp    %eax,-0x14(%ebp)
  800a10:	72 14                	jb     800a26 <printnum+0x46>
  800a12:	8b 45 d8             	mov    -0x28(%ebp),%eax
  800a15:	39 45 e8             	cmp    %eax,-0x18(%ebp)
  800a18:	76 0c                	jbe    800a26 <printnum+0x46>
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800a1a:	8b 5d 14             	mov    0x14(%ebp),%ebx
  800a1d:	83 eb 01             	sub    $0x1,%ebx
  800a20:	85 db                	test   %ebx,%ebx
  800a22:	7f 57                	jg     800a7b <printnum+0x9b>
  800a24:	eb 64                	jmp    800a8a <printnum+0xaa>
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800a26:	89 74 24 10          	mov    %esi,0x10(%esp)
  800a2a:	8b 45 14             	mov    0x14(%ebp),%eax
  800a2d:	83 e8 01             	sub    $0x1,%eax
  800a30:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800a34:	89 54 24 08          	mov    %edx,0x8(%esp)
  800a38:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  800a3c:	8b 74 24 0c          	mov    0xc(%esp),%esi
  800a40:	8b 45 e8             	mov    -0x18(%ebp),%eax
  800a43:	8b 55 ec             	mov    -0x14(%ebp),%edx
  800a46:	89 44 24 08          	mov    %eax,0x8(%esp)
  800a4a:	89 54 24 0c          	mov    %edx,0xc(%esp)
  800a4e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  800a51:	8b 55 dc             	mov    -0x24(%ebp),%edx
  800a54:	89 04 24             	mov    %eax,(%esp)
  800a57:	89 54 24 04          	mov    %edx,0x4(%esp)
  800a5b:	e8 80 13 01 00       	call   811de0 <__udivdi3>
  800a60:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800a64:	89 74 24 0c          	mov    %esi,0xc(%esp)
  800a68:	89 04 24             	mov    %eax,(%esp)
  800a6b:	89 54 24 04          	mov    %edx,0x4(%esp)
  800a6f:	89 fa                	mov    %edi,%edx
  800a71:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a74:	e8 67 ff ff ff       	call   8009e0 <printnum>
  800a79:	eb 0f                	jmp    800a8a <printnum+0xaa>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  800a7b:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800a7f:	89 34 24             	mov    %esi,(%esp)
  800a82:	ff 55 e4             	call   *-0x1c(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800a85:	83 eb 01             	sub    $0x1,%ebx
  800a88:	75 f1                	jne    800a7b <printnum+0x9b>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800a8a:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800a8e:	8b 74 24 04          	mov    0x4(%esp),%esi
  800a92:	8b 45 e8             	mov    -0x18(%ebp),%eax
  800a95:	8b 55 ec             	mov    -0x14(%ebp),%edx
  800a98:	89 44 24 08          	mov    %eax,0x8(%esp)
  800a9c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  800aa0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  800aa3:	8b 55 dc             	mov    -0x24(%ebp),%edx
  800aa6:	89 04 24             	mov    %eax,(%esp)
  800aa9:	89 54 24 04          	mov    %edx,0x4(%esp)
  800aad:	e8 5e 14 01 00       	call   811f10 <__umoddi3>
  800ab2:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ab6:	0f be 80 26 23 81 00 	movsbl 0x812326(%eax),%eax
  800abd:	89 04 24             	mov    %eax,(%esp)
  800ac0:	ff 55 e4             	call   *-0x1c(%ebp)
}
  800ac3:	83 c4 3c             	add    $0x3c,%esp
  800ac6:	5b                   	pop    %ebx
  800ac7:	5e                   	pop    %esi
  800ac8:	5f                   	pop    %edi
  800ac9:	5d                   	pop    %ebp
  800aca:	c3                   	ret    

00800acb <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800acb:	55                   	push   %ebp
  800acc:	89 e5                	mov    %esp,%ebp
  800ace:	89 c1                	mov    %eax,%ecx
	if (lflag >= 2)
  800ad0:	83 fa 01             	cmp    $0x1,%edx
  800ad3:	7e 0e                	jle    800ae3 <getuint+0x18>
		return va_arg(*ap, unsigned long long);
  800ad5:	8b 10                	mov    (%eax),%edx
  800ad7:	8d 42 08             	lea    0x8(%edx),%eax
  800ada:	89 01                	mov    %eax,(%ecx)
  800adc:	8b 02                	mov    (%edx),%eax
  800ade:	8b 52 04             	mov    0x4(%edx),%edx
  800ae1:	eb 22                	jmp    800b05 <getuint+0x3a>
	else if (lflag)
  800ae3:	85 d2                	test   %edx,%edx
  800ae5:	74 10                	je     800af7 <getuint+0x2c>
		return va_arg(*ap, unsigned long);
  800ae7:	8b 10                	mov    (%eax),%edx
  800ae9:	8d 42 04             	lea    0x4(%edx),%eax
  800aec:	89 01                	mov    %eax,(%ecx)
  800aee:	8b 02                	mov    (%edx),%eax
  800af0:	ba 00 00 00 00       	mov    $0x0,%edx
  800af5:	eb 0e                	jmp    800b05 <getuint+0x3a>
	else
		return va_arg(*ap, unsigned int);
  800af7:	8b 10                	mov    (%eax),%edx
  800af9:	8d 42 04             	lea    0x4(%edx),%eax
  800afc:	89 01                	mov    %eax,(%ecx)
  800afe:	8b 02                	mov    (%edx),%eax
  800b00:	ba 00 00 00 00       	mov    $0x0,%edx
}
  800b05:	5d                   	pop    %ebp
  800b06:	c3                   	ret    

00800b07 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800b07:	55                   	push   %ebp
  800b08:	89 e5                	mov    %esp,%ebp
  800b0a:	8b 55 0c             	mov    0xc(%ebp),%edx
	b->cnt++;
  800b0d:	83 42 08 01          	addl   $0x1,0x8(%edx)
	if (b->buf < b->ebuf)
  800b11:	8b 02                	mov    (%edx),%eax
  800b13:	3b 42 04             	cmp    0x4(%edx),%eax
  800b16:	73 0b                	jae    800b23 <sprintputch+0x1c>
		*b->buf++ = ch;
  800b18:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
  800b1c:	88 08                	mov    %cl,(%eax)
  800b1e:	83 c0 01             	add    $0x1,%eax
  800b21:	89 02                	mov    %eax,(%edx)
}
  800b23:	5d                   	pop    %ebp
  800b24:	c3                   	ret    

00800b25 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800b25:	55                   	push   %ebp
  800b26:	89 e5                	mov    %esp,%ebp
  800b28:	57                   	push   %edi
  800b29:	56                   	push   %esi
  800b2a:	53                   	push   %ebx
  800b2b:	83 ec 3c             	sub    $0x3c,%esp
  800b2e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  800b31:	eb 18                	jmp    800b4b <vprintfmt+0x26>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  800b33:	84 c0                	test   %al,%al
  800b35:	0f 84 9f 03 00 00    	je     800eda <vprintfmt+0x3b5>
				return;
			putch(ch, putdat);
  800b3b:	8b 55 0c             	mov    0xc(%ebp),%edx
  800b3e:	89 54 24 04          	mov    %edx,0x4(%esp)
  800b42:	0f b6 c0             	movzbl %al,%eax
  800b45:	89 04 24             	mov    %eax,(%esp)
  800b48:	ff 55 08             	call   *0x8(%ebp)
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800b4b:	0f b6 03             	movzbl (%ebx),%eax
  800b4e:	83 c3 01             	add    $0x1,%ebx
  800b51:	3c 25                	cmp    $0x25,%al
  800b53:	75 de                	jne    800b33 <vprintfmt+0xe>
  800b55:	b9 00 00 00 00       	mov    $0x0,%ecx
  800b5a:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
  800b61:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800b66:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  800b6d:	c6 45 eb 20          	movb   $0x20,-0x15(%ebp)
  800b71:	eb 07                	jmp    800b7a <vprintfmt+0x55>
  800b73:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800b7a:	0f b6 13             	movzbl (%ebx),%edx
  800b7d:	83 c3 01             	add    $0x1,%ebx
  800b80:	8d 42 dd             	lea    -0x23(%edx),%eax
  800b83:	3c 55                	cmp    $0x55,%al
  800b85:	0f 87 22 03 00 00    	ja     800ead <vprintfmt+0x388>
  800b8b:	0f b6 c0             	movzbl %al,%eax
  800b8e:	ff 24 85 60 24 81 00 	jmp    *0x812460(,%eax,4)
  800b95:	c6 45 eb 30          	movb   $0x30,-0x15(%ebp)
  800b99:	eb df                	jmp    800b7a <vprintfmt+0x55>
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  800b9b:	0f b6 c2             	movzbl %dl,%eax
  800b9e:	8d 78 d0             	lea    -0x30(%eax),%edi
				ch = *fmt;
  800ba1:	0f be 13             	movsbl (%ebx),%edx
				if (ch < '0' || ch > '9')
  800ba4:	8d 42 d0             	lea    -0x30(%edx),%eax
  800ba7:	83 f8 09             	cmp    $0x9,%eax
  800baa:	76 08                	jbe    800bb4 <vprintfmt+0x8f>
  800bac:	eb 39                	jmp    800be7 <vprintfmt+0xc2>
  800bae:	c6 45 eb 2d          	movb   $0x2d,-0x15(%ebp)
  800bb2:	eb c6                	jmp    800b7a <vprintfmt+0x55>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800bb4:	83 c3 01             	add    $0x1,%ebx
				precision = precision * 10 + ch - '0';
  800bb7:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  800bba:	8d 7c 42 d0          	lea    -0x30(%edx,%eax,2),%edi
				ch = *fmt;
  800bbe:	0f be 13             	movsbl (%ebx),%edx
				if (ch < '0' || ch > '9')
  800bc1:	8d 42 d0             	lea    -0x30(%edx),%eax
  800bc4:	83 f8 09             	cmp    $0x9,%eax
  800bc7:	77 1e                	ja     800be7 <vprintfmt+0xc2>
  800bc9:	eb e9                	jmp    800bb4 <vprintfmt+0x8f>
					break;
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  800bcb:	8b 55 14             	mov    0x14(%ebp),%edx
  800bce:	8d 42 04             	lea    0x4(%edx),%eax
  800bd1:	89 45 14             	mov    %eax,0x14(%ebp)
  800bd4:	8b 3a                	mov    (%edx),%edi
  800bd6:	eb 0f                	jmp    800be7 <vprintfmt+0xc2>
			goto process_precision;

		case '.':
			if (width < 0)
  800bd8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  800bdc:	79 9c                	jns    800b7a <vprintfmt+0x55>
  800bde:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  800be5:	eb 93                	jmp    800b7a <vprintfmt+0x55>
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  800be7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  800beb:	90                   	nop    
  800bec:	8d 74 26 00          	lea    0x0(%esi),%esi
  800bf0:	79 88                	jns    800b7a <vprintfmt+0x55>
  800bf2:	89 7d f0             	mov    %edi,-0x10(%ebp)
  800bf5:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800bfa:	e9 7b ff ff ff       	jmp    800b7a <vprintfmt+0x55>
				width = precision, precision = -1;
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  800bff:	83 c1 01             	add    $0x1,%ecx
  800c02:	e9 73 ff ff ff       	jmp    800b7a <vprintfmt+0x55>
			goto reswitch;

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  800c07:	8b 45 14             	mov    0x14(%ebp),%eax
  800c0a:	8d 50 04             	lea    0x4(%eax),%edx
  800c0d:	89 55 14             	mov    %edx,0x14(%ebp)
  800c10:	8b 55 0c             	mov    0xc(%ebp),%edx
  800c13:	89 54 24 04          	mov    %edx,0x4(%esp)
  800c17:	8b 00                	mov    (%eax),%eax
  800c19:	89 04 24             	mov    %eax,(%esp)
  800c1c:	ff 55 08             	call   *0x8(%ebp)
  800c1f:	e9 27 ff ff ff       	jmp    800b4b <vprintfmt+0x26>
			break;

		// error message
		case 'e':
			err = va_arg(ap, int);
  800c24:	8b 55 14             	mov    0x14(%ebp),%edx
  800c27:	8d 42 04             	lea    0x4(%edx),%eax
  800c2a:	89 45 14             	mov    %eax,0x14(%ebp)
  800c2d:	8b 02                	mov    (%edx),%eax
  800c2f:	89 c2                	mov    %eax,%edx
  800c31:	c1 fa 1f             	sar    $0x1f,%edx
  800c34:	31 d0                	xor    %edx,%eax
  800c36:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
  800c38:	83 f8 0f             	cmp    $0xf,%eax
  800c3b:	7f 0b                	jg     800c48 <vprintfmt+0x123>
  800c3d:	8b 14 85 c0 25 81 00 	mov    0x8125c0(,%eax,4),%edx
  800c44:	85 d2                	test   %edx,%edx
  800c46:	75 23                	jne    800c6b <vprintfmt+0x146>
				printfmt(putch, putdat, "error %d", err);
  800c48:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800c4c:	c7 44 24 08 37 23 81 	movl   $0x812337,0x8(%esp)
  800c53:	00 
  800c54:	8b 45 0c             	mov    0xc(%ebp),%eax
  800c57:	89 44 24 04          	mov    %eax,0x4(%esp)
  800c5b:	8b 55 08             	mov    0x8(%ebp),%edx
  800c5e:	89 14 24             	mov    %edx,(%esp)
  800c61:	e8 ff 02 00 00       	call   800f65 <printfmt>
  800c66:	e9 e0 fe ff ff       	jmp    800b4b <vprintfmt+0x26>
			else
				printfmt(putch, putdat, "%s", p);
  800c6b:	89 54 24 0c          	mov    %edx,0xc(%esp)
  800c6f:	c7 44 24 08 4a 28 81 	movl   $0x81284a,0x8(%esp)
  800c76:	00 
  800c77:	8b 45 0c             	mov    0xc(%ebp),%eax
  800c7a:	89 44 24 04          	mov    %eax,0x4(%esp)
  800c7e:	8b 55 08             	mov    0x8(%ebp),%edx
  800c81:	89 14 24             	mov    %edx,(%esp)
  800c84:	e8 dc 02 00 00       	call   800f65 <printfmt>
  800c89:	e9 bd fe ff ff       	jmp    800b4b <vprintfmt+0x26>
  800c8e:	8b 75 f0             	mov    -0x10(%ebp),%esi
  800c91:	89 f9                	mov    %edi,%ecx
  800c93:	89 5d ec             	mov    %ebx,-0x14(%ebp)
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  800c96:	8b 55 14             	mov    0x14(%ebp),%edx
  800c99:	8d 42 04             	lea    0x4(%edx),%eax
  800c9c:	89 45 14             	mov    %eax,0x14(%ebp)
  800c9f:	8b 12                	mov    (%edx),%edx
  800ca1:	89 55 dc             	mov    %edx,-0x24(%ebp)
  800ca4:	85 d2                	test   %edx,%edx
  800ca6:	75 07                	jne    800caf <vprintfmt+0x18a>
  800ca8:	c7 45 dc 40 23 81 00 	movl   $0x812340,-0x24(%ebp)
				p = "(null)";
			if (width > 0 && padc != '-')
  800caf:	85 f6                	test   %esi,%esi
  800cb1:	7e 41                	jle    800cf4 <vprintfmt+0x1cf>
  800cb3:	80 7d eb 2d          	cmpb   $0x2d,-0x15(%ebp)
  800cb7:	74 3b                	je     800cf4 <vprintfmt+0x1cf>
				for (width -= strnlen(p, precision); width > 0; width--)
  800cb9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800cbd:	8b 45 dc             	mov    -0x24(%ebp),%eax
  800cc0:	89 04 24             	mov    %eax,(%esp)
  800cc3:	e8 e8 02 00 00       	call   800fb0 <strnlen>
  800cc8:	29 c6                	sub    %eax,%esi
  800cca:	89 75 f0             	mov    %esi,-0x10(%ebp)
  800ccd:	85 f6                	test   %esi,%esi
  800ccf:	7e 23                	jle    800cf4 <vprintfmt+0x1cf>
					putch(padc, putdat);
  800cd1:	0f be 55 eb          	movsbl -0x15(%ebp),%edx
  800cd5:	89 55 d8             	mov    %edx,-0x28(%ebp)
  800cd8:	8b 45 0c             	mov    0xc(%ebp),%eax
  800cdb:	89 44 24 04          	mov    %eax,0x4(%esp)
  800cdf:	8b 55 d8             	mov    -0x28(%ebp),%edx
  800ce2:	89 14 24             	mov    %edx,(%esp)
  800ce5:	ff 55 08             	call   *0x8(%ebp)
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800ce8:	83 ee 01             	sub    $0x1,%esi
  800ceb:	75 eb                	jne    800cd8 <vprintfmt+0x1b3>
  800ced:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800cf4:	8b 55 dc             	mov    -0x24(%ebp),%edx
  800cf7:	0f b6 02             	movzbl (%edx),%eax
  800cfa:	0f be d0             	movsbl %al,%edx
  800cfd:	8b 75 dc             	mov    -0x24(%ebp),%esi
  800d00:	84 c0                	test   %al,%al
  800d02:	75 42                	jne    800d46 <vprintfmt+0x221>
  800d04:	eb 49                	jmp    800d4f <vprintfmt+0x22a>
				if (altflag && (ch < ' ' || ch > '~'))
  800d06:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  800d0a:	74 1b                	je     800d27 <vprintfmt+0x202>
  800d0c:	8d 42 e0             	lea    -0x20(%edx),%eax
  800d0f:	83 f8 5e             	cmp    $0x5e,%eax
  800d12:	76 13                	jbe    800d27 <vprintfmt+0x202>
					putch('?', putdat);
  800d14:	8b 45 0c             	mov    0xc(%ebp),%eax
  800d17:	89 44 24 04          	mov    %eax,0x4(%esp)
  800d1b:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  800d22:	ff 55 08             	call   *0x8(%ebp)
  800d25:	eb 0d                	jmp    800d34 <vprintfmt+0x20f>
				else
					putch(ch, putdat);
  800d27:	8b 45 0c             	mov    0xc(%ebp),%eax
  800d2a:	89 44 24 04          	mov    %eax,0x4(%esp)
  800d2e:	89 14 24             	mov    %edx,(%esp)
  800d31:	ff 55 08             	call   *0x8(%ebp)
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800d34:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
  800d38:	0f b6 46 01          	movzbl 0x1(%esi),%eax
  800d3c:	83 c6 01             	add    $0x1,%esi
  800d3f:	84 c0                	test   %al,%al
  800d41:	74 0c                	je     800d4f <vprintfmt+0x22a>
  800d43:	0f be d0             	movsbl %al,%edx
  800d46:	85 ff                	test   %edi,%edi
  800d48:	78 bc                	js     800d06 <vprintfmt+0x1e1>
  800d4a:	83 ef 01             	sub    $0x1,%edi
  800d4d:	79 b7                	jns    800d06 <vprintfmt+0x1e1>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800d4f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  800d53:	0f 8e f2 fd ff ff    	jle    800b4b <vprintfmt+0x26>
				putch(' ', putdat);
  800d59:	8b 55 0c             	mov    0xc(%ebp),%edx
  800d5c:	89 54 24 04          	mov    %edx,0x4(%esp)
  800d60:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  800d67:	ff 55 08             	call   *0x8(%ebp)
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800d6a:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
  800d6e:	75 e9                	jne    800d59 <vprintfmt+0x234>
  800d70:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  800d73:	e9 d3 fd ff ff       	jmp    800b4b <vprintfmt+0x26>
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  800d78:	83 f9 01             	cmp    $0x1,%ecx
  800d7b:	90                   	nop    
  800d7c:	8d 74 26 00          	lea    0x0(%esi),%esi
  800d80:	7e 10                	jle    800d92 <vprintfmt+0x26d>
		return va_arg(*ap, long long);
  800d82:	8b 55 14             	mov    0x14(%ebp),%edx
  800d85:	8d 42 08             	lea    0x8(%edx),%eax
  800d88:	89 45 14             	mov    %eax,0x14(%ebp)
  800d8b:	8b 32                	mov    (%edx),%esi
  800d8d:	8b 7a 04             	mov    0x4(%edx),%edi
  800d90:	eb 2a                	jmp    800dbc <vprintfmt+0x297>
	else if (lflag)
  800d92:	85 c9                	test   %ecx,%ecx
  800d94:	74 14                	je     800daa <vprintfmt+0x285>
		return va_arg(*ap, long);
  800d96:	8b 45 14             	mov    0x14(%ebp),%eax
  800d99:	8d 50 04             	lea    0x4(%eax),%edx
  800d9c:	89 55 14             	mov    %edx,0x14(%ebp)
  800d9f:	8b 00                	mov    (%eax),%eax
  800da1:	89 c6                	mov    %eax,%esi
  800da3:	89 c7                	mov    %eax,%edi
  800da5:	c1 ff 1f             	sar    $0x1f,%edi
  800da8:	eb 12                	jmp    800dbc <vprintfmt+0x297>
	else
		return va_arg(*ap, int);
  800daa:	8b 45 14             	mov    0x14(%ebp),%eax
  800dad:	8d 50 04             	lea    0x4(%eax),%edx
  800db0:	89 55 14             	mov    %edx,0x14(%ebp)
  800db3:	8b 00                	mov    (%eax),%eax
  800db5:	89 c6                	mov    %eax,%esi
  800db7:	89 c7                	mov    %eax,%edi
  800db9:	c1 ff 1f             	sar    $0x1f,%edi
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  800dbc:	89 f2                	mov    %esi,%edx
  800dbe:	89 f9                	mov    %edi,%ecx
  800dc0:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
			if ((long long) num < 0) {
  800dc7:	85 ff                	test   %edi,%edi
  800dc9:	0f 89 9b 00 00 00    	jns    800e6a <vprintfmt+0x345>
				putch('-', putdat);
  800dcf:	8b 45 0c             	mov    0xc(%ebp),%eax
  800dd2:	89 44 24 04          	mov    %eax,0x4(%esp)
  800dd6:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  800ddd:	ff 55 08             	call   *0x8(%ebp)
				num = -(long long) num;
  800de0:	89 f2                	mov    %esi,%edx
  800de2:	89 f9                	mov    %edi,%ecx
  800de4:	f7 da                	neg    %edx
  800de6:	83 d1 00             	adc    $0x0,%ecx
  800de9:	f7 d9                	neg    %ecx
  800deb:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
  800df2:	eb 76                	jmp    800e6a <vprintfmt+0x345>
			base = 10;
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  800df4:	89 ca                	mov    %ecx,%edx
  800df6:	8d 45 14             	lea    0x14(%ebp),%eax
  800df9:	e8 cd fc ff ff       	call   800acb <getuint>
  800dfe:	89 d1                	mov    %edx,%ecx
  800e00:	89 c2                	mov    %eax,%edx
  800e02:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
  800e09:	eb 5f                	jmp    800e6a <vprintfmt+0x345>
		case 'o':
			// Replace this with your code.
			//putch('X', putdat);
			//putch('X', putdat);
			//putch('X', putdat);
			num = getuint(&ap,lflag);
  800e0b:	89 ca                	mov    %ecx,%edx
  800e0d:	8d 45 14             	lea    0x14(%ebp),%eax
  800e10:	e8 b6 fc ff ff       	call   800acb <getuint>
  800e15:	e9 31 fd ff ff       	jmp    800b4b <vprintfmt+0x26>
			base=8;
			break;

		// pointer
		case 'p':
			putch('0', putdat);
  800e1a:	8b 55 0c             	mov    0xc(%ebp),%edx
  800e1d:	89 54 24 04          	mov    %edx,0x4(%esp)
  800e21:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  800e28:	ff 55 08             	call   *0x8(%ebp)
			putch('x', putdat);
  800e2b:	8b 45 0c             	mov    0xc(%ebp),%eax
  800e2e:	89 44 24 04          	mov    %eax,0x4(%esp)
  800e32:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  800e39:	ff 55 08             	call   *0x8(%ebp)
			num = (unsigned long long)
  800e3c:	8b 55 14             	mov    0x14(%ebp),%edx
  800e3f:	8d 42 04             	lea    0x4(%edx),%eax
  800e42:	89 45 14             	mov    %eax,0x14(%ebp)
  800e45:	8b 12                	mov    (%edx),%edx
  800e47:	b9 00 00 00 00       	mov    $0x0,%ecx
  800e4c:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
  800e53:	eb 15                	jmp    800e6a <vprintfmt+0x345>
			base = 16;
			goto number;

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  800e55:	89 ca                	mov    %ecx,%edx
  800e57:	8d 45 14             	lea    0x14(%ebp),%eax
  800e5a:	e8 6c fc ff ff       	call   800acb <getuint>
  800e5f:	89 d1                	mov    %edx,%ecx
  800e61:	89 c2                	mov    %eax,%edx
  800e63:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
			base = 16;
		number:
			printnum(putch, putdat, num, base, width, padc);
  800e6a:	0f be 45 eb          	movsbl -0x15(%ebp),%eax
  800e6e:	89 44 24 10          	mov    %eax,0x10(%esp)
  800e72:	8b 45 f0             	mov    -0x10(%ebp),%eax
  800e75:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800e79:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800e7c:	89 44 24 08          	mov    %eax,0x8(%esp)
  800e80:	89 14 24             	mov    %edx,(%esp)
  800e83:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800e87:	8b 55 0c             	mov    0xc(%ebp),%edx
  800e8a:	8b 45 08             	mov    0x8(%ebp),%eax
  800e8d:	e8 4e fb ff ff       	call   8009e0 <printnum>
  800e92:	e9 b4 fc ff ff       	jmp    800b4b <vprintfmt+0x26>
			break;

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  800e97:	8b 55 0c             	mov    0xc(%ebp),%edx
  800e9a:	89 54 24 04          	mov    %edx,0x4(%esp)
  800e9e:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  800ea5:	ff 55 08             	call   *0x8(%ebp)
  800ea8:	e9 9e fc ff ff       	jmp    800b4b <vprintfmt+0x26>
			break;
			
		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800ead:	8b 45 0c             	mov    0xc(%ebp),%eax
  800eb0:	89 44 24 04          	mov    %eax,0x4(%esp)
  800eb4:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  800ebb:	ff 55 08             	call   *0x8(%ebp)
			for (fmt--; fmt[-1] != '%'; fmt--)
  800ebe:	83 eb 01             	sub    $0x1,%ebx
  800ec1:	80 7b ff 25          	cmpb   $0x25,-0x1(%ebx)
  800ec5:	0f 84 80 fc ff ff    	je     800b4b <vprintfmt+0x26>
  800ecb:	83 eb 01             	sub    $0x1,%ebx
  800ece:	80 7b ff 25          	cmpb   $0x25,-0x1(%ebx)
  800ed2:	0f 84 73 fc ff ff    	je     800b4b <vprintfmt+0x26>
  800ed8:	eb f1                	jmp    800ecb <vprintfmt+0x3a6>
				/* do nothing */;
			break;
		}
	}
}
  800eda:	83 c4 3c             	add    $0x3c,%esp
  800edd:	5b                   	pop    %ebx
  800ede:	5e                   	pop    %esi
  800edf:	5f                   	pop    %edi
  800ee0:	5d                   	pop    %ebp
  800ee1:	c3                   	ret    

00800ee2 <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800ee2:	55                   	push   %ebp
  800ee3:	89 e5                	mov    %esp,%ebp
  800ee5:	83 ec 28             	sub    $0x28,%esp
  800ee8:	8b 55 08             	mov    0x8(%ebp),%edx
  800eeb:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
  800eee:	85 d2                	test   %edx,%edx
  800ef0:	74 04                	je     800ef6 <vsnprintf+0x14>
  800ef2:	85 c0                	test   %eax,%eax
  800ef4:	7f 07                	jg     800efd <vsnprintf+0x1b>
  800ef6:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800efb:	eb 3b                	jmp    800f38 <vsnprintf+0x56>
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};
  800efd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  800f04:	8d 44 02 ff          	lea    -0x1(%edx,%eax,1),%eax
  800f08:	89 45 f8             	mov    %eax,-0x8(%ebp)
  800f0b:	89 55 f4             	mov    %edx,-0xc(%ebp)

	if (buf == NULL || n < 1)
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  800f0e:	8b 45 14             	mov    0x14(%ebp),%eax
  800f11:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800f15:	8b 45 10             	mov    0x10(%ebp),%eax
  800f18:	89 44 24 08          	mov    %eax,0x8(%esp)
  800f1c:	8d 45 f4             	lea    -0xc(%ebp),%eax
  800f1f:	89 44 24 04          	mov    %eax,0x4(%esp)
  800f23:	c7 04 24 07 0b 80 00 	movl   $0x800b07,(%esp)
  800f2a:	e8 f6 fb ff ff       	call   800b25 <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  800f2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  800f32:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  800f35:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  800f38:	c9                   	leave  
  800f39:	c3                   	ret    

00800f3a <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800f3a:	55                   	push   %ebp
  800f3b:	89 e5                	mov    %esp,%ebp
  800f3d:	83 ec 28             	sub    $0x28,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  800f40:	8d 45 14             	lea    0x14(%ebp),%eax
  800f43:	89 45 fc             	mov    %eax,-0x4(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
  800f46:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800f4a:	8b 45 10             	mov    0x10(%ebp),%eax
  800f4d:	89 44 24 08          	mov    %eax,0x8(%esp)
  800f51:	8b 45 0c             	mov    0xc(%ebp),%eax
  800f54:	89 44 24 04          	mov    %eax,0x4(%esp)
  800f58:	8b 45 08             	mov    0x8(%ebp),%eax
  800f5b:	89 04 24             	mov    %eax,(%esp)
  800f5e:	e8 7f ff ff ff       	call   800ee2 <vsnprintf>
	va_end(ap);

	return rc;
}
  800f63:	c9                   	leave  
  800f64:	c3                   	ret    

00800f65 <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800f65:	55                   	push   %ebp
  800f66:	89 e5                	mov    %esp,%ebp
  800f68:	83 ec 28             	sub    $0x28,%esp
	va_list ap;

	va_start(ap, fmt);
  800f6b:	8d 45 14             	lea    0x14(%ebp),%eax
  800f6e:	89 45 fc             	mov    %eax,-0x4(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
  800f71:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800f75:	8b 45 10             	mov    0x10(%ebp),%eax
  800f78:	89 44 24 08          	mov    %eax,0x8(%esp)
  800f7c:	8b 45 0c             	mov    0xc(%ebp),%eax
  800f7f:	89 44 24 04          	mov    %eax,0x4(%esp)
  800f83:	8b 45 08             	mov    0x8(%ebp),%eax
  800f86:	89 04 24             	mov    %eax,(%esp)
  800f89:	e8 97 fb ff ff       	call   800b25 <vprintfmt>
	va_end(ap);
}
  800f8e:	c9                   	leave  
  800f8f:	c3                   	ret    

00800f90 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800f90:	55                   	push   %ebp
  800f91:	89 e5                	mov    %esp,%ebp
  800f93:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  800f96:	b8 00 00 00 00       	mov    $0x0,%eax
  800f9b:	80 3a 00             	cmpb   $0x0,(%edx)
  800f9e:	74 0e                	je     800fae <strlen+0x1e>
  800fa0:	b8 00 00 00 00       	mov    $0x0,%eax
		n++;
  800fa5:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800fa8:	80 3c 10 00          	cmpb   $0x0,(%eax,%edx,1)
  800fac:	75 f7                	jne    800fa5 <strlen+0x15>
		n++;
	return n;
}
  800fae:	5d                   	pop    %ebp
  800faf:	c3                   	ret    

00800fb0 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800fb0:	55                   	push   %ebp
  800fb1:	89 e5                	mov    %esp,%ebp
  800fb3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  800fb6:	8b 55 0c             	mov    0xc(%ebp),%edx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800fb9:	85 d2                	test   %edx,%edx
  800fbb:	74 19                	je     800fd6 <strnlen+0x26>
  800fbd:	80 39 00             	cmpb   $0x0,(%ecx)
  800fc0:	74 14                	je     800fd6 <strnlen+0x26>
  800fc2:	b8 00 00 00 00       	mov    $0x0,%eax
		n++;
  800fc7:	83 c0 01             	add    $0x1,%eax
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800fca:	39 d0                	cmp    %edx,%eax
  800fcc:	74 0d                	je     800fdb <strnlen+0x2b>
  800fce:	80 3c 08 00          	cmpb   $0x0,(%eax,%ecx,1)
  800fd2:	74 07                	je     800fdb <strnlen+0x2b>
  800fd4:	eb f1                	jmp    800fc7 <strnlen+0x17>
  800fd6:	b8 00 00 00 00       	mov    $0x0,%eax
		n++;
	return n;
}
  800fdb:	5d                   	pop    %ebp
  800fdc:	8d 74 26 00          	lea    0x0(%esi),%esi
  800fe0:	c3                   	ret    

00800fe1 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800fe1:	55                   	push   %ebp
  800fe2:	89 e5                	mov    %esp,%ebp
  800fe4:	53                   	push   %ebx
  800fe5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800fe8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  800feb:	89 da                	mov    %ebx,%edx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  800fed:	0f b6 01             	movzbl (%ecx),%eax
  800ff0:	88 02                	mov    %al,(%edx)
  800ff2:	83 c2 01             	add    $0x1,%edx
  800ff5:	83 c1 01             	add    $0x1,%ecx
  800ff8:	84 c0                	test   %al,%al
  800ffa:	75 f1                	jne    800fed <strcpy+0xc>
		/* do nothing */;
	return ret;
}
  800ffc:	89 d8                	mov    %ebx,%eax
  800ffe:	5b                   	pop    %ebx
  800fff:	5d                   	pop    %ebp
  801000:	c3                   	ret    

00801001 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  801001:	55                   	push   %ebp
  801002:	89 e5                	mov    %esp,%ebp
  801004:	57                   	push   %edi
  801005:	56                   	push   %esi
  801006:	53                   	push   %ebx
  801007:	8b 7d 08             	mov    0x8(%ebp),%edi
  80100a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80100d:	8b 75 10             	mov    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801010:	85 f6                	test   %esi,%esi
  801012:	74 1c                	je     801030 <strncpy+0x2f>
  801014:	89 fa                	mov    %edi,%edx
  801016:	bb 00 00 00 00       	mov    $0x0,%ebx
		*dst++ = *src;
  80101b:	0f b6 01             	movzbl (%ecx),%eax
  80101e:	88 02                	mov    %al,(%edx)
  801020:	83 c2 01             	add    $0x1,%edx
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  801023:	80 39 01             	cmpb   $0x1,(%ecx)
  801026:	83 d9 ff             	sbb    $0xffffffff,%ecx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801029:	83 c3 01             	add    $0x1,%ebx
  80102c:	39 f3                	cmp    %esi,%ebx
  80102e:	75 eb                	jne    80101b <strncpy+0x1a>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  801030:	89 f8                	mov    %edi,%eax
  801032:	5b                   	pop    %ebx
  801033:	5e                   	pop    %esi
  801034:	5f                   	pop    %edi
  801035:	5d                   	pop    %ebp
  801036:	c3                   	ret    

00801037 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  801037:	55                   	push   %ebp
  801038:	89 e5                	mov    %esp,%ebp
  80103a:	56                   	push   %esi
  80103b:	53                   	push   %ebx
  80103c:	8b 75 08             	mov    0x8(%ebp),%esi
  80103f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801042:	8b 55 10             	mov    0x10(%ebp),%edx
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  801045:	89 f0                	mov    %esi,%eax
  801047:	85 d2                	test   %edx,%edx
  801049:	74 2c                	je     801077 <strlcpy+0x40>
		while (--size > 0 && *src != '\0')
  80104b:	89 d3                	mov    %edx,%ebx
  80104d:	83 eb 01             	sub    $0x1,%ebx
  801050:	74 20                	je     801072 <strlcpy+0x3b>
  801052:	0f b6 11             	movzbl (%ecx),%edx
  801055:	84 d2                	test   %dl,%dl
  801057:	74 19                	je     801072 <strlcpy+0x3b>
  801059:	89 f0                	mov    %esi,%eax
			*dst++ = *src++;
  80105b:	88 10                	mov    %dl,(%eax)
  80105d:	83 c0 01             	add    $0x1,%eax
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  801060:	83 eb 01             	sub    $0x1,%ebx
  801063:	74 0f                	je     801074 <strlcpy+0x3d>
  801065:	0f b6 51 01          	movzbl 0x1(%ecx),%edx
  801069:	83 c1 01             	add    $0x1,%ecx
  80106c:	84 d2                	test   %dl,%dl
  80106e:	74 04                	je     801074 <strlcpy+0x3d>
  801070:	eb e9                	jmp    80105b <strlcpy+0x24>
  801072:	89 f0                	mov    %esi,%eax
			*dst++ = *src++;
		*dst = '\0';
  801074:	c6 00 00             	movb   $0x0,(%eax)
  801077:	29 f0                	sub    %esi,%eax
	}
	return dst - dst_in;
}
  801079:	5b                   	pop    %ebx
  80107a:	5e                   	pop    %esi
  80107b:	5d                   	pop    %ebp
  80107c:	c3                   	ret    

0080107d <pstrcpy>:
//i386-disassember Lab3:your code here pstrcpy()
void pstrcpy(char *buf, int buf_size, const char *str)
{   
  80107d:	55                   	push   %ebp
  80107e:	89 e5                	mov    %esp,%ebp
  801080:	56                   	push   %esi
  801081:	53                   	push   %ebx
  801082:	8b 75 08             	mov    0x8(%ebp),%esi
  801085:	8b 45 0c             	mov    0xc(%ebp),%eax
  801088:	8b 55 10             	mov    0x10(%ebp),%edx
    int c;
    char *q = buf;

    if (buf_size <= 0)
  80108b:	85 c0                	test   %eax,%eax
  80108d:	7e 2e                	jle    8010bd <pstrcpy+0x40>
        return;

    for(;;) {
        c = *str++;
  80108f:	0f b6 0a             	movzbl (%edx),%ecx
        if (c == 0 || q >= buf + buf_size - 1)
  801092:	84 c9                	test   %cl,%cl
  801094:	74 22                	je     8010b8 <pstrcpy+0x3b>
  801096:	8d 5c 06 ff          	lea    -0x1(%esi,%eax,1),%ebx
  80109a:	89 f0                	mov    %esi,%eax
  80109c:	39 de                	cmp    %ebx,%esi
  80109e:	72 09                	jb     8010a9 <pstrcpy+0x2c>
  8010a0:	eb 16                	jmp    8010b8 <pstrcpy+0x3b>
  8010a2:	83 c2 01             	add    $0x1,%edx
  8010a5:	39 d8                	cmp    %ebx,%eax
  8010a7:	73 11                	jae    8010ba <pstrcpy+0x3d>
            break;
        *q++ = c;
  8010a9:	88 08                	mov    %cl,(%eax)
  8010ab:	83 c0 01             	add    $0x1,%eax

    if (buf_size <= 0)
        return;

    for(;;) {
        c = *str++;
  8010ae:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
        if (c == 0 || q >= buf + buf_size - 1)
  8010b2:	84 c9                	test   %cl,%cl
  8010b4:	75 ec                	jne    8010a2 <pstrcpy+0x25>
  8010b6:	eb 02                	jmp    8010ba <pstrcpy+0x3d>
  8010b8:	89 f0                	mov    %esi,%eax
            break;
        *q++ = c;
    }
    *q = '\0';
  8010ba:	c6 00 00             	movb   $0x0,(%eax)
}
  8010bd:	5b                   	pop    %ebx
  8010be:	5e                   	pop    %esi
  8010bf:	5d                   	pop    %ebp
  8010c0:	c3                   	ret    

008010c1 <strcmp>:
int
strcmp(const char *p, const char *q)
{
  8010c1:	55                   	push   %ebp
  8010c2:	89 e5                	mov    %esp,%ebp
  8010c4:	8b 55 08             	mov    0x8(%ebp),%edx
  8010c7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	while (*p && *p == *q)
  8010ca:	0f b6 02             	movzbl (%edx),%eax
  8010cd:	84 c0                	test   %al,%al
  8010cf:	74 16                	je     8010e7 <strcmp+0x26>
  8010d1:	3a 01                	cmp    (%ecx),%al
  8010d3:	75 12                	jne    8010e7 <strcmp+0x26>
		p++, q++;
  8010d5:	83 c1 01             	add    $0x1,%ecx
    *q = '\0';
}
int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  8010d8:	0f b6 42 01          	movzbl 0x1(%edx),%eax
  8010dc:	84 c0                	test   %al,%al
  8010de:	74 07                	je     8010e7 <strcmp+0x26>
  8010e0:	83 c2 01             	add    $0x1,%edx
  8010e3:	3a 01                	cmp    (%ecx),%al
  8010e5:	74 ee                	je     8010d5 <strcmp+0x14>
  8010e7:	0f b6 c0             	movzbl %al,%eax
  8010ea:	0f b6 11             	movzbl (%ecx),%edx
  8010ed:	29 d0                	sub    %edx,%eax
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
}
  8010ef:	5d                   	pop    %ebp
  8010f0:	c3                   	ret    

008010f1 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  8010f1:	55                   	push   %ebp
  8010f2:	89 e5                	mov    %esp,%ebp
  8010f4:	53                   	push   %ebx
  8010f5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8010f8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8010fb:	8b 55 10             	mov    0x10(%ebp),%edx
	while (n > 0 && *p && *p == *q)
  8010fe:	85 d2                	test   %edx,%edx
  801100:	74 2d                	je     80112f <strncmp+0x3e>
  801102:	0f b6 01             	movzbl (%ecx),%eax
  801105:	84 c0                	test   %al,%al
  801107:	74 1a                	je     801123 <strncmp+0x32>
  801109:	3a 03                	cmp    (%ebx),%al
  80110b:	75 16                	jne    801123 <strncmp+0x32>
  80110d:	83 ea 01             	sub    $0x1,%edx
  801110:	74 1d                	je     80112f <strncmp+0x3e>
		n--, p++, q++;
  801112:	83 c1 01             	add    $0x1,%ecx
  801115:	83 c3 01             	add    $0x1,%ebx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  801118:	0f b6 01             	movzbl (%ecx),%eax
  80111b:	84 c0                	test   %al,%al
  80111d:	74 04                	je     801123 <strncmp+0x32>
  80111f:	3a 03                	cmp    (%ebx),%al
  801121:	74 ea                	je     80110d <strncmp+0x1c>
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  801123:	0f b6 11             	movzbl (%ecx),%edx
  801126:	0f b6 03             	movzbl (%ebx),%eax
  801129:	29 c2                	sub    %eax,%edx
  80112b:	89 d0                	mov    %edx,%eax
  80112d:	eb 05                	jmp    801134 <strncmp+0x43>
  80112f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801134:	5b                   	pop    %ebx
  801135:	5d                   	pop    %ebp
  801136:	c3                   	ret    

00801137 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  801137:	55                   	push   %ebp
  801138:	89 e5                	mov    %esp,%ebp
  80113a:	8b 45 08             	mov    0x8(%ebp),%eax
  80113d:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  801141:	0f b6 10             	movzbl (%eax),%edx
  801144:	84 d2                	test   %dl,%dl
  801146:	74 14                	je     80115c <strchr+0x25>
		if (*s == c)
  801148:	38 ca                	cmp    %cl,%dl
  80114a:	75 06                	jne    801152 <strchr+0x1b>
  80114c:	eb 13                	jmp    801161 <strchr+0x2a>
  80114e:	38 ca                	cmp    %cl,%dl
  801150:	74 0f                	je     801161 <strchr+0x2a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  801152:	83 c0 01             	add    $0x1,%eax
  801155:	0f b6 10             	movzbl (%eax),%edx
  801158:	84 d2                	test   %dl,%dl
  80115a:	75 f2                	jne    80114e <strchr+0x17>
  80115c:	b8 00 00 00 00       	mov    $0x0,%eax
		if (*s == c)
			return (char *) s;
	return 0;
}
  801161:	5d                   	pop    %ebp
  801162:	c3                   	ret    

00801163 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  801163:	55                   	push   %ebp
  801164:	89 e5                	mov    %esp,%ebp
  801166:	8b 45 08             	mov    0x8(%ebp),%eax
  801169:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80116d:	0f b6 10             	movzbl (%eax),%edx
  801170:	84 d2                	test   %dl,%dl
  801172:	74 18                	je     80118c <strfind+0x29>
		if (*s == c)
  801174:	38 ca                	cmp    %cl,%dl
  801176:	75 0a                	jne    801182 <strfind+0x1f>
  801178:	eb 12                	jmp    80118c <strfind+0x29>
  80117a:	38 ca                	cmp    %cl,%dl
  80117c:	8d 74 26 00          	lea    0x0(%esi),%esi
  801180:	74 0a                	je     80118c <strfind+0x29>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  801182:	83 c0 01             	add    $0x1,%eax
  801185:	0f b6 10             	movzbl (%eax),%edx
  801188:	84 d2                	test   %dl,%dl
  80118a:	75 ee                	jne    80117a <strfind+0x17>
		if (*s == c)
			break;
	return (char *) s;
}
  80118c:	5d                   	pop    %ebp
  80118d:	c3                   	ret    

0080118e <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80118e:	55                   	push   %ebp
  80118f:	89 e5                	mov    %esp,%ebp
  801191:	83 ec 08             	sub    $0x8,%esp
  801194:	89 1c 24             	mov    %ebx,(%esp)
  801197:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80119b:	8b 7d 08             	mov    0x8(%ebp),%edi
  80119e:	8b 5d 10             	mov    0x10(%ebp),%ebx
	char *p;

	if (n == 0)
  8011a1:	85 db                	test   %ebx,%ebx
  8011a3:	74 36                	je     8011db <memset+0x4d>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  8011a5:	f7 c7 03 00 00 00    	test   $0x3,%edi
  8011ab:	75 26                	jne    8011d3 <memset+0x45>
  8011ad:	f6 c3 03             	test   $0x3,%bl
  8011b0:	75 21                	jne    8011d3 <memset+0x45>
		c &= 0xFF;
  8011b2:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  8011b6:	89 d0                	mov    %edx,%eax
  8011b8:	c1 e0 18             	shl    $0x18,%eax
  8011bb:	89 d1                	mov    %edx,%ecx
  8011bd:	c1 e1 10             	shl    $0x10,%ecx
  8011c0:	09 c8                	or     %ecx,%eax
  8011c2:	09 d0                	or     %edx,%eax
  8011c4:	c1 e2 08             	shl    $0x8,%edx
  8011c7:	09 d0                	or     %edx,%eax
  8011c9:	89 d9                	mov    %ebx,%ecx
  8011cb:	c1 e9 02             	shr    $0x2,%ecx
  8011ce:	fc                   	cld    
  8011cf:	f3 ab                	rep stos %eax,%es:(%edi)
  8011d1:	eb 08                	jmp    8011db <memset+0x4d>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  8011d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  8011d6:	89 d9                	mov    %ebx,%ecx
  8011d8:	fc                   	cld    
  8011d9:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  8011db:	89 f8                	mov    %edi,%eax
  8011dd:	8b 1c 24             	mov    (%esp),%ebx
  8011e0:	8b 7c 24 04          	mov    0x4(%esp),%edi
  8011e4:	89 ec                	mov    %ebp,%esp
  8011e6:	5d                   	pop    %ebp
  8011e7:	c3                   	ret    

008011e8 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  8011e8:	55                   	push   %ebp
  8011e9:	89 e5                	mov    %esp,%ebp
  8011eb:	83 ec 08             	sub    $0x8,%esp
  8011ee:	89 34 24             	mov    %esi,(%esp)
  8011f1:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8011f5:	8b 45 08             	mov    0x8(%ebp),%eax
  8011f8:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;
	
	s = src;
  8011fb:	8b 75 0c             	mov    0xc(%ebp),%esi
	d = dst;
  8011fe:	89 c7                	mov    %eax,%edi
	if (s < d && s + n > d) {
  801200:	39 c6                	cmp    %eax,%esi
  801202:	73 38                	jae    80123c <memmove+0x54>
  801204:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  801207:	39 d0                	cmp    %edx,%eax
  801209:	73 31                	jae    80123c <memmove+0x54>
		s += n;
		d += n;
  80120b:	8d 34 08             	lea    (%eax,%ecx,1),%esi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80120e:	f6 c2 03             	test   $0x3,%dl
  801211:	75 1d                	jne    801230 <memmove+0x48>
  801213:	f7 c6 03 00 00 00    	test   $0x3,%esi
  801219:	75 15                	jne    801230 <memmove+0x48>
  80121b:	f6 c1 03             	test   $0x3,%cl
  80121e:	66 90                	xchg   %ax,%ax
  801220:	75 0e                	jne    801230 <memmove+0x48>
			asm volatile("std; rep movsl\n"
  801222:	8d 7e fc             	lea    -0x4(%esi),%edi
  801225:	8d 72 fc             	lea    -0x4(%edx),%esi
  801228:	c1 e9 02             	shr    $0x2,%ecx
  80122b:	fd                   	std    
  80122c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80122e:	eb 09                	jmp    801239 <memmove+0x51>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  801230:	8d 7e ff             	lea    -0x1(%esi),%edi
  801233:	8d 72 ff             	lea    -0x1(%edx),%esi
  801236:	fd                   	std    
  801237:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  801239:	fc                   	cld    
  80123a:	eb 21                	jmp    80125d <memmove+0x75>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80123c:	f7 c6 03 00 00 00    	test   $0x3,%esi
  801242:	75 16                	jne    80125a <memmove+0x72>
  801244:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80124a:	75 0e                	jne    80125a <memmove+0x72>
  80124c:	f6 c1 03             	test   $0x3,%cl
  80124f:	90                   	nop    
  801250:	75 08                	jne    80125a <memmove+0x72>
			asm volatile("cld; rep movsl\n"
  801252:	c1 e9 02             	shr    $0x2,%ecx
  801255:	fc                   	cld    
  801256:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  801258:	eb 03                	jmp    80125d <memmove+0x75>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80125a:	fc                   	cld    
  80125b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80125d:	8b 34 24             	mov    (%esp),%esi
  801260:	8b 7c 24 04          	mov    0x4(%esp),%edi
  801264:	89 ec                	mov    %ebp,%esp
  801266:	5d                   	pop    %ebp
  801267:	c3                   	ret    

00801268 <memcpy>:

/* sigh - gcc emits references to this for structure assignments! */
/* it is *not* prototyped in inc/string.h - do not use directly. */
void *
memcpy(void *dst, void *src, size_t n)
{
  801268:	55                   	push   %ebp
  801269:	89 e5                	mov    %esp,%ebp
  80126b:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80126e:	8b 45 10             	mov    0x10(%ebp),%eax
  801271:	89 44 24 08          	mov    %eax,0x8(%esp)
  801275:	8b 45 0c             	mov    0xc(%ebp),%eax
  801278:	89 44 24 04          	mov    %eax,0x4(%esp)
  80127c:	8b 45 08             	mov    0x8(%ebp),%eax
  80127f:	89 04 24             	mov    %eax,(%esp)
  801282:	e8 61 ff ff ff       	call   8011e8 <memmove>
}
  801287:	c9                   	leave  
  801288:	c3                   	ret    

00801289 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  801289:	55                   	push   %ebp
  80128a:	89 e5                	mov    %esp,%ebp
  80128c:	57                   	push   %edi
  80128d:	56                   	push   %esi
  80128e:	53                   	push   %ebx
  80128f:	83 ec 04             	sub    $0x4,%esp
  801292:	8b 45 08             	mov    0x8(%ebp),%eax
  801295:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  801298:	8b 55 10             	mov    0x10(%ebp),%edx
  80129b:	83 ea 01             	sub    $0x1,%edx
  80129e:	83 fa ff             	cmp    $0xffffffff,%edx
  8012a1:	74 47                	je     8012ea <memcmp+0x61>
		if (*s1 != *s2)
  8012a3:	0f b6 30             	movzbl (%eax),%esi
  8012a6:	0f b6 39             	movzbl (%ecx),%edi
			return (int) *s1 - (int) *s2;
  8012a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
		if (*s1 != *s2)
  8012ac:	89 f0                	mov    %esi,%eax
  8012ae:	89 fb                	mov    %edi,%ebx
  8012b0:	38 d8                	cmp    %bl,%al
  8012b2:	74 2e                	je     8012e2 <memcmp+0x59>
  8012b4:	eb 1c                	jmp    8012d2 <memcmp+0x49>
  8012b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8012b9:	0f b6 70 01          	movzbl 0x1(%eax),%esi
  8012bd:	0f b6 79 01          	movzbl 0x1(%ecx),%edi
  8012c1:	83 c0 01             	add    $0x1,%eax
  8012c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  8012c7:	83 c1 01             	add    $0x1,%ecx
  8012ca:	89 f3                	mov    %esi,%ebx
  8012cc:	89 f8                	mov    %edi,%eax
  8012ce:	38 c3                	cmp    %al,%bl
  8012d0:	74 10                	je     8012e2 <memcmp+0x59>
			return (int) *s1 - (int) *s2;
  8012d2:	89 f1                	mov    %esi,%ecx
  8012d4:	0f b6 d1             	movzbl %cl,%edx
  8012d7:	89 fb                	mov    %edi,%ebx
  8012d9:	0f b6 c3             	movzbl %bl,%eax
  8012dc:	29 c2                	sub    %eax,%edx
  8012de:	89 d0                	mov    %edx,%eax
  8012e0:	eb 0d                	jmp    8012ef <memcmp+0x66>
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  8012e2:	83 ea 01             	sub    $0x1,%edx
  8012e5:	83 fa ff             	cmp    $0xffffffff,%edx
  8012e8:	75 cc                	jne    8012b6 <memcmp+0x2d>
  8012ea:	b8 00 00 00 00       	mov    $0x0,%eax
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
}
  8012ef:	83 c4 04             	add    $0x4,%esp
  8012f2:	5b                   	pop    %ebx
  8012f3:	5e                   	pop    %esi
  8012f4:	5f                   	pop    %edi
  8012f5:	5d                   	pop    %ebp
  8012f6:	c3                   	ret    

008012f7 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  8012f7:	55                   	push   %ebp
  8012f8:	89 e5                	mov    %esp,%ebp
  8012fa:	8b 45 08             	mov    0x8(%ebp),%eax
	const void *ends = (const char *) s + n;
  8012fd:	89 c1                	mov    %eax,%ecx
  8012ff:	03 4d 10             	add    0x10(%ebp),%ecx
	for (; s < ends; s++)
  801302:	39 c8                	cmp    %ecx,%eax
  801304:	73 15                	jae    80131b <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
  801306:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
  80130a:	38 10                	cmp    %dl,(%eax)
  80130c:	75 06                	jne    801314 <memfind+0x1d>
  80130e:	eb 0b                	jmp    80131b <memfind+0x24>
  801310:	38 10                	cmp    %dl,(%eax)
  801312:	74 07                	je     80131b <memfind+0x24>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  801314:	83 c0 01             	add    $0x1,%eax
  801317:	39 c8                	cmp    %ecx,%eax
  801319:	75 f5                	jne    801310 <memfind+0x19>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  80131b:	5d                   	pop    %ebp
  80131c:	8d 74 26 00          	lea    0x0(%esi),%esi
  801320:	c3                   	ret    

00801321 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  801321:	55                   	push   %ebp
  801322:	89 e5                	mov    %esp,%ebp
  801324:	57                   	push   %edi
  801325:	56                   	push   %esi
  801326:	53                   	push   %ebx
  801327:	83 ec 04             	sub    $0x4,%esp
  80132a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80132d:	8b 75 10             	mov    0x10(%ebp),%esi
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  801330:	0f b6 01             	movzbl (%ecx),%eax
  801333:	3c 20                	cmp    $0x20,%al
  801335:	74 04                	je     80133b <strtol+0x1a>
  801337:	3c 09                	cmp    $0x9,%al
  801339:	75 0e                	jne    801349 <strtol+0x28>
		s++;
  80133b:	83 c1 01             	add    $0x1,%ecx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80133e:	0f b6 01             	movzbl (%ecx),%eax
  801341:	3c 20                	cmp    $0x20,%al
  801343:	74 f6                	je     80133b <strtol+0x1a>
  801345:	3c 09                	cmp    $0x9,%al
  801347:	74 f2                	je     80133b <strtol+0x1a>
		s++;

	// plus/minus sign
	if (*s == '+')
  801349:	3c 2b                	cmp    $0x2b,%al
  80134b:	75 0c                	jne    801359 <strtol+0x38>
		s++;
  80134d:	83 c1 01             	add    $0x1,%ecx
  801350:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  801357:	eb 15                	jmp    80136e <strtol+0x4d>
	else if (*s == '-')
  801359:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  801360:	3c 2d                	cmp    $0x2d,%al
  801362:	75 0a                	jne    80136e <strtol+0x4d>
		s++, neg = 1;
  801364:	83 c1 01             	add    $0x1,%ecx
  801367:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80136e:	85 f6                	test   %esi,%esi
  801370:	0f 94 c0             	sete   %al
  801373:	74 05                	je     80137a <strtol+0x59>
  801375:	83 fe 10             	cmp    $0x10,%esi
  801378:	75 18                	jne    801392 <strtol+0x71>
  80137a:	80 39 30             	cmpb   $0x30,(%ecx)
  80137d:	75 13                	jne    801392 <strtol+0x71>
  80137f:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  801383:	75 0d                	jne    801392 <strtol+0x71>
		s += 2, base = 16;
  801385:	83 c1 02             	add    $0x2,%ecx
  801388:	be 10 00 00 00       	mov    $0x10,%esi
  80138d:	8d 76 00             	lea    0x0(%esi),%esi
  801390:	eb 1b                	jmp    8013ad <strtol+0x8c>
	else if (base == 0 && s[0] == '0')
  801392:	85 f6                	test   %esi,%esi
  801394:	75 0e                	jne    8013a4 <strtol+0x83>
  801396:	80 39 30             	cmpb   $0x30,(%ecx)
  801399:	75 09                	jne    8013a4 <strtol+0x83>
		s++, base = 8;
  80139b:	83 c1 01             	add    $0x1,%ecx
  80139e:	66 be 08 00          	mov    $0x8,%si
  8013a2:	eb 09                	jmp    8013ad <strtol+0x8c>
	else if (base == 0)
  8013a4:	84 c0                	test   %al,%al
  8013a6:	74 05                	je     8013ad <strtol+0x8c>
  8013a8:	be 0a 00 00 00       	mov    $0xa,%esi
  8013ad:	bf 00 00 00 00       	mov    $0x0,%edi

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  8013b2:	0f b6 11             	movzbl (%ecx),%edx
  8013b5:	89 d3                	mov    %edx,%ebx
  8013b7:	8d 42 d0             	lea    -0x30(%edx),%eax
  8013ba:	3c 09                	cmp    $0x9,%al
  8013bc:	77 08                	ja     8013c6 <strtol+0xa5>
			dig = *s - '0';
  8013be:	0f be c2             	movsbl %dl,%eax
  8013c1:	8d 50 d0             	lea    -0x30(%eax),%edx
  8013c4:	eb 1c                	jmp    8013e2 <strtol+0xc1>
		else if (*s >= 'a' && *s <= 'z')
  8013c6:	8d 43 9f             	lea    -0x61(%ebx),%eax
  8013c9:	3c 19                	cmp    $0x19,%al
  8013cb:	77 08                	ja     8013d5 <strtol+0xb4>
			dig = *s - 'a' + 10;
  8013cd:	0f be c2             	movsbl %dl,%eax
  8013d0:	8d 50 a9             	lea    -0x57(%eax),%edx
  8013d3:	eb 0d                	jmp    8013e2 <strtol+0xc1>
		else if (*s >= 'A' && *s <= 'Z')
  8013d5:	8d 43 bf             	lea    -0x41(%ebx),%eax
  8013d8:	3c 19                	cmp    $0x19,%al
  8013da:	77 17                	ja     8013f3 <strtol+0xd2>
			dig = *s - 'A' + 10;
  8013dc:	0f be c2             	movsbl %dl,%eax
  8013df:	8d 50 c9             	lea    -0x37(%eax),%edx
		else
			break;
		if (dig >= base)
  8013e2:	39 f2                	cmp    %esi,%edx
  8013e4:	7d 0d                	jge    8013f3 <strtol+0xd2>
			break;
		s++, val = (val * base) + dig;
  8013e6:	83 c1 01             	add    $0x1,%ecx
  8013e9:	89 f8                	mov    %edi,%eax
  8013eb:	0f af c6             	imul   %esi,%eax
  8013ee:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  8013f1:	eb bf                	jmp    8013b2 <strtol+0x91>
		// we don't properly detect overflow!
	}
  8013f3:	89 f8                	mov    %edi,%eax

	if (endptr)
  8013f5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8013f9:	74 05                	je     801400 <strtol+0xdf>
		*endptr = (char *) s;
  8013fb:	8b 55 0c             	mov    0xc(%ebp),%edx
  8013fe:	89 0a                	mov    %ecx,(%edx)
	return (neg ? -val : val);
  801400:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  801404:	74 04                	je     80140a <strtol+0xe9>
  801406:	89 c7                	mov    %eax,%edi
  801408:	f7 df                	neg    %edi
}
  80140a:	89 f8                	mov    %edi,%eax
  80140c:	83 c4 04             	add    $0x4,%esp
  80140f:	5b                   	pop    %ebx
  801410:	5e                   	pop    %esi
  801411:	5f                   	pop    %edi
  801412:	5d                   	pop    %ebp
  801413:	c3                   	ret    

00801414 <sys_cgetc>:
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}

int
sys_cgetc(void)
{
  801414:	55                   	push   %ebp
  801415:	89 e5                	mov    %esp,%ebp
  801417:	83 ec 0c             	sub    $0xc,%esp
  80141a:	89 1c 24             	mov    %ebx,(%esp)
  80141d:	89 74 24 04          	mov    %esi,0x4(%esp)
  801421:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801425:	b8 01 00 00 00       	mov    $0x1,%eax
  80142a:	bf 00 00 00 00       	mov    $0x0,%edi
  80142f:	89 fa                	mov    %edi,%edx
  801431:	89 f9                	mov    %edi,%ecx
  801433:	89 fb                	mov    %edi,%ebx
  801435:	89 fe                	mov    %edi,%esi
  801437:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  801439:	8b 1c 24             	mov    (%esp),%ebx
  80143c:	8b 74 24 04          	mov    0x4(%esp),%esi
  801440:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801444:	89 ec                	mov    %ebp,%esp
  801446:	5d                   	pop    %ebp
  801447:	c3                   	ret    

00801448 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  801448:	55                   	push   %ebp
  801449:	89 e5                	mov    %esp,%ebp
  80144b:	83 ec 0c             	sub    $0xc,%esp
  80144e:	89 1c 24             	mov    %ebx,(%esp)
  801451:	89 74 24 04          	mov    %esi,0x4(%esp)
  801455:	89 7c 24 08          	mov    %edi,0x8(%esp)
  801459:	8b 55 08             	mov    0x8(%ebp),%edx
  80145c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80145f:	bf 00 00 00 00       	mov    $0x0,%edi
  801464:	89 f8                	mov    %edi,%eax
  801466:	89 fb                	mov    %edi,%ebx
  801468:	89 fe                	mov    %edi,%esi
  80146a:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80146c:	8b 1c 24             	mov    (%esp),%ebx
  80146f:	8b 74 24 04          	mov    0x4(%esp),%esi
  801473:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801477:	89 ec                	mov    %ebp,%esp
  801479:	5d                   	pop    %ebp
  80147a:	c3                   	ret    

0080147b <sys_time_msec>:
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}

unsigned int
sys_time_msec(void)
{
  80147b:	55                   	push   %ebp
  80147c:	89 e5                	mov    %esp,%ebp
  80147e:	83 ec 0c             	sub    $0xc,%esp
  801481:	89 1c 24             	mov    %ebx,(%esp)
  801484:	89 74 24 04          	mov    %esi,0x4(%esp)
  801488:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80148c:	b8 0e 00 00 00       	mov    $0xe,%eax
  801491:	bf 00 00 00 00       	mov    $0x0,%edi
  801496:	89 fa                	mov    %edi,%edx
  801498:	89 f9                	mov    %edi,%ecx
  80149a:	89 fb                	mov    %edi,%ebx
  80149c:	89 fe                	mov    %edi,%esi
  80149e:	cd 30                	int    $0x30

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  8014a0:	8b 1c 24             	mov    (%esp),%ebx
  8014a3:	8b 74 24 04          	mov    0x4(%esp),%esi
  8014a7:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8014ab:	89 ec                	mov    %ebp,%esp
  8014ad:	5d                   	pop    %ebp
  8014ae:	c3                   	ret    

008014af <sys_ipc_recv>:
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}

int
sys_ipc_recv(void *dstva)
{
  8014af:	55                   	push   %ebp
  8014b0:	89 e5                	mov    %esp,%ebp
  8014b2:	83 ec 28             	sub    $0x28,%esp
  8014b5:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8014b8:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8014bb:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8014be:	8b 55 08             	mov    0x8(%ebp),%edx
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8014c1:	b8 0d 00 00 00       	mov    $0xd,%eax
  8014c6:	bf 00 00 00 00       	mov    $0x0,%edi
  8014cb:	89 f9                	mov    %edi,%ecx
  8014cd:	89 fb                	mov    %edi,%ebx
  8014cf:	89 fe                	mov    %edi,%esi
  8014d1:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  8014d3:	85 c0                	test   %eax,%eax
  8014d5:	7e 28                	jle    8014ff <sys_ipc_recv+0x50>
		panic("syscall %d returned %d (> 0)", num, ret);
  8014d7:	89 44 24 10          	mov    %eax,0x10(%esp)
  8014db:	c7 44 24 0c 0d 00 00 	movl   $0xd,0xc(%esp)
  8014e2:	00 
  8014e3:	c7 44 24 08 1f 26 81 	movl   $0x81261f,0x8(%esp)
  8014ea:	00 
  8014eb:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8014f2:	00 
  8014f3:	c7 04 24 3c 26 81 00 	movl   $0x81263c,(%esp)
  8014fa:	e8 ad f3 ff ff       	call   8008ac <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  8014ff:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801502:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801505:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801508:	89 ec                	mov    %ebp,%esp
  80150a:	5d                   	pop    %ebp
  80150b:	c3                   	ret    

0080150c <sys_ipc_try_send>:
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80150c:	55                   	push   %ebp
  80150d:	89 e5                	mov    %esp,%ebp
  80150f:	83 ec 0c             	sub    $0xc,%esp
  801512:	89 1c 24             	mov    %ebx,(%esp)
  801515:	89 74 24 04          	mov    %esi,0x4(%esp)
  801519:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80151d:	8b 55 08             	mov    0x8(%ebp),%edx
  801520:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801523:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801526:	8b 7d 14             	mov    0x14(%ebp),%edi
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801529:	b8 0c 00 00 00       	mov    $0xc,%eax
  80152e:	be 00 00 00 00       	mov    $0x0,%esi
  801533:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  801535:	8b 1c 24             	mov    (%esp),%ebx
  801538:	8b 74 24 04          	mov    0x4(%esp),%esi
  80153c:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801540:	89 ec                	mov    %ebp,%esp
  801542:	5d                   	pop    %ebp
  801543:	c3                   	ret    

00801544 <sys_env_set_pgfault_upcall>:
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  801544:	55                   	push   %ebp
  801545:	89 e5                	mov    %esp,%ebp
  801547:	83 ec 28             	sub    $0x28,%esp
  80154a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80154d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801550:	89 7d fc             	mov    %edi,-0x4(%ebp)
  801553:	8b 55 08             	mov    0x8(%ebp),%edx
  801556:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801559:	b8 0a 00 00 00       	mov    $0xa,%eax
  80155e:	bf 00 00 00 00       	mov    $0x0,%edi
  801563:	89 fb                	mov    %edi,%ebx
  801565:	89 fe                	mov    %edi,%esi
  801567:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801569:	85 c0                	test   %eax,%eax
  80156b:	7e 28                	jle    801595 <sys_env_set_pgfault_upcall+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  80156d:	89 44 24 10          	mov    %eax,0x10(%esp)
  801571:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
  801578:	00 
  801579:	c7 44 24 08 1f 26 81 	movl   $0x81261f,0x8(%esp)
  801580:	00 
  801581:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801588:	00 
  801589:	c7 04 24 3c 26 81 00 	movl   $0x81263c,(%esp)
  801590:	e8 17 f3 ff ff       	call   8008ac <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  801595:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801598:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80159b:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80159e:	89 ec                	mov    %ebp,%esp
  8015a0:	5d                   	pop    %ebp
  8015a1:	c3                   	ret    

008015a2 <sys_env_set_trapframe>:
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  8015a2:	55                   	push   %ebp
  8015a3:	89 e5                	mov    %esp,%ebp
  8015a5:	83 ec 28             	sub    $0x28,%esp
  8015a8:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8015ab:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8015ae:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8015b1:	8b 55 08             	mov    0x8(%ebp),%edx
  8015b4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8015b7:	b8 09 00 00 00       	mov    $0x9,%eax
  8015bc:	bf 00 00 00 00       	mov    $0x0,%edi
  8015c1:	89 fb                	mov    %edi,%ebx
  8015c3:	89 fe                	mov    %edi,%esi
  8015c5:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  8015c7:	85 c0                	test   %eax,%eax
  8015c9:	7e 28                	jle    8015f3 <sys_env_set_trapframe+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  8015cb:	89 44 24 10          	mov    %eax,0x10(%esp)
  8015cf:	c7 44 24 0c 09 00 00 	movl   $0x9,0xc(%esp)
  8015d6:	00 
  8015d7:	c7 44 24 08 1f 26 81 	movl   $0x81261f,0x8(%esp)
  8015de:	00 
  8015df:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8015e6:	00 
  8015e7:	c7 04 24 3c 26 81 00 	movl   $0x81263c,(%esp)
  8015ee:	e8 b9 f2 ff ff       	call   8008ac <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  8015f3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8015f6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8015f9:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8015fc:	89 ec                	mov    %ebp,%esp
  8015fe:	5d                   	pop    %ebp
  8015ff:	c3                   	ret    

00801600 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  801600:	55                   	push   %ebp
  801601:	89 e5                	mov    %esp,%ebp
  801603:	83 ec 28             	sub    $0x28,%esp
  801606:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801609:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80160c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80160f:	8b 55 08             	mov    0x8(%ebp),%edx
  801612:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801615:	b8 08 00 00 00       	mov    $0x8,%eax
  80161a:	bf 00 00 00 00       	mov    $0x0,%edi
  80161f:	89 fb                	mov    %edi,%ebx
  801621:	89 fe                	mov    %edi,%esi
  801623:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801625:	85 c0                	test   %eax,%eax
  801627:	7e 28                	jle    801651 <sys_env_set_status+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  801629:	89 44 24 10          	mov    %eax,0x10(%esp)
  80162d:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
  801634:	00 
  801635:	c7 44 24 08 1f 26 81 	movl   $0x81261f,0x8(%esp)
  80163c:	00 
  80163d:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801644:	00 
  801645:	c7 04 24 3c 26 81 00 	movl   $0x81263c,(%esp)
  80164c:	e8 5b f2 ff ff       	call   8008ac <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  801651:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801654:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801657:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80165a:	89 ec                	mov    %ebp,%esp
  80165c:	5d                   	pop    %ebp
  80165d:	c3                   	ret    

0080165e <sys_page_unmap>:
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}

int
sys_page_unmap(envid_t envid, void *va)
{
  80165e:	55                   	push   %ebp
  80165f:	89 e5                	mov    %esp,%ebp
  801661:	83 ec 28             	sub    $0x28,%esp
  801664:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801667:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80166a:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80166d:	8b 55 08             	mov    0x8(%ebp),%edx
  801670:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801673:	b8 06 00 00 00       	mov    $0x6,%eax
  801678:	bf 00 00 00 00       	mov    $0x0,%edi
  80167d:	89 fb                	mov    %edi,%ebx
  80167f:	89 fe                	mov    %edi,%esi
  801681:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801683:	85 c0                	test   %eax,%eax
  801685:	7e 28                	jle    8016af <sys_page_unmap+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  801687:	89 44 24 10          	mov    %eax,0x10(%esp)
  80168b:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  801692:	00 
  801693:	c7 44 24 08 1f 26 81 	movl   $0x81261f,0x8(%esp)
  80169a:	00 
  80169b:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8016a2:	00 
  8016a3:	c7 04 24 3c 26 81 00 	movl   $0x81263c,(%esp)
  8016aa:	e8 fd f1 ff ff       	call   8008ac <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  8016af:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8016b2:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8016b5:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8016b8:	89 ec                	mov    %ebp,%esp
  8016ba:	5d                   	pop    %ebp
  8016bb:	c3                   	ret    

008016bc <sys_page_map>:
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  8016bc:	55                   	push   %ebp
  8016bd:	89 e5                	mov    %esp,%ebp
  8016bf:	83 ec 28             	sub    $0x28,%esp
  8016c2:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8016c5:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8016c8:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8016cb:	8b 55 08             	mov    0x8(%ebp),%edx
  8016ce:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8016d1:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8016d4:	8b 7d 14             	mov    0x14(%ebp),%edi
  8016d7:	8b 75 18             	mov    0x18(%ebp),%esi
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8016da:	b8 05 00 00 00       	mov    $0x5,%eax
  8016df:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  8016e1:	85 c0                	test   %eax,%eax
  8016e3:	7e 28                	jle    80170d <sys_page_map+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  8016e5:	89 44 24 10          	mov    %eax,0x10(%esp)
  8016e9:	c7 44 24 0c 05 00 00 	movl   $0x5,0xc(%esp)
  8016f0:	00 
  8016f1:	c7 44 24 08 1f 26 81 	movl   $0x81261f,0x8(%esp)
  8016f8:	00 
  8016f9:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801700:	00 
  801701:	c7 04 24 3c 26 81 00 	movl   $0x81263c,(%esp)
  801708:	e8 9f f1 ff ff       	call   8008ac <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80170d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801710:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801713:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801716:	89 ec                	mov    %ebp,%esp
  801718:	5d                   	pop    %ebp
  801719:	c3                   	ret    

0080171a <sys_page_alloc>:
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80171a:	55                   	push   %ebp
  80171b:	89 e5                	mov    %esp,%ebp
  80171d:	83 ec 28             	sub    $0x28,%esp
  801720:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801723:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801726:	89 7d fc             	mov    %edi,-0x4(%ebp)
  801729:	8b 55 08             	mov    0x8(%ebp),%edx
  80172c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80172f:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801732:	b8 04 00 00 00       	mov    $0x4,%eax
  801737:	bf 00 00 00 00       	mov    $0x0,%edi
  80173c:	89 fe                	mov    %edi,%esi
  80173e:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801740:	85 c0                	test   %eax,%eax
  801742:	7e 28                	jle    80176c <sys_page_alloc+0x52>
		panic("syscall %d returned %d (> 0)", num, ret);
  801744:	89 44 24 10          	mov    %eax,0x10(%esp)
  801748:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
  80174f:	00 
  801750:	c7 44 24 08 1f 26 81 	movl   $0x81261f,0x8(%esp)
  801757:	00 
  801758:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80175f:	00 
  801760:	c7 04 24 3c 26 81 00 	movl   $0x81263c,(%esp)
  801767:	e8 40 f1 ff ff       	call   8008ac <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80176c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80176f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801772:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801775:	89 ec                	mov    %ebp,%esp
  801777:	5d                   	pop    %ebp
  801778:	c3                   	ret    

00801779 <sys_yield>:
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}

void
sys_yield(void)
{
  801779:	55                   	push   %ebp
  80177a:	89 e5                	mov    %esp,%ebp
  80177c:	83 ec 0c             	sub    $0xc,%esp
  80177f:	89 1c 24             	mov    %ebx,(%esp)
  801782:	89 74 24 04          	mov    %esi,0x4(%esp)
  801786:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80178a:	b8 0b 00 00 00       	mov    $0xb,%eax
  80178f:	bf 00 00 00 00       	mov    $0x0,%edi
  801794:	89 fa                	mov    %edi,%edx
  801796:	89 f9                	mov    %edi,%ecx
  801798:	89 fb                	mov    %edi,%ebx
  80179a:	89 fe                	mov    %edi,%esi
  80179c:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80179e:	8b 1c 24             	mov    (%esp),%ebx
  8017a1:	8b 74 24 04          	mov    0x4(%esp),%esi
  8017a5:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8017a9:	89 ec                	mov    %ebp,%esp
  8017ab:	5d                   	pop    %ebp
  8017ac:	c3                   	ret    

008017ad <sys_getenvid>:
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}

envid_t
sys_getenvid(void)
{
  8017ad:	55                   	push   %ebp
  8017ae:	89 e5                	mov    %esp,%ebp
  8017b0:	83 ec 0c             	sub    $0xc,%esp
  8017b3:	89 1c 24             	mov    %ebx,(%esp)
  8017b6:	89 74 24 04          	mov    %esi,0x4(%esp)
  8017ba:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8017be:	b8 02 00 00 00       	mov    $0x2,%eax
  8017c3:	bf 00 00 00 00       	mov    $0x0,%edi
  8017c8:	89 fa                	mov    %edi,%edx
  8017ca:	89 f9                	mov    %edi,%ecx
  8017cc:	89 fb                	mov    %edi,%ebx
  8017ce:	89 fe                	mov    %edi,%esi
  8017d0:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  8017d2:	8b 1c 24             	mov    (%esp),%ebx
  8017d5:	8b 74 24 04          	mov    0x4(%esp),%esi
  8017d9:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8017dd:	89 ec                	mov    %ebp,%esp
  8017df:	5d                   	pop    %ebp
  8017e0:	c3                   	ret    

008017e1 <sys_env_destroy>:
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}

int
sys_env_destroy(envid_t envid)
{
  8017e1:	55                   	push   %ebp
  8017e2:	89 e5                	mov    %esp,%ebp
  8017e4:	83 ec 28             	sub    $0x28,%esp
  8017e7:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8017ea:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8017ed:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8017f0:	8b 55 08             	mov    0x8(%ebp),%edx
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8017f3:	b8 03 00 00 00       	mov    $0x3,%eax
  8017f8:	bf 00 00 00 00       	mov    $0x0,%edi
  8017fd:	89 f9                	mov    %edi,%ecx
  8017ff:	89 fb                	mov    %edi,%ebx
  801801:	89 fe                	mov    %edi,%esi
  801803:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801805:	85 c0                	test   %eax,%eax
  801807:	7e 28                	jle    801831 <sys_env_destroy+0x50>
		panic("syscall %d returned %d (> 0)", num, ret);
  801809:	89 44 24 10          	mov    %eax,0x10(%esp)
  80180d:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
  801814:	00 
  801815:	c7 44 24 08 1f 26 81 	movl   $0x81261f,0x8(%esp)
  80181c:	00 
  80181d:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801824:	00 
  801825:	c7 04 24 3c 26 81 00 	movl   $0x81263c,(%esp)
  80182c:	e8 7b f0 ff ff       	call   8008ac <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  801831:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801834:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801837:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80183a:	89 ec                	mov    %ebp,%esp
  80183c:	5d                   	pop    %ebp
  80183d:	c3                   	ret    
	...

00801840 <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
// 
static int
duppage(envid_t envid, unsigned pn)
{
  801840:	55                   	push   %ebp
  801841:	89 e5                	mov    %esp,%ebp
  801843:	53                   	push   %ebx
  801844:	83 ec 14             	sub    $0x14,%esp
  801847:	89 c1                	mov    %eax,%ecx
	int r;

	// LAB 4: Your code here.
	pde_t *pde;
	pte_t *pte;
	void *addr=(void*)(pn*PGSIZE);
  801849:	89 d3                	mov    %edx,%ebx
  80184b:	c1 e3 0c             	shl    $0xc,%ebx
	pde =(pde_t*) &vpd[VPD(addr)];
	if(*pde&PTE_P)
  80184e:	89 d8                	mov    %ebx,%eax
  801850:	c1 e8 16             	shr    $0x16,%eax
  801853:	f6 04 85 00 d0 7b ef 	testb  $0x1,-0x10843000(,%eax,4)
  80185a:	01 
  80185b:	74 14                	je     801871 <duppage+0x31>
	{
		pte=(pte_t*)&vpt[VPN(addr)];
	}
	else    panic("page table for pn page is not exist");
	if((*pte&PTE_W)||(*pte&PTE_COW))
  80185d:	89 d8                	mov    %ebx,%eax
  80185f:	c1 e8 0c             	shr    $0xc,%eax
  801862:	f7 04 85 00 00 40 ef 	testl  $0x802,-0x10c00000(,%eax,4)
  801869:	02 08 00 00 
  80186d:	75 1e                	jne    80188d <duppage+0x4d>
  80186f:	eb 73                	jmp    8018e4 <duppage+0xa4>
	pde =(pde_t*) &vpd[VPD(addr)];
	if(*pde&PTE_P)
	{
		pte=(pte_t*)&vpt[VPN(addr)];
	}
	else    panic("page table for pn page is not exist");
  801871:	c7 44 24 08 4c 26 81 	movl   $0x81264c,0x8(%esp)
  801878:	00 
  801879:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  801880:	00 
  801881:	c7 04 24 0a 27 81 00 	movl   $0x81270a,(%esp)
  801888:	e8 1f f0 ff ff       	call   8008ac <_panic>
	if((*pte&PTE_W)||(*pte&PTE_COW))
	{
		if((r=sys_page_map(0,addr,envid,addr,PTE_COW|PTE_U))<0)
  80188d:	c7 44 24 10 04 08 00 	movl   $0x804,0x10(%esp)
  801894:	00 
  801895:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  801899:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80189d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8018a1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8018a8:	e8 0f fe ff ff       	call   8016bc <sys_page_map>
  8018ad:	85 c0                	test   %eax,%eax
  8018af:	78 60                	js     801911 <duppage+0xd1>
			return r;
		if((r=sys_page_map(0,addr,0,addr,PTE_COW|PTE_U))<0)//envid
  8018b1:	c7 44 24 10 04 08 00 	movl   $0x804,0x10(%esp)
  8018b8:	00 
  8018b9:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  8018bd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8018c4:	00 
  8018c5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8018c9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8018d0:	e8 e7 fd ff ff       	call   8016bc <sys_page_map>
  8018d5:	85 c0                	test   %eax,%eax
  8018d7:	0f 9f c2             	setg   %dl
  8018da:	0f b6 d2             	movzbl %dl,%edx
  8018dd:	83 ea 01             	sub    $0x1,%edx
  8018e0:	21 d0                	and    %edx,%eax
  8018e2:	eb 2d                	jmp    801911 <duppage+0xd1>
                        return r;
	}
	else{	
		if((r=sys_page_map(0,addr,envid,addr,PTE_U|PTE_P))<0)
  8018e4:	c7 44 24 10 05 00 00 	movl   $0x5,0x10(%esp)
  8018eb:	00 
  8018ec:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  8018f0:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8018f4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8018f8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8018ff:	e8 b8 fd ff ff       	call   8016bc <sys_page_map>
  801904:	85 c0                	test   %eax,%eax
  801906:	0f 9f c2             	setg   %dl
  801909:	0f b6 d2             	movzbl %dl,%edx
  80190c:	83 ea 01             	sub    $0x1,%edx
  80190f:	21 d0                	and    %edx,%eax
			return r;
	}
	//panic("duppage not implemented");
	return 0;
}
  801911:	83 c4 14             	add    $0x14,%esp
  801914:	5b                   	pop    %ebx
  801915:	5d                   	pop    %ebp
  801916:	c3                   	ret    

00801917 <sfork>:
	return 0;
}
// Challenge!
int
sfork(void)
{
  801917:	55                   	push   %ebp
  801918:	89 e5                	mov    %esp,%ebp
  80191a:	57                   	push   %edi
  80191b:	56                   	push   %esi
  80191c:	53                   	push   %ebx
  80191d:	83 ec 1c             	sub    $0x1c,%esp
static __inline envid_t sys_exofork(void) __attribute__((always_inline));
static __inline envid_t
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  801920:	ba 07 00 00 00       	mov    $0x7,%edx
  801925:	89 d0                	mov    %edx,%eax
  801927:	cd 30                	int    $0x30
  801929:	89 45 f0             	mov    %eax,-0x10(%ebp)
	pte_t *pte;
	unsigned i;
	uint32_t addr;
	envid_t envid;
	envid = sys_exofork();//
	if(envid < 0)
  80192c:	85 c0                	test   %eax,%eax
  80192e:	79 20                	jns    801950 <sfork+0x39>
		panic("sys_exofork: %e", envid);
  801930:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801934:	c7 44 24 08 15 27 81 	movl   $0x812715,0x8(%esp)
  80193b:	00 
  80193c:	c7 44 24 04 dc 00 00 	movl   $0xdc,0x4(%esp)
  801943:	00 
  801944:	c7 04 24 0a 27 81 00 	movl   $0x81270a,(%esp)
  80194b:	e8 5c ef ff ff       	call   8008ac <_panic>
	if(envid==0)//
  801950:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  801954:	75 21                	jne    801977 <sfork+0x60>
	{
		env = &envs[ENVX(sys_getenvid())];
  801956:	e8 52 fe ff ff       	call   8017ad <sys_getenvid>
  80195b:	25 ff 03 00 00       	and    $0x3ff,%eax
  801960:	6b c0 7c             	imul   $0x7c,%eax,%eax
  801963:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  801968:	a3 b4 e5 b3 00       	mov    %eax,0xb3e5b4
  80196d:	b8 00 00 00 00       	mov    $0x0,%eax
  801972:	e9 83 01 00 00       	jmp    801afa <sfork+0x1e3>
		return 0;
	}
	else{//,
	//
		env = &envs[ENVX(sys_getenvid())];
  801977:	e8 31 fe ff ff       	call   8017ad <sys_getenvid>
  80197c:	25 ff 03 00 00       	and    $0x3ff,%eax
  801981:	6b c0 7c             	imul   $0x7c,%eax,%eax
  801984:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  801989:	a3 b4 e5 b3 00       	mov    %eax,0xb3e5b4
		set_pgfault_handler(pgfault);//
  80198e:	c7 04 24 02 1b 80 00 	movl   $0x801b02,(%esp)
  801995:	e8 ee 15 00 00       	call   802f88 <set_pgfault_handler>
  80199a:	be 00 00 00 00       	mov    $0x0,%esi
  80199f:	bf 00 00 00 00       	mov    $0x0,%edi
		for(i=0;i<(unsigned)VPN(UTOP);i++)//writable or copy-to-write
		{
			addr=i*PGSIZE;
			pde =(pde_t*) &vpd[VPD(addr)];
  8019a4:	89 f8                	mov    %edi,%eax
  8019a6:	c1 e8 16             	shr    $0x16,%eax
  8019a9:	c1 e0 02             	shl    $0x2,%eax
			if(*pde&PTE_P)//
  8019ac:	f6 80 00 d0 7b ef 01 	testb  $0x1,-0x10843000(%eax)
  8019b3:	0f 84 dc 00 00 00    	je     801a95 <sfork+0x17e>
			{
				pte=(pte_t*)&vpt[VPN(addr)];
			}
			else    continue;
			if((i==(unsigned)VPN(USTACKTOP-PGSIZE))||(i==(unsigned)VPN(PFTEMP)))
  8019b9:	81 fe fd eb 0e 00    	cmp    $0xeebfd,%esi
  8019bf:	74 08                	je     8019c9 <sfork+0xb2>
  8019c1:	81 fe ff 07 00 00    	cmp    $0x7ff,%esi
  8019c7:	75 17                	jne    8019e0 <sfork+0xc9>
								//
			{	
				if((r=duppage(envid,i))<0)
  8019c9:	89 f2                	mov    %esi,%edx
  8019cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8019ce:	e8 6d fe ff ff       	call   801840 <duppage>
  8019d3:	85 c0                	test   %eax,%eax
  8019d5:	0f 89 ba 00 00 00    	jns    801a95 <sfork+0x17e>
  8019db:	e9 1a 01 00 00       	jmp    801afa <sfork+0x1e3>
	// LAB 4: Your code here.
	pde_t *pde;
	pte_t *pte;
	void *addr=(void*)(pn*PGSIZE);
	pde =(pde_t*) &vpd[VPD(addr)];
	if(*pde&PTE_P)
  8019e0:	f6 80 00 d0 7b ef 01 	testb  $0x1,-0x10843000(%eax)
  8019e7:	74 11                	je     8019fa <sfork+0xe3>
	{
		pte=(pte_t*)&vpt[VPN(addr)];
  8019e9:	89 f8                	mov    %edi,%eax
  8019eb:	c1 e8 0c             	shr    $0xc,%eax
	}
	else    panic("page table for pn page is not exist");
	if(*pte&PTE_W)
  8019ee:	f6 04 85 00 00 40 ef 	testb  $0x2,-0x10c00000(,%eax,4)
  8019f5:	02 
  8019f6:	75 1e                	jne    801a16 <sfork+0xff>
  8019f8:	eb 74                	jmp    801a6e <sfork+0x157>
	pde =(pde_t*) &vpd[VPD(addr)];
	if(*pde&PTE_P)
	{
		pte=(pte_t*)&vpt[VPN(addr)];
	}
	else    panic("page table for pn page is not exist");
  8019fa:	c7 44 24 08 4c 26 81 	movl   $0x81264c,0x8(%esp)
  801a01:	00 
  801a02:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  801a09:	00 
  801a0a:	c7 04 24 0a 27 81 00 	movl   $0x81270a,(%esp)
  801a11:	e8 96 ee ff ff       	call   8008ac <_panic>
	if(*pte&PTE_W)
	{
		//cprintf("sduppage:addr=%x\n",addr);
		if((r=sys_page_map(0,addr,envid,addr,PTE_W|PTE_U))<0)
  801a16:	c7 44 24 10 06 00 00 	movl   $0x6,0x10(%esp)
  801a1d:	00 
  801a1e:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  801a22:	8b 45 f0             	mov    -0x10(%ebp),%eax
  801a25:	89 44 24 08          	mov    %eax,0x8(%esp)
  801a29:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801a2d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801a34:	e8 83 fc ff ff       	call   8016bc <sys_page_map>
  801a39:	85 c0                	test   %eax,%eax
  801a3b:	0f 88 b9 00 00 00    	js     801afa <sfork+0x1e3>
			return r;
		if((r=sys_page_map(0,addr,0,addr,PTE_W|PTE_U))<0)//envid
  801a41:	c7 44 24 10 06 00 00 	movl   $0x6,0x10(%esp)
  801a48:	00 
  801a49:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  801a4d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801a54:	00 
  801a55:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801a59:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801a60:	e8 57 fc ff ff       	call   8016bc <sys_page_map>
  801a65:	85 c0                	test   %eax,%eax
  801a67:	79 2c                	jns    801a95 <sfork+0x17e>
  801a69:	e9 8c 00 00 00       	jmp    801afa <sfork+0x1e3>
                        return r;
	}
	else{	
		if((r=sys_page_map(0,addr,envid,addr,PTE_U|PTE_P))<0)
  801a6e:	c7 44 24 10 05 00 00 	movl   $0x5,0x10(%esp)
  801a75:	00 
  801a76:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  801a7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  801a7d:	89 44 24 08          	mov    %eax,0x8(%esp)
  801a81:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801a85:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801a8c:	e8 2b fc ff ff       	call   8016bc <sys_page_map>
  801a91:	85 c0                	test   %eax,%eax
  801a93:	78 65                	js     801afa <sfork+0x1e3>
	}
	else{//,
	//
		env = &envs[ENVX(sys_getenvid())];
		set_pgfault_handler(pgfault);//
		for(i=0;i<(unsigned)VPN(UTOP);i++)//writable or copy-to-write
  801a95:	83 c6 01             	add    $0x1,%esi
  801a98:	81 c7 00 10 00 00    	add    $0x1000,%edi
  801a9e:	81 fe 00 ec 0e 00    	cmp    $0xeec00,%esi
  801aa4:	0f 85 fa fe ff ff    	jne    8019a4 <sfork+0x8d>
				continue;
			}
			if((r=sduppage(envid,i))<0)
				return r;
		}
		if((r=sys_page_alloc(envid,(void*)(UXSTACKTOP-PGSIZE),PTE_W|PTE_U|PTE_P))<0)
  801aaa:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801ab1:	00 
  801ab2:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  801ab9:	ee 
  801aba:	8b 45 f0             	mov    -0x10(%ebp),%eax
  801abd:	89 04 24             	mov    %eax,(%esp)
  801ac0:	e8 55 fc ff ff       	call   80171a <sys_page_alloc>
  801ac5:	85 c0                	test   %eax,%eax
  801ac7:	78 31                	js     801afa <sfork+0x1e3>
                        return r;//
		if((r=sys_env_set_pgfault_upcall(envid,(void*)_pgfault_upcall))<0)
  801ac9:	c7 44 24 04 0c 30 80 	movl   $0x80300c,0x4(%esp)
  801ad0:	00 
  801ad1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  801ad4:	89 04 24             	mov    %eax,(%esp)
  801ad7:	e8 68 fa ff ff       	call   801544 <sys_env_set_pgfault_upcall>
  801adc:	85 c0                	test   %eax,%eax
  801ade:	78 1a                	js     801afa <sfork+0x1e3>
			return r;//
		if((r=sys_env_set_status(envid,ENV_RUNNABLE))<0)
  801ae0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  801ae7:	00 
  801ae8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  801aeb:	89 04 24             	mov    %eax,(%esp)
  801aee:	e8 0d fb ff ff       	call   801600 <sys_env_set_status>
  801af3:	85 c0                	test   %eax,%eax
  801af5:	78 03                	js     801afa <sfork+0x1e3>
  801af7:	8b 45 f0             	mov    -0x10(%ebp),%eax
			return r;//
		return envid;
	}
	//panic("sfork not implemented");
	//return -E_INVAL;
}
  801afa:	83 c4 1c             	add    $0x1c,%esp
  801afd:	5b                   	pop    %ebx
  801afe:	5e                   	pop    %esi
  801aff:	5f                   	pop    %edi
  801b00:	5d                   	pop    %ebp
  801b01:	c3                   	ret    

00801b02 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  801b02:	55                   	push   %ebp
  801b03:	89 e5                	mov    %esp,%ebp
  801b05:	56                   	push   %esi
  801b06:	53                   	push   %ebx
  801b07:	83 ec 20             	sub    $0x20,%esp
  801b0a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	void *addr = (void *) utf->utf_fault_va;
	uint32_t err = utf->utf_err;
  801b0d:	8b 71 04             	mov    0x4(%ecx),%esi

	// LAB 4: Your code here.
	pde_t *pde;
	pte_t *pte;
	uint32_t *va,*srcva,*dstva;
	pde =(pde_t*) &vpd[VPD(addr)];
  801b10:	8b 19                	mov    (%ecx),%ebx
  801b12:	89 d8                	mov    %ebx,%eax
  801b14:	c1 e8 16             	shr    $0x16,%eax
  801b17:	c1 e0 02             	shl    $0x2,%eax
  801b1a:	8d 90 00 d0 7b ef    	lea    -0x10843000(%eax),%edx
	if(*pde&PTE_P)
  801b20:	f6 80 00 d0 7b ef 01 	testb  $0x1,-0x10843000(%eax)
  801b27:	74 16                	je     801b3f <pgfault+0x3d>
	{
		pte=(pte_t*)&vpt[VPN(addr)];
  801b29:	89 d8                	mov    %ebx,%eax
  801b2b:	c1 e8 0c             	shr    $0xc,%eax
  801b2e:	8d 04 85 00 00 40 ef 	lea    -0x10c00000(,%eax,4),%eax
	else{
		cprintf("addr=%x err=%x *pde=%x utf_eip=%x\n",(uint32_t)addr,err,*pde,utf->utf_eip);	
		panic("page table for fault va is not exist");
	}
	//cprintf("addr=%x err=%x *pte=%x utf_eip=%x\n",(uint32_t)addr,err,*pte,utf->utf_eip);
	if(!(err&FEC_WR)||!(*pte&PTE_COW))
  801b35:	f7 c6 02 00 00 00    	test   $0x2,%esi
  801b3b:	75 3f                	jne    801b7c <pgfault+0x7a>
  801b3d:	eb 43                	jmp    801b82 <pgfault+0x80>
	if(*pde&PTE_P)
	{
		pte=(pte_t*)&vpt[VPN(addr)];
	}
	else{
		cprintf("addr=%x err=%x *pde=%x utf_eip=%x\n",(uint32_t)addr,err,*pde,utf->utf_eip);	
  801b3f:	8b 41 28             	mov    0x28(%ecx),%eax
  801b42:	8b 12                	mov    (%edx),%edx
  801b44:	89 44 24 10          	mov    %eax,0x10(%esp)
  801b48:	89 54 24 0c          	mov    %edx,0xc(%esp)
  801b4c:	89 74 24 08          	mov    %esi,0x8(%esp)
  801b50:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  801b54:	c7 04 24 70 26 81 00 	movl   $0x812670,(%esp)
  801b5b:	e8 19 ee ff ff       	call   800979 <cprintf>
		panic("page table for fault va is not exist");
  801b60:	c7 44 24 08 94 26 81 	movl   $0x812694,0x8(%esp)
  801b67:	00 
  801b68:	c7 44 24 04 27 00 00 	movl   $0x27,0x4(%esp)
  801b6f:	00 
  801b70:	c7 04 24 0a 27 81 00 	movl   $0x81270a,(%esp)
  801b77:	e8 30 ed ff ff       	call   8008ac <_panic>
	}
	//cprintf("addr=%x err=%x *pte=%x utf_eip=%x\n",(uint32_t)addr,err,*pte,utf->utf_eip);
	if(!(err&FEC_WR)||!(*pte&PTE_COW))
  801b7c:	f6 40 01 08          	testb  $0x8,0x1(%eax)
  801b80:	75 49                	jne    801bcb <pgfault+0xc9>
	{	
		cprintf("envid=%x addr=%x err=%x *pte=%x utf_eip=%x\n",env->env_id,(uint32_t)addr,err,*pte,utf->utf_eip);
  801b82:	8b 51 28             	mov    0x28(%ecx),%edx
  801b85:	8b 08                	mov    (%eax),%ecx
  801b87:	a1 b4 e5 b3 00       	mov    0xb3e5b4,%eax
  801b8c:	8b 40 4c             	mov    0x4c(%eax),%eax
  801b8f:	89 54 24 14          	mov    %edx,0x14(%esp)
  801b93:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  801b97:	89 74 24 0c          	mov    %esi,0xc(%esp)
  801b9b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  801b9f:	89 44 24 04          	mov    %eax,0x4(%esp)
  801ba3:	c7 04 24 bc 26 81 00 	movl   $0x8126bc,(%esp)
  801baa:	e8 ca ed ff ff       	call   800979 <cprintf>
		panic("faulting access is illegle");
  801baf:	c7 44 24 08 25 27 81 	movl   $0x812725,0x8(%esp)
  801bb6:	00 
  801bb7:	c7 44 24 04 2d 00 00 	movl   $0x2d,0x4(%esp)
  801bbe:	00 
  801bbf:	c7 04 24 0a 27 81 00 	movl   $0x81270a,(%esp)
  801bc6:	e8 e1 ec ff ff       	call   8008ac <_panic>
	//   You should make three system calls.
	//   No need to explicitly delete the old page's mapping.

	// LAB 4: Your code here.
	//cprintf("pgfault:env_id=%x\n",env->env_id);
	if((r=sys_page_alloc(0,PFTEMP,PTE_W|PTE_U|PTE_P))<0)
  801bcb:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801bd2:	00 
  801bd3:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801bda:	00 
  801bdb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801be2:	e8 33 fb ff ff       	call   80171a <sys_page_alloc>
  801be7:	85 c0                	test   %eax,%eax
  801be9:	79 20                	jns    801c0b <pgfault+0x109>
			//id=0id(curenv->env_id),env->env-id,env
		panic("alloc a page for PFTEMP failed:%e",r);
  801beb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801bef:	c7 44 24 08 e8 26 81 	movl   $0x8126e8,0x8(%esp)
  801bf6:	00 
  801bf7:	c7 44 24 04 3a 00 00 	movl   $0x3a,0x4(%esp)
  801bfe:	00 
  801bff:	c7 04 24 0a 27 81 00 	movl   $0x81270a,(%esp)
  801c06:	e8 a1 ec ff ff       	call   8008ac <_panic>
	//cprintf("PFTEMP=%x add=%x\n",PFTEMP,(uint32_t)addr&0xfffff000);
	srcva = (uint32_t*)((uint32_t)addr&0xfffff000);
  801c0b:	89 de                	mov    %ebx,%esi
  801c0d:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
  801c13:	89 f2                	mov    %esi,%edx
	dstva = (uint32_t*)PFTEMP;
	//strncpy((char*)PFTEMP,(char*)((uint32_t)addr&0xfffff000),PGSIZE);
	for(;srcva<(uint32_t*)(ROUNDUP(addr,PGSIZE));srcva++)//strncpy
  801c15:	8d 83 ff 0f 00 00    	lea    0xfff(%ebx),%eax
  801c1b:	89 c3                	mov    %eax,%ebx
  801c1d:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  801c23:	39 de                	cmp    %ebx,%esi
  801c25:	73 13                	jae    801c3a <pgfault+0x138>
  801c27:	b9 00 f0 7f 00       	mov    $0x7ff000,%ecx
	{
		*dstva=*srcva;
  801c2c:	8b 02                	mov    (%edx),%eax
  801c2e:	89 01                	mov    %eax,(%ecx)
		dstva++;
  801c30:	83 c1 04             	add    $0x4,%ecx
		panic("alloc a page for PFTEMP failed:%e",r);
	//cprintf("PFTEMP=%x add=%x\n",PFTEMP,(uint32_t)addr&0xfffff000);
	srcva = (uint32_t*)((uint32_t)addr&0xfffff000);
	dstva = (uint32_t*)PFTEMP;
	//strncpy((char*)PFTEMP,(char*)((uint32_t)addr&0xfffff000),PGSIZE);
	for(;srcva<(uint32_t*)(ROUNDUP(addr,PGSIZE));srcva++)//strncpy
  801c33:	83 c2 04             	add    $0x4,%edx
  801c36:	39 da                	cmp    %ebx,%edx
  801c38:	72 f2                	jb     801c2c <pgfault+0x12a>
	{
		*dstva=*srcva;
		dstva++;
	}
	if((r=sys_page_map(0,(void*)PFTEMP,0,(void*)((uint32_t)addr&0xfffff000),PTE_W|PTE_U|PTE_P))<0)
  801c3a:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  801c41:	00 
  801c42:	89 74 24 0c          	mov    %esi,0xc(%esp)
  801c46:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801c4d:	00 
  801c4e:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801c55:	00 
  801c56:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801c5d:	e8 5a fa ff ff       	call   8016bc <sys_page_map>
  801c62:	85 c0                	test   %eax,%eax
  801c64:	79 1c                	jns    801c82 <pgfault+0x180>
			//id=0id(curenv->env_id),env->env-id,env
		panic("page mapping failed");
  801c66:	c7 44 24 08 40 27 81 	movl   $0x812740,0x8(%esp)
  801c6d:	00 
  801c6e:	c7 44 24 04 46 00 00 	movl   $0x46,0x4(%esp)
  801c75:	00 
  801c76:	c7 04 24 0a 27 81 00 	movl   $0x81270a,(%esp)
  801c7d:	e8 2a ec ff ff       	call   8008ac <_panic>
	//panic("pgfault not implemented");
}
  801c82:	83 c4 20             	add    $0x20,%esp
  801c85:	5b                   	pop    %ebx
  801c86:	5e                   	pop    %esi
  801c87:	5d                   	pop    %ebp
  801c88:	c3                   	ret    

00801c89 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  801c89:	55                   	push   %ebp
  801c8a:	89 e5                	mov    %esp,%ebp
  801c8c:	56                   	push   %esi
  801c8d:	53                   	push   %ebx
  801c8e:	83 ec 10             	sub    $0x10,%esp
  801c91:	ba 07 00 00 00       	mov    $0x7,%edx
  801c96:	89 d0                	mov    %edx,%eax
  801c98:	cd 30                	int    $0x30
  801c9a:	89 c6                	mov    %eax,%esi
	pte_t *pte;
	unsigned i;
	uint32_t addr;
	envid_t envid;
	envid = sys_exofork();//
	if(envid < 0)
  801c9c:	85 c0                	test   %eax,%eax
  801c9e:	79 20                	jns    801cc0 <fork+0x37>
		panic("sys_exofork: %e", envid);
  801ca0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801ca4:	c7 44 24 08 15 27 81 	movl   $0x812715,0x8(%esp)
  801cab:	00 
  801cac:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  801cb3:	00 
  801cb4:	c7 04 24 0a 27 81 00 	movl   $0x81270a,(%esp)
  801cbb:	e8 ec eb ff ff       	call   8008ac <_panic>
	if(envid==0)//
  801cc0:	85 c0                	test   %eax,%eax
  801cc2:	75 21                	jne    801ce5 <fork+0x5c>
	{
		env = &envs[ENVX(sys_getenvid())];
  801cc4:	e8 e4 fa ff ff       	call   8017ad <sys_getenvid>
  801cc9:	25 ff 03 00 00       	and    $0x3ff,%eax
  801cce:	6b c0 7c             	imul   $0x7c,%eax,%eax
  801cd1:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  801cd6:	a3 b4 e5 b3 00       	mov    %eax,0xb3e5b4
  801cdb:	b8 00 00 00 00       	mov    $0x0,%eax
  801ce0:	e9 9e 00 00 00       	jmp    801d83 <fork+0xfa>
		return 0;
	}
	else{//
		set_pgfault_handler(pgfault);//
  801ce5:	c7 04 24 02 1b 80 00 	movl   $0x801b02,(%esp)
  801cec:	e8 97 12 00 00       	call   802f88 <set_pgfault_handler>
  801cf1:	bb 00 00 00 00       	mov    $0x0,%ebx
  801cf6:	eb 08                	jmp    801d00 <fork+0x77>
		for(i=0;i<(unsigned)VPN(UTOP);i++)//writable or copy-to-write
		{
			if(i==(unsigned)VPN(UXSTACKTOP-PGSIZE))//
  801cf8:	81 fb ff eb 0e 00    	cmp    $0xeebff,%ebx
  801cfe:	74 3d                	je     801d3d <fork+0xb4>
				continue;
  801d00:	89 da                	mov    %ebx,%edx
  801d02:	c1 e2 0c             	shl    $0xc,%edx
			addr=i*PGSIZE;
			pde =(pde_t*) &vpd[VPD(addr)];
  801d05:	89 d0                	mov    %edx,%eax
  801d07:	c1 e8 16             	shr    $0x16,%eax
			if(*pde&PTE_P)//
  801d0a:	f6 04 85 00 d0 7b ef 	testb  $0x1,-0x10843000(,%eax,4)
  801d11:	01 
  801d12:	74 1e                	je     801d32 <fork+0xa9>
			{
				pte=(pte_t*)&vpt[VPN(addr)];
  801d14:	89 d0                	mov    %edx,%eax
  801d16:	c1 e8 0a             	shr    $0xa,%eax
			}
			else    continue;
			if((*pte&PTE_W)||(*pte&PTE_COW))
  801d19:	f7 80 00 00 40 ef 02 	testl  $0x802,-0x10c00000(%eax)
  801d20:	08 00 00 
  801d23:	74 0d                	je     801d32 <fork+0xa9>
			{
				if((r=duppage(envid,i))<0)
  801d25:	89 da                	mov    %ebx,%edx
  801d27:	89 f0                	mov    %esi,%eax
  801d29:	e8 12 fb ff ff       	call   801840 <duppage>
  801d2e:	85 c0                	test   %eax,%eax
  801d30:	78 51                	js     801d83 <fork+0xfa>
		env = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	else{//
		set_pgfault_handler(pgfault);//
		for(i=0;i<(unsigned)VPN(UTOP);i++)//writable or copy-to-write
  801d32:	83 c3 01             	add    $0x1,%ebx
  801d35:	81 fb 00 ec 0e 00    	cmp    $0xeec00,%ebx
  801d3b:	75 bb                	jne    801cf8 <fork+0x6f>
			{
				if((r=duppage(envid,i))<0)
					return r;
			}
		}
		if((r=sys_page_alloc(envid,(void*)(UXSTACKTOP-PGSIZE),PTE_W|PTE_U|PTE_P))<0)
  801d3d:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801d44:	00 
  801d45:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  801d4c:	ee 
  801d4d:	89 34 24             	mov    %esi,(%esp)
  801d50:	e8 c5 f9 ff ff       	call   80171a <sys_page_alloc>
  801d55:	85 c0                	test   %eax,%eax
  801d57:	78 2a                	js     801d83 <fork+0xfa>
			return r;//
		if((r=sys_env_set_pgfault_upcall(envid,(void*)_pgfault_upcall))<0)
  801d59:	c7 44 24 04 0c 30 80 	movl   $0x80300c,0x4(%esp)
  801d60:	00 
  801d61:	89 34 24             	mov    %esi,(%esp)
  801d64:	e8 db f7 ff ff       	call   801544 <sys_env_set_pgfault_upcall>
  801d69:	85 c0                	test   %eax,%eax
  801d6b:	78 16                	js     801d83 <fork+0xfa>
			return r;//
		if((r=sys_env_set_status(envid,ENV_RUNNABLE))<0)
  801d6d:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  801d74:	00 
  801d75:	89 34 24             	mov    %esi,(%esp)
  801d78:	e8 83 f8 ff ff       	call   801600 <sys_env_set_status>
  801d7d:	85 c0                	test   %eax,%eax
  801d7f:	78 02                	js     801d83 <fork+0xfa>
  801d81:	89 f0                	mov    %esi,%eax
			return r;//
		return envid;
	}
	//panic("fork not implemented");
}
  801d83:	83 c4 10             	add    $0x10,%esp
  801d86:	5b                   	pop    %ebx
  801d87:	5e                   	pop    %esi
  801d88:	5d                   	pop    %ebp
  801d89:	c3                   	ret    
  801d8a:	00 00                	add    %al,(%eax)
  801d8c:	00 00                	add    %al,(%eax)
	...

00801d90 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  801d90:	55                   	push   %ebp
  801d91:	89 e5                	mov    %esp,%ebp
  801d93:	57                   	push   %edi
  801d94:	56                   	push   %esi
  801d95:	53                   	push   %ebx
  801d96:	83 ec 1c             	sub    $0x1c,%esp
  801d99:	8b 75 08             	mov    0x8(%ebp),%esi
  801d9c:	8b 7d 14             	mov    0x14(%ebp),%edi
	// LAB 4: Your code here.
	int r,i=0;
	env = &envs[ENVX(sys_getenvid())];
  801d9f:	e8 09 fa ff ff       	call   8017ad <sys_getenvid>
  801da4:	25 ff 03 00 00       	and    $0x3ff,%eax
  801da9:	6b c0 7c             	imul   $0x7c,%eax,%eax
  801dac:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  801db1:	a3 b4 e5 b3 00       	mov    %eax,0xb3e5b4
	do{
		//cprintf("%x send value to %x\n",env->env_id,to_env);
		env = &envs[ENVX(sys_getenvid())];
  801db6:	e8 f2 f9 ff ff       	call   8017ad <sys_getenvid>
  801dbb:	25 ff 03 00 00       	and    $0x3ff,%eax
  801dc0:	6b c0 7c             	imul   $0x7c,%eax,%eax
  801dc3:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  801dc8:	a3 b4 e5 b3 00       	mov    %eax,0xb3e5b4
		if(env->env_id==to_env){
  801dcd:	8b 40 4c             	mov    0x4c(%eax),%eax
  801dd0:	39 f0                	cmp    %esi,%eax
  801dd2:	75 0e                	jne    801de2 <ipc_send+0x52>
			cprintf("send:the reciver is sender\n");
  801dd4:	c7 04 24 54 27 81 00 	movl   $0x812754,(%esp)
  801ddb:	e8 99 eb ff ff       	call   800979 <cprintf>
  801de0:	eb 5a                	jmp    801e3c <ipc_send+0xac>
			return;
		}
		if((r=sys_ipc_try_send(to_env,val,pg,perm))<0)
  801de2:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  801de6:	8b 45 10             	mov    0x10(%ebp),%eax
  801de9:	89 44 24 08          	mov    %eax,0x8(%esp)
  801ded:	8b 45 0c             	mov    0xc(%ebp),%eax
  801df0:	89 44 24 04          	mov    %eax,0x4(%esp)
  801df4:	89 34 24             	mov    %esi,(%esp)
  801df7:	e8 10 f7 ff ff       	call   80150c <sys_ipc_try_send>
  801dfc:	89 c3                	mov    %eax,%ebx
  801dfe:	85 c0                	test   %eax,%eax
  801e00:	79 25                	jns    801e27 <ipc_send+0x97>
		{	
			if(r!=-E_IPC_NOT_RECV)
  801e02:	83 f8 f9             	cmp    $0xfffffff9,%eax
  801e05:	74 2b                	je     801e32 <ipc_send+0xa2>
				panic("send error:%e",r);
  801e07:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801e0b:	c7 44 24 08 70 27 81 	movl   $0x812770,0x8(%esp)
  801e12:	00 
  801e13:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  801e1a:	00 
  801e1b:	c7 04 24 7e 27 81 00 	movl   $0x81277e,(%esp)
  801e22:	e8 85 ea ff ff       	call   8008ac <_panic>
		}
			sys_yield();
  801e27:	e8 4d f9 ff ff       	call   801779 <sys_yield>
		
	}while(r!=0);
  801e2c:	85 db                	test   %ebx,%ebx
  801e2e:	75 86                	jne    801db6 <ipc_send+0x26>
  801e30:	eb 0a                	jmp    801e3c <ipc_send+0xac>
		if((r=sys_ipc_try_send(to_env,val,pg,perm))<0)
		{	
			if(r!=-E_IPC_NOT_RECV)
				panic("send error:%e",r);
		}
			sys_yield();
  801e32:	e8 42 f9 ff ff       	call   801779 <sys_yield>
  801e37:	e9 7a ff ff ff       	jmp    801db6 <ipc_send+0x26>
		
	}while(r!=0);
	return;
	//panic("ipc_send not implemented");
}
  801e3c:	83 c4 1c             	add    $0x1c,%esp
  801e3f:	5b                   	pop    %ebx
  801e40:	5e                   	pop    %esi
  801e41:	5f                   	pop    %edi
  801e42:	5d                   	pop    %ebp
  801e43:	c3                   	ret    

00801e44 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  801e44:	55                   	push   %ebp
  801e45:	89 e5                	mov    %esp,%ebp
  801e47:	57                   	push   %edi
  801e48:	56                   	push   %esi
  801e49:	53                   	push   %ebx
  801e4a:	83 ec 0c             	sub    $0xc,%esp
  801e4d:	8b 75 08             	mov    0x8(%ebp),%esi
  801e50:	8b 7d 10             	mov    0x10(%ebp),%edi
	// LAB 4: Your code here.
	int r;
	void *dstva=NULL;
	if(pg)
		dstva=pg;
	env = &envs[ENVX(sys_getenvid())];
  801e53:	e8 55 f9 ff ff       	call   8017ad <sys_getenvid>
  801e58:	25 ff 03 00 00       	and    $0x3ff,%eax
  801e5d:	6b c0 7c             	imul   $0x7c,%eax,%eax
  801e60:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  801e65:	a3 b4 e5 b3 00       	mov    %eax,0xb3e5b4
	if(from_env_store&&(env->env_id==*from_env_store))
  801e6a:	85 f6                	test   %esi,%esi
  801e6c:	74 29                	je     801e97 <ipc_recv+0x53>
  801e6e:	8b 40 4c             	mov    0x4c(%eax),%eax
  801e71:	3b 06                	cmp    (%esi),%eax
  801e73:	75 22                	jne    801e97 <ipc_recv+0x53>
	{
		*from_env_store=0;
  801e75:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		*perm_store=0;
  801e7b:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
		cprintf("send:the reciver is sender\n");
  801e81:	c7 04 24 54 27 81 00 	movl   $0x812754,(%esp)
  801e88:	e8 ec ea ff ff       	call   800979 <cprintf>
  801e8d:	bb 00 00 00 00       	mov    $0x0,%ebx
  801e92:	e9 8a 00 00 00       	jmp    801f21 <ipc_recv+0xdd>
		return 0;
	}
	env = &envs[ENVX(sys_getenvid())];
  801e97:	e8 11 f9 ff ff       	call   8017ad <sys_getenvid>
  801e9c:	25 ff 03 00 00       	and    $0x3ff,%eax
  801ea1:	6b c0 7c             	imul   $0x7c,%eax,%eax
  801ea4:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  801ea9:	a3 b4 e5 b3 00       	mov    %eax,0xb3e5b4
	if((r=sys_ipc_recv(dstva))<0)
  801eae:	8b 45 0c             	mov    0xc(%ebp),%eax
  801eb1:	89 04 24             	mov    %eax,(%esp)
  801eb4:	e8 f6 f5 ff ff       	call   8014af <sys_ipc_recv>
  801eb9:	89 c3                	mov    %eax,%ebx
  801ebb:	85 c0                	test   %eax,%eax
  801ebd:	79 1a                	jns    801ed9 <ipc_recv+0x95>
	{
		*from_env_store=0;
  801ebf:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		*perm_store=0;
  801ec5:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
		cprintf("reciver failed\n");
  801ecb:	c7 04 24 88 27 81 00 	movl   $0x812788,(%esp)
  801ed2:	e8 a2 ea ff ff       	call   800979 <cprintf>
  801ed7:	eb 48                	jmp    801f21 <ipc_recv+0xdd>
		return r;
	}
	else{//
		env = &envs[ENVX(sys_getenvid())];
  801ed9:	e8 cf f8 ff ff       	call   8017ad <sys_getenvid>
  801ede:	25 ff 03 00 00       	and    $0x3ff,%eax
  801ee3:	6b c0 7c             	imul   $0x7c,%eax,%eax
  801ee6:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  801eeb:	a3 b4 e5 b3 00       	mov    %eax,0xb3e5b4
		if(from_env_store)
  801ef0:	85 f6                	test   %esi,%esi
  801ef2:	74 05                	je     801ef9 <ipc_recv+0xb5>
			*from_env_store=env->env_ipc_from;	
  801ef4:	8b 40 74             	mov    0x74(%eax),%eax
  801ef7:	89 06                	mov    %eax,(%esi)
		if(perm_store)
  801ef9:	85 ff                	test   %edi,%edi
  801efb:	74 0a                	je     801f07 <ipc_recv+0xc3>
			*perm_store=env->env_ipc_perm;
  801efd:	a1 b4 e5 b3 00       	mov    0xb3e5b4,%eax
  801f02:	8b 40 78             	mov    0x78(%eax),%eax
  801f05:	89 07                	mov    %eax,(%edi)
		env = &envs[ENVX(sys_getenvid())];
  801f07:	e8 a1 f8 ff ff       	call   8017ad <sys_getenvid>
  801f0c:	25 ff 03 00 00       	and    $0x3ff,%eax
  801f11:	6b c0 7c             	imul   $0x7c,%eax,%eax
  801f14:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  801f19:	a3 b4 e5 b3 00       	mov    %eax,0xb3e5b4
		return env->env_ipc_value;
  801f1e:	8b 58 70             	mov    0x70(%eax),%ebx
	}
	//panic("ipc_recv not implemented");
	return 0;
}
  801f21:	89 d8                	mov    %ebx,%eax
  801f23:	83 c4 0c             	add    $0xc,%esp
  801f26:	5b                   	pop    %ebx
  801f27:	5e                   	pop    %esi
  801f28:	5f                   	pop    %edi
  801f29:	5d                   	pop    %ebp
  801f2a:	c3                   	ret    
  801f2b:	00 00                	add    %al,(%eax)
  801f2d:	00 00                	add    %al,(%eax)
	...

00801f30 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  801f30:	55                   	push   %ebp
  801f31:	89 e5                	mov    %esp,%ebp
  801f33:	8b 45 08             	mov    0x8(%ebp),%eax
  801f36:	05 00 00 00 30       	add    $0x30000000,%eax
  801f3b:	c1 e8 0c             	shr    $0xc,%eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
}
  801f3e:	5d                   	pop    %ebp
  801f3f:	c3                   	ret    

00801f40 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  801f40:	55                   	push   %ebp
  801f41:	89 e5                	mov    %esp,%ebp
  801f43:	83 ec 04             	sub    $0x4,%esp
	return INDEX2DATA(fd2num(fd));
  801f46:	8b 45 08             	mov    0x8(%ebp),%eax
  801f49:	89 04 24             	mov    %eax,(%esp)
  801f4c:	e8 df ff ff ff       	call   801f30 <fd2num>
  801f51:	c1 e0 0c             	shl    $0xc,%eax
  801f54:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  801f59:	c9                   	leave  
  801f5a:	c3                   	ret    

00801f5b <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  801f5b:	55                   	push   %ebp
  801f5c:	89 e5                	mov    %esp,%ebp
  801f5e:	53                   	push   %ebx
  801f5f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  801f62:	ba 00 00 00 d0       	mov    $0xd0000000,%edx
  801f67:	89 d1                	mov    %edx,%ecx
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((vpd[PDX(fd)] & PTE_P) == 0 || (vpt[VPN(fd)] & PTE_P) == 0) {
  801f69:	89 d0                	mov    %edx,%eax
  801f6b:	c1 e8 16             	shr    $0x16,%eax
  801f6e:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  801f75:	a8 01                	test   $0x1,%al
  801f77:	74 10                	je     801f89 <fd_alloc+0x2e>
  801f79:	89 d0                	mov    %edx,%eax
  801f7b:	c1 e8 0c             	shr    $0xc,%eax
  801f7e:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  801f85:	a8 01                	test   $0x1,%al
  801f87:	75 09                	jne    801f92 <fd_alloc+0x37>
			*fd_store = fd;
  801f89:	89 0b                	mov    %ecx,(%ebx)
  801f8b:	b8 00 00 00 00       	mov    $0x0,%eax
  801f90:	eb 19                	jmp    801fab <fd_alloc+0x50>
			return 0;
  801f92:	81 c2 00 10 00 00    	add    $0x1000,%edx
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  801f98:	81 fa 00 00 02 d0    	cmp    $0xd0020000,%edx
  801f9e:	75 c7                	jne    801f67 <fd_alloc+0xc>
		if ((vpd[PDX(fd)] & PTE_P) == 0 || (vpt[VPN(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  801fa0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  801fa6:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
	return -E_MAX_OPEN;
}
  801fab:	5b                   	pop    %ebx
  801fac:	5d                   	pop    %ebp
  801fad:	c3                   	ret    

00801fae <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  801fae:	55                   	push   %ebp
  801faf:	89 e5                	mov    %esp,%ebp
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  801fb1:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  801fb5:	77 38                	ja     801fef <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", env->env_id, fd);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  801fb7:	8b 45 08             	mov    0x8(%ebp),%eax
  801fba:	c1 e0 0c             	shl    $0xc,%eax
  801fbd:	8d 90 00 00 00 d0    	lea    -0x30000000(%eax),%edx
	if (!(vpd[PDX(fd)] & PTE_P) || !(vpt[VPN(fd)] & PTE_P)) {
  801fc3:	89 d0                	mov    %edx,%eax
  801fc5:	c1 e8 16             	shr    $0x16,%eax
  801fc8:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  801fcf:	a8 01                	test   $0x1,%al
  801fd1:	74 1c                	je     801fef <fd_lookup+0x41>
  801fd3:	89 d0                	mov    %edx,%eax
  801fd5:	c1 e8 0c             	shr    $0xc,%eax
  801fd8:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  801fdf:	a8 01                	test   $0x1,%al
  801fe1:	74 0c                	je     801fef <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] closed fd %d\n", env->env_id, fd);
		return -E_INVAL;
	}
	*fd_store = fd;
  801fe3:	8b 45 0c             	mov    0xc(%ebp),%eax
  801fe6:	89 10                	mov    %edx,(%eax)
  801fe8:	b8 00 00 00 00       	mov    $0x0,%eax
  801fed:	eb 05                	jmp    801ff4 <fd_lookup+0x46>
	return 0;
  801fef:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  801ff4:	5d                   	pop    %ebp
  801ff5:	c3                   	ret    

00801ff6 <seek>:
	return (*dev->dev_write)(fd, buf, n);
}

int
seek(int fdnum, off_t offset)
{
  801ff6:	55                   	push   %ebp
  801ff7:	89 e5                	mov    %esp,%ebp
  801ff9:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  801ffc:	8d 45 fc             	lea    -0x4(%ebp),%eax
  801fff:	89 44 24 04          	mov    %eax,0x4(%esp)
  802003:	8b 45 08             	mov    0x8(%ebp),%eax
  802006:	89 04 24             	mov    %eax,(%esp)
  802009:	e8 a0 ff ff ff       	call   801fae <fd_lookup>
  80200e:	85 c0                	test   %eax,%eax
  802010:	78 0e                	js     802020 <seek+0x2a>
		return r;
	fd->fd_offset = offset;
  802012:	8b 45 fc             	mov    -0x4(%ebp),%eax
  802015:	8b 55 0c             	mov    0xc(%ebp),%edx
  802018:	89 50 04             	mov    %edx,0x4(%eax)
  80201b:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
}
  802020:	c9                   	leave  
  802021:	c3                   	ret    

00802022 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  802022:	55                   	push   %ebp
  802023:	89 e5                	mov    %esp,%ebp
  802025:	53                   	push   %ebx
  802026:	83 ec 14             	sub    $0x14,%esp
  802029:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80202c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int i;
	for (i = 0; devtab[i]; i++)
  80202f:	ba 04 80 81 00       	mov    $0x818004,%edx
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
  802034:	b8 00 00 00 00       	mov    $0x0,%eax
int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
		if (devtab[i]->dev_id == dev_id) {
  802039:	39 0d 04 80 81 00    	cmp    %ecx,0x818004
  80203f:	75 11                	jne    802052 <dev_lookup+0x30>
  802041:	eb 04                	jmp    802047 <dev_lookup+0x25>
  802043:	39 0a                	cmp    %ecx,(%edx)
  802045:	75 0b                	jne    802052 <dev_lookup+0x30>
			*dev = devtab[i];
  802047:	89 13                	mov    %edx,(%ebx)
  802049:	b8 00 00 00 00       	mov    $0x0,%eax
  80204e:	66 90                	xchg   %ax,%ax
  802050:	eb 35                	jmp    802087 <dev_lookup+0x65>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  802052:	83 c0 01             	add    $0x1,%eax
  802055:	8b 14 85 14 28 81 00 	mov    0x812814(,%eax,4),%edx
  80205c:	85 d2                	test   %edx,%edx
  80205e:	75 e3                	jne    802043 <dev_lookup+0x21>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", env->env_id, dev_id);
  802060:	a1 b4 e5 b3 00       	mov    0xb3e5b4,%eax
  802065:	8b 40 4c             	mov    0x4c(%eax),%eax
  802068:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80206c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802070:	c7 04 24 98 27 81 00 	movl   $0x812798,(%esp)
  802077:	e8 fd e8 ff ff       	call   800979 <cprintf>
	*dev = 0;
  80207c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  802082:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	return -E_INVAL;
}
  802087:	83 c4 14             	add    $0x14,%esp
  80208a:	5b                   	pop    %ebx
  80208b:	5d                   	pop    %ebp
  80208c:	c3                   	ret    

0080208d <fstat>:
	return (*dev->dev_trunc)(fd, newsize);
}

int
fstat(int fdnum, struct Stat *stat)
{
  80208d:	55                   	push   %ebp
  80208e:	89 e5                	mov    %esp,%ebp
  802090:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802093:	8d 45 f8             	lea    -0x8(%ebp),%eax
  802096:	89 44 24 04          	mov    %eax,0x4(%esp)
  80209a:	8b 45 08             	mov    0x8(%ebp),%eax
  80209d:	89 04 24             	mov    %eax,(%esp)
  8020a0:	e8 09 ff ff ff       	call   801fae <fd_lookup>
  8020a5:	89 c2                	mov    %eax,%edx
  8020a7:	85 c0                	test   %eax,%eax
  8020a9:	78 5a                	js     802105 <fstat+0x78>
  8020ab:	8d 45 fc             	lea    -0x4(%ebp),%eax
  8020ae:	89 44 24 04          	mov    %eax,0x4(%esp)
  8020b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  8020b5:	8b 00                	mov    (%eax),%eax
  8020b7:	89 04 24             	mov    %eax,(%esp)
  8020ba:	e8 63 ff ff ff       	call   802022 <dev_lookup>
  8020bf:	89 c2                	mov    %eax,%edx
  8020c1:	85 c0                	test   %eax,%eax
  8020c3:	78 40                	js     802105 <fstat+0x78>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if (!dev->dev_stat)
  8020c5:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
  8020ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
  8020cd:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  8020d1:	74 32                	je     802105 <fstat+0x78>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  8020d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  8020d6:	c6 00 00             	movb   $0x0,(%eax)
	stat->st_size = 0;
  8020d9:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
  8020e0:	00 00 00 
	stat->st_isdir = 0;
  8020e3:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
  8020ea:	00 00 00 
	stat->st_dev = dev;
  8020ed:	8b 55 fc             	mov    -0x4(%ebp),%edx
  8020f0:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
	return (*dev->dev_stat)(fd, stat);
  8020f6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8020fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
  8020fd:	89 04 24             	mov    %eax,(%esp)
  802100:	ff 52 14             	call   *0x14(%edx)
  802103:	89 c2                	mov    %eax,%edx
}
  802105:	89 d0                	mov    %edx,%eax
  802107:	c9                   	leave  
  802108:	c3                   	ret    

00802109 <ftruncate>:
	return 0;
}

int
ftruncate(int fdnum, off_t newsize)
{
  802109:	55                   	push   %ebp
  80210a:	89 e5                	mov    %esp,%ebp
  80210c:	53                   	push   %ebx
  80210d:	83 ec 24             	sub    $0x24,%esp
  802110:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  802113:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802116:	89 44 24 04          	mov    %eax,0x4(%esp)
  80211a:	89 1c 24             	mov    %ebx,(%esp)
  80211d:	e8 8c fe ff ff       	call   801fae <fd_lookup>
  802122:	85 c0                	test   %eax,%eax
  802124:	78 61                	js     802187 <ftruncate+0x7e>
  802126:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802129:	8b 10                	mov    (%eax),%edx
  80212b:	8d 45 f8             	lea    -0x8(%ebp),%eax
  80212e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802132:	89 14 24             	mov    %edx,(%esp)
  802135:	e8 e8 fe ff ff       	call   802022 <dev_lookup>
  80213a:	85 c0                	test   %eax,%eax
  80213c:	78 49                	js     802187 <ftruncate+0x7e>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80213e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  802141:	f6 41 08 03          	testb  $0x3,0x8(%ecx)
  802145:	75 23                	jne    80216a <ftruncate+0x61>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  802147:	a1 b4 e5 b3 00       	mov    0xb3e5b4,%eax
  80214c:	8b 40 4c             	mov    0x4c(%eax),%eax
  80214f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802153:	89 44 24 04          	mov    %eax,0x4(%esp)
  802157:	c7 04 24 b8 27 81 00 	movl   $0x8127b8,(%esp)
  80215e:	e8 16 e8 ff ff       	call   800979 <cprintf>
  802163:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  802168:	eb 1d                	jmp    802187 <ftruncate+0x7e>
			env->env_id, fdnum); 
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
  80216a:	8b 55 f8             	mov    -0x8(%ebp),%edx
  80216d:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  802172:	83 7a 18 00          	cmpl   $0x0,0x18(%edx)
  802176:	74 0f                	je     802187 <ftruncate+0x7e>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  802178:	8b 42 18             	mov    0x18(%edx),%eax
  80217b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80217e:	89 54 24 04          	mov    %edx,0x4(%esp)
  802182:	89 0c 24             	mov    %ecx,(%esp)
  802185:	ff d0                	call   *%eax
}
  802187:	83 c4 24             	add    $0x24,%esp
  80218a:	5b                   	pop    %ebx
  80218b:	5d                   	pop    %ebp
  80218c:	c3                   	ret    

0080218d <write>:
	return tot;
}

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80218d:	55                   	push   %ebp
  80218e:	89 e5                	mov    %esp,%ebp
  802190:	53                   	push   %ebx
  802191:	83 ec 24             	sub    $0x24,%esp
  802194:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802197:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80219a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80219e:	89 1c 24             	mov    %ebx,(%esp)
  8021a1:	e8 08 fe ff ff       	call   801fae <fd_lookup>
  8021a6:	85 c0                	test   %eax,%eax
  8021a8:	78 68                	js     802212 <write+0x85>
  8021aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8021ad:	8b 10                	mov    (%eax),%edx
  8021af:	8d 45 f8             	lea    -0x8(%ebp),%eax
  8021b2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8021b6:	89 14 24             	mov    %edx,(%esp)
  8021b9:	e8 64 fe ff ff       	call   802022 <dev_lookup>
  8021be:	85 c0                	test   %eax,%eax
  8021c0:	78 50                	js     802212 <write+0x85>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  8021c2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  8021c5:	f6 41 08 03          	testb  $0x3,0x8(%ecx)
  8021c9:	75 23                	jne    8021ee <write+0x61>
		cprintf("[%08x] write %d -- bad mode\n", env->env_id, fdnum);
  8021cb:	a1 b4 e5 b3 00       	mov    0xb3e5b4,%eax
  8021d0:	8b 40 4c             	mov    0x4c(%eax),%eax
  8021d3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8021d7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8021db:	c7 04 24 d9 27 81 00 	movl   $0x8127d9,(%esp)
  8021e2:	e8 92 e7 ff ff       	call   800979 <cprintf>
  8021e7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8021ec:	eb 24                	jmp    802212 <write+0x85>
		return -E_INVAL;
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  8021ee:	8b 55 f8             	mov    -0x8(%ebp),%edx
  8021f1:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8021f6:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  8021fa:	74 16                	je     802212 <write+0x85>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  8021fc:	8b 42 0c             	mov    0xc(%edx),%eax
  8021ff:	8b 55 10             	mov    0x10(%ebp),%edx
  802202:	89 54 24 08          	mov    %edx,0x8(%esp)
  802206:	8b 55 0c             	mov    0xc(%ebp),%edx
  802209:	89 54 24 04          	mov    %edx,0x4(%esp)
  80220d:	89 0c 24             	mov    %ecx,(%esp)
  802210:	ff d0                	call   *%eax
}
  802212:	83 c4 24             	add    $0x24,%esp
  802215:	5b                   	pop    %ebx
  802216:	5d                   	pop    %ebp
  802217:	c3                   	ret    

00802218 <read>:
	return r;
}

ssize_t
read(int fdnum, void *buf, size_t n)
{
  802218:	55                   	push   %ebp
  802219:	89 e5                	mov    %esp,%ebp
  80221b:	53                   	push   %ebx
  80221c:	83 ec 24             	sub    $0x24,%esp
  80221f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802222:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802225:	89 44 24 04          	mov    %eax,0x4(%esp)
  802229:	89 1c 24             	mov    %ebx,(%esp)
  80222c:	e8 7d fd ff ff       	call   801fae <fd_lookup>
  802231:	85 c0                	test   %eax,%eax
  802233:	78 6d                	js     8022a2 <read+0x8a>
  802235:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802238:	8b 10                	mov    (%eax),%edx
  80223a:	8d 45 f8             	lea    -0x8(%ebp),%eax
  80223d:	89 44 24 04          	mov    %eax,0x4(%esp)
  802241:	89 14 24             	mov    %edx,(%esp)
  802244:	e8 d9 fd ff ff       	call   802022 <dev_lookup>
  802249:	85 c0                	test   %eax,%eax
  80224b:	78 55                	js     8022a2 <read+0x8a>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80224d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  802250:	8b 41 08             	mov    0x8(%ecx),%eax
  802253:	83 e0 03             	and    $0x3,%eax
  802256:	83 f8 01             	cmp    $0x1,%eax
  802259:	75 23                	jne    80227e <read+0x66>
		cprintf("[%08x] read %d -- bad mode\n", env->env_id, fdnum); 
  80225b:	a1 b4 e5 b3 00       	mov    0xb3e5b4,%eax
  802260:	8b 40 4c             	mov    0x4c(%eax),%eax
  802263:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802267:	89 44 24 04          	mov    %eax,0x4(%esp)
  80226b:	c7 04 24 f6 27 81 00 	movl   $0x8127f6,(%esp)
  802272:	e8 02 e7 ff ff       	call   800979 <cprintf>
  802277:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80227c:	eb 24                	jmp    8022a2 <read+0x8a>
		return -E_INVAL;
	}
	if (!dev->dev_read)
  80227e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  802281:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  802286:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  80228a:	74 16                	je     8022a2 <read+0x8a>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80228c:	8b 42 08             	mov    0x8(%edx),%eax
  80228f:	8b 55 10             	mov    0x10(%ebp),%edx
  802292:	89 54 24 08          	mov    %edx,0x8(%esp)
  802296:	8b 55 0c             	mov    0xc(%ebp),%edx
  802299:	89 54 24 04          	mov    %edx,0x4(%esp)
  80229d:	89 0c 24             	mov    %ecx,(%esp)
  8022a0:	ff d0                	call   *%eax
}
  8022a2:	83 c4 24             	add    $0x24,%esp
  8022a5:	5b                   	pop    %ebx
  8022a6:	5d                   	pop    %ebp
  8022a7:	c3                   	ret    

008022a8 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  8022a8:	55                   	push   %ebp
  8022a9:	89 e5                	mov    %esp,%ebp
  8022ab:	57                   	push   %edi
  8022ac:	56                   	push   %esi
  8022ad:	53                   	push   %ebx
  8022ae:	83 ec 0c             	sub    $0xc,%esp
  8022b1:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8022b4:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  8022b7:	b8 00 00 00 00       	mov    $0x0,%eax
  8022bc:	85 f6                	test   %esi,%esi
  8022be:	74 36                	je     8022f6 <readn+0x4e>
  8022c0:	bb 00 00 00 00       	mov    $0x0,%ebx
  8022c5:	ba 00 00 00 00       	mov    $0x0,%edx
		m = read(fdnum, (char*)buf + tot, n - tot);
  8022ca:	89 f0                	mov    %esi,%eax
  8022cc:	29 d0                	sub    %edx,%eax
  8022ce:	89 44 24 08          	mov    %eax,0x8(%esp)
  8022d2:	8d 04 17             	lea    (%edi,%edx,1),%eax
  8022d5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8022d9:	8b 45 08             	mov    0x8(%ebp),%eax
  8022dc:	89 04 24             	mov    %eax,(%esp)
  8022df:	e8 34 ff ff ff       	call   802218 <read>
		if (m < 0)
  8022e4:	85 c0                	test   %eax,%eax
  8022e6:	78 0e                	js     8022f6 <readn+0x4e>
			return m;
		if (m == 0)
  8022e8:	85 c0                	test   %eax,%eax
  8022ea:	74 08                	je     8022f4 <readn+0x4c>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  8022ec:	01 c3                	add    %eax,%ebx
  8022ee:	89 da                	mov    %ebx,%edx
  8022f0:	39 f3                	cmp    %esi,%ebx
  8022f2:	72 d6                	jb     8022ca <readn+0x22>
  8022f4:	89 d8                	mov    %ebx,%eax
			return m;
		if (m == 0)
			break;
	}
	return tot;
}
  8022f6:	83 c4 0c             	add    $0xc,%esp
  8022f9:	5b                   	pop    %ebx
  8022fa:	5e                   	pop    %esi
  8022fb:	5f                   	pop    %edi
  8022fc:	5d                   	pop    %ebp
  8022fd:	c3                   	ret    

008022fe <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  8022fe:	55                   	push   %ebp
  8022ff:	89 e5                	mov    %esp,%ebp
  802301:	83 ec 28             	sub    $0x28,%esp
  802304:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802307:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80230a:	8b 75 08             	mov    0x8(%ebp),%esi
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80230d:	89 34 24             	mov    %esi,(%esp)
  802310:	e8 1b fc ff ff       	call   801f30 <fd2num>
  802315:	8d 55 f4             	lea    -0xc(%ebp),%edx
  802318:	89 54 24 04          	mov    %edx,0x4(%esp)
  80231c:	89 04 24             	mov    %eax,(%esp)
  80231f:	e8 8a fc ff ff       	call   801fae <fd_lookup>
  802324:	89 c3                	mov    %eax,%ebx
  802326:	85 c0                	test   %eax,%eax
  802328:	78 05                	js     80232f <fd_close+0x31>
  80232a:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  80232d:	74 0d                	je     80233c <fd_close+0x3e>
	    || fd != fd2)
		return (must_exist ? r : 0);
  80232f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  802333:	75 44                	jne    802379 <fd_close+0x7b>
  802335:	bb 00 00 00 00       	mov    $0x0,%ebx
  80233a:	eb 3d                	jmp    802379 <fd_close+0x7b>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80233c:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80233f:	89 44 24 04          	mov    %eax,0x4(%esp)
  802343:	8b 06                	mov    (%esi),%eax
  802345:	89 04 24             	mov    %eax,(%esp)
  802348:	e8 d5 fc ff ff       	call   802022 <dev_lookup>
  80234d:	89 c3                	mov    %eax,%ebx
  80234f:	85 c0                	test   %eax,%eax
  802351:	78 16                	js     802369 <fd_close+0x6b>
		if (dev->dev_close)
  802353:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802356:	8b 40 10             	mov    0x10(%eax),%eax
  802359:	bb 00 00 00 00       	mov    $0x0,%ebx
  80235e:	85 c0                	test   %eax,%eax
  802360:	74 07                	je     802369 <fd_close+0x6b>
			r = (*dev->dev_close)(fd);
  802362:	89 34 24             	mov    %esi,(%esp)
  802365:	ff d0                	call   *%eax
  802367:	89 c3                	mov    %eax,%ebx
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  802369:	89 74 24 04          	mov    %esi,0x4(%esp)
  80236d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802374:	e8 e5 f2 ff ff       	call   80165e <sys_page_unmap>
	return r;
}
  802379:	89 d8                	mov    %ebx,%eax
  80237b:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80237e:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802381:	89 ec                	mov    %ebp,%esp
  802383:	5d                   	pop    %ebp
  802384:	c3                   	ret    

00802385 <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  802385:	55                   	push   %ebp
  802386:	89 e5                	mov    %esp,%ebp
  802388:	83 ec 18             	sub    $0x18,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80238b:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80238e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802392:	8b 45 08             	mov    0x8(%ebp),%eax
  802395:	89 04 24             	mov    %eax,(%esp)
  802398:	e8 11 fc ff ff       	call   801fae <fd_lookup>
  80239d:	85 c0                	test   %eax,%eax
  80239f:	78 13                	js     8023b4 <close+0x2f>
		return r;
	else
		return fd_close(fd, 1);
  8023a1:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8023a8:	00 
  8023a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  8023ac:	89 04 24             	mov    %eax,(%esp)
  8023af:	e8 4a ff ff ff       	call   8022fe <fd_close>
}
  8023b4:	c9                   	leave  
  8023b5:	c3                   	ret    

008023b6 <stat>:
	return (*dev->dev_stat)(fd, stat);
}

int
stat(const char *path, struct Stat *stat)
{
  8023b6:	55                   	push   %ebp
  8023b7:	89 e5                	mov    %esp,%ebp
  8023b9:	83 ec 18             	sub    $0x18,%esp
  8023bc:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8023bf:	89 75 fc             	mov    %esi,-0x4(%ebp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  8023c2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8023c9:	00 
  8023ca:	8b 45 08             	mov    0x8(%ebp),%eax
  8023cd:	89 04 24             	mov    %eax,(%esp)
  8023d0:	e8 5a 03 00 00       	call   80272f <open>
  8023d5:	89 c6                	mov    %eax,%esi
  8023d7:	85 c0                	test   %eax,%eax
  8023d9:	78 1b                	js     8023f6 <stat+0x40>
		return fd;
	r = fstat(fd, stat);
  8023db:	8b 45 0c             	mov    0xc(%ebp),%eax
  8023de:	89 44 24 04          	mov    %eax,0x4(%esp)
  8023e2:	89 34 24             	mov    %esi,(%esp)
  8023e5:	e8 a3 fc ff ff       	call   80208d <fstat>
  8023ea:	89 c3                	mov    %eax,%ebx
	close(fd);
  8023ec:	89 34 24             	mov    %esi,(%esp)
  8023ef:	e8 91 ff ff ff       	call   802385 <close>
  8023f4:	89 de                	mov    %ebx,%esi
	return r;
}
  8023f6:	89 f0                	mov    %esi,%eax
  8023f8:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8023fb:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8023fe:	89 ec                	mov    %ebp,%esp
  802400:	5d                   	pop    %ebp
  802401:	c3                   	ret    

00802402 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  802402:	55                   	push   %ebp
  802403:	89 e5                	mov    %esp,%ebp
  802405:	83 ec 38             	sub    $0x38,%esp
  802408:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80240b:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80240e:	89 7d fc             	mov    %edi,-0x4(%ebp)
  802411:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  802414:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802417:	89 44 24 04          	mov    %eax,0x4(%esp)
  80241b:	8b 45 08             	mov    0x8(%ebp),%eax
  80241e:	89 04 24             	mov    %eax,(%esp)
  802421:	e8 88 fb ff ff       	call   801fae <fd_lookup>
  802426:	89 c3                	mov    %eax,%ebx
  802428:	85 c0                	test   %eax,%eax
  80242a:	0f 88 e1 00 00 00    	js     802511 <dup+0x10f>
		return r;
	close(newfdnum);
  802430:	89 3c 24             	mov    %edi,(%esp)
  802433:	e8 4d ff ff ff       	call   802385 <close>

	newfd = INDEX2FD(newfdnum);
  802438:	89 f8                	mov    %edi,%eax
  80243a:	c1 e0 0c             	shl    $0xc,%eax
  80243d:	8d b0 00 00 00 d0    	lea    -0x30000000(%eax),%esi
	ova = fd2data(oldfd);
  802443:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802446:	89 04 24             	mov    %eax,(%esp)
  802449:	e8 f2 fa ff ff       	call   801f40 <fd2data>
  80244e:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  802450:	89 34 24             	mov    %esi,(%esp)
  802453:	e8 e8 fa ff ff       	call   801f40 <fd2data>
  802458:	89 45 e0             	mov    %eax,-0x20(%ebp)

	if ((vpd[PDX(ova)] & PTE_P) && (vpt[VPN(ova)] & PTE_P))
  80245b:	89 d8                	mov    %ebx,%eax
  80245d:	c1 e8 16             	shr    $0x16,%eax
  802460:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  802467:	a8 01                	test   $0x1,%al
  802469:	74 45                	je     8024b0 <dup+0xae>
  80246b:	89 da                	mov    %ebx,%edx
  80246d:	c1 ea 0c             	shr    $0xc,%edx
  802470:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  802477:	a8 01                	test   $0x1,%al
  802479:	74 35                	je     8024b0 <dup+0xae>
		if ((r = sys_page_map(0, ova, 0, nva, vpt[VPN(ova)] & PTE_USER)) < 0)
  80247b:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  802482:	25 07 0e 00 00       	and    $0xe07,%eax
  802487:	89 44 24 10          	mov    %eax,0x10(%esp)
  80248b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80248e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  802492:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802499:	00 
  80249a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80249e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8024a5:	e8 12 f2 ff ff       	call   8016bc <sys_page_map>
  8024aa:	89 c3                	mov    %eax,%ebx
  8024ac:	85 c0                	test   %eax,%eax
  8024ae:	78 3e                	js     8024ee <dup+0xec>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, vpt[VPN(oldfd)] & PTE_USER)) < 0)
  8024b0:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8024b3:	89 d0                	mov    %edx,%eax
  8024b5:	c1 e8 0c             	shr    $0xc,%eax
  8024b8:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  8024bf:	25 07 0e 00 00       	and    $0xe07,%eax
  8024c4:	89 44 24 10          	mov    %eax,0x10(%esp)
  8024c8:	89 74 24 0c          	mov    %esi,0xc(%esp)
  8024cc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8024d3:	00 
  8024d4:	89 54 24 04          	mov    %edx,0x4(%esp)
  8024d8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8024df:	e8 d8 f1 ff ff       	call   8016bc <sys_page_map>
  8024e4:	89 c3                	mov    %eax,%ebx
  8024e6:	85 c0                	test   %eax,%eax
  8024e8:	78 04                	js     8024ee <dup+0xec>
		goto err;
  8024ea:	89 fb                	mov    %edi,%ebx
  8024ec:	eb 23                	jmp    802511 <dup+0x10f>

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  8024ee:	89 74 24 04          	mov    %esi,0x4(%esp)
  8024f2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8024f9:	e8 60 f1 ff ff       	call   80165e <sys_page_unmap>
	sys_page_unmap(0, nva);
  8024fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
  802501:	89 44 24 04          	mov    %eax,0x4(%esp)
  802505:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80250c:	e8 4d f1 ff ff       	call   80165e <sys_page_unmap>
	return r;
}
  802511:	89 d8                	mov    %ebx,%eax
  802513:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  802516:	8b 75 f8             	mov    -0x8(%ebp),%esi
  802519:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80251c:	89 ec                	mov    %ebp,%esp
  80251e:	5d                   	pop    %ebp
  80251f:	c3                   	ret    

00802520 <close_all>:
		return fd_close(fd, 1);
}

void
close_all(void)
{
  802520:	55                   	push   %ebp
  802521:	89 e5                	mov    %esp,%ebp
  802523:	53                   	push   %ebx
  802524:	83 ec 04             	sub    $0x4,%esp
  802527:	bb 00 00 00 00       	mov    $0x0,%ebx
	int i;
	for (i = 0; i < MAXFD; i++)
		close(i);
  80252c:	89 1c 24             	mov    %ebx,(%esp)
  80252f:	e8 51 fe ff ff       	call   802385 <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  802534:	83 c3 01             	add    $0x1,%ebx
  802537:	83 fb 20             	cmp    $0x20,%ebx
  80253a:	75 f0                	jne    80252c <close_all+0xc>
		close(i);
}
  80253c:	83 c4 04             	add    $0x4,%esp
  80253f:	5b                   	pop    %ebx
  802540:	5d                   	pop    %ebp
  802541:	c3                   	ret    
	...

00802544 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  802544:	55                   	push   %ebp
  802545:	89 e5                	mov    %esp,%ebp
  802547:	53                   	push   %ebx
  802548:	83 ec 14             	sub    $0x14,%esp
  80254b:	89 d3                	mov    %edx,%ebx
	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", env->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(envs[1].env_id, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  80254d:	8b 15 c8 00 c0 ee    	mov    0xeec000c8,%edx
  802553:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80255a:	00 
  80255b:	c7 44 24 08 00 50 81 	movl   $0x815000,0x8(%esp)
  802562:	00 
  802563:	89 44 24 04          	mov    %eax,0x4(%esp)
  802567:	89 14 24             	mov    %edx,(%esp)
  80256a:	e8 21 f8 ff ff       	call   801d90 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  80256f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802576:	00 
  802577:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80257b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802582:	e8 bd f8 ff ff       	call   801e44 <ipc_recv>
}
  802587:	83 c4 14             	add    $0x14,%esp
  80258a:	5b                   	pop    %ebx
  80258b:	5d                   	pop    %ebp
  80258c:	c3                   	ret    

0080258d <sync>:
}

// Synchronize disk with buffer cache
int
sync(void)
{
  80258d:	55                   	push   %ebp
  80258e:	89 e5                	mov    %esp,%ebp
  802590:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  802593:	ba 00 00 00 00       	mov    $0x0,%edx
  802598:	b8 08 00 00 00       	mov    $0x8,%eax
  80259d:	e8 a2 ff ff ff       	call   802544 <fsipc>
}
  8025a2:	c9                   	leave  
  8025a3:	c3                   	ret    

008025a4 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  8025a4:	55                   	push   %ebp
  8025a5:	89 e5                	mov    %esp,%ebp
  8025a7:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  8025aa:	8b 45 08             	mov    0x8(%ebp),%eax
  8025ad:	8b 40 0c             	mov    0xc(%eax),%eax
  8025b0:	a3 00 50 81 00       	mov    %eax,0x815000
	fsipcbuf.set_size.req_size = newsize;
  8025b5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8025b8:	a3 04 50 81 00       	mov    %eax,0x815004
	return fsipc(FSREQ_SET_SIZE, NULL);
  8025bd:	ba 00 00 00 00       	mov    $0x0,%edx
  8025c2:	b8 02 00 00 00       	mov    $0x2,%eax
  8025c7:	e8 78 ff ff ff       	call   802544 <fsipc>
}
  8025cc:	c9                   	leave  
  8025cd:	c3                   	ret    

008025ce <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  8025ce:	55                   	push   %ebp
  8025cf:	89 e5                	mov    %esp,%ebp
  8025d1:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  8025d4:	8b 45 08             	mov    0x8(%ebp),%eax
  8025d7:	8b 40 0c             	mov    0xc(%eax),%eax
  8025da:	a3 00 50 81 00       	mov    %eax,0x815000
	return fsipc(FSREQ_FLUSH, NULL);
  8025df:	ba 00 00 00 00       	mov    $0x0,%edx
  8025e4:	b8 06 00 00 00       	mov    $0x6,%eax
  8025e9:	e8 56 ff ff ff       	call   802544 <fsipc>
}
  8025ee:	c9                   	leave  
  8025ef:	c3                   	ret    

008025f0 <devfile_stat>:
	//panic("devfile_write not implemented");
}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  8025f0:	55                   	push   %ebp
  8025f1:	89 e5                	mov    %esp,%ebp
  8025f3:	53                   	push   %ebx
  8025f4:	83 ec 14             	sub    $0x14,%esp
  8025f7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  8025fa:	8b 45 08             	mov    0x8(%ebp),%eax
  8025fd:	8b 40 0c             	mov    0xc(%eax),%eax
  802600:	a3 00 50 81 00       	mov    %eax,0x815000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  802605:	ba 00 00 00 00       	mov    $0x0,%edx
  80260a:	b8 05 00 00 00       	mov    $0x5,%eax
  80260f:	e8 30 ff ff ff       	call   802544 <fsipc>
  802614:	85 c0                	test   %eax,%eax
  802616:	78 2b                	js     802643 <devfile_stat+0x53>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  802618:	c7 44 24 04 00 50 81 	movl   $0x815000,0x4(%esp)
  80261f:	00 
  802620:	89 1c 24             	mov    %ebx,(%esp)
  802623:	e8 b9 e9 ff ff       	call   800fe1 <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  802628:	a1 80 50 81 00       	mov    0x815080,%eax
  80262d:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  802633:	a1 84 50 81 00       	mov    0x815084,%eax
  802638:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
  80263e:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
}
  802643:	83 c4 14             	add    $0x14,%esp
  802646:	5b                   	pop    %ebx
  802647:	5d                   	pop    %ebp
  802648:	c3                   	ret    

00802649 <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  802649:	55                   	push   %ebp
  80264a:	89 e5                	mov    %esp,%ebp
  80264c:	83 ec 18             	sub    $0x18,%esp
  80264f:	8b 55 10             	mov    0x10(%ebp),%edx
	// remember that write is always allowed to write *fewer*
	// bytes than requested.
	// LAB 5: Your code here
	ssize_t writesize;
	size_t bufsize;
	fsipcbuf.write.req_fileid=fd->fd_file.id;
  802652:	8b 45 08             	mov    0x8(%ebp),%eax
  802655:	8b 40 0c             	mov    0xc(%eax),%eax
  802658:	a3 00 50 81 00       	mov    %eax,0x815000
	bufsize=sizeof(fsipcbuf.write.req_buf);
	if(n<bufsize)
  80265d:	89 d0                	mov    %edx,%eax
  80265f:	81 fa f7 0f 00 00    	cmp    $0xff7,%edx
  802665:	76 05                	jbe    80266c <devfile_write+0x23>
  802667:	b8 f8 0f 00 00       	mov    $0xff8,%eax
		bufsize=n;	
	fsipcbuf.write.req_n=n;
  80266c:	89 15 04 50 81 00    	mov    %edx,0x815004
	memmove((void*)fsipcbuf.write.req_buf,buf,bufsize);
  802672:	89 44 24 08          	mov    %eax,0x8(%esp)
  802676:	8b 45 0c             	mov    0xc(%ebp),%eax
  802679:	89 44 24 04          	mov    %eax,0x4(%esp)
  80267d:	c7 04 24 08 50 81 00 	movl   $0x815008,(%esp)
  802684:	e8 5f eb ff ff       	call   8011e8 <memmove>
	writesize=(ssize_t)fsipc(FSREQ_WRITE,NULL);
  802689:	ba 00 00 00 00       	mov    $0x0,%edx
  80268e:	b8 04 00 00 00       	mov    $0x4,%eax
  802693:	e8 ac fe ff ff       	call   802544 <fsipc>
	return writesize;
	//panic("devfile_write not implemented");
}
  802698:	c9                   	leave  
  802699:	c3                   	ret    

0080269a <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  80269a:	55                   	push   %ebp
  80269b:	89 e5                	mov    %esp,%ebp
  80269d:	53                   	push   %ebx
  80269e:	83 ec 14             	sub    $0x14,%esp
	// system server.
	// LAB 5: Your code here
	ssize_t readsize;
	if(debug)
		cprintf("devfile_read:fileid=%x readsize=%x\n",fd->fd_file.id,n);
	fsipcbuf.read.req_fileid=fd->fd_file.id;
  8026a1:	8b 45 08             	mov    0x8(%ebp),%eax
  8026a4:	8b 40 0c             	mov    0xc(%eax),%eax
  8026a7:	a3 00 50 81 00       	mov    %eax,0x815000
	fsipcbuf.read.req_n=n;
  8026ac:	8b 45 10             	mov    0x10(%ebp),%eax
  8026af:	a3 04 50 81 00       	mov    %eax,0x815004
	readsize=(ssize_t)fsipc(FSREQ_READ,&fsipcbuf);
  8026b4:	ba 00 50 81 00       	mov    $0x815000,%edx
  8026b9:	b8 03 00 00 00       	mov    $0x3,%eax
  8026be:	e8 81 fe ff ff       	call   802544 <fsipc>
  8026c3:	89 c3                	mov    %eax,%ebx
	//cprintf("readsize=%d\n",readsize);
	if(debug)
		cprintf("devfile_read:buf1=%s\nbuf2=%s\n",(char*)&fsipcbuf,fsipcbuf.readRet.ret_buf);
	if(readsize>0)
  8026c5:	85 c0                	test   %eax,%eax
  8026c7:	7e 17                	jle    8026e0 <devfile_read+0x46>
		memmove(buf,(void*)&fsipcbuf,(size_t)readsize);
  8026c9:	89 44 24 08          	mov    %eax,0x8(%esp)
  8026cd:	c7 44 24 04 00 50 81 	movl   $0x815000,0x4(%esp)
  8026d4:	00 
  8026d5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8026d8:	89 04 24             	mov    %eax,(%esp)
  8026db:	e8 08 eb ff ff       	call   8011e8 <memmove>
	//cprintf("readsize=%d",readsize);
	return readsize;
	//panic("devfile_read not implemented");
}
  8026e0:	89 d8                	mov    %ebx,%eax
  8026e2:	83 c4 14             	add    $0x14,%esp
  8026e5:	5b                   	pop    %ebx
  8026e6:	5d                   	pop    %ebp
  8026e7:	c3                   	ret    

008026e8 <remove>:
}

// Delete a file
int
remove(const char *path)
{
  8026e8:	55                   	push   %ebp
  8026e9:	89 e5                	mov    %esp,%ebp
  8026eb:	53                   	push   %ebx
  8026ec:	83 ec 14             	sub    $0x14,%esp
  8026ef:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (strlen(path) >= MAXPATHLEN)
  8026f2:	89 1c 24             	mov    %ebx,(%esp)
  8026f5:	e8 96 e8 ff ff       	call   800f90 <strlen>
  8026fa:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  8026ff:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  802704:	7f 21                	jg     802727 <remove+0x3f>
		return -E_BAD_PATH;
	strcpy(fsipcbuf.remove.req_path, path);
  802706:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80270a:	c7 04 24 00 50 81 00 	movl   $0x815000,(%esp)
  802711:	e8 cb e8 ff ff       	call   800fe1 <strcpy>
	return fsipc(FSREQ_REMOVE, NULL);
  802716:	ba 00 00 00 00       	mov    $0x0,%edx
  80271b:	b8 07 00 00 00       	mov    $0x7,%eax
  802720:	e8 1f fe ff ff       	call   802544 <fsipc>
  802725:	89 c2                	mov    %eax,%edx
}
  802727:	89 d0                	mov    %edx,%eax
  802729:	83 c4 14             	add    $0x14,%esp
  80272c:	5b                   	pop    %ebx
  80272d:	5d                   	pop    %ebp
  80272e:	c3                   	ret    

0080272f <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  80272f:	55                   	push   %ebp
  802730:	89 e5                	mov    %esp,%ebp
  802732:	56                   	push   %esi
  802733:	53                   	push   %ebx
  802734:	83 ec 30             	sub    $0x30,%esp

	// LAB 5: Your code here.
	struct Fd *fd;
	int r;
	void *page;
	if((r=fd_alloc(&fd))<0){
  802737:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80273a:	89 04 24             	mov    %eax,(%esp)
  80273d:	e8 19 f8 ff ff       	call   801f5b <fd_alloc>
  802742:	89 c3                	mov    %eax,%ebx
  802744:	85 c0                	test   %eax,%eax
  802746:	79 18                	jns    802760 <open+0x31>
		fd_close(fd,0);
  802748:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80274f:	00 
  802750:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802753:	89 04 24             	mov    %eax,(%esp)
  802756:	e8 a3 fb ff ff       	call   8022fe <fd_close>
  80275b:	e9 9f 00 00 00       	jmp    8027ff <open+0xd0>
		return r;
	}
	//cprintf("open:fd=%x\n",fd);
	strcpy(fsipcbuf.open.req_path,path);
  802760:	8b 45 08             	mov    0x8(%ebp),%eax
  802763:	89 44 24 04          	mov    %eax,0x4(%esp)
  802767:	c7 04 24 00 50 81 00 	movl   $0x815000,(%esp)
  80276e:	e8 6e e8 ff ff       	call   800fe1 <strcpy>
	fsipcbuf.open.req_omode=mode;
  802773:	8b 45 0c             	mov    0xc(%ebp),%eax
  802776:	a3 00 54 81 00       	mov    %eax,0x815400
	page=(void*)fd2data(fd);
  80277b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80277e:	89 04 24             	mov    %eax,(%esp)
  802781:	e8 ba f7 ff ff       	call   801f40 <fd2data>
  802786:	89 c6                	mov    %eax,%esi
	if((r=fsipc(FSREQ_OPEN,(void*)fd))<0)
  802788:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80278b:	b8 01 00 00 00       	mov    $0x1,%eax
  802790:	e8 af fd ff ff       	call   802544 <fsipc>
  802795:	89 c3                	mov    %eax,%ebx
  802797:	85 c0                	test   %eax,%eax
  802799:	79 15                	jns    8027b0 <open+0x81>
	{
		fd_close(fd,1);
  80279b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8027a2:	00 
  8027a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8027a6:	89 04 24             	mov    %eax,(%esp)
  8027a9:	e8 50 fb ff ff       	call   8022fe <fd_close>
  8027ae:	eb 4f                	jmp    8027ff <open+0xd0>
		return r;	
	}
	//cprintf("open:page=%x\n",page);
	if((r=sys_page_map(0,(void*)fd,0,(void*)page,PTE_P | PTE_W | PTE_U))<0)
  8027b0:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  8027b7:	00 
  8027b8:	89 74 24 0c          	mov    %esi,0xc(%esp)
  8027bc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8027c3:	00 
  8027c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8027c7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8027cb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8027d2:	e8 e5 ee ff ff       	call   8016bc <sys_page_map>
  8027d7:	89 c3                	mov    %eax,%ebx
  8027d9:	85 c0                	test   %eax,%eax
  8027db:	79 15                	jns    8027f2 <open+0xc3>
	{
		fd_close(fd,1);
  8027dd:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8027e4:	00 
  8027e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8027e8:	89 04 24             	mov    %eax,(%esp)
  8027eb:	e8 0e fb ff ff       	call   8022fe <fd_close>
  8027f0:	eb 0d                	jmp    8027ff <open+0xd0>
		return r;
	}
	//cprintf("open:fileid=%x\n",fd->fd_file.id);
	return fd2num(fd);
  8027f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8027f5:	89 04 24             	mov    %eax,(%esp)
  8027f8:	e8 33 f7 ff ff       	call   801f30 <fd2num>
  8027fd:	89 c3                	mov    %eax,%ebx
	//panic("open not implemented");
}
  8027ff:	89 d8                	mov    %ebx,%eax
  802801:	83 c4 30             	add    $0x30,%esp
  802804:	5b                   	pop    %ebx
  802805:	5e                   	pop    %esi
  802806:	5d                   	pop    %ebp
  802807:	c3                   	ret    
	...

00802810 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  802810:	55                   	push   %ebp
  802811:	89 e5                	mov    %esp,%ebp
  802813:	83 ec 08             	sub    $0x8,%esp
	strcpy(stat->st_name, "<sock>");
  802816:	c7 44 24 04 20 28 81 	movl   $0x812820,0x4(%esp)
  80281d:	00 
  80281e:	8b 45 0c             	mov    0xc(%ebp),%eax
  802821:	89 04 24             	mov    %eax,(%esp)
  802824:	e8 b8 e7 ff ff       	call   800fe1 <strcpy>
	return 0;
}
  802829:	b8 00 00 00 00       	mov    $0x0,%eax
  80282e:	c9                   	leave  
  80282f:	c3                   	ret    

00802830 <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  802830:	55                   	push   %ebp
  802831:	89 e5                	mov    %esp,%ebp
  802833:	83 ec 08             	sub    $0x8,%esp
	return nsipc_close(fd->fd_sock.sockid);
  802836:	8b 45 08             	mov    0x8(%ebp),%eax
  802839:	8b 40 0c             	mov    0xc(%eax),%eax
  80283c:	89 04 24             	mov    %eax,(%esp)
  80283f:	e8 9e 02 00 00       	call   802ae2 <nsipc_close>
}
  802844:	c9                   	leave  
  802845:	c3                   	ret    

00802846 <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  802846:	55                   	push   %ebp
  802847:	89 e5                	mov    %esp,%ebp
  802849:	83 ec 18             	sub    $0x18,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  80284c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  802853:	00 
  802854:	8b 45 10             	mov    0x10(%ebp),%eax
  802857:	89 44 24 08          	mov    %eax,0x8(%esp)
  80285b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80285e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802862:	8b 45 08             	mov    0x8(%ebp),%eax
  802865:	8b 40 0c             	mov    0xc(%eax),%eax
  802868:	89 04 24             	mov    %eax,(%esp)
  80286b:	e8 ae 02 00 00       	call   802b1e <nsipc_send>
}
  802870:	c9                   	leave  
  802871:	c3                   	ret    

00802872 <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  802872:	55                   	push   %ebp
  802873:	89 e5                	mov    %esp,%ebp
  802875:	83 ec 18             	sub    $0x18,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  802878:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80287f:	00 
  802880:	8b 45 10             	mov    0x10(%ebp),%eax
  802883:	89 44 24 08          	mov    %eax,0x8(%esp)
  802887:	8b 45 0c             	mov    0xc(%ebp),%eax
  80288a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80288e:	8b 45 08             	mov    0x8(%ebp),%eax
  802891:	8b 40 0c             	mov    0xc(%eax),%eax
  802894:	89 04 24             	mov    %eax,(%esp)
  802897:	e8 f5 02 00 00       	call   802b91 <nsipc_recv>
}
  80289c:	c9                   	leave  
  80289d:	c3                   	ret    

0080289e <alloc_sockfd>:
	return sfd->fd_sock.sockid;
}

static int
alloc_sockfd(int sockid)
{
  80289e:	55                   	push   %ebp
  80289f:	89 e5                	mov    %esp,%ebp
  8028a1:	56                   	push   %esi
  8028a2:	53                   	push   %ebx
  8028a3:	83 ec 20             	sub    $0x20,%esp
  8028a6:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  8028a8:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8028ab:	89 04 24             	mov    %eax,(%esp)
  8028ae:	e8 a8 f6 ff ff       	call   801f5b <fd_alloc>
  8028b3:	89 c3                	mov    %eax,%ebx
  8028b5:	85 c0                	test   %eax,%eax
  8028b7:	78 21                	js     8028da <alloc_sockfd+0x3c>
  8028b9:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  8028c0:	00 
  8028c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8028c4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8028c8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8028cf:	e8 46 ee ff ff       	call   80171a <sys_page_alloc>
  8028d4:	89 c3                	mov    %eax,%ebx
  8028d6:	85 c0                	test   %eax,%eax
  8028d8:	79 0a                	jns    8028e4 <alloc_sockfd+0x46>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U)) < 0) {
		nsipc_close(sockid);
  8028da:	89 34 24             	mov    %esi,(%esp)
  8028dd:	e8 00 02 00 00       	call   802ae2 <nsipc_close>
  8028e2:	eb 28                	jmp    80290c <alloc_sockfd+0x6e>
		return r;
	}

	sfd->fd_dev_id = devsock.dev_id;
  8028e4:	8b 15 20 80 81 00    	mov    0x818020,%edx
  8028ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8028ed:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  8028ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8028f2:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  8028f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8028fc:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  8028ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802902:	89 04 24             	mov    %eax,(%esp)
  802905:	e8 26 f6 ff ff       	call   801f30 <fd2num>
  80290a:	89 c3                	mov    %eax,%ebx
}
  80290c:	89 d8                	mov    %ebx,%eax
  80290e:	83 c4 20             	add    $0x20,%esp
  802911:	5b                   	pop    %ebx
  802912:	5e                   	pop    %esi
  802913:	5d                   	pop    %ebp
  802914:	c3                   	ret    

00802915 <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  802915:	55                   	push   %ebp
  802916:	89 e5                	mov    %esp,%ebp
  802918:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  80291b:	8b 45 10             	mov    0x10(%ebp),%eax
  80291e:	89 44 24 08          	mov    %eax,0x8(%esp)
  802922:	8b 45 0c             	mov    0xc(%ebp),%eax
  802925:	89 44 24 04          	mov    %eax,0x4(%esp)
  802929:	8b 45 08             	mov    0x8(%ebp),%eax
  80292c:	89 04 24             	mov    %eax,(%esp)
  80292f:	e8 62 01 00 00       	call   802a96 <nsipc_socket>
  802934:	85 c0                	test   %eax,%eax
  802936:	78 05                	js     80293d <socket+0x28>
		return r;
	return alloc_sockfd(r);
  802938:	e8 61 ff ff ff       	call   80289e <alloc_sockfd>
}
  80293d:	c9                   	leave  
  80293e:	66 90                	xchg   %ax,%ax
  802940:	c3                   	ret    

00802941 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  802941:	55                   	push   %ebp
  802942:	89 e5                	mov    %esp,%ebp
  802944:	83 ec 18             	sub    $0x18,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  802947:	8d 55 fc             	lea    -0x4(%ebp),%edx
  80294a:	89 54 24 04          	mov    %edx,0x4(%esp)
  80294e:	89 04 24             	mov    %eax,(%esp)
  802951:	e8 58 f6 ff ff       	call   801fae <fd_lookup>
  802956:	89 c2                	mov    %eax,%edx
  802958:	85 c0                	test   %eax,%eax
  80295a:	78 15                	js     802971 <fd2sockid+0x30>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  80295c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  80295f:	8b 01                	mov    (%ecx),%eax
  802961:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
  802966:	3b 05 20 80 81 00    	cmp    0x818020,%eax
  80296c:	75 03                	jne    802971 <fd2sockid+0x30>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  80296e:	8b 51 0c             	mov    0xc(%ecx),%edx
}
  802971:	89 d0                	mov    %edx,%eax
  802973:	c9                   	leave  
  802974:	c3                   	ret    

00802975 <listen>:
	return nsipc_connect(r, name, namelen);
}

int
listen(int s, int backlog)
{
  802975:	55                   	push   %ebp
  802976:	89 e5                	mov    %esp,%ebp
  802978:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80297b:	8b 45 08             	mov    0x8(%ebp),%eax
  80297e:	e8 be ff ff ff       	call   802941 <fd2sockid>
  802983:	85 c0                	test   %eax,%eax
  802985:	78 0f                	js     802996 <listen+0x21>
		return r;
	return nsipc_listen(r, backlog);
  802987:	8b 55 0c             	mov    0xc(%ebp),%edx
  80298a:	89 54 24 04          	mov    %edx,0x4(%esp)
  80298e:	89 04 24             	mov    %eax,(%esp)
  802991:	e8 2a 01 00 00       	call   802ac0 <nsipc_listen>
}
  802996:	c9                   	leave  
  802997:	c3                   	ret    

00802998 <connect>:
	return nsipc_close(fd->fd_sock.sockid);
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  802998:	55                   	push   %ebp
  802999:	89 e5                	mov    %esp,%ebp
  80299b:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80299e:	8b 45 08             	mov    0x8(%ebp),%eax
  8029a1:	e8 9b ff ff ff       	call   802941 <fd2sockid>
  8029a6:	85 c0                	test   %eax,%eax
  8029a8:	78 16                	js     8029c0 <connect+0x28>
		return r;
	return nsipc_connect(r, name, namelen);
  8029aa:	8b 55 10             	mov    0x10(%ebp),%edx
  8029ad:	89 54 24 08          	mov    %edx,0x8(%esp)
  8029b1:	8b 55 0c             	mov    0xc(%ebp),%edx
  8029b4:	89 54 24 04          	mov    %edx,0x4(%esp)
  8029b8:	89 04 24             	mov    %eax,(%esp)
  8029bb:	e8 51 02 00 00       	call   802c11 <nsipc_connect>
}
  8029c0:	c9                   	leave  
  8029c1:	c3                   	ret    

008029c2 <shutdown>:
	return nsipc_bind(r, name, namelen);
}

int
shutdown(int s, int how)
{
  8029c2:	55                   	push   %ebp
  8029c3:	89 e5                	mov    %esp,%ebp
  8029c5:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  8029c8:	8b 45 08             	mov    0x8(%ebp),%eax
  8029cb:	e8 71 ff ff ff       	call   802941 <fd2sockid>
  8029d0:	85 c0                	test   %eax,%eax
  8029d2:	78 0f                	js     8029e3 <shutdown+0x21>
		return r;
	return nsipc_shutdown(r, how);
  8029d4:	8b 55 0c             	mov    0xc(%ebp),%edx
  8029d7:	89 54 24 04          	mov    %edx,0x4(%esp)
  8029db:	89 04 24             	mov    %eax,(%esp)
  8029de:	e8 19 01 00 00       	call   802afc <nsipc_shutdown>
}
  8029e3:	c9                   	leave  
  8029e4:	c3                   	ret    

008029e5 <bind>:
	return alloc_sockfd(r);
}

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  8029e5:	55                   	push   %ebp
  8029e6:	89 e5                	mov    %esp,%ebp
  8029e8:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  8029eb:	8b 45 08             	mov    0x8(%ebp),%eax
  8029ee:	e8 4e ff ff ff       	call   802941 <fd2sockid>
  8029f3:	85 c0                	test   %eax,%eax
  8029f5:	78 16                	js     802a0d <bind+0x28>
		return r;
	return nsipc_bind(r, name, namelen);
  8029f7:	8b 55 10             	mov    0x10(%ebp),%edx
  8029fa:	89 54 24 08          	mov    %edx,0x8(%esp)
  8029fe:	8b 55 0c             	mov    0xc(%ebp),%edx
  802a01:	89 54 24 04          	mov    %edx,0x4(%esp)
  802a05:	89 04 24             	mov    %eax,(%esp)
  802a08:	e8 43 02 00 00       	call   802c50 <nsipc_bind>
}
  802a0d:	c9                   	leave  
  802a0e:	c3                   	ret    

00802a0f <accept>:
	return fd2num(sfd);
}

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  802a0f:	55                   	push   %ebp
  802a10:	89 e5                	mov    %esp,%ebp
  802a12:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802a15:	8b 45 08             	mov    0x8(%ebp),%eax
  802a18:	e8 24 ff ff ff       	call   802941 <fd2sockid>
  802a1d:	85 c0                	test   %eax,%eax
  802a1f:	78 1f                	js     802a40 <accept+0x31>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  802a21:	8b 55 10             	mov    0x10(%ebp),%edx
  802a24:	89 54 24 08          	mov    %edx,0x8(%esp)
  802a28:	8b 55 0c             	mov    0xc(%ebp),%edx
  802a2b:	89 54 24 04          	mov    %edx,0x4(%esp)
  802a2f:	89 04 24             	mov    %eax,(%esp)
  802a32:	e8 58 02 00 00       	call   802c8f <nsipc_accept>
  802a37:	85 c0                	test   %eax,%eax
  802a39:	78 05                	js     802a40 <accept+0x31>
		return r;
	return alloc_sockfd(r);
  802a3b:	e8 5e fe ff ff       	call   80289e <alloc_sockfd>
}
  802a40:	c9                   	leave  
  802a41:	c3                   	ret    
	...

00802a50 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  802a50:	55                   	push   %ebp
  802a51:	89 e5                	mov    %esp,%ebp
  802a53:	83 ec 18             	sub    $0x18,%esp
	if (debug)
		cprintf("[%08x] nsipc %d\n", env->env_id, type);

	ipc_send(envs[2].env_id, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  802a56:	8b 15 44 01 c0 ee    	mov    0xeec00144,%edx
  802a5c:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  802a63:	00 
  802a64:	c7 44 24 08 00 70 81 	movl   $0x817000,0x8(%esp)
  802a6b:	00 
  802a6c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802a70:	89 14 24             	mov    %edx,(%esp)
  802a73:	e8 18 f3 ff ff       	call   801d90 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  802a78:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802a7f:	00 
  802a80:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802a87:	00 
  802a88:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802a8f:	e8 b0 f3 ff ff       	call   801e44 <ipc_recv>
}
  802a94:	c9                   	leave  
  802a95:	c3                   	ret    

00802a96 <nsipc_socket>:
	return nsipc(NSREQ_SEND);
}

int
nsipc_socket(int domain, int type, int protocol)
{
  802a96:	55                   	push   %ebp
  802a97:	89 e5                	mov    %esp,%ebp
  802a99:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  802a9c:	8b 45 08             	mov    0x8(%ebp),%eax
  802a9f:	a3 00 70 81 00       	mov    %eax,0x817000
	nsipcbuf.socket.req_type = type;
  802aa4:	8b 45 0c             	mov    0xc(%ebp),%eax
  802aa7:	a3 04 70 81 00       	mov    %eax,0x817004
	nsipcbuf.socket.req_protocol = protocol;
  802aac:	8b 45 10             	mov    0x10(%ebp),%eax
  802aaf:	a3 08 70 81 00       	mov    %eax,0x817008
	return nsipc(NSREQ_SOCKET);
  802ab4:	b8 09 00 00 00       	mov    $0x9,%eax
  802ab9:	e8 92 ff ff ff       	call   802a50 <nsipc>
}
  802abe:	c9                   	leave  
  802abf:	c3                   	ret    

00802ac0 <nsipc_listen>:
	return nsipc(NSREQ_CONNECT);
}

int
nsipc_listen(int s, int backlog)
{
  802ac0:	55                   	push   %ebp
  802ac1:	89 e5                	mov    %esp,%ebp
  802ac3:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  802ac6:	8b 45 08             	mov    0x8(%ebp),%eax
  802ac9:	a3 00 70 81 00       	mov    %eax,0x817000
	nsipcbuf.listen.req_backlog = backlog;
  802ace:	8b 45 0c             	mov    0xc(%ebp),%eax
  802ad1:	a3 04 70 81 00       	mov    %eax,0x817004
	return nsipc(NSREQ_LISTEN);
  802ad6:	b8 06 00 00 00       	mov    $0x6,%eax
  802adb:	e8 70 ff ff ff       	call   802a50 <nsipc>
}
  802ae0:	c9                   	leave  
  802ae1:	c3                   	ret    

00802ae2 <nsipc_close>:
	return nsipc(NSREQ_SHUTDOWN);
}

int
nsipc_close(int s)
{
  802ae2:	55                   	push   %ebp
  802ae3:	89 e5                	mov    %esp,%ebp
  802ae5:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  802ae8:	8b 45 08             	mov    0x8(%ebp),%eax
  802aeb:	a3 00 70 81 00       	mov    %eax,0x817000
	return nsipc(NSREQ_CLOSE);
  802af0:	b8 04 00 00 00       	mov    $0x4,%eax
  802af5:	e8 56 ff ff ff       	call   802a50 <nsipc>
}
  802afa:	c9                   	leave  
  802afb:	c3                   	ret    

00802afc <nsipc_shutdown>:
	return nsipc(NSREQ_BIND);
}

int
nsipc_shutdown(int s, int how)
{
  802afc:	55                   	push   %ebp
  802afd:	89 e5                	mov    %esp,%ebp
  802aff:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  802b02:	8b 45 08             	mov    0x8(%ebp),%eax
  802b05:	a3 00 70 81 00       	mov    %eax,0x817000
	nsipcbuf.shutdown.req_how = how;
  802b0a:	8b 45 0c             	mov    0xc(%ebp),%eax
  802b0d:	a3 04 70 81 00       	mov    %eax,0x817004
	return nsipc(NSREQ_SHUTDOWN);
  802b12:	b8 03 00 00 00       	mov    $0x3,%eax
  802b17:	e8 34 ff ff ff       	call   802a50 <nsipc>
}
  802b1c:	c9                   	leave  
  802b1d:	c3                   	ret    

00802b1e <nsipc_send>:
	return r;
}

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  802b1e:	55                   	push   %ebp
  802b1f:	89 e5                	mov    %esp,%ebp
  802b21:	53                   	push   %ebx
  802b22:	83 ec 14             	sub    $0x14,%esp
  802b25:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  802b28:	8b 45 08             	mov    0x8(%ebp),%eax
  802b2b:	a3 00 70 81 00       	mov    %eax,0x817000
	assert(size < 1600);
  802b30:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  802b36:	7e 24                	jle    802b5c <nsipc_send+0x3e>
  802b38:	c7 44 24 0c 2c 28 81 	movl   $0x81282c,0xc(%esp)
  802b3f:	00 
  802b40:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  802b47:	00 
  802b48:	c7 44 24 04 66 00 00 	movl   $0x66,0x4(%esp)
  802b4f:	00 
  802b50:	c7 04 24 4d 28 81 00 	movl   $0x81284d,(%esp)
  802b57:	e8 50 dd ff ff       	call   8008ac <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  802b5c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802b60:	8b 45 0c             	mov    0xc(%ebp),%eax
  802b63:	89 44 24 04          	mov    %eax,0x4(%esp)
  802b67:	c7 04 24 0c 70 81 00 	movl   $0x81700c,(%esp)
  802b6e:	e8 75 e6 ff ff       	call   8011e8 <memmove>
	nsipcbuf.send.req_size = size;
  802b73:	89 1d 04 70 81 00    	mov    %ebx,0x817004
	nsipcbuf.send.req_flags = flags;
  802b79:	8b 45 14             	mov    0x14(%ebp),%eax
  802b7c:	a3 08 70 81 00       	mov    %eax,0x817008
	return nsipc(NSREQ_SEND);
  802b81:	b8 08 00 00 00       	mov    $0x8,%eax
  802b86:	e8 c5 fe ff ff       	call   802a50 <nsipc>
}
  802b8b:	83 c4 14             	add    $0x14,%esp
  802b8e:	5b                   	pop    %ebx
  802b8f:	5d                   	pop    %ebp
  802b90:	c3                   	ret    

00802b91 <nsipc_recv>:
	return nsipc(NSREQ_LISTEN);
}

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  802b91:	55                   	push   %ebp
  802b92:	89 e5                	mov    %esp,%ebp
  802b94:	56                   	push   %esi
  802b95:	53                   	push   %ebx
  802b96:	83 ec 10             	sub    $0x10,%esp
  802b99:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  802b9c:	8b 45 08             	mov    0x8(%ebp),%eax
  802b9f:	a3 00 70 81 00       	mov    %eax,0x817000
	nsipcbuf.recv.req_len = len;
  802ba4:	89 35 04 70 81 00    	mov    %esi,0x817004
	nsipcbuf.recv.req_flags = flags;
  802baa:	8b 45 14             	mov    0x14(%ebp),%eax
  802bad:	a3 08 70 81 00       	mov    %eax,0x817008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  802bb2:	b8 07 00 00 00       	mov    $0x7,%eax
  802bb7:	e8 94 fe ff ff       	call   802a50 <nsipc>
  802bbc:	89 c3                	mov    %eax,%ebx
  802bbe:	85 c0                	test   %eax,%eax
  802bc0:	78 46                	js     802c08 <nsipc_recv+0x77>
		assert(r < 1600 && r <= len);
  802bc2:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  802bc7:	7f 04                	jg     802bcd <nsipc_recv+0x3c>
  802bc9:	39 c6                	cmp    %eax,%esi
  802bcb:	7d 24                	jge    802bf1 <nsipc_recv+0x60>
  802bcd:	c7 44 24 0c 59 28 81 	movl   $0x812859,0xc(%esp)
  802bd4:	00 
  802bd5:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  802bdc:	00 
  802bdd:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
  802be4:	00 
  802be5:	c7 04 24 4d 28 81 00 	movl   $0x81284d,(%esp)
  802bec:	e8 bb dc ff ff       	call   8008ac <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  802bf1:	89 44 24 08          	mov    %eax,0x8(%esp)
  802bf5:	c7 44 24 04 00 70 81 	movl   $0x817000,0x4(%esp)
  802bfc:	00 
  802bfd:	8b 45 0c             	mov    0xc(%ebp),%eax
  802c00:	89 04 24             	mov    %eax,(%esp)
  802c03:	e8 e0 e5 ff ff       	call   8011e8 <memmove>
	}

	return r;
}
  802c08:	89 d8                	mov    %ebx,%eax
  802c0a:	83 c4 10             	add    $0x10,%esp
  802c0d:	5b                   	pop    %ebx
  802c0e:	5e                   	pop    %esi
  802c0f:	5d                   	pop    %ebp
  802c10:	c3                   	ret    

00802c11 <nsipc_connect>:
	return nsipc(NSREQ_CLOSE);
}

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  802c11:	55                   	push   %ebp
  802c12:	89 e5                	mov    %esp,%ebp
  802c14:	53                   	push   %ebx
  802c15:	83 ec 14             	sub    $0x14,%esp
  802c18:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  802c1b:	8b 45 08             	mov    0x8(%ebp),%eax
  802c1e:	a3 00 70 81 00       	mov    %eax,0x817000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  802c23:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802c27:	8b 45 0c             	mov    0xc(%ebp),%eax
  802c2a:	89 44 24 04          	mov    %eax,0x4(%esp)
  802c2e:	c7 04 24 04 70 81 00 	movl   $0x817004,(%esp)
  802c35:	e8 ae e5 ff ff       	call   8011e8 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  802c3a:	89 1d 14 70 81 00    	mov    %ebx,0x817014
	return nsipc(NSREQ_CONNECT);
  802c40:	b8 05 00 00 00       	mov    $0x5,%eax
  802c45:	e8 06 fe ff ff       	call   802a50 <nsipc>
}
  802c4a:	83 c4 14             	add    $0x14,%esp
  802c4d:	5b                   	pop    %ebx
  802c4e:	5d                   	pop    %ebp
  802c4f:	c3                   	ret    

00802c50 <nsipc_bind>:
	return r;
}

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  802c50:	55                   	push   %ebp
  802c51:	89 e5                	mov    %esp,%ebp
  802c53:	53                   	push   %ebx
  802c54:	83 ec 14             	sub    $0x14,%esp
  802c57:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  802c5a:	8b 45 08             	mov    0x8(%ebp),%eax
  802c5d:	a3 00 70 81 00       	mov    %eax,0x817000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  802c62:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802c66:	8b 45 0c             	mov    0xc(%ebp),%eax
  802c69:	89 44 24 04          	mov    %eax,0x4(%esp)
  802c6d:	c7 04 24 04 70 81 00 	movl   $0x817004,(%esp)
  802c74:	e8 6f e5 ff ff       	call   8011e8 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  802c79:	89 1d 14 70 81 00    	mov    %ebx,0x817014
	return nsipc(NSREQ_BIND);
  802c7f:	b8 02 00 00 00       	mov    $0x2,%eax
  802c84:	e8 c7 fd ff ff       	call   802a50 <nsipc>
}
  802c89:	83 c4 14             	add    $0x14,%esp
  802c8c:	5b                   	pop    %ebx
  802c8d:	5d                   	pop    %ebp
  802c8e:	c3                   	ret    

00802c8f <nsipc_accept>:
	return ipc_recv(NULL, NULL, NULL);
}

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  802c8f:	55                   	push   %ebp
  802c90:	89 e5                	mov    %esp,%ebp
  802c92:	53                   	push   %ebx
  802c93:	83 ec 14             	sub    $0x14,%esp
	int r;
	
	nsipcbuf.accept.req_s = s;
  802c96:	8b 45 08             	mov    0x8(%ebp),%eax
  802c99:	a3 00 70 81 00       	mov    %eax,0x817000
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  802c9e:	b8 01 00 00 00       	mov    $0x1,%eax
  802ca3:	e8 a8 fd ff ff       	call   802a50 <nsipc>
  802ca8:	89 c3                	mov    %eax,%ebx
  802caa:	85 c0                	test   %eax,%eax
  802cac:	78 26                	js     802cd4 <nsipc_accept+0x45>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  802cae:	a1 10 70 81 00       	mov    0x817010,%eax
  802cb3:	89 44 24 08          	mov    %eax,0x8(%esp)
  802cb7:	c7 44 24 04 00 70 81 	movl   $0x817000,0x4(%esp)
  802cbe:	00 
  802cbf:	8b 45 0c             	mov    0xc(%ebp),%eax
  802cc2:	89 04 24             	mov    %eax,(%esp)
  802cc5:	e8 1e e5 ff ff       	call   8011e8 <memmove>
		*addrlen = ret->ret_addrlen;
  802cca:	a1 10 70 81 00       	mov    0x817010,%eax
  802ccf:	8b 55 10             	mov    0x10(%ebp),%edx
  802cd2:	89 02                	mov    %eax,(%edx)
	}
	return r;
}
  802cd4:	89 d8                	mov    %ebx,%eax
  802cd6:	83 c4 14             	add    $0x14,%esp
  802cd9:	5b                   	pop    %ebx
  802cda:	5d                   	pop    %ebp
  802cdb:	c3                   	ret    
  802cdc:	00 00                	add    %al,(%eax)
	...

00802ce0 <free>:
	return v;
}

void
free(void *v)
{
  802ce0:	55                   	push   %ebp
  802ce1:	89 e5                	mov    %esp,%ebp
  802ce3:	57                   	push   %edi
  802ce4:	56                   	push   %esi
  802ce5:	53                   	push   %ebx
  802ce6:	83 ec 1c             	sub    $0x1c,%esp
  802ce9:	8b 45 08             	mov    0x8(%ebp),%eax
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  802cec:	85 c0                	test   %eax,%eax
  802cee:	0f 84 b8 00 00 00    	je     802dac <free+0xcc>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  802cf4:	8b 3d c4 28 81 00    	mov    0x8128c4,%edi
  802cfa:	39 c7                	cmp    %eax,%edi
  802cfc:	77 0a                	ja     802d08 <free+0x28>
  802cfe:	8b 35 c8 28 81 00    	mov    0x8128c8,%esi
  802d04:	39 f0                	cmp    %esi,%eax
  802d06:	72 24                	jb     802d2c <free+0x4c>
  802d08:	c7 44 24 0c 70 28 81 	movl   $0x812870,0xc(%esp)
  802d0f:	00 
  802d10:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  802d17:	00 
  802d18:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  802d1f:	00 
  802d20:	c7 04 24 9e 28 81 00 	movl   $0x81289e,(%esp)
  802d27:	e8 80 db ff ff       	call   8008ac <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  802d2c:	89 c3                	mov    %eax,%ebx
  802d2e:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  802d34:	eb 42                	jmp    802d78 <free+0x98>

	while (vpt[VPN(c)] & PTE_CONTINUED) {
		sys_page_unmap(0, c);
  802d36:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802d3a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802d41:	e8 18 e9 ff ff       	call   80165e <sys_page_unmap>
		c += PGSIZE;
  802d46:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  802d4c:	39 df                	cmp    %ebx,%edi
  802d4e:	77 04                	ja     802d54 <free+0x74>
  802d50:	39 de                	cmp    %ebx,%esi
  802d52:	77 24                	ja     802d78 <free+0x98>
  802d54:	c7 44 24 0c ab 28 81 	movl   $0x8128ab,0xc(%esp)
  802d5b:	00 
  802d5c:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  802d63:	00 
  802d64:	c7 44 24 04 81 00 00 	movl   $0x81,0x4(%esp)
  802d6b:	00 
  802d6c:	c7 04 24 9e 28 81 00 	movl   $0x81289e,(%esp)
  802d73:	e8 34 db ff ff       	call   8008ac <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (vpt[VPN(c)] & PTE_CONTINUED) {
  802d78:	89 d8                	mov    %ebx,%eax
  802d7a:	c1 e8 0c             	shr    $0xc,%eax
  802d7d:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  802d84:	f6 c4 04             	test   $0x4,%ah
  802d87:	75 ad                	jne    802d36 <free+0x56>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  802d89:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  802d8f:	83 e8 01             	sub    $0x1,%eax
  802d92:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  802d98:	85 c0                	test   %eax,%eax
  802d9a:	75 10                	jne    802dac <free+0xcc>
		sys_page_unmap(0, c);	
  802d9c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802da0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802da7:	e8 b2 e8 ff ff       	call   80165e <sys_page_unmap>
}
  802dac:	83 c4 1c             	add    $0x1c,%esp
  802daf:	5b                   	pop    %ebx
  802db0:	5e                   	pop    %esi
  802db1:	5f                   	pop    %edi
  802db2:	5d                   	pop    %ebp
  802db3:	c3                   	ret    

00802db4 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  802db4:	55                   	push   %ebp
  802db5:	89 e5                	mov    %esp,%ebp
  802db7:	57                   	push   %edi
  802db8:	56                   	push   %esi
  802db9:	53                   	push   %ebx
  802dba:	83 ec 1c             	sub    $0x1c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  802dbd:	83 3d d0 83 81 00 00 	cmpl   $0x0,0x8183d0
  802dc4:	75 0a                	jne    802dd0 <malloc+0x1c>
		mptr = mbegin;
  802dc6:	a1 c4 28 81 00       	mov    0x8128c4,%eax
  802dcb:	a3 d0 83 81 00       	mov    %eax,0x8183d0

	n = ROUNDUP(n, 4);
  802dd0:	8b 45 08             	mov    0x8(%ebp),%eax
  802dd3:	83 c0 03             	add    $0x3,%eax
  802dd6:	83 e0 fc             	and    $0xfffffffc,%eax
  802dd9:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (n >= MAXMALLOC)
  802ddc:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  802de1:	0f 87 90 01 00 00    	ja     802f77 <malloc+0x1c3>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  802de7:	8b 0d d0 83 81 00    	mov    0x8183d0,%ecx
  802ded:	f7 c1 ff 0f 00 00    	test   $0xfff,%ecx
  802df3:	74 4a                	je     802e3f <malloc+0x8b>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  802df5:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
  802df8:	89 ca                	mov    %ecx,%edx
  802dfa:	c1 ea 0c             	shr    $0xc,%edx
  802dfd:	8d 43 03             	lea    0x3(%ebx),%eax
  802e00:	c1 e8 0c             	shr    $0xc,%eax
  802e03:	39 c2                	cmp    %eax,%edx
  802e05:	75 1c                	jne    802e23 <malloc+0x6f>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  802e07:	8d 81 ff 0f 00 00    	lea    0xfff(%ecx),%eax
  802e0d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  802e12:	83 40 fc 01          	addl   $0x1,-0x4(%eax)
			v = mptr;
  802e16:	89 ca                	mov    %ecx,%edx
			mptr += n;
  802e18:	89 1d d0 83 81 00    	mov    %ebx,0x8183d0
  802e1e:	e9 59 01 00 00       	jmp    802f7c <malloc+0x1c8>
			return v;
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  802e23:	89 0c 24             	mov    %ecx,(%esp)
  802e26:	e8 b5 fe ff ff       	call   802ce0 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  802e2b:	a1 d0 83 81 00       	mov    0x8183d0,%eax
  802e30:	05 00 10 00 00       	add    $0x1000,%eax
  802e35:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  802e3a:	a3 d0 83 81 00       	mov    %eax,0x8183d0
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  802e3f:	8b 35 c8 28 81 00    	mov    0x8128c8,%esi
  802e45:	8b 1d d0 83 81 00    	mov    0x8183d0,%ebx
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
  802e4b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	 * runs of more than a page can't have ref counts so we 
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  802e52:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802e55:	83 c0 04             	add    $0x4,%eax
  802e58:	89 45 e8             	mov    %eax,-0x18(%ebp)
  802e5b:	eb 06                	jmp    802e63 <malloc+0xaf>
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
  802e5d:	8b 1d c4 28 81 00    	mov    0x8128c4,%ebx
	 * runs of more than a page can't have ref counts so we 
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  802e63:	8b 7d e8             	mov    -0x18(%ebp),%edi
static uint8_t *mptr;

static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;
  802e66:	89 da                	mov    %ebx,%edx
  802e68:	8d 0c 3b             	lea    (%ebx,%edi,1),%ecx

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  802e6b:	39 cb                	cmp    %ecx,%ebx
  802e6d:	0f 83 d3 00 00 00    	jae    802f46 <malloc+0x192>
		if (va >= (uintptr_t) mend
  802e73:	39 f3                	cmp    %esi,%ebx
  802e75:	72 0b                	jb     802e82 <malloc+0xce>
  802e77:	eb 43                	jmp    802ebc <malloc+0x108>
  802e79:	39 f2                	cmp    %esi,%edx
  802e7b:	90                   	nop    
  802e7c:	8d 74 26 00          	lea    0x0(%esi),%esi
  802e80:	73 3a                	jae    802ebc <malloc+0x108>
  802e82:	89 d0                	mov    %edx,%eax
  802e84:	c1 e8 16             	shr    $0x16,%eax
  802e87:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  802e8e:	a8 01                	test   $0x1,%al
  802e90:	74 10                	je     802ea2 <malloc+0xee>
  802e92:	89 d0                	mov    %edx,%eax
  802e94:	c1 e8 0c             	shr    $0xc,%eax
  802e97:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  802e9e:	a8 01                	test   $0x1,%al
  802ea0:	75 1a                	jne    802ebc <malloc+0x108>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  802ea2:	81 c2 00 10 00 00    	add    $0x1000,%edx
  802ea8:	39 d1                	cmp    %edx,%ecx
  802eaa:	77 cd                	ja     802e79 <malloc+0xc5>
  802eac:	89 1d d0 83 81 00    	mov    %ebx,0x8183d0
  802eb2:	be 00 00 00 00       	mov    $0x0,%esi
  802eb7:	e9 9b 00 00 00       	jmp    802f57 <malloc+0x1a3>
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
  802ebc:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		if (mptr == mend) {
  802ec2:	3b 1d c8 28 81 00    	cmp    0x8128c8,%ebx
  802ec8:	75 99                	jne    802e63 <malloc+0xaf>
			mptr = mbegin;
			if (++nwrap == 2)
  802eca:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  802ece:	83 7d ec 02          	cmpl   $0x2,-0x14(%ebp)
  802ed2:	75 89                	jne    802e5d <malloc+0xa9>
  802ed4:	8b 0d c4 28 81 00    	mov    0x8128c4,%ecx
  802eda:	89 0d d0 83 81 00    	mov    %ecx,0x8183d0
  802ee0:	ba 00 00 00 00       	mov    $0x0,%edx
  802ee5:	e9 92 00 00 00       	jmp    802f7c <malloc+0x1c8>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  802eea:	8d 9e 00 10 00 00    	lea    0x1000(%esi),%ebx
  802ef0:	39 fb                	cmp    %edi,%ebx
  802ef2:	19 c0                	sbb    %eax,%eax
  802ef4:	25 00 04 00 00       	and    $0x400,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  802ef9:	83 c8 07             	or     $0x7,%eax
  802efc:	8d 93 00 f0 ff ff    	lea    -0x1000(%ebx),%edx
  802f02:	03 15 d0 83 81 00    	add    0x8183d0,%edx
  802f08:	89 44 24 08          	mov    %eax,0x8(%esp)
  802f0c:	89 54 24 04          	mov    %edx,0x4(%esp)
  802f10:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802f17:	e8 fe e7 ff ff       	call   80171a <sys_page_alloc>
  802f1c:	85 c0                	test   %eax,%eax
  802f1e:	79 35                	jns    802f55 <malloc+0x1a1>
			for (; i >= 0; i -= PGSIZE)
  802f20:	85 f6                	test   %esi,%esi
  802f22:	78 53                	js     802f77 <malloc+0x1c3>
				sys_page_unmap(0, mptr + i);
  802f24:	89 f0                	mov    %esi,%eax
  802f26:	03 05 d0 83 81 00    	add    0x8183d0,%eax
  802f2c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802f30:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802f37:	e8 22 e7 ff ff       	call   80165e <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  802f3c:	81 ee 00 10 00 00    	sub    $0x1000,%esi
  802f42:	78 33                	js     802f77 <malloc+0x1c3>
  802f44:	eb de                	jmp    802f24 <malloc+0x170>
  802f46:	89 1d d0 83 81 00    	mov    %ebx,0x8183d0
  802f4c:	8d 74 26 00          	lea    0x0(%esi),%esi
  802f50:	e9 5d ff ff ff       	jmp    802eb2 <malloc+0xfe>
  802f55:	89 de                	mov    %ebx,%esi
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  802f57:	39 fe                	cmp    %edi,%esi
  802f59:	72 8f                	jb     802eea <malloc+0x136>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  802f5b:	a1 d0 83 81 00       	mov    0x8183d0,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  802f60:	c7 44 30 fc 02 00 00 	movl   $0x2,-0x4(%eax,%esi,1)
  802f67:	00 
	v = mptr;
  802f68:	89 c2                	mov    %eax,%edx
	mptr += n;
  802f6a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  802f6d:	8d 04 08             	lea    (%eax,%ecx,1),%eax
  802f70:	a3 d0 83 81 00       	mov    %eax,0x8183d0
  802f75:	eb 05                	jmp    802f7c <malloc+0x1c8>
	return v;
  802f77:	ba 00 00 00 00       	mov    $0x0,%edx
}
  802f7c:	89 d0                	mov    %edx,%eax
  802f7e:	83 c4 1c             	add    $0x1c,%esp
  802f81:	5b                   	pop    %ebx
  802f82:	5e                   	pop    %esi
  802f83:	5f                   	pop    %edi
  802f84:	5d                   	pop    %ebp
  802f85:	c3                   	ret    
	...

00802f88 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  802f88:	55                   	push   %ebp
  802f89:	89 e5                	mov    %esp,%ebp
  802f8b:	83 ec 18             	sub    $0x18,%esp
	int r;

	if (_pgfault_handler == 0) {
  802f8e:	83 3d bc e5 b3 00 00 	cmpl   $0x0,0xb3e5bc
  802f95:	75 6a                	jne    803001 <set_pgfault_handler+0x79>
		// First time through!
		// LAB 4: Your code here.
		env=(struct Env*)&envs[ENVX(sys_getenvid())];
  802f97:	e8 11 e8 ff ff       	call   8017ad <sys_getenvid>
  802f9c:	25 ff 03 00 00       	and    $0x3ff,%eax
  802fa1:	6b c0 7c             	imul   $0x7c,%eax,%eax
  802fa4:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  802fa9:	a3 b4 e5 b3 00       	mov    %eax,0xb3e5b4
		if((r=sys_page_alloc(env->env_id,(void*)(UXSTACKTOP-PGSIZE),PTE_W|PTE_U|PTE_P))<0)
  802fae:	8b 40 4c             	mov    0x4c(%eax),%eax
  802fb1:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  802fb8:	00 
  802fb9:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  802fc0:	ee 
  802fc1:	89 04 24             	mov    %eax,(%esp)
  802fc4:	e8 51 e7 ff ff       	call   80171a <sys_page_alloc>
  802fc9:	85 c0                	test   %eax,%eax
  802fcb:	79 1c                	jns    802fe9 <set_pgfault_handler+0x61>
		{
			panic("Alloc a page for an exception stack failed");
  802fcd:	c7 44 24 08 cc 28 81 	movl   $0x8128cc,0x8(%esp)
  802fd4:	00 
  802fd5:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  802fdc:	00 
  802fdd:	c7 04 24 f7 28 81 00 	movl   $0x8128f7,(%esp)
  802fe4:	e8 c3 d8 ff ff       	call   8008ac <_panic>
		}
		sys_env_set_pgfault_upcall(env->env_id,(void*)_pgfault_upcall);
  802fe9:	a1 b4 e5 b3 00       	mov    0xb3e5b4,%eax
  802fee:	8b 40 4c             	mov    0x4c(%eax),%eax
  802ff1:	c7 44 24 04 0c 30 80 	movl   $0x80300c,0x4(%esp)
  802ff8:	00 
  802ff9:	89 04 24             	mov    %eax,(%esp)
  802ffc:	e8 43 e5 ff ff       	call   801544 <sys_env_set_pgfault_upcall>
		//panic("set_pgfault_handler not implemented");
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  803001:	8b 45 08             	mov    0x8(%ebp),%eax
  803004:	a3 bc e5 b3 00       	mov    %eax,0xb3e5bc
}
  803009:	c9                   	leave  
  80300a:	c3                   	ret    
	...

0080300c <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  80300c:	54                   	push   %esp
	movl _pgfault_handler, %eax
  80300d:	a1 bc e5 b3 00       	mov    0xb3e5bc,%eax
	call *%eax
  803012:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  803014:	83 c4 04             	add    $0x4,%esp
	// registers are available for intermediate calculations.  You
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
	movl  0x28(%esp),%eax //utf->utf_eip
  803017:	8b 44 24 28          	mov    0x28(%esp),%eax
	pushl %eax
  80301b:	50                   	push   %eax
	movl %esp,%eax
  80301c:	89 e0                	mov    %esp,%eax
	movl 0x34(%eax),%esp  //utf_eip
  80301e:	8b 60 34             	mov    0x34(%eax),%esp
	pushl (%eax)
  803021:	ff 30                	pushl  (%eax)
	movl %eax,%esp	     //
  803023:	89 c4                	mov    %eax,%esp
	subl $0x4,0x34(%esp) //utf->utf_esp4,,
  803025:	83 6c 24 34 04       	subl   $0x4,0x34(%esp)
	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	addl $0xc,%esp     //
  80302a:	83 c4 0c             	add    $0xc,%esp
	popal
  80302d:	61                   	popa   
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	addl $0x4,%esp  //eflags
  80302e:	83 c4 04             	add    $0x4,%esp
	popfl          //eflags?
  803031:	9d                   	popf   
		       //eflags
	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popl %esp     //
  803032:	5c                   	pop    %esp
	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	ret
  803033:	c3                   	ret    
	...

00803040 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  803040:	55                   	push   %ebp
  803041:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  803043:	83 f8 1f             	cmp    $0x1f,%eax
  803046:	76 11                	jbe    803059 <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  803048:	c7 05 60 e5 b3 00 09 	movl   $0x9,0xb3e560
  80304f:	00 00 00 
  803052:	ba 00 00 00 00       	mov    $0x0,%edx
  803057:	eb 24                	jmp    80307d <get_socket+0x3d>
    return NULL;
  }

  sock = &sockets[s];
  803059:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80305c:	c1 e0 02             	shl    $0x2,%eax
  80305f:	8d 90 e0 83 81 00    	lea    0x8183e0(%eax),%edx

  if (!sock->conn) {
  803065:	83 b8 e0 83 81 00 00 	cmpl   $0x0,0x8183e0(%eax)
  80306c:	75 0f                	jne    80307d <get_socket+0x3d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  80306e:	c7 05 60 e5 b3 00 09 	movl   $0x9,0xb3e560
  803075:	00 00 00 
  803078:	ba 00 00 00 00       	mov    $0x0,%edx
    return NULL;
  }

  return sock;
}
  80307d:	89 d0                	mov    %edx,%eax
  80307f:	5d                   	pop    %ebp
  803080:	c3                   	ret    

00803081 <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  803081:	55                   	push   %ebp
  803082:	89 e5                	mov    %esp,%ebp
  803084:	56                   	push   %esi
  803085:	53                   	push   %ebx
  803086:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  803089:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  80308c:	8b 45 08             	mov    0x8(%ebp),%eax
  80308f:	e8 ac ff ff ff       	call   803040 <get_socket>
  803094:	89 c2                	mov    %eax,%edx
  u16_t buflen = 0;

  if (!sock)
  803096:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80309b:	85 d2                	test   %edx,%edx
  80309d:	0f 84 ac 00 00 00    	je     80314f <lwip_ioctl+0xce>
    return -1;

  switch (cmd) {
  8030a3:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  8030a9:	74 5f                	je     80310a <lwip_ioctl+0x89>
  8030ab:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  8030b1:	0f 85 82 00 00 00    	jne    803139 <lwip_ioctl+0xb8>
  case FIONREAD:
    if (!argp) {
  8030b7:	85 f6                	test   %esi,%esi
  8030b9:	75 18                	jne    8030d3 <lwip_ioctl+0x52>
      sock_set_errno(sock, EINVAL);
  8030bb:	c7 42 10 16 00 00 00 	movl   $0x16,0x10(%edx)
  8030c2:	c7 05 60 e5 b3 00 16 	movl   $0x16,0xb3e560
  8030c9:	00 00 00 
  8030cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8030d1:	eb 7c                	jmp    80314f <lwip_ioctl+0xce>
      return -1;
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  8030d3:	8b 02                	mov    (%edx),%eax
  8030d5:	0f b7 48 20          	movzwl 0x20(%eax),%ecx
  8030d9:	66 89 0e             	mov    %cx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  8030dc:	8b 42 04             	mov    0x4(%edx),%eax
  8030df:	85 c0                	test   %eax,%eax
  8030e1:	74 0f                	je     8030f2 <lwip_ioctl+0x71>
      buflen = netbuf_len(sock->lastdata);
  8030e3:	8b 00                	mov    (%eax),%eax
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  8030e5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8030e9:	01 c8                	add    %ecx,%eax
  8030eb:	66 2b 42 08          	sub    0x8(%edx),%ax
  8030ef:	66 89 06             	mov    %ax,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  8030f2:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
  8030f9:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  803100:	00 00 00 
  803103:	b8 00 00 00 00       	mov    $0x0,%eax
  803108:	eb 45                	jmp    80314f <lwip_ioctl+0xce>
    return 0;

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  80310a:	85 f6                	test   %esi,%esi
  80310c:	74 0d                	je     80311b <lwip_ioctl+0x9a>
  80310e:	83 3e 00             	cmpl   $0x0,(%esi)
  803111:	74 08                	je     80311b <lwip_ioctl+0x9a>
      sock->flags |= O_NONBLOCK;
  803113:	66 81 4a 0e 00 08    	orw    $0x800,0xe(%edx)
  803119:	eb 06                	jmp    803121 <lwip_ioctl+0xa0>
    else
      sock->flags &= ~O_NONBLOCK;
  80311b:	66 81 62 0e ff f7    	andw   $0xf7ff,0xe(%edx)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  803121:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
  803128:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  80312f:	00 00 00 
  803132:	b8 00 00 00 00       	mov    $0x0,%eax
  803137:	eb 16                	jmp    80314f <lwip_ioctl+0xce>
    return 0;

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  803139:	c7 42 10 26 00 00 00 	movl   $0x26,0x10(%edx)
  803140:	c7 05 60 e5 b3 00 26 	movl   $0x26,0xb3e560
  803147:	00 00 00 
  80314a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  } /* switch (cmd) */
}
  80314f:	5b                   	pop    %ebx
  803150:	5e                   	pop    %esi
  803151:	5d                   	pop    %ebp
  803152:	c3                   	ret    

00803153 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  803153:	55                   	push   %ebp
  803154:	89 e5                	mov    %esp,%ebp
  803156:	83 ec 38             	sub    $0x38,%esp
  803159:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80315c:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80315f:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803162:	8b 75 0c             	mov    0xc(%ebp),%esi
  803165:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  803168:	8b 45 08             	mov    0x8(%ebp),%eax
  80316b:	e8 d0 fe ff ff       	call   803040 <get_socket>
  803170:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  803172:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  803177:	85 c0                	test   %eax,%eax
  803179:	0f 84 66 01 00 00    	je     8032e5 <lwip_setsockopt+0x192>
    return -1;

  if (NULL == optval) {
  80317f:	85 ff                	test   %edi,%edi
  803181:	75 1b                	jne    80319e <lwip_setsockopt+0x4b>
    sock_set_errno(sock, EFAULT);
  803183:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  80318a:	c7 05 60 e5 b3 00 0e 	movl   $0xe,0xb3e560
  803191:	00 00 00 
  803194:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  803199:	e9 47 01 00 00       	jmp    8032e5 <lwip_setsockopt+0x192>
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  80319e:	83 fe 06             	cmp    $0x6,%esi
  8031a1:	0f 84 81 00 00 00    	je     803228 <lwip_setsockopt+0xd5>
  8031a7:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  8031ad:	74 09                	je     8031b8 <lwip_setsockopt+0x65>
  8031af:	85 f6                	test   %esi,%esi
  8031b1:	74 5b                	je     80320e <lwip_setsockopt+0xbb>
  8031b3:	e9 a5 00 00 00       	jmp    80325d <lwip_setsockopt+0x10a>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8031b8:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8031bc:	8d 74 26 00          	lea    0x0(%esi),%esi
  8031c0:	74 1a                	je     8031dc <lwip_setsockopt+0x89>
  8031c2:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  8031c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  8031d0:	74 19                	je     8031eb <lwip_setsockopt+0x98>
  8031d2:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  8031d6:	0f 85 81 00 00 00    	jne    80325d <lwip_setsockopt+0x10a>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  8031dc:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8031e0:	0f 86 f1 00 00 00    	jbe    8032d7 <lwip_setsockopt+0x184>
  8031e6:	e9 8b 00 00 00       	jmp    803276 <lwip_setsockopt+0x123>
        err = EINVAL;
      }
      break;
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  8031eb:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  8031ef:	19 d2                	sbb    %edx,%edx
  8031f1:	83 e2 16             	and    $0x16,%edx
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8031f4:	8b 00                	mov    (%eax),%eax
  8031f6:	83 38 20             	cmpl   $0x20,(%eax)
  8031f9:	0f 85 df 00 00 00    	jne    8032de <lwip_setsockopt+0x18b>
  8031ff:	8b 40 08             	mov    0x8(%eax),%eax
  803202:	f6 40 10 02          	testb  $0x2,0x10(%eax)
  803206:	0f 85 d2 00 00 00    	jne    8032de <lwip_setsockopt+0x18b>
  80320c:	eb 54                	jmp    803262 <lwip_setsockopt+0x10f>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  80320e:	8b 45 10             	mov    0x10(%ebp),%eax
  803211:	83 e8 01             	sub    $0x1,%eax
  803214:	83 f8 01             	cmp    $0x1,%eax
  803217:	77 44                	ja     80325d <lwip_setsockopt+0x10a>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  803219:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80321d:	8d 76 00             	lea    0x0(%esi),%esi
  803220:	0f 86 b1 00 00 00    	jbe    8032d7 <lwip_setsockopt+0x184>
  803226:	eb 4e                	jmp    803276 <lwip_setsockopt+0x123>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  803228:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80322c:	8d 74 26 00          	lea    0x0(%esi),%esi
  803230:	0f 86 a1 00 00 00    	jbe    8032d7 <lwip_setsockopt+0x184>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  803236:	8b 00                	mov    (%eax),%eax
  803238:	ba 00 00 00 00       	mov    $0x0,%edx
  80323d:	83 38 10             	cmpl   $0x10,(%eax)
  803240:	0f 85 9f 00 00 00    	jne    8032e5 <lwip_setsockopt+0x192>
      return 0;

    switch (optname) {
  803246:	8b 45 10             	mov    0x10(%ebp),%eax
  803249:	83 e8 01             	sub    $0x1,%eax
  80324c:	ba 5c 00 00 00       	mov    $0x5c,%edx
  803251:	83 f8 01             	cmp    $0x1,%eax
  803254:	77 10                	ja     803266 <lwip_setsockopt+0x113>
  803256:	ba 00 00 00 00       	mov    $0x0,%edx
  80325b:	eb 05                	jmp    803262 <lwip_setsockopt+0x10f>
  80325d:	ba 5c 00 00 00       	mov    $0x5c,%edx
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  803262:	85 d2                	test   %edx,%edx
  803264:	74 10                	je     803276 <lwip_setsockopt+0x123>
    sock_set_errno(sock, err);
  803266:	89 53 10             	mov    %edx,0x10(%ebx)
  803269:	89 15 60 e5 b3 00    	mov    %edx,0xb3e560
  80326f:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  803274:	eb 6f                	jmp    8032e5 <lwip_setsockopt+0x192>
    return -1;
  }


  /* Now do the actual option processing */
  data.sock = sock;
  803276:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  data.level = level;
  803279:	89 75 e0             	mov    %esi,-0x20(%ebp)
  data.optname = optname;
  80327c:	8b 45 10             	mov    0x10(%ebp),%eax
  80327f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  data.optval = (void*)optval;
  803282:	89 7d e8             	mov    %edi,-0x18(%ebp)
  data.optlen = &optlen;
  803285:	8d 45 18             	lea    0x18(%ebp),%eax
  803288:	89 45 ec             	mov    %eax,-0x14(%ebp)
  data.err = err;
  80328b:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  80328f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  803296:	00 
  803297:	8d 45 d8             	lea    -0x28(%ebp),%eax
  80329a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80329e:	c7 04 24 c6 34 80 00 	movl   $0x8034c6,(%esp)
  8032a5:	e8 96 1b 00 00       	call   804e40 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  8032aa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8032b1:	00 
  8032b2:	8b 03                	mov    (%ebx),%eax
  8032b4:	8b 40 10             	mov    0x10(%eax),%eax
  8032b7:	89 04 24             	mov    %eax,(%esp)
  8032ba:	e8 1a a2 00 00       	call   80d4d9 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  8032bf:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx
  8032c3:	0f be c2             	movsbl %dl,%eax

  sock_set_errno(sock, err);
  8032c6:	89 43 10             	mov    %eax,0x10(%ebx)
  8032c9:	a3 60 e5 b3 00       	mov    %eax,0xb3e560
  return err ? -1 : 0;
  8032ce:	80 fa 01             	cmp    $0x1,%dl
  8032d1:	19 d2                	sbb    %edx,%edx
  8032d3:	f7 d2                	not    %edx
  8032d5:	eb 0e                	jmp    8032e5 <lwip_setsockopt+0x192>
  8032d7:	ba 16 00 00 00       	mov    $0x16,%edx
  8032dc:	eb 88                	jmp    803266 <lwip_setsockopt+0x113>
  8032de:	ba 61 00 00 00       	mov    $0x61,%edx
  8032e3:	eb 81                	jmp    803266 <lwip_setsockopt+0x113>
}
  8032e5:	89 d0                	mov    %edx,%eax
  8032e7:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8032ea:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8032ed:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8032f0:	89 ec                	mov    %ebp,%esp
  8032f2:	5d                   	pop    %ebp
  8032f3:	c3                   	ret    

008032f4 <lwip_getsockopt>:
  return lwip_getaddrname(s, name, namelen, 1);
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  8032f4:	55                   	push   %ebp
  8032f5:	89 e5                	mov    %esp,%ebp
  8032f7:	83 ec 38             	sub    $0x38,%esp
  8032fa:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8032fd:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803300:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803303:	8b 7d 0c             	mov    0xc(%ebp),%edi
  803306:	8b 75 10             	mov    0x10(%ebp),%esi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  803309:	8b 45 08             	mov    0x8(%ebp),%eax
  80330c:	e8 2f fd ff ff       	call   803040 <get_socket>
  803311:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  803313:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  803318:	85 c0                	test   %eax,%eax
  80331a:	0f 84 97 01 00 00    	je     8034b7 <lwip_getsockopt+0x1c3>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  803320:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  803324:	74 06                	je     80332c <lwip_getsockopt+0x38>
  803326:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  80332a:	75 1b                	jne    803347 <lwip_getsockopt+0x53>
    sock_set_errno(sock, EFAULT);
  80332c:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  803333:	c7 05 60 e5 b3 00 0e 	movl   $0xe,0xb3e560
  80333a:	00 00 00 
  80333d:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  803342:	e9 70 01 00 00       	jmp    8034b7 <lwip_getsockopt+0x1c3>
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  803347:	83 ff 06             	cmp    $0x6,%edi
  80334a:	0f 84 a8 00 00 00    	je     8033f8 <lwip_getsockopt+0x104>
  803350:	81 ff ff 0f 00 00    	cmp    $0xfff,%edi
  803356:	74 0d                	je     803365 <lwip_getsockopt+0x71>
  803358:	85 ff                	test   %edi,%edi
  80335a:	0f 84 80 00 00 00    	je     8033e0 <lwip_getsockopt+0xec>
  803360:	e9 c5 00 00 00       	jmp    80342a <lwip_getsockopt+0x136>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  803365:	83 fe 20             	cmp    $0x20,%esi
  803368:	74 3e                	je     8033a8 <lwip_getsockopt+0xb4>
  80336a:	83 fe 20             	cmp    $0x20,%esi
  80336d:	8d 76 00             	lea    0x0(%esi),%esi
  803370:	7f 10                	jg     803382 <lwip_getsockopt+0x8e>
  803372:	83 fe 02             	cmp    $0x2,%esi
  803375:	74 31                	je     8033a8 <lwip_getsockopt+0xb4>
  803377:	83 fe 08             	cmp    $0x8,%esi
  80337a:	0f 85 aa 00 00 00    	jne    80342a <lwip_getsockopt+0x136>
  803380:	eb 26                	jmp    8033a8 <lwip_getsockopt+0xb4>
  803382:	81 fe 07 10 00 00    	cmp    $0x1007,%esi
  803388:	0f 8c 9c 00 00 00    	jl     80342a <lwip_getsockopt+0x136>
  80338e:	81 fe 08 10 00 00    	cmp    $0x1008,%esi
  803394:	7e 12                	jle    8033a8 <lwip_getsockopt+0xb4>
  803396:	81 fe 0a 10 00 00    	cmp    $0x100a,%esi
  80339c:	8d 74 26 00          	lea    0x0(%esi),%esi
  8033a0:	0f 85 84 00 00 00    	jne    80342a <lwip_getsockopt+0x136>
  8033a6:	eb 13                	jmp    8033bb <lwip_getsockopt+0xc7>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  8033a8:	8b 45 18             	mov    0x18(%ebp),%eax
  8033ab:	83 38 03             	cmpl   $0x3,(%eax)
  8033ae:	66 90                	xchg   %ax,%ax
  8033b0:	0f 86 f0 00 00 00    	jbe    8034a6 <lwip_getsockopt+0x1b2>
  8033b6:	e9 8a 00 00 00       	jmp    803445 <lwip_getsockopt+0x151>
        err = EINVAL;
      }
      break;

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  8033bb:	8b 45 18             	mov    0x18(%ebp),%eax
  8033be:	83 38 04             	cmpl   $0x4,(%eax)
  8033c1:	19 d2                	sbb    %edx,%edx
  8033c3:	83 e2 16             	and    $0x16,%edx
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8033c6:	8b 03                	mov    (%ebx),%eax
  8033c8:	83 38 20             	cmpl   $0x20,(%eax)
  8033cb:	0f 85 dc 00 00 00    	jne    8034ad <lwip_getsockopt+0x1b9>
  8033d1:	8b 40 08             	mov    0x8(%eax),%eax
  8033d4:	f6 40 10 02          	testb  $0x2,0x10(%eax)
  8033d8:	0f 85 cf 00 00 00    	jne    8034ad <lwip_getsockopt+0x1b9>
  8033de:	eb 4f                	jmp    80342f <lwip_getsockopt+0x13b>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8033e0:	8d 46 ff             	lea    -0x1(%esi),%eax
  8033e3:	83 f8 01             	cmp    $0x1,%eax
  8033e6:	77 42                	ja     80342a <lwip_getsockopt+0x136>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  8033e8:	8b 45 18             	mov    0x18(%ebp),%eax
  8033eb:	83 38 03             	cmpl   $0x3,(%eax)
  8033ee:	66 90                	xchg   %ax,%ax
  8033f0:	0f 86 b0 00 00 00    	jbe    8034a6 <lwip_getsockopt+0x1b2>
  8033f6:	eb 4d                	jmp    803445 <lwip_getsockopt+0x151>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  8033f8:	8b 45 18             	mov    0x18(%ebp),%eax
  8033fb:	83 38 03             	cmpl   $0x3,(%eax)
  8033fe:	66 90                	xchg   %ax,%ax
  803400:	0f 86 a0 00 00 00    	jbe    8034a6 <lwip_getsockopt+0x1b2>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  803406:	8b 03                	mov    (%ebx),%eax
  803408:	ba 00 00 00 00       	mov    $0x0,%edx
  80340d:	83 38 10             	cmpl   $0x10,(%eax)
  803410:	0f 85 a1 00 00 00    	jne    8034b7 <lwip_getsockopt+0x1c3>
      return 0;

    switch (optname) {
  803416:	8d 46 ff             	lea    -0x1(%esi),%eax
  803419:	ba 5c 00 00 00       	mov    $0x5c,%edx
  80341e:	83 f8 01             	cmp    $0x1,%eax
  803421:	77 10                	ja     803433 <lwip_getsockopt+0x13f>
  803423:	ba 00 00 00 00       	mov    $0x0,%edx
  803428:	eb 05                	jmp    80342f <lwip_getsockopt+0x13b>
  80342a:	ba 5c 00 00 00       	mov    $0x5c,%edx
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  80342f:	84 d2                	test   %dl,%dl
  803431:	74 12                	je     803445 <lwip_getsockopt+0x151>
    sock_set_errno(sock, err);
  803433:	0f be c2             	movsbl %dl,%eax
  803436:	89 43 10             	mov    %eax,0x10(%ebx)
  803439:	a3 60 e5 b3 00       	mov    %eax,0xb3e560
  80343e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  803443:	eb 72                	jmp    8034b7 <lwip_getsockopt+0x1c3>
    return -1;
  }

  /* Now do the actual option processing */
  data.sock = sock;
  803445:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  data.level = level;
  803448:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.optname = optname;
  80344b:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  data.optval = optval;
  80344e:	8b 45 14             	mov    0x14(%ebp),%eax
  803451:	89 45 e8             	mov    %eax,-0x18(%ebp)
  data.optlen = optlen;
  803454:	8b 45 18             	mov    0x18(%ebp),%eax
  803457:	89 45 ec             	mov    %eax,-0x14(%ebp)
  data.err = err;
  80345a:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  80345e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  803465:	00 
  803466:	8d 45 d8             	lea    -0x28(%ebp),%eax
  803469:	89 44 24 04          	mov    %eax,0x4(%esp)
  80346d:	c7 04 24 d9 35 80 00 	movl   $0x8035d9,(%esp)
  803474:	e8 c7 19 00 00       	call   804e40 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  803479:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803480:	00 
  803481:	8b 03                	mov    (%ebx),%eax
  803483:	8b 40 10             	mov    0x10(%eax),%eax
  803486:	89 04 24             	mov    %eax,(%esp)
  803489:	e8 4b a0 00 00       	call   80d4d9 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  80348e:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx

  sock_set_errno(sock, err);
  803492:	0f be c2             	movsbl %dl,%eax
  803495:	89 43 10             	mov    %eax,0x10(%ebx)
  803498:	a3 60 e5 b3 00       	mov    %eax,0xb3e560
  return err ? -1 : 0;
  80349d:	80 fa 01             	cmp    $0x1,%dl
  8034a0:	19 d2                	sbb    %edx,%edx
  8034a2:	f7 d2                	not    %edx
  8034a4:	eb 11                	jmp    8034b7 <lwip_getsockopt+0x1c3>
  8034a6:	ba 16 00 00 00       	mov    $0x16,%edx
  8034ab:	eb 86                	jmp    803433 <lwip_getsockopt+0x13f>
  8034ad:	ba 61 00 00 00       	mov    $0x61,%edx
  8034b2:	e9 7c ff ff ff       	jmp    803433 <lwip_getsockopt+0x13f>
}
  8034b7:	89 d0                	mov    %edx,%eax
  8034b9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8034bc:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8034bf:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8034c2:	89 ec                	mov    %ebp,%esp
  8034c4:	5d                   	pop    %ebp
  8034c5:	c3                   	ret    

008034c6 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  8034c6:	55                   	push   %ebp
  8034c7:	89 e5                	mov    %esp,%ebp
  8034c9:	56                   	push   %esi
  8034ca:	53                   	push   %ebx
  8034cb:	83 ec 10             	sub    $0x10,%esp
  8034ce:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8034d1:	85 c0                	test   %eax,%eax
  8034d3:	75 1c                	jne    8034f1 <lwip_setsockopt_internal+0x2b>
  8034d5:	c7 44 24 08 05 29 81 	movl   $0x812905,0x8(%esp)
  8034dc:	00 
  8034dd:	c7 44 24 04 ae 06 00 	movl   $0x6ae,0x4(%esp)
  8034e4:	00 
  8034e5:	c7 04 24 11 29 81 00 	movl   $0x812911,(%esp)
  8034ec:	e8 bb d3 ff ff       	call   8008ac <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  8034f1:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  8034f3:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  8034f6:	8b 70 10             	mov    0x10(%eax),%esi

  switch (level) {
  8034f9:	8b 40 08             	mov    0x8(%eax),%eax
  8034fc:	83 f8 06             	cmp    $0x6,%eax
  8034ff:	0f 84 87 00 00 00    	je     80358c <lwip_setsockopt_internal+0xc6>
  803505:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  80350a:	74 09                	je     803515 <lwip_setsockopt_internal+0x4f>
  80350c:	85 c0                	test   %eax,%eax
  80350e:	74 5a                	je     80356a <lwip_setsockopt_internal+0xa4>
  803510:	e9 b0 00 00 00       	jmp    8035c5 <lwip_setsockopt_internal+0xff>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  803515:	83 f9 20             	cmp    $0x20,%ecx
  803518:	74 11                	je     80352b <lwip_setsockopt_internal+0x65>
  80351a:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  803520:	74 2d                	je     80354f <lwip_setsockopt_internal+0x89>
  803522:	83 f9 08             	cmp    $0x8,%ecx
  803525:	0f 85 9a 00 00 00    	jne    8035c5 <lwip_setsockopt_internal+0xff>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  80352b:	83 3e 00             	cmpl   $0x0,(%esi)
  80352e:	66 90                	xchg   %ax,%ax
  803530:	74 0e                	je     803540 <lwip_setsockopt_internal+0x7a>
        sock->conn->pcb.ip->so_options |= optname;
  803532:	8b 03                	mov    (%ebx),%eax
  803534:	8b 40 08             	mov    0x8(%eax),%eax
  803537:	66 09 48 08          	or     %cx,0x8(%eax)
  80353b:	e9 85 00 00 00       	jmp    8035c5 <lwip_setsockopt_internal+0xff>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  803540:	8b 03                	mov    (%ebx),%eax
  803542:	8b 50 08             	mov    0x8(%eax),%edx
  803545:	89 c8                	mov    %ecx,%eax
  803547:	f7 d0                	not    %eax
  803549:	66 21 42 08          	and    %ax,0x8(%edx)
  80354d:	eb 76                	jmp    8035c5 <lwip_setsockopt_internal+0xff>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  80354f:	83 3e 00             	cmpl   $0x0,(%esi)
  803552:	74 0b                	je     80355f <lwip_setsockopt_internal+0x99>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  803554:	8b 03                	mov    (%ebx),%eax
  803556:	8b 40 08             	mov    0x8(%eax),%eax
  803559:	80 48 10 01          	orb    $0x1,0x10(%eax)
  80355d:	eb 66                	jmp    8035c5 <lwip_setsockopt_internal+0xff>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  80355f:	8b 03                	mov    (%ebx),%eax
  803561:	8b 40 08             	mov    0x8(%eax),%eax
  803564:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  803568:	eb 5b                	jmp    8035c5 <lwip_setsockopt_internal+0xff>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  80356a:	83 f9 01             	cmp    $0x1,%ecx
  80356d:	74 11                	je     803580 <lwip_setsockopt_internal+0xba>
  80356f:	83 f9 02             	cmp    $0x2,%ecx
  803572:	75 51                	jne    8035c5 <lwip_setsockopt_internal+0xff>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  803574:	8b 03                	mov    (%ebx),%eax
  803576:	8b 50 08             	mov    0x8(%eax),%edx
  803579:	8b 06                	mov    (%esi),%eax
  80357b:	88 42 0b             	mov    %al,0xb(%edx)
  80357e:	eb 45                	jmp    8035c5 <lwip_setsockopt_internal+0xff>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  803580:	8b 03                	mov    (%ebx),%eax
  803582:	8b 50 08             	mov    0x8(%eax),%edx
  803585:	8b 06                	mov    (%esi),%eax
  803587:	88 42 0a             	mov    %al,0xa(%edx)
  80358a:	eb 39                	jmp    8035c5 <lwip_setsockopt_internal+0xff>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  80358c:	83 f9 01             	cmp    $0x1,%ecx
  80358f:	74 07                	je     803598 <lwip_setsockopt_internal+0xd2>
  803591:	83 f9 02             	cmp    $0x2,%ecx
  803594:	75 2f                	jne    8035c5 <lwip_setsockopt_internal+0xff>
  803596:	eb 20                	jmp    8035b8 <lwip_setsockopt_internal+0xf2>
    case TCP_NODELAY:
      if (*(int*)optval) {
  803598:	83 3e 00             	cmpl   $0x0,(%esi)
  80359b:	90                   	nop    
  80359c:	8d 74 26 00          	lea    0x0(%esi),%esi
  8035a0:	74 0b                	je     8035ad <lwip_setsockopt_internal+0xe7>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  8035a2:	8b 03                	mov    (%ebx),%eax
  8035a4:	8b 40 08             	mov    0x8(%eax),%eax
  8035a7:	80 48 20 40          	orb    $0x40,0x20(%eax)
  8035ab:	eb 18                	jmp    8035c5 <lwip_setsockopt_internal+0xff>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  8035ad:	8b 03                	mov    (%ebx),%eax
  8035af:	8b 40 08             	mov    0x8(%eax),%eax
  8035b2:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  8035b6:	eb 0d                	jmp    8035c5 <lwip_setsockopt_internal+0xff>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  8035b8:	8b 03                	mov    (%ebx),%eax
  8035ba:	8b 50 08             	mov    0x8(%eax),%edx
  8035bd:	8b 06                	mov    (%esi),%eax
  8035bf:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  8035c5:	8b 03                	mov    (%ebx),%eax
  8035c7:	8b 40 10             	mov    0x10(%eax),%eax
  8035ca:	89 04 24             	mov    %eax,(%esp)
  8035cd:	e8 e8 a1 00 00       	call   80d7ba <sys_sem_signal>
}
  8035d2:	83 c4 10             	add    $0x10,%esp
  8035d5:	5b                   	pop    %ebx
  8035d6:	5e                   	pop    %esi
  8035d7:	5d                   	pop    %ebp
  8035d8:	c3                   	ret    

008035d9 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  8035d9:	55                   	push   %ebp
  8035da:	89 e5                	mov    %esp,%ebp
  8035dc:	53                   	push   %ebx
  8035dd:	83 ec 14             	sub    $0x14,%esp
  8035e0:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8035e3:	85 c0                	test   %eax,%eax
  8035e5:	75 1c                	jne    803603 <lwip_getsockopt_internal+0x2a>
  8035e7:	c7 44 24 08 05 29 81 	movl   $0x812905,0x8(%esp)
  8035ee:	00 
  8035ef:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  8035f6:	00 
  8035f7:	c7 04 24 11 29 81 00 	movl   $0x812911,(%esp)
  8035fe:	e8 a9 d2 ff ff       	call   8008ac <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  803603:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  803605:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  803608:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  80360b:	8b 40 08             	mov    0x8(%eax),%eax
  80360e:	83 f8 06             	cmp    $0x6,%eax
  803611:	0f 84 1f 01 00 00    	je     803736 <lwip_getsockopt_internal+0x15d>
  803617:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  80361c:	74 0d                	je     80362b <lwip_getsockopt_internal+0x52>
  80361e:	85 c0                	test   %eax,%eax
  803620:	0f 84 ec 00 00 00    	je     803712 <lwip_getsockopt_internal+0x139>
  803626:	e9 34 01 00 00       	jmp    80375f <lwip_getsockopt_internal+0x186>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80362b:	83 fa 20             	cmp    $0x20,%edx
  80362e:	66 90                	xchg   %ax,%ax
  803630:	74 40                	je     803672 <lwip_getsockopt_internal+0x99>
  803632:	83 fa 20             	cmp    $0x20,%edx
  803635:	7f 11                	jg     803648 <lwip_getsockopt_internal+0x6f>
  803637:	83 fa 02             	cmp    $0x2,%edx
  80363a:	74 36                	je     803672 <lwip_getsockopt_internal+0x99>
  80363c:	83 fa 08             	cmp    $0x8,%edx
  80363f:	90                   	nop    
  803640:	0f 85 19 01 00 00    	jne    80375f <lwip_getsockopt_internal+0x186>
  803646:	eb 2a                	jmp    803672 <lwip_getsockopt_internal+0x99>
  803648:	81 fa 08 10 00 00    	cmp    $0x1008,%edx
  80364e:	66 90                	xchg   %ax,%ax
  803650:	74 32                	je     803684 <lwip_getsockopt_internal+0xab>
  803652:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  803658:	0f 84 a4 00 00 00    	je     803702 <lwip_getsockopt_internal+0x129>
  80365e:	81 fa 07 10 00 00    	cmp    $0x1007,%edx
  803664:	0f 85 f5 00 00 00    	jne    80375f <lwip_getsockopt_internal+0x186>
  80366a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  803670:	eb 5a                	jmp    8036cc <lwip_getsockopt_internal+0xf3>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  803672:	8b 01                	mov    (%ecx),%eax
  803674:	8b 40 08             	mov    0x8(%eax),%eax
  803677:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80367b:	21 d0                	and    %edx,%eax
  80367d:	89 03                	mov    %eax,(%ebx)
  80367f:	e9 db 00 00 00       	jmp    80375f <lwip_getsockopt_internal+0x186>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  803684:	8b 01                	mov    (%ecx),%eax
  803686:	8b 00                	mov    (%eax),%eax
  803688:	89 c2                	mov    %eax,%edx
  80368a:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  803690:	83 fa 20             	cmp    $0x20,%edx
  803693:	74 23                	je     8036b8 <lwip_getsockopt_internal+0xdf>
  803695:	83 fa 40             	cmp    $0x40,%edx
  803698:	74 08                	je     8036a2 <lwip_getsockopt_internal+0xc9>
  80369a:	83 fa 10             	cmp    $0x10,%edx
  80369d:	75 26                	jne    8036c5 <lwip_getsockopt_internal+0xec>
  80369f:	90                   	nop    
  8036a0:	eb 0b                	jmp    8036ad <lwip_getsockopt_internal+0xd4>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  8036a2:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
  8036a8:	e9 b2 00 00 00       	jmp    80375f <lwip_getsockopt_internal+0x186>
        break;
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  8036ad:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
  8036b3:	e9 a7 00 00 00       	jmp    80375f <lwip_getsockopt_internal+0x186>
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  8036b8:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
  8036be:	66 90                	xchg   %ax,%ax
  8036c0:	e9 9a 00 00 00       	jmp    80375f <lwip_getsockopt_internal+0x186>
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  8036c5:	89 03                	mov    %eax,(%ebx)
  8036c7:	e9 93 00 00 00       	jmp    80375f <lwip_getsockopt_internal+0x186>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  8036cc:	83 79 10 00          	cmpl   $0x0,0x10(%ecx)
  8036d0:	75 22                	jne    8036f4 <lwip_getsockopt_internal+0x11b>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  8036d2:	8b 01                	mov    (%ecx),%eax
  8036d4:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  8036d8:	f7 d8                	neg    %eax
  8036da:	ba 05 00 00 00       	mov    $0x5,%edx
  8036df:	83 f8 0e             	cmp    $0xe,%eax
  8036e2:	77 07                	ja     8036eb <lwip_getsockopt_internal+0x112>
  8036e4:	8b 14 85 e0 29 81 00 	mov    0x8129e0(,%eax,4),%edx
  8036eb:	89 51 10             	mov    %edx,0x10(%ecx)
  8036ee:	89 15 60 e5 b3 00    	mov    %edx,0xb3e560
      } 
      *(int *)optval = sock->err;
  8036f4:	8b 41 10             	mov    0x10(%ecx),%eax
  8036f7:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  8036f9:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
  803700:	eb 5d                	jmp    80375f <lwip_getsockopt_internal+0x186>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  803702:	8b 01                	mov    (%ecx),%eax
  803704:	8b 40 08             	mov    0x8(%eax),%eax
  803707:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80370b:	83 e0 01             	and    $0x1,%eax
  80370e:	89 03                	mov    %eax,(%ebx)
  803710:	eb 4d                	jmp    80375f <lwip_getsockopt_internal+0x186>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  803712:	83 fa 01             	cmp    $0x1,%edx
  803715:	74 12                	je     803729 <lwip_getsockopt_internal+0x150>
  803717:	83 fa 02             	cmp    $0x2,%edx
  80371a:	75 43                	jne    80375f <lwip_getsockopt_internal+0x186>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  80371c:	8b 01                	mov    (%ecx),%eax
  80371e:	8b 40 08             	mov    0x8(%eax),%eax
  803721:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  803725:	89 03                	mov    %eax,(%ebx)
  803727:	eb 36                	jmp    80375f <lwip_getsockopt_internal+0x186>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  803729:	8b 01                	mov    (%ecx),%eax
  80372b:	8b 40 08             	mov    0x8(%eax),%eax
  80372e:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  803732:	89 03                	mov    %eax,(%ebx)
  803734:	eb 29                	jmp    80375f <lwip_getsockopt_internal+0x186>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  803736:	83 fa 01             	cmp    $0x1,%edx
  803739:	74 07                	je     803742 <lwip_getsockopt_internal+0x169>
  80373b:	83 fa 02             	cmp    $0x2,%edx
  80373e:	75 1f                	jne    80375f <lwip_getsockopt_internal+0x186>
  803740:	eb 10                	jmp    803752 <lwip_getsockopt_internal+0x179>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  803742:	8b 01                	mov    (%ecx),%eax
  803744:	8b 40 08             	mov    0x8(%eax),%eax
  803747:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  80374b:	83 e0 40             	and    $0x40,%eax
  80374e:	89 03                	mov    %eax,(%ebx)
  803750:	eb 0d                	jmp    80375f <lwip_getsockopt_internal+0x186>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  803752:	8b 01                	mov    (%ecx),%eax
  803754:	8b 40 08             	mov    0x8(%eax),%eax
  803757:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  80375d:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  80375f:	8b 01                	mov    (%ecx),%eax
  803761:	8b 40 10             	mov    0x10(%eax),%eax
  803764:	89 04 24             	mov    %eax,(%esp)
  803767:	e8 4e a0 00 00       	call   80d7ba <sys_sem_signal>
}
  80376c:	83 c4 14             	add    $0x14,%esp
  80376f:	5b                   	pop    %ebx
  803770:	5d                   	pop    %ebp
  803771:	c3                   	ret    

00803772 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  803772:	55                   	push   %ebp
  803773:	89 e5                	mov    %esp,%ebp
  803775:	57                   	push   %edi
  803776:	56                   	push   %esi
  803777:	53                   	push   %ebx
  803778:	83 ec 2c             	sub    $0x2c,%esp
  80377b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80377e:	89 55 d8             	mov    %edx,-0x28(%ebp)
  803781:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  803784:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80378b:	00 
  80378c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803793:	00 
  803794:	8d 45 f0             	lea    -0x10(%ebp),%eax
  803797:	89 04 24             	mov    %eax,(%esp)
  80379a:	e8 ef d9 ff ff       	call   80118e <memset>
  FD_ZERO(&lwriteset);
  80379f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8037a6:	00 
  8037a7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8037ae:	00 
  8037af:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8037b2:	89 04 24             	mov    %eax,(%esp)
  8037b5:	e8 d4 d9 ff ff       	call   80118e <memset>
  FD_ZERO(&lexceptset);
  8037ba:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8037c1:	00 
  8037c2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8037c9:	00 
  8037ca:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8037cd:	89 04 24             	mov    %eax,(%esp)
  8037d0:	e8 b9 d9 ff ff       	call   80118e <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  8037d5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  8037dc:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  8037e0:	0f 8e 9b 00 00 00    	jle    803881 <lwip_selscan+0x10f>
  8037e6:	bb 00 00 00 00       	mov    $0x0,%ebx
  8037eb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if (FD_ISSET(i, readset)) {
  8037f2:	89 d8                	mov    %ebx,%eax
  8037f4:	c1 f8 1f             	sar    $0x1f,%eax
  8037f7:	c1 e8 1d             	shr    $0x1d,%eax
  8037fa:	01 d8                	add    %ebx,%eax
  8037fc:	89 c6                	mov    %eax,%esi
  8037fe:	c1 fe 03             	sar    $0x3,%esi
  803801:	89 df                	mov    %ebx,%edi
  803803:	83 e7 07             	and    $0x7,%edi
  803806:	8b 55 d8             	mov    -0x28(%ebp),%edx
  803809:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  80380d:	89 f9                	mov    %edi,%ecx
  80380f:	d3 f8                	sar    %cl,%eax
  803811:	a8 01                	test   $0x1,%al
  803813:	74 2e                	je     803843 <lwip_selscan+0xd1>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  803815:	89 d8                	mov    %ebx,%eax
  803817:	e8 24 f8 ff ff       	call   803040 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  80381c:	85 c0                	test   %eax,%eax
  80381e:	74 23                	je     803843 <lwip_selscan+0xd1>
  803820:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  803824:	75 0c                	jne    803832 <lwip_selscan+0xc0>
  803826:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  80382b:	90                   	nop    
  80382c:	8d 74 26 00          	lea    0x0(%esi),%esi
  803830:	74 11                	je     803843 <lwip_selscan+0xd1>
        FD_SET(i, &lreadset);
  803832:	b8 01 00 00 00       	mov    $0x1,%eax
  803837:	89 f9                	mov    %edi,%ecx
  803839:	d3 e0                	shl    %cl,%eax
  80383b:	08 44 35 f0          	or     %al,-0x10(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  80383f:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  803843:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  803846:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  80384a:	89 f9                	mov    %edi,%ecx
  80384c:	d3 f8                	sar    %cl,%eax
  80384e:	a8 01                	test   $0x1,%al
  803850:	74 23                	je     803875 <lwip_selscan+0x103>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  803852:	89 d8                	mov    %ebx,%eax
  803854:	e8 e7 f7 ff ff       	call   803040 <get_socket>
      if (p_sock && p_sock->sendevent) {
  803859:	85 c0                	test   %eax,%eax
  80385b:	74 18                	je     803875 <lwip_selscan+0x103>
  80385d:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  803862:	74 11                	je     803875 <lwip_selscan+0x103>
        FD_SET(i, &lwriteset);
  803864:	b8 01 00 00 00       	mov    $0x1,%eax
  803869:	89 f9                	mov    %edi,%ecx
  80386b:	d3 e0                	shl    %cl,%eax
  80386d:	08 44 35 ec          	or     %al,-0x14(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  803871:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  803875:	83 c3 01             	add    $0x1,%ebx
  803878:	3b 5d dc             	cmp    -0x24(%ebp),%ebx
  80387b:	0f 85 71 ff ff ff    	jne    8037f2 <lwip_selscan+0x80>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  803881:	8b 45 f0             	mov    -0x10(%ebp),%eax
  803884:	8b 55 d8             	mov    -0x28(%ebp),%edx
  803887:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  803889:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80388c:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80388f:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  803891:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803898:	00 
  803899:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8038a0:	00 
  8038a1:	8b 45 08             	mov    0x8(%ebp),%eax
  8038a4:	89 04 24             	mov    %eax,(%esp)
  8038a7:	e8 e2 d8 ff ff       	call   80118e <memset>
  
  return nready;
}
  8038ac:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8038af:	83 c4 2c             	add    $0x2c,%esp
  8038b2:	5b                   	pop    %ebx
  8038b3:	5e                   	pop    %esi
  8038b4:	5f                   	pop    %edi
  8038b5:	5d                   	pop    %ebp
  8038b6:	c3                   	ret    

008038b7 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  8038b7:	55                   	push   %ebp
  8038b8:	89 e5                	mov    %esp,%ebp
  8038ba:	83 ec 48             	sub    $0x48,%esp
  8038bd:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8038c0:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8038c3:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8038c6:	89 55 d0             	mov    %edx,-0x30(%ebp)
  8038c9:	89 ce                	mov    %ecx,%esi
  8038cb:	0f b6 7d 08          	movzbl 0x8(%ebp),%edi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  8038cf:	e8 6c f7 ff ff       	call   803040 <get_socket>
  8038d4:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8038d6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8038db:	85 db                	test   %ebx,%ebx
  8038dd:	0f 84 93 00 00 00    	je     803976 <lwip_getaddrname+0xbf>
    return -1;

  memset(&sin, 0, sizeof(sin));
  8038e3:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  8038ea:	00 
  8038eb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8038f2:	00 
  8038f3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8038f6:	89 04 24             	mov    %eax,(%esp)
  8038f9:	e8 90 d8 ff ff       	call   80118e <memset>
  sin.sin_len = sizeof(sin);
  8038fe:	c6 45 e4 10          	movb   $0x10,-0x1c(%ebp)
  sin.sin_family = AF_INET;
  803902:	c6 45 e5 02          	movb   $0x2,-0x1b(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  803906:	89 fa                	mov    %edi,%edx
  803908:	0f b6 c2             	movzbl %dl,%eax
  80390b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80390f:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  803912:	89 44 24 08          	mov    %eax,0x8(%esp)
  803916:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803919:	89 44 24 04          	mov    %eax,0x4(%esp)
  80391d:	8b 03                	mov    (%ebx),%eax
  80391f:	89 04 24             	mov    %eax,(%esp)
  803922:	e8 1f ab 00 00       	call   80e446 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  803927:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80392b:	89 04 24             	mov    %eax,(%esp)
  80392e:	e8 5c 6f 00 00       	call   80a88f <htons>
  803933:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  803937:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80393a:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if (*namelen > sizeof(sin))
  80393d:	83 3e 10             	cmpl   $0x10,(%esi)
  803940:	76 06                	jbe    803948 <lwip_getaddrname+0x91>
    *namelen = sizeof(sin);
  803942:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  803948:	8b 06                	mov    (%esi),%eax
  80394a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80394e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803951:	89 44 24 04          	mov    %eax,0x4(%esp)
  803955:	8b 45 d0             	mov    -0x30(%ebp),%eax
  803958:	89 04 24             	mov    %eax,(%esp)
  80395b:	e8 08 d9 ff ff       	call   801268 <memcpy>
  sock_set_errno(sock, 0);
  803960:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  803967:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  80396e:	00 00 00 
  803971:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  803976:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  803979:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80397c:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80397f:	89 ec                	mov    %ebp,%esp
  803981:	5d                   	pop    %ebp
  803982:	c3                   	ret    

00803983 <lwip_getsockname>:
  return lwip_getaddrname(s, name, namelen, 0);
}

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  803983:	55                   	push   %ebp
  803984:	89 e5                	mov    %esp,%ebp
  803986:	83 ec 08             	sub    $0x8,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  803989:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803990:	8b 4d 10             	mov    0x10(%ebp),%ecx
  803993:	8b 55 0c             	mov    0xc(%ebp),%edx
  803996:	8b 45 08             	mov    0x8(%ebp),%eax
  803999:	e8 19 ff ff ff       	call   8038b7 <lwip_getaddrname>
}
  80399e:	c9                   	leave  
  80399f:	c3                   	ret    

008039a0 <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  8039a0:	55                   	push   %ebp
  8039a1:	89 e5                	mov    %esp,%ebp
  8039a3:	83 ec 08             	sub    $0x8,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  8039a6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8039ad:	8b 4d 10             	mov    0x10(%ebp),%ecx
  8039b0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8039b3:	8b 45 08             	mov    0x8(%ebp),%eax
  8039b6:	e8 fc fe ff ff       	call   8038b7 <lwip_getaddrname>
}
  8039bb:	c9                   	leave  
  8039bc:	c3                   	ret    

008039bd <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  8039bd:	55                   	push   %ebp
  8039be:	89 e5                	mov    %esp,%ebp
  8039c0:	57                   	push   %edi
  8039c1:	56                   	push   %esi
  8039c2:	53                   	push   %ebx
  8039c3:	83 ec 1c             	sub    $0x1c,%esp
  8039c6:	8b 75 08             	mov    0x8(%ebp),%esi
  8039c9:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  8039cc:	85 f6                	test   %esi,%esi
  8039ce:	0f 84 6f 01 00 00    	je     803b43 <event_callback+0x186>
    s = conn->socket;
  8039d4:	8b 5e 1c             	mov    0x1c(%esi),%ebx
    if (s < 0) {
  8039d7:	85 db                	test   %ebx,%ebx
  8039d9:	79 3d                	jns    803a18 <event_callback+0x5b>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  8039db:	a1 64 86 81 00       	mov    0x818664,%eax
  8039e0:	89 04 24             	mov    %eax,(%esp)
  8039e3:	e8 93 47 00 00       	call   80817b <sys_sem_wait>
      if (conn->socket < 0) {
  8039e8:	8b 46 1c             	mov    0x1c(%esi),%eax
  8039eb:	85 c0                	test   %eax,%eax
  8039ed:	79 1c                	jns    803a0b <event_callback+0x4e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  8039ef:	85 ff                	test   %edi,%edi
  8039f1:	75 06                	jne    8039f9 <event_callback+0x3c>
          conn->socket--;
  8039f3:	83 e8 01             	sub    $0x1,%eax
  8039f6:	89 46 1c             	mov    %eax,0x1c(%esi)
        }
        sys_sem_signal(socksem);
  8039f9:	a1 64 86 81 00       	mov    0x818664,%eax
  8039fe:	89 04 24             	mov    %eax,(%esp)
  803a01:	e8 b4 9d 00 00       	call   80d7ba <sys_sem_signal>
  803a06:	e9 38 01 00 00       	jmp    803b43 <event_callback+0x186>
        return;
      }
      sys_sem_signal(socksem);
  803a0b:	a1 64 86 81 00       	mov    0x818664,%eax
  803a10:	89 04 24             	mov    %eax,(%esp)
  803a13:	e8 a2 9d 00 00       	call   80d7ba <sys_sem_signal>
    }

    sock = get_socket(s);
  803a18:	89 d8                	mov    %ebx,%eax
  803a1a:	e8 21 f6 ff ff       	call   803040 <get_socket>
  803a1f:	89 c6                	mov    %eax,%esi
    if (!sock) {
  803a21:	85 c0                	test   %eax,%eax
  803a23:	0f 84 1a 01 00 00    	je     803b43 <event_callback+0x186>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  803a29:	a1 68 86 81 00       	mov    0x818668,%eax
  803a2e:	89 04 24             	mov    %eax,(%esp)
  803a31:	e8 45 47 00 00       	call   80817b <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  803a36:	83 ff 01             	cmp    $0x1,%edi
  803a39:	74 1e                	je     803a59 <event_callback+0x9c>
  803a3b:	83 ff 01             	cmp    $0x1,%edi
  803a3e:	72 12                	jb     803a52 <event_callback+0x95>
  803a40:	83 ff 02             	cmp    $0x2,%edi
  803a43:	74 1d                	je     803a62 <event_callback+0xa5>
  803a45:	83 ff 03             	cmp    $0x3,%edi
  803a48:	75 28                	jne    803a72 <event_callback+0xb5>
  803a4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  803a50:	eb 18                	jmp    803a6a <event_callback+0xad>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  803a52:	66 83 46 0a 01       	addw   $0x1,0xa(%esi)
  803a57:	eb 35                	jmp    803a8e <event_callback+0xd1>
      break;
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  803a59:	66 83 6e 0a 01       	subw   $0x1,0xa(%esi)
  803a5e:	66 90                	xchg   %ax,%ax
  803a60:	eb 2c                	jmp    803a8e <event_callback+0xd1>
      break;
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  803a62:	66 c7 46 0c 01 00    	movw   $0x1,0xc(%esi)
  803a68:	eb 24                	jmp    803a8e <event_callback+0xd1>
      break;
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  803a6a:	66 c7 46 0c 00 00    	movw   $0x0,0xc(%esi)
  803a70:	eb 1c                	jmp    803a8e <event_callback+0xd1>
      break;
    default:
      LWIP_ASSERT("unknown event", 0);
  803a72:	c7 44 24 08 28 29 81 	movl   $0x812928,0x8(%esp)
  803a79:	00 
  803a7a:	c7 44 24 04 17 04 00 	movl   $0x417,0x4(%esp)
  803a81:	00 
  803a82:	c7 04 24 11 29 81 00 	movl   $0x812911,(%esp)
  803a89:	e8 1e ce ff ff       	call   8008ac <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  803a8e:	a1 68 86 81 00       	mov    0x818668,%eax
  803a93:	89 04 24             	mov    %eax,(%esp)
  803a96:	e8 1f 9d 00 00       	call   80d7ba <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  803a9b:	89 d8                	mov    %ebx,%eax
  803a9d:	c1 f8 1f             	sar    $0x1f,%eax
  803aa0:	c1 e8 1d             	shr    $0x1d,%eax
  803aa3:	01 d8                	add    %ebx,%eax
  803aa5:	c1 f8 03             	sar    $0x3,%eax
  803aa8:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if (sock->rcvevent)
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  803aab:	89 df                	mov    %ebx,%edi
  803aad:	83 e7 07             	and    $0x7,%edi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  803ab0:	a1 68 86 81 00       	mov    0x818668,%eax
  803ab5:	89 04 24             	mov    %eax,(%esp)
  803ab8:	e8 be 46 00 00       	call   80817b <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  803abd:	8b 1d 60 86 81 00    	mov    0x818660,%ebx
  803ac3:	85 db                	test   %ebx,%ebx
  803ac5:	74 6f                	je     803b36 <event_callback+0x179>
      if (scb->sem_signalled == 0) {
  803ac7:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  803acb:	75 3a                	jne    803b07 <event_callback+0x14a>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  803acd:	8b 43 04             	mov    0x4(%ebx),%eax
  803ad0:	85 c0                	test   %eax,%eax
  803ad2:	74 16                	je     803aea <event_callback+0x12d>
  803ad4:	8b 55 f0             	mov    -0x10(%ebp),%edx
  803ad7:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
  803adb:	89 f9                	mov    %edi,%ecx
  803add:	d3 f8                	sar    %cl,%eax
  803adf:	a8 01                	test   $0x1,%al
  803ae1:	74 07                	je     803aea <event_callback+0x12d>
          if (sock->rcvevent)
  803ae3:	66 83 7e 0a 00       	cmpw   $0x0,0xa(%esi)
  803ae8:	75 28                	jne    803b12 <event_callback+0x155>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  803aea:	8b 43 08             	mov    0x8(%ebx),%eax
  803aed:	85 c0                	test   %eax,%eax
  803aef:	74 16                	je     803b07 <event_callback+0x14a>
  803af1:	8b 55 f0             	mov    -0x10(%ebp),%edx
  803af4:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
  803af8:	89 f9                	mov    %edi,%ecx
  803afa:	d3 f8                	sar    %cl,%eax
  803afc:	a8 01                	test   $0x1,%al
  803afe:	74 07                	je     803b07 <event_callback+0x14a>
          if (sock->sendevent)
  803b00:	66 83 7e 0c 00       	cmpw   $0x0,0xc(%esi)
  803b05:	75 0b                	jne    803b12 <event_callback+0x155>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  803b07:	8b 1b                	mov    (%ebx),%ebx
  803b09:	85 db                	test   %ebx,%ebx
  803b0b:	74 29                	je     803b36 <event_callback+0x179>
  803b0d:	8d 76 00             	lea    0x0(%esi),%esi
  803b10:	eb b5                	jmp    803ac7 <event_callback+0x10a>
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
      scb->sem_signalled = 1;
  803b12:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  803b19:	a1 68 86 81 00       	mov    0x818668,%eax
  803b1e:	89 04 24             	mov    %eax,(%esp)
  803b21:	e8 94 9c 00 00       	call   80d7ba <sys_sem_signal>
      sys_sem_signal(scb->sem);
  803b26:	8b 43 14             	mov    0x14(%ebx),%eax
  803b29:	89 04 24             	mov    %eax,(%esp)
  803b2c:	e8 89 9c 00 00       	call   80d7ba <sys_sem_signal>
  803b31:	e9 7a ff ff ff       	jmp    803ab0 <event_callback+0xf3>
    } else {
      sys_sem_signal(selectsem);
  803b36:	a1 68 86 81 00       	mov    0x818668,%eax
  803b3b:	89 04 24             	mov    %eax,(%esp)
  803b3e:	e8 77 9c 00 00       	call   80d7ba <sys_sem_signal>
      break;
    }
  }
}
  803b43:	83 c4 1c             	add    $0x1c,%esp
  803b46:	5b                   	pop    %ebx
  803b47:	5e                   	pop    %esi
  803b48:	5f                   	pop    %edi
  803b49:	5d                   	pop    %ebp
  803b4a:	c3                   	ret    

00803b4b <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  803b4b:	55                   	push   %ebp
  803b4c:	89 e5                	mov    %esp,%ebp
  803b4e:	56                   	push   %esi
  803b4f:	53                   	push   %ebx
  803b50:	83 ec 10             	sub    $0x10,%esp
  803b53:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  803b55:	a1 64 86 81 00       	mov    0x818664,%eax
  803b5a:	89 04 24             	mov    %eax,(%esp)
  803b5d:	e8 19 46 00 00       	call   80817b <sys_sem_wait>
  803b62:	bb 00 00 00 00       	mov    $0x0,%ebx
  803b67:	b8 00 00 00 00       	mov    $0x0,%eax

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
    if (!sockets[i].conn) {
  803b6c:	83 b8 e0 83 81 00 00 	cmpl   $0x0,0x8183e0(%eax)
  803b73:	75 53                	jne    803bc8 <alloc_socket+0x7d>
      sockets[i].conn       = newconn;
  803b75:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  803b78:	c1 e0 02             	shl    $0x2,%eax
  803b7b:	89 b0 e0 83 81 00    	mov    %esi,0x8183e0(%eax)
      sockets[i].lastdata   = NULL;
  803b81:	c7 80 e4 83 81 00 00 	movl   $0x0,0x8183e4(%eax)
  803b88:	00 00 00 
      sockets[i].lastoffset = 0;
  803b8b:	66 c7 80 e8 83 81 00 	movw   $0x0,0x8183e8(%eax)
  803b92:	00 00 
      sockets[i].rcvevent   = 0;
  803b94:	66 c7 80 ea 83 81 00 	movw   $0x0,0x8183ea(%eax)
  803b9b:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  803b9d:	66 c7 80 ec 83 81 00 	movw   $0x1,0x8183ec(%eax)
  803ba4:	01 00 
      sockets[i].flags      = 0;
  803ba6:	66 c7 80 ee 83 81 00 	movw   $0x0,0x8183ee(%eax)
  803bad:	00 00 
      sockets[i].err        = 0;
  803baf:	c7 80 f0 83 81 00 00 	movl   $0x0,0x8183f0(%eax)
  803bb6:	00 00 00 
      sys_sem_signal(socksem);
  803bb9:	a1 64 86 81 00       	mov    0x818664,%eax
  803bbe:	89 04 24             	mov    %eax,(%esp)
  803bc1:	e8 f4 9b 00 00       	call   80d7ba <sys_sem_signal>
  803bc6:	eb 1d                	jmp    803be5 <alloc_socket+0x9a>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  803bc8:	83 c3 01             	add    $0x1,%ebx
  803bcb:	83 c0 14             	add    $0x14,%eax
  803bce:	83 fb 20             	cmp    $0x20,%ebx
  803bd1:	75 99                	jne    803b6c <alloc_socket+0x21>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  803bd3:	a1 64 86 81 00       	mov    0x818664,%eax
  803bd8:	89 04 24             	mov    %eax,(%esp)
  803bdb:	e8 da 9b 00 00       	call   80d7ba <sys_sem_signal>
  803be0:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return -1;
}
  803be5:	89 d8                	mov    %ebx,%eax
  803be7:	83 c4 10             	add    $0x10,%esp
  803bea:	5b                   	pop    %ebx
  803beb:	5e                   	pop    %esi
  803bec:	5d                   	pop    %ebp
  803bed:	c3                   	ret    

00803bee <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  803bee:	55                   	push   %ebp
  803bef:	89 e5                	mov    %esp,%ebp
  803bf1:	83 ec 08             	sub    $0x8,%esp
  socksem   = sys_sem_new(1);
  803bf4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803bfb:	e8 16 9a 00 00       	call   80d616 <sys_sem_new>
  803c00:	a3 64 86 81 00       	mov    %eax,0x818664
  selectsem = sys_sem_new(1);
  803c05:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803c0c:	e8 05 9a 00 00       	call   80d616 <sys_sem_new>
  803c11:	a3 68 86 81 00       	mov    %eax,0x818668
}
  803c16:	c9                   	leave  
  803c17:	c3                   	ret    

00803c18 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  803c18:	55                   	push   %ebp
  803c19:	89 e5                	mov    %esp,%ebp
  803c1b:	57                   	push   %edi
  803c1c:	56                   	push   %esi
  803c1d:	53                   	push   %ebx
  803c1e:	83 ec 4c             	sub    $0x4c,%esp
  803c21:	8b 75 0c             	mov    0xc(%ebp),%esi
  803c24:	8b 7d 10             	mov    0x10(%ebp),%edi

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  803c27:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  select_cb.readset = readset;
  803c2e:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  select_cb.writeset = writeset;
  803c31:	89 7d d8             	mov    %edi,-0x28(%ebp)
  select_cb.exceptset = exceptset;
  803c34:	8b 45 14             	mov    0x14(%ebp),%eax
  803c37:	89 45 dc             	mov    %eax,-0x24(%ebp)
  select_cb.sem_signalled = 0;
  803c3a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  803c41:	a1 68 86 81 00       	mov    0x818668,%eax
  803c46:	89 04 24             	mov    %eax,(%esp)
  803c49:	e8 2d 45 00 00       	call   80817b <sys_sem_wait>

  if (readset)
  803c4e:	85 f6                	test   %esi,%esi
  803c50:	74 1d                	je     803c6f <lwip_select+0x57>
    lreadset = *readset;
  803c52:	0f b6 56 02          	movzbl 0x2(%esi),%edx
  803c56:	0f b6 4e 01          	movzbl 0x1(%esi),%ecx
  803c5a:	0f b6 1e             	movzbl (%esi),%ebx
  803c5d:	0f b6 46 03          	movzbl 0x3(%esi),%eax
  803c61:	88 45 f3             	mov    %al,-0xd(%ebp)
  803c64:	88 55 f2             	mov    %dl,-0xe(%ebp)
  803c67:	88 4d f1             	mov    %cl,-0xf(%ebp)
  803c6a:	88 5d f0             	mov    %bl,-0x10(%ebp)
  803c6d:	eb 1b                	jmp    803c8a <lwip_select+0x72>
  else
    FD_ZERO(&lreadset);
  803c6f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803c76:	00 
  803c77:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803c7e:	00 
  803c7f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  803c82:	89 04 24             	mov    %eax,(%esp)
  803c85:	e8 04 d5 ff ff       	call   80118e <memset>
  if (writeset)
  803c8a:	85 ff                	test   %edi,%edi
  803c8c:	74 1d                	je     803cab <lwip_select+0x93>
    lwriteset = *writeset;
  803c8e:	0f b6 57 02          	movzbl 0x2(%edi),%edx
  803c92:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
  803c96:	0f b6 1f             	movzbl (%edi),%ebx
  803c99:	0f b6 47 03          	movzbl 0x3(%edi),%eax
  803c9d:	88 45 ef             	mov    %al,-0x11(%ebp)
  803ca0:	88 55 ee             	mov    %dl,-0x12(%ebp)
  803ca3:	88 4d ed             	mov    %cl,-0x13(%ebp)
  803ca6:	88 5d ec             	mov    %bl,-0x14(%ebp)
  803ca9:	eb 1b                	jmp    803cc6 <lwip_select+0xae>
  else
    FD_ZERO(&lwriteset);
  803cab:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803cb2:	00 
  803cb3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803cba:	00 
  803cbb:	8d 45 ec             	lea    -0x14(%ebp),%eax
  803cbe:	89 04 24             	mov    %eax,(%esp)
  803cc1:	e8 c8 d4 ff ff       	call   80118e <memset>
  if (exceptset)
  803cc6:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  803cca:	74 22                	je     803cee <lwip_select+0xd6>
    lexceptset = *exceptset;
  803ccc:	8b 4d 14             	mov    0x14(%ebp),%ecx
  803ccf:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
  803cd3:	89 c8                	mov    %ecx,%eax
  803cd5:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
  803cd9:	0f b6 18             	movzbl (%eax),%ebx
  803cdc:	0f b6 40 03          	movzbl 0x3(%eax),%eax
  803ce0:	88 45 eb             	mov    %al,-0x15(%ebp)
  803ce3:	88 55 ea             	mov    %dl,-0x16(%ebp)
  803ce6:	88 4d e9             	mov    %cl,-0x17(%ebp)
  803ce9:	88 5d e8             	mov    %bl,-0x18(%ebp)
  803cec:	eb 1b                	jmp    803d09 <lwip_select+0xf1>
  else
    FD_ZERO(&lexceptset);
  803cee:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803cf5:	00 
  803cf6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803cfd:	00 
  803cfe:	8d 45 e8             	lea    -0x18(%ebp),%eax
  803d01:	89 04 24             	mov    %eax,(%esp)
  803d04:	e8 85 d4 ff ff       	call   80118e <memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  803d09:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  803d0c:	8d 55 f0             	lea    -0x10(%ebp),%edx
  803d0f:	8d 45 e8             	lea    -0x18(%ebp),%eax
  803d12:	89 04 24             	mov    %eax,(%esp)
  803d15:	8b 45 08             	mov    0x8(%ebp),%eax
  803d18:	e8 55 fa ff ff       	call   803772 <lwip_selscan>
  803d1d:	89 c3                	mov    %eax,%ebx

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  803d1f:	85 c0                	test   %eax,%eax
  803d21:	0f 85 80 02 00 00    	jne    803fa7 <lwip_select+0x38f>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  803d27:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  803d2b:	0f 84 8b 00 00 00    	je     803dbc <lwip_select+0x1a4>
  803d31:	8b 55 18             	mov    0x18(%ebp),%edx
  803d34:	83 3a 00             	cmpl   $0x0,(%edx)
  803d37:	0f 85 a3 02 00 00    	jne    803fe0 <lwip_select+0x3c8>
  803d3d:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
  803d41:	0f 85 99 02 00 00    	jne    803fe0 <lwip_select+0x3c8>
      sys_sem_signal(selectsem);
  803d47:	a1 68 86 81 00       	mov    0x818668,%eax
  803d4c:	89 04 24             	mov    %eax,(%esp)
  803d4f:	e8 66 9a 00 00       	call   80d7ba <sys_sem_signal>
      if (readset)
  803d54:	85 f6                	test   %esi,%esi
  803d56:	74 18                	je     803d70 <lwip_select+0x158>
        FD_ZERO(readset);
  803d58:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803d5f:	00 
  803d60:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803d67:	00 
  803d68:	89 34 24             	mov    %esi,(%esp)
  803d6b:	e8 1e d4 ff ff       	call   80118e <memset>
      if (writeset)
  803d70:	85 ff                	test   %edi,%edi
  803d72:	74 18                	je     803d8c <lwip_select+0x174>
        FD_ZERO(writeset);
  803d74:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803d7b:	00 
  803d7c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803d83:	00 
  803d84:	89 3c 24             	mov    %edi,(%esp)
  803d87:	e8 02 d4 ff ff       	call   80118e <memset>
      if (exceptset)
  803d8c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  803d90:	74 1b                	je     803dad <lwip_select+0x195>
        FD_ZERO(exceptset);
  803d92:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803d99:	00 
  803d9a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803da1:	00 
  803da2:	8b 4d 14             	mov    0x14(%ebp),%ecx
  803da5:	89 0c 24             	mov    %ecx,(%esp)
  803da8:	e8 e1 d3 ff ff       	call   80118e <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  803dad:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  803db4:	00 00 00 
  803db7:	e9 8c 02 00 00       	jmp    804048 <lwip_select+0x430>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  803dbc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803dc3:	e8 4e 98 00 00       	call   80d616 <sys_sem_new>
  803dc8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  803dcb:	a1 60 86 81 00       	mov    0x818660,%eax
  803dd0:	89 45 d0             	mov    %eax,-0x30(%ebp)
    select_cb_list = &select_cb;
  803dd3:	8d 45 d0             	lea    -0x30(%ebp),%eax
  803dd6:	a3 60 86 81 00       	mov    %eax,0x818660
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  803ddb:	a1 68 86 81 00       	mov    0x818668,%eax
  803de0:	89 04 24             	mov    %eax,(%esp)
  803de3:	e8 d2 99 00 00       	call   80d7ba <sys_sem_signal>
  803de8:	b9 00 00 00 00       	mov    $0x0,%ecx
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  803ded:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  803df1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803df4:	89 04 24             	mov    %eax,(%esp)
  803df7:	e8 0c 44 00 00       	call   808208 <sys_sem_wait_timeout>
  803dfc:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  803dff:	a1 68 86 81 00       	mov    0x818668,%eax
  803e04:	89 04 24             	mov    %eax,(%esp)
  803e07:	e8 6f 43 00 00       	call   80817b <sys_sem_wait>
    if (select_cb_list == &select_cb)
  803e0c:	8b 0d 60 86 81 00    	mov    0x818660,%ecx
  803e12:	8d 45 d0             	lea    -0x30(%ebp),%eax
  803e15:	39 c8                	cmp    %ecx,%eax
  803e17:	75 26                	jne    803e3f <lwip_select+0x227>
      select_cb_list = select_cb.next;
  803e19:	8b 45 d0             	mov    -0x30(%ebp),%eax
  803e1c:	a3 60 86 81 00       	mov    %eax,0x818660
  803e21:	eb 2b                	jmp    803e4e <lwip_select+0x236>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  803e23:	8b 02                	mov    (%edx),%eax
  803e25:	39 c8                	cmp    %ecx,%eax
  803e27:	74 0f                	je     803e38 <lwip_select+0x220>
  803e29:	89 c2                	mov    %eax,%edx
  803e2b:	eb 03                	jmp    803e30 <lwip_select+0x218>
  803e2d:	8d 4d d0             	lea    -0x30(%ebp),%ecx
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  803e30:	85 d2                	test   %edx,%edx
  803e32:	75 ef                	jne    803e23 <lwip_select+0x20b>
  803e34:	eb 18                	jmp    803e4e <lwip_select+0x236>
  803e36:	89 ca                	mov    %ecx,%edx
        if (p_selcb->next == &select_cb) {
          p_selcb->next = select_cb.next;
  803e38:	8b 45 d0             	mov    -0x30(%ebp),%eax
  803e3b:	89 02                	mov    %eax,(%edx)
  803e3d:	eb 0f                	jmp    803e4e <lwip_select+0x236>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  803e3f:	85 c9                	test   %ecx,%ecx
  803e41:	74 0b                	je     803e4e <lwip_select+0x236>
        if (p_selcb->next == &select_cb) {
  803e43:	8b 11                	mov    (%ecx),%edx
  803e45:	8d 45 d0             	lea    -0x30(%ebp),%eax
  803e48:	39 c2                	cmp    %eax,%edx
  803e4a:	75 e1                	jne    803e2d <lwip_select+0x215>
  803e4c:	eb e8                	jmp    803e36 <lwip_select+0x21e>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  803e4e:	a1 68 86 81 00       	mov    0x818668,%eax
  803e53:	89 04 24             	mov    %eax,(%esp)
  803e56:	e8 5f 99 00 00       	call   80d7ba <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  803e5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803e5e:	89 04 24             	mov    %eax,(%esp)
  803e61:	e8 1a 93 00 00       	call   80d180 <sys_sem_free>
    if (i == 0)  {
  803e66:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  803e6a:	75 68                	jne    803ed4 <lwip_select+0x2bc>
      /* Timeout */
      if (readset)
  803e6c:	85 f6                	test   %esi,%esi
  803e6e:	74 18                	je     803e88 <lwip_select+0x270>
        FD_ZERO(readset);
  803e70:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803e77:	00 
  803e78:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e7f:	00 
  803e80:	89 34 24             	mov    %esi,(%esp)
  803e83:	e8 06 d3 ff ff       	call   80118e <memset>
      if (writeset)
  803e88:	85 ff                	test   %edi,%edi
  803e8a:	74 18                	je     803ea4 <lwip_select+0x28c>
        FD_ZERO(writeset);
  803e8c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803e93:	00 
  803e94:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e9b:	00 
  803e9c:	89 3c 24             	mov    %edi,(%esp)
  803e9f:	e8 ea d2 ff ff       	call   80118e <memset>
      if (exceptset)
  803ea4:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  803ea8:	74 1b                	je     803ec5 <lwip_select+0x2ad>
        FD_ZERO(exceptset);
  803eaa:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803eb1:	00 
  803eb2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803eb9:	00 
  803eba:	8b 45 14             	mov    0x14(%ebp),%eax
  803ebd:	89 04 24             	mov    %eax,(%esp)
  803ec0:	e8 c9 d2 ff ff       	call   80118e <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  803ec5:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  803ecc:	00 00 00 
  803ecf:	e9 74 01 00 00       	jmp    804048 <lwip_select+0x430>
  
      return 0;
    }
    
    if (readset)
  803ed4:	85 f6                	test   %esi,%esi
  803ed6:	74 1d                	je     803ef5 <lwip_select+0x2dd>
      lreadset = *readset;
  803ed8:	0f b6 56 02          	movzbl 0x2(%esi),%edx
  803edc:	0f b6 4e 01          	movzbl 0x1(%esi),%ecx
  803ee0:	0f b6 1e             	movzbl (%esi),%ebx
  803ee3:	0f b6 46 03          	movzbl 0x3(%esi),%eax
  803ee7:	88 45 f3             	mov    %al,-0xd(%ebp)
  803eea:	88 55 f2             	mov    %dl,-0xe(%ebp)
  803eed:	88 4d f1             	mov    %cl,-0xf(%ebp)
  803ef0:	88 5d f0             	mov    %bl,-0x10(%ebp)
  803ef3:	eb 1b                	jmp    803f10 <lwip_select+0x2f8>
    else
      FD_ZERO(&lreadset);
  803ef5:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803efc:	00 
  803efd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803f04:	00 
  803f05:	8d 45 f0             	lea    -0x10(%ebp),%eax
  803f08:	89 04 24             	mov    %eax,(%esp)
  803f0b:	e8 7e d2 ff ff       	call   80118e <memset>
    if (writeset)
  803f10:	85 ff                	test   %edi,%edi
  803f12:	74 1d                	je     803f31 <lwip_select+0x319>
      lwriteset = *writeset;
  803f14:	0f b6 57 02          	movzbl 0x2(%edi),%edx
  803f18:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
  803f1c:	0f b6 1f             	movzbl (%edi),%ebx
  803f1f:	0f b6 47 03          	movzbl 0x3(%edi),%eax
  803f23:	88 45 ef             	mov    %al,-0x11(%ebp)
  803f26:	88 55 ee             	mov    %dl,-0x12(%ebp)
  803f29:	88 4d ed             	mov    %cl,-0x13(%ebp)
  803f2c:	88 5d ec             	mov    %bl,-0x14(%ebp)
  803f2f:	eb 1b                	jmp    803f4c <lwip_select+0x334>
    else
      FD_ZERO(&lwriteset);
  803f31:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803f38:	00 
  803f39:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803f40:	00 
  803f41:	8d 45 ec             	lea    -0x14(%ebp),%eax
  803f44:	89 04 24             	mov    %eax,(%esp)
  803f47:	e8 42 d2 ff ff       	call   80118e <memset>
    if (exceptset)
  803f4c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  803f50:	74 22                	je     803f74 <lwip_select+0x35c>
      lexceptset = *exceptset;
  803f52:	8b 4d 14             	mov    0x14(%ebp),%ecx
  803f55:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
  803f59:	89 c8                	mov    %ecx,%eax
  803f5b:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
  803f5f:	0f b6 18             	movzbl (%eax),%ebx
  803f62:	0f b6 40 03          	movzbl 0x3(%eax),%eax
  803f66:	88 45 eb             	mov    %al,-0x15(%ebp)
  803f69:	88 55 ea             	mov    %dl,-0x16(%ebp)
  803f6c:	88 4d e9             	mov    %cl,-0x17(%ebp)
  803f6f:	88 5d e8             	mov    %bl,-0x18(%ebp)
  803f72:	eb 1b                	jmp    803f8f <lwip_select+0x377>
    else
      FD_ZERO(&lexceptset);
  803f74:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803f7b:	00 
  803f7c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803f83:	00 
  803f84:	8d 45 e8             	lea    -0x18(%ebp),%eax
  803f87:	89 04 24             	mov    %eax,(%esp)
  803f8a:	e8 ff d1 ff ff       	call   80118e <memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  803f8f:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  803f92:	8d 55 f0             	lea    -0x10(%ebp),%edx
  803f95:	8d 45 e8             	lea    -0x18(%ebp),%eax
  803f98:	89 04 24             	mov    %eax,(%esp)
  803f9b:	8b 45 08             	mov    0x8(%ebp),%eax
  803f9e:	e8 cf f7 ff ff       	call   803772 <lwip_selscan>
  803fa3:	89 c3                	mov    %eax,%ebx
  803fa5:	eb 0d                	jmp    803fb4 <lwip_select+0x39c>
  } else
    sys_sem_signal(selectsem);
  803fa7:	a1 68 86 81 00       	mov    0x818668,%eax
  803fac:	89 04 24             	mov    %eax,(%esp)
  803faf:	e8 06 98 00 00       	call   80d7ba <sys_sem_signal>
  
  if (readset)
  803fb4:	85 f6                	test   %esi,%esi
  803fb6:	74 05                	je     803fbd <lwip_select+0x3a5>
    *readset = lreadset;
  803fb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  803fbb:	89 06                	mov    %eax,(%esi)
  if (writeset)
  803fbd:	85 ff                	test   %edi,%edi
  803fbf:	74 05                	je     803fc6 <lwip_select+0x3ae>
    *writeset = lwriteset;
  803fc1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  803fc4:	89 07                	mov    %eax,(%edi)
  if (exceptset)
  803fc6:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  803fca:	74 08                	je     803fd4 <lwip_select+0x3bc>
    *exceptset = lexceptset;
  803fcc:	8b 45 e8             	mov    -0x18(%ebp),%eax
  803fcf:	8b 55 14             	mov    0x14(%ebp),%edx
  803fd2:	89 02                	mov    %eax,(%edx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  803fd4:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  803fdb:	00 00 00 
  803fde:	eb 68                	jmp    804048 <lwip_select+0x430>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  803fe0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803fe7:	e8 2a 96 00 00       	call   80d616 <sys_sem_new>
  803fec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  803fef:	a1 60 86 81 00       	mov    0x818660,%eax
  803ff4:	89 45 d0             	mov    %eax,-0x30(%ebp)
    select_cb_list = &select_cb;
  803ff7:	8d 45 d0             	lea    -0x30(%ebp),%eax
  803ffa:	a3 60 86 81 00       	mov    %eax,0x818660
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  803fff:	a1 68 86 81 00       	mov    0x818668,%eax
  804004:	89 04 24             	mov    %eax,(%esp)
  804007:	e8 ae 97 00 00       	call   80d7ba <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  80400c:	8b 45 18             	mov    0x18(%ebp),%eax
  80400f:	8b 48 04             	mov    0x4(%eax),%ecx
  804012:	81 c1 f4 01 00 00    	add    $0x1f4,%ecx
  804018:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80401d:	89 c8                	mov    %ecx,%eax
  80401f:	f7 ea                	imul   %edx
  804021:	c1 fa 06             	sar    $0x6,%edx
  804024:	89 c8                	mov    %ecx,%eax
  804026:	c1 f8 1f             	sar    $0x1f,%eax
  804029:	29 c2                	sub    %eax,%edx
  80402b:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80402e:	69 01 e8 03 00 00    	imul   $0x3e8,(%ecx),%eax
      if(msectimeout == 0)
  804034:	b9 01 00 00 00       	mov    $0x1,%ecx
  804039:	01 d0                	add    %edx,%eax
  80403b:	0f 84 ac fd ff ff    	je     803ded <lwip_select+0x1d5>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  804041:	89 c1                	mov    %eax,%ecx
  804043:	e9 a5 fd ff ff       	jmp    803ded <lwip_select+0x1d5>
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  
  return nready;
}
  804048:	89 d8                	mov    %ebx,%eax
  80404a:	83 c4 4c             	add    $0x4c,%esp
  80404d:	5b                   	pop    %ebx
  80404e:	5e                   	pop    %esi
  80404f:	5f                   	pop    %edi
  804050:	5d                   	pop    %ebp
  804051:	c3                   	ret    

00804052 <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  804052:	55                   	push   %ebp
  804053:	89 e5                	mov    %esp,%ebp
  804055:	56                   	push   %esi
  804056:	53                   	push   %ebx
  804057:	83 ec 10             	sub    $0x10,%esp
  80405a:	8b 45 0c             	mov    0xc(%ebp),%eax
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  80405d:	83 f8 02             	cmp    $0x2,%eax
  804060:	74 30                	je     804092 <lwip_socket+0x40>
  804062:	83 f8 03             	cmp    $0x3,%eax
  804065:	74 0b                	je     804072 <lwip_socket+0x20>
  804067:	83 f8 01             	cmp    $0x1,%eax
  80406a:	75 72                	jne    8040de <lwip_socket+0x8c>
  80406c:	8d 74 26 00          	lea    0x0(%esi),%esi
  804070:	eb 4c                	jmp    8040be <lwip_socket+0x6c>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  804072:	c7 44 24 08 bd 39 80 	movl   $0x8039bd,0x8(%esp)
  804079:	00 
  80407a:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  80407e:	89 44 24 04          	mov    %eax,0x4(%esp)
  804082:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  804089:	e8 c7 a6 00 00       	call   80e755 <netconn_new_with_proto_and_callback>
  80408e:	89 c3                	mov    %eax,%ebx
  804090:	eb 5d                	jmp    8040ef <lwip_socket+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  804092:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  804099:	0f 94 c0             	sete   %al
  80409c:	0f b6 c0             	movzbl %al,%eax
  80409f:	83 c0 20             	add    $0x20,%eax
  8040a2:	c7 44 24 08 bd 39 80 	movl   $0x8039bd,0x8(%esp)
  8040a9:	00 
  8040aa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8040b1:	00 
  8040b2:	89 04 24             	mov    %eax,(%esp)
  8040b5:	e8 9b a6 00 00       	call   80e755 <netconn_new_with_proto_and_callback>
  8040ba:	89 c3                	mov    %eax,%ebx
  8040bc:	eb 31                	jmp    8040ef <lwip_socket+0x9d>
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8040be:	c7 44 24 08 bd 39 80 	movl   $0x8039bd,0x8(%esp)
  8040c5:	00 
  8040c6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8040cd:	00 
  8040ce:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  8040d5:	e8 7b a6 00 00       	call   80e755 <netconn_new_with_proto_and_callback>
  8040da:	89 c3                	mov    %eax,%ebx
  8040dc:	eb 11                	jmp    8040ef <lwip_socket+0x9d>
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  8040de:	c7 05 60 e5 b3 00 16 	movl   $0x16,0xb3e560
  8040e5:	00 00 00 
  8040e8:	be ff ff ff ff       	mov    $0xffffffff,%esi
  8040ed:	eb 44                	jmp    804133 <lwip_socket+0xe1>
    return -1;
  }

  if (!conn) {
  8040ef:	85 db                	test   %ebx,%ebx
  8040f1:	75 11                	jne    804104 <lwip_socket+0xb2>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  8040f3:	c7 05 60 e5 b3 00 69 	movl   $0x69,0xb3e560
  8040fa:	00 00 00 
  8040fd:	be ff ff ff ff       	mov    $0xffffffff,%esi
  804102:	eb 2f                	jmp    804133 <lwip_socket+0xe1>
    return -1;
  }

  i = alloc_socket(conn);
  804104:	89 d8                	mov    %ebx,%eax
  804106:	e8 40 fa ff ff       	call   803b4b <alloc_socket>
  80410b:	89 c6                	mov    %eax,%esi

  if (i == -1) {
  80410d:	83 f8 ff             	cmp    $0xffffffff,%eax
  804110:	75 14                	jne    804126 <lwip_socket+0xd4>
    netconn_delete(conn);
  804112:	89 1c 24             	mov    %ebx,(%esp)
  804115:	e8 fe a5 00 00       	call   80e718 <netconn_delete>
    set_errno(ENFILE);
  80411a:	c7 05 60 e5 b3 00 17 	movl   $0x17,0xb3e560
  804121:	00 00 00 
  804124:	eb 0d                	jmp    804133 <lwip_socket+0xe1>
    return -1;
  }
  conn->socket = i;
  804126:	89 43 1c             	mov    %eax,0x1c(%ebx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  804129:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  804130:	00 00 00 
  return i;
}
  804133:	89 f0                	mov    %esi,%eax
  804135:	83 c4 10             	add    $0x10,%esp
  804138:	5b                   	pop    %ebx
  804139:	5e                   	pop    %esi
  80413a:	5d                   	pop    %ebp
  80413b:	c3                   	ret    

0080413c <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  80413c:	55                   	push   %ebp
  80413d:	89 e5                	mov    %esp,%ebp
  80413f:	83 ec 28             	sub    $0x28,%esp
  804142:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  804145:	89 75 f8             	mov    %esi,-0x8(%ebp)
  804148:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80414b:	8b 7d 08             	mov    0x8(%ebp),%edi
  80414e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  804151:	89 f8                	mov    %edi,%eax
  804153:	e8 e8 ee ff ff       	call   803040 <get_socket>
  804158:	89 c6                	mov    %eax,%esi
  if (!sock)
  80415a:	85 c0                	test   %eax,%eax
  80415c:	75 0a                	jne    804168 <lwip_send+0x2c>
  80415e:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  804163:	e9 87 00 00 00       	jmp    8041ef <lwip_send+0xb3>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  804168:	8b 10                	mov    (%eax),%edx
  80416a:	83 3a 10             	cmpl   $0x10,(%edx)
  80416d:	74 2e                	je     80419d <lwip_send+0x61>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  80416f:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  804176:	00 
  804177:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80417e:	00 
  80417f:	8b 45 14             	mov    0x14(%ebp),%eax
  804182:	89 44 24 0c          	mov    %eax,0xc(%esp)
  804186:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80418a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80418d:	89 44 24 04          	mov    %eax,0x4(%esp)
  804191:	89 3c 24             	mov    %edi,(%esp)
  804194:	e8 8e 00 00 00       	call   804227 <lwip_sendto>
  804199:	89 c3                	mov    %eax,%ebx
  80419b:	eb 52                	jmp    8041ef <lwip_send+0xb3>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  80419d:	8b 45 14             	mov    0x14(%ebp),%eax
  8041a0:	83 e0 10             	and    $0x10,%eax
  8041a3:	83 f8 01             	cmp    $0x1,%eax
  8041a6:	19 c0                	sbb    %eax,%eax
  8041a8:	83 e0 fe             	and    $0xfffffffe,%eax
  8041ab:	83 c0 03             	add    $0x3,%eax
  8041ae:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8041b2:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8041b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  8041b9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8041bd:	89 14 24             	mov    %edx,(%esp)
  8041c0:	e8 41 a0 00 00       	call   80e206 <netconn_write>
  8041c5:	89 c1                	mov    %eax,%ecx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  8041c7:	0f be c0             	movsbl %al,%eax
  8041ca:	f7 d8                	neg    %eax
  8041cc:	ba 05 00 00 00       	mov    $0x5,%edx
  8041d1:	83 f8 0e             	cmp    $0xe,%eax
  8041d4:	77 07                	ja     8041dd <lwip_send+0xa1>
  8041d6:	8b 14 85 e0 29 81 00 	mov    0x8129e0(,%eax,4),%edx
  8041dd:	89 56 10             	mov    %edx,0x10(%esi)
  8041e0:	89 15 60 e5 b3 00    	mov    %edx,0xb3e560
  return (err==ERR_OK?size:-1);
  8041e6:	80 f9 01             	cmp    $0x1,%cl
  8041e9:	19 c0                	sbb    %eax,%eax
  8041eb:	f7 d0                	not    %eax
  8041ed:	09 c3                	or     %eax,%ebx
}
  8041ef:	89 d8                	mov    %ebx,%eax
  8041f1:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8041f4:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8041f7:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8041fa:	89 ec                	mov    %ebp,%esp
  8041fc:	5d                   	pop    %ebp
  8041fd:	c3                   	ret    

008041fe <lwip_write>:
  return i;
}

int
lwip_write(int s, const void *data, int size)
{
  8041fe:	55                   	push   %ebp
  8041ff:	89 e5                	mov    %esp,%ebp
  804201:	83 ec 18             	sub    $0x18,%esp
  return lwip_send(s, data, size, 0);
  804204:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80420b:	00 
  80420c:	8b 45 10             	mov    0x10(%ebp),%eax
  80420f:	89 44 24 08          	mov    %eax,0x8(%esp)
  804213:	8b 45 0c             	mov    0xc(%ebp),%eax
  804216:	89 44 24 04          	mov    %eax,0x4(%esp)
  80421a:	8b 45 08             	mov    0x8(%ebp),%eax
  80421d:	89 04 24             	mov    %eax,(%esp)
  804220:	e8 17 ff ff ff       	call   80413c <lwip_send>
}
  804225:	c9                   	leave  
  804226:	c3                   	ret    

00804227 <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  804227:	55                   	push   %ebp
  804228:	89 e5                	mov    %esp,%ebp
  80422a:	57                   	push   %edi
  80422b:	56                   	push   %esi
  80422c:	53                   	push   %ebx
  80422d:	83 ec 3c             	sub    $0x3c,%esp
  804230:	8b 75 10             	mov    0x10(%ebp),%esi
  804233:	8b 5d 18             	mov    0x18(%ebp),%ebx
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  804236:	8b 45 08             	mov    0x8(%ebp),%eax
  804239:	e8 02 ee ff ff       	call   803040 <get_socket>
  80423e:	89 c7                	mov    %eax,%edi
  if (!sock)
  804240:	85 c0                	test   %eax,%eax
  804242:	75 0a                	jne    80424e <lwip_sendto+0x27>
  804244:	be ff ff ff ff       	mov    $0xffffffff,%esi
  804249:	e9 33 01 00 00       	jmp    804381 <lwip_sendto+0x15a>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  80424e:	8b 00                	mov    (%eax),%eax
  804250:	83 38 10             	cmpl   $0x10,(%eax)
  804253:	75 24                	jne    804279 <lwip_sendto+0x52>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  804255:	8b 45 14             	mov    0x14(%ebp),%eax
  804258:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80425c:	89 74 24 08          	mov    %esi,0x8(%esp)
  804260:	8b 45 0c             	mov    0xc(%ebp),%eax
  804263:	89 44 24 04          	mov    %eax,0x4(%esp)
  804267:	8b 45 08             	mov    0x8(%ebp),%eax
  80426a:	89 04 24             	mov    %eax,(%esp)
  80426d:	e8 ca fe ff ff       	call   80413c <lwip_send>
  804272:	89 c6                	mov    %eax,%esi
  804274:	e9 08 01 00 00       	jmp    804381 <lwip_sendto+0x15a>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  804279:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  80427f:	76 1c                	jbe    80429d <lwip_sendto+0x76>
  804281:	c7 44 24 08 b8 29 81 	movl   $0x8129b8,0x8(%esp)
  804288:	00 
  804289:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
  804290:	00 
  804291:	c7 04 24 11 29 81 00 	movl   $0x812911,(%esp)
  804298:	e8 0f c6 ff ff       	call   8008ac <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  80429d:	85 db                	test   %ebx,%ebx
  80429f:	0f 95 c0             	setne  %al
  8042a2:	75 06                	jne    8042aa <lwip_sendto+0x83>
  8042a4:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8042a8:	74 2a                	je     8042d4 <lwip_sendto+0xad>
  8042aa:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8042ae:	66 90                	xchg   %ax,%ax
  8042b0:	75 06                	jne    8042b8 <lwip_sendto+0x91>
  8042b2:	80 7b 01 02          	cmpb   $0x2,0x1(%ebx)
  8042b6:	74 1c                	je     8042d4 <lwip_sendto+0xad>
  8042b8:	c7 44 24 08 36 29 81 	movl   $0x812936,0x8(%esp)
  8042bf:	00 
  8042c0:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
  8042c7:	00 
  8042c8:	c7 04 24 11 29 81 00 	movl   $0x812911,(%esp)
  8042cf:	e8 d8 c5 ff ff       	call   8008ac <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  8042d4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8042db:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  if (to) {
  8042e2:	84 c0                	test   %al,%al
  8042e4:	74 1e                	je     804304 <lwip_sendto+0xdd>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  8042e6:	8b 43 04             	mov    0x4(%ebx),%eax
  8042e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  8042ec:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  8042f0:	89 04 24             	mov    %eax,(%esp)
  8042f3:	e8 ad 65 00 00       	call   80a8a5 <ntohs>
    buf.addr         = &remote_addr;
  8042f8:	8d 55 f0             	lea    -0x10(%ebp),%edx
  8042fb:	89 55 e8             	mov    %edx,-0x18(%ebp)
    buf.port         = remote_port;
  8042fe:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  804302:	eb 14                	jmp    804318 <lwip_sendto+0xf1>
  } else {
    remote_addr.addr = 0;
  804304:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  80430b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    buf.port         = 0;
  804312:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  804318:	0f b7 c6             	movzwl %si,%eax
  80431b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80431f:	8b 45 0c             	mov    0xc(%ebp),%eax
  804322:	89 44 24 04          	mov    %eax,0x4(%esp)
  804326:	8d 45 e0             	lea    -0x20(%ebp),%eax
  804329:	89 04 24             	mov    %eax,(%esp)
  80432c:	e8 d1 0e 00 00       	call   805202 <netbuf_ref>
  804331:	0f be d8             	movsbl %al,%ebx
  804334:	84 c0                	test   %al,%al
  804336:	75 14                	jne    80434c <lwip_sendto+0x125>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  804338:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80433b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80433f:	8b 07                	mov    (%edi),%eax
  804341:	89 04 24             	mov    %eax,(%esp)
  804344:	e8 3a 9f 00 00       	call   80e283 <netconn_send>
  804349:	0f be d8             	movsbl %al,%ebx
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  80434c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80434f:	85 c0                	test   %eax,%eax
  804351:	74 08                	je     80435b <lwip_sendto+0x134>
    pbuf_free(buf.p);
  804353:	89 04 24             	mov    %eax,(%esp)
  804356:	e8 18 37 00 00       	call   807a73 <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  80435b:	89 da                	mov    %ebx,%edx
  80435d:	f7 da                	neg    %edx
  80435f:	b8 05 00 00 00       	mov    $0x5,%eax
  804364:	83 fa 0e             	cmp    $0xe,%edx
  804367:	77 07                	ja     804370 <lwip_sendto+0x149>
  804369:	8b 04 95 e0 29 81 00 	mov    0x8129e0(,%edx,4),%eax
  804370:	89 47 10             	mov    %eax,0x10(%edi)
  804373:	a3 60 e5 b3 00       	mov    %eax,0xb3e560
  return (err==ERR_OK?size:-1);
  804378:	83 fb 01             	cmp    $0x1,%ebx
  80437b:	19 c0                	sbb    %eax,%eax
  80437d:	f7 d0                	not    %eax
  80437f:	09 c6                	or     %eax,%esi
}
  804381:	89 f0                	mov    %esi,%eax
  804383:	83 c4 3c             	add    $0x3c,%esp
  804386:	5b                   	pop    %ebx
  804387:	5e                   	pop    %esi
  804388:	5f                   	pop    %edi
  804389:	5d                   	pop    %ebp
  80438a:	c3                   	ret    

0080438b <lwip_recvfrom>:
}

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  80438b:	55                   	push   %ebp
  80438c:	89 e5                	mov    %esp,%ebp
  80438e:	57                   	push   %edi
  80438f:	56                   	push   %esi
  804390:	53                   	push   %ebx
  804391:	83 ec 4c             	sub    $0x4c,%esp
  804394:	8b 75 14             	mov    0x14(%ebp),%esi
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  804397:	8b 45 08             	mov    0x8(%ebp),%eax
  80439a:	e8 a1 ec ff ff       	call   803040 <get_socket>
  80439f:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8043a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8043a6:	85 db                	test   %ebx,%ebx
  8043a8:	0f 84 20 02 00 00    	je     8045ce <lwip_recvfrom+0x243>
  8043ae:	66 c7 45 d0 00 00    	movw   $0x0,-0x30(%ebp)
  8043b4:	c6 45 d3 00          	movb   $0x0,-0x2d(%ebp)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8043b8:	89 f0                	mov    %esi,%eax
  8043ba:	83 e0 08             	and    $0x8,%eax
  8043bd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8043c0:	83 e6 01             	and    $0x1,%esi
  8043c3:	89 75 c0             	mov    %esi,-0x40(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  8043c6:	8b 73 04             	mov    0x4(%ebx),%esi
  8043c9:	85 f6                	test   %esi,%esi
  8043cb:	0f 85 7e 00 00 00    	jne    80444f <lwip_recvfrom+0xc4>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8043d1:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  8043d5:	75 06                	jne    8043dd <lwip_recvfrom+0x52>
  8043d7:	f6 43 0f 08          	testb  $0x8,0xf(%ebx)
  8043db:	74 22                	je     8043ff <lwip_recvfrom+0x74>
  8043dd:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  8043e2:	75 1b                	jne    8043ff <lwip_recvfrom+0x74>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  8043e4:	c7 43 10 0b 00 00 00 	movl   $0xb,0x10(%ebx)
  8043eb:	c7 05 60 e5 b3 00 0b 	movl   $0xb,0xb3e560
  8043f2:	00 00 00 
  8043f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8043fa:	e9 cf 01 00 00       	jmp    8045ce <lwip_recvfrom+0x243>
        return -1;
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  8043ff:	8b 03                	mov    (%ebx),%eax
  804401:	89 04 24             	mov    %eax,(%esp)
  804404:	e8 63 a1 00 00       	call   80e56c <netconn_recv>
  804409:	89 c6                	mov    %eax,%esi
  80440b:	89 43 04             	mov    %eax,0x4(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  80440e:	85 c0                	test   %eax,%eax
  804410:	75 3d                	jne    80444f <lwip_recvfrom+0xc4>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  804412:	8b 03                	mov    (%ebx),%eax
  804414:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  804418:	74 0b                	je     804425 <lwip_recvfrom+0x9a>
  80441a:	ba 6e 00 00 00       	mov    $0x6e,%edx
  80441f:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  804423:	74 17                	je     80443c <lwip_recvfrom+0xb1>
  804425:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  804429:	f7 d8                	neg    %eax
  80442b:	ba 05 00 00 00       	mov    $0x5,%edx
  804430:	83 f8 0e             	cmp    $0xe,%eax
  804433:	77 07                	ja     80443c <lwip_recvfrom+0xb1>
  804435:	8b 14 85 e0 29 81 00 	mov    0x8129e0(,%eax,4),%edx
  80443c:	89 53 10             	mov    %edx,0x10(%ebx)
  80443f:	89 15 60 e5 b3 00    	mov    %edx,0xb3e560
  804445:	b8 00 00 00 00       	mov    $0x0,%eax
  80444a:	e9 7f 01 00 00       	jmp    8045ce <lwip_recvfrom+0x243>
        return 0;
      }
    }

    buflen = netbuf_len(buf);
  80444f:	8b 0e                	mov    (%esi),%ecx
  804451:	0f b7 41 08          	movzwl 0x8(%ecx),%eax
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  804455:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  804459:	66 29 d0             	sub    %dx,%ax

    if (len > buflen) {
  80445c:	0f b7 f8             	movzwl %ax,%edi
  80445f:	89 7d c8             	mov    %edi,-0x38(%ebp)
  804462:	89 c7                	mov    %eax,%edi
  804464:	8b 45 c8             	mov    -0x38(%ebp),%eax
  804467:	39 45 10             	cmp    %eax,0x10(%ebp)
  80446a:	7f 04                	jg     804470 <lwip_recvfrom+0xe5>
      copylen = buflen;
    } else {
      copylen = len;
  80446c:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  804470:	0f b7 c7             	movzwl %di,%eax
  804473:	89 45 cc             	mov    %eax,-0x34(%ebp)
  804476:	0f b7 c2             	movzwl %dx,%eax
  804479:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80447d:	8b 55 cc             	mov    -0x34(%ebp),%edx
  804480:	89 54 24 08          	mov    %edx,0x8(%esp)
  804484:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  804488:	03 45 0c             	add    0xc(%ebp),%eax
  80448b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80448f:	89 0c 24             	mov    %ecx,(%esp)
  804492:	e8 5c 33 00 00       	call   8077f3 <pbuf_copy_partial>

    off += copylen;
  804497:	66 01 7d d0          	add    %di,-0x30(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80449b:	8b 03                	mov    (%ebx),%eax
  80449d:	89 04 24             	mov    %eax,(%esp)
  8044a0:	e8 eb 9c 00 00       	call   80e190 <netconn_type>
  8044a5:	83 f8 10             	cmp    $0x10,%eax
  8044a8:	75 1b                	jne    8044c5 <lwip_recvfrom+0x13a>
      len -= copylen;
  8044aa:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8044ad:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8044b0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8044b4:	7e 0f                	jle    8044c5 <lwip_recvfrom+0x13a>
  8044b6:	8b 06                	mov    (%esi),%eax
  8044b8:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  8044bc:	75 07                	jne    8044c5 <lwip_recvfrom+0x13a>
  8044be:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  8044c3:	75 04                	jne    8044c9 <lwip_recvfrom+0x13e>
  8044c5:	c6 45 d3 01          	movb   $0x1,-0x2d(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8044c9:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  8044cd:	75 39                	jne    804508 <lwip_recvfrom+0x17d>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8044cf:	8b 03                	mov    (%ebx),%eax
  8044d1:	83 38 10             	cmpl   $0x10,(%eax)
  8044d4:	75 13                	jne    8044e9 <lwip_recvfrom+0x15e>
  8044d6:	8b 45 c8             	mov    -0x38(%ebp),%eax
  8044d9:	2b 45 cc             	sub    -0x34(%ebp),%eax
  8044dc:	85 c0                	test   %eax,%eax
  8044de:	7e 09                	jle    8044e9 <lwip_recvfrom+0x15e>
        sock->lastdata = buf;
  8044e0:	89 73 04             	mov    %esi,0x4(%ebx)
        sock->lastoffset += copylen;
  8044e3:	66 01 7b 08          	add    %di,0x8(%ebx)
  8044e7:	eb 15                	jmp    8044fe <lwip_recvfrom+0x173>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
      } else {
        sock->lastdata = NULL;
  8044e9:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
        sock->lastoffset = 0;
  8044f0:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  8044f6:	89 34 24             	mov    %esi,(%esp)
  8044f9:	e8 c5 0c 00 00       	call   8051c3 <netbuf_delete>
      }
    } else {
      done = 1;
    }
  } while (!done);
  8044fe:	80 7d d3 00          	cmpb   $0x0,-0x2d(%ebp)
  804502:	0f 84 be fe ff ff    	je     8043c6 <lwip_recvfrom+0x3b>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  804508:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  80450c:	0f 84 a7 00 00 00    	je     8045b9 <lwip_recvfrom+0x22e>
  804512:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  804516:	0f 84 9d 00 00 00    	je     8045b9 <lwip_recvfrom+0x22e>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80451c:	8b 03                	mov    (%ebx),%eax
  80451e:	89 04 24             	mov    %eax,(%esp)
  804521:	e8 6a 9c 00 00       	call   80e190 <netconn_type>
  804526:	83 f8 10             	cmp    $0x10,%eax
  804529:	75 22                	jne    80454d <lwip_recvfrom+0x1c2>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  80452b:	8d 7d e4             	lea    -0x1c(%ebp),%edi
      netconn_getaddr(sock->conn, addr, &port, 0);
  80452e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804535:	00 
  804536:	8d 45 f2             	lea    -0xe(%ebp),%eax
  804539:	89 44 24 08          	mov    %eax,0x8(%esp)
  80453d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  804541:	8b 03                	mov    (%ebx),%eax
  804543:	89 04 24             	mov    %eax,(%esp)
  804546:	e8 fb 9e 00 00       	call   80e446 <netconn_getaddr>
  80454b:	eb 0b                	jmp    804558 <lwip_recvfrom+0x1cd>
    } else {
      addr = netbuf_fromaddr(buf);
  80454d:	8b 7e 08             	mov    0x8(%esi),%edi
      port = netbuf_fromport(buf);
  804550:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  804554:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  804558:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  80455f:	00 
  804560:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804567:	00 
  804568:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80456b:	89 04 24             	mov    %eax,(%esp)
  80456e:	e8 1b cc ff ff       	call   80118e <memset>
    sin.sin_len = sizeof(sin);
  804573:	c6 45 e0 10          	movb   $0x10,-0x20(%ebp)
    sin.sin_family = AF_INET;
  804577:	c6 45 e1 02          	movb   $0x2,-0x1f(%ebp)
    sin.sin_port = htons(port);
  80457b:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  80457f:	89 04 24             	mov    %eax,(%esp)
  804582:	e8 08 63 00 00       	call   80a88f <htons>
  804587:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  80458b:	8b 07                	mov    (%edi),%eax
  80458d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    if (*fromlen > sizeof(sin))
  804590:	8b 55 1c             	mov    0x1c(%ebp),%edx
  804593:	83 3a 10             	cmpl   $0x10,(%edx)
  804596:	76 06                	jbe    80459e <lwip_recvfrom+0x213>
      *fromlen = sizeof(sin);
  804598:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

    SMEMCPY(from, &sin, *fromlen);
  80459e:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  8045a1:	8b 07                	mov    (%edi),%eax
  8045a3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8045a7:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8045aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  8045ae:	8b 45 18             	mov    0x18(%ebp),%eax
  8045b1:	89 04 24             	mov    %eax,(%esp)
  8045b4:	e8 af cc ff ff       	call   801268 <memcpy>
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  8045b9:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8045c0:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  8045c7:	00 00 00 
  return off;
  8045ca:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
}
  8045ce:	83 c4 4c             	add    $0x4c,%esp
  8045d1:	5b                   	pop    %ebx
  8045d2:	5e                   	pop    %esi
  8045d3:	5f                   	pop    %edi
  8045d4:	5d                   	pop    %ebp
  8045d5:	c3                   	ret    

008045d6 <lwip_recv>:
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
}

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  8045d6:	55                   	push   %ebp
  8045d7:	89 e5                	mov    %esp,%ebp
  8045d9:	83 ec 18             	sub    $0x18,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8045dc:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8045e3:	00 
  8045e4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8045eb:	00 
  8045ec:	8b 45 14             	mov    0x14(%ebp),%eax
  8045ef:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8045f3:	8b 45 10             	mov    0x10(%ebp),%eax
  8045f6:	89 44 24 08          	mov    %eax,0x8(%esp)
  8045fa:	8b 45 0c             	mov    0xc(%ebp),%eax
  8045fd:	89 44 24 04          	mov    %eax,0x4(%esp)
  804601:	8b 45 08             	mov    0x8(%ebp),%eax
  804604:	89 04 24             	mov    %eax,(%esp)
  804607:	e8 7f fd ff ff       	call   80438b <lwip_recvfrom>
}
  80460c:	c9                   	leave  
  80460d:	c3                   	ret    

0080460e <lwip_read>:
  return off;
}

int
lwip_read(int s, void *mem, int len)
{
  80460e:	55                   	push   %ebp
  80460f:	89 e5                	mov    %esp,%ebp
  804611:	83 ec 18             	sub    $0x18,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  804614:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80461b:	00 
  80461c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  804623:	00 
  804624:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80462b:	00 
  80462c:	8b 45 10             	mov    0x10(%ebp),%eax
  80462f:	89 44 24 08          	mov    %eax,0x8(%esp)
  804633:	8b 45 0c             	mov    0xc(%ebp),%eax
  804636:	89 44 24 04          	mov    %eax,0x4(%esp)
  80463a:	8b 45 08             	mov    0x8(%ebp),%eax
  80463d:	89 04 24             	mov    %eax,(%esp)
  804640:	e8 46 fd ff ff       	call   80438b <lwip_recvfrom>
}
  804645:	c9                   	leave  
  804646:	c3                   	ret    

00804647 <lwip_close>:
  return 0;
}

int
lwip_close(int s)
{
  804647:	55                   	push   %ebp
  804648:	89 e5                	mov    %esp,%ebp
  80464a:	53                   	push   %ebx
  80464b:	83 ec 04             	sub    $0x4,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  80464e:	8b 45 08             	mov    0x8(%ebp),%eax
  804651:	e8 ea e9 ff ff       	call   803040 <get_socket>
  804656:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  804658:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80465d:	85 db                	test   %ebx,%ebx
  80465f:	74 5c                	je     8046bd <lwip_close+0x76>
    return -1;
  }

  netconn_delete(sock->conn);
  804661:	8b 03                	mov    (%ebx),%eax
  804663:	89 04 24             	mov    %eax,(%esp)
  804666:	e8 ad a0 00 00       	call   80e718 <netconn_delete>

  sys_sem_wait(socksem);
  80466b:	a1 64 86 81 00       	mov    0x818664,%eax
  804670:	89 04 24             	mov    %eax,(%esp)
  804673:	e8 03 3b 00 00       	call   80817b <sys_sem_wait>
  if (sock->lastdata) {
  804678:	8b 43 04             	mov    0x4(%ebx),%eax
  80467b:	85 c0                	test   %eax,%eax
  80467d:	74 08                	je     804687 <lwip_close+0x40>
    netbuf_delete(sock->lastdata);
  80467f:	89 04 24             	mov    %eax,(%esp)
  804682:	e8 3c 0b 00 00       	call   8051c3 <netbuf_delete>
  }
  sock->lastdata   = NULL;
  804687:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  80468e:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  804694:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  80469a:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8046a1:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  8046a8:	00 00 00 
  sys_sem_signal(socksem);
  8046ab:	a1 64 86 81 00       	mov    0x818664,%eax
  8046b0:	89 04 24             	mov    %eax,(%esp)
  8046b3:	e8 02 91 00 00       	call   80d7ba <sys_sem_signal>
  8046b8:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  8046bd:	83 c4 04             	add    $0x4,%esp
  8046c0:	5b                   	pop    %ebx
  8046c1:	5d                   	pop    %ebp
  8046c2:	c3                   	ret    

008046c3 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  8046c3:	55                   	push   %ebp
  8046c4:	89 e5                	mov    %esp,%ebp
  8046c6:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  8046c9:	8b 45 08             	mov    0x8(%ebp),%eax
  8046cc:	89 04 24             	mov    %eax,(%esp)
  8046cf:	e8 73 ff ff ff       	call   804647 <lwip_close>
}
  8046d4:	c9                   	leave  
  8046d5:	c3                   	ret    

008046d6 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  8046d6:	55                   	push   %ebp
  8046d7:	89 e5                	mov    %esp,%ebp
  8046d9:	53                   	push   %ebx
  8046da:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  8046dd:	8b 45 08             	mov    0x8(%ebp),%eax
  8046e0:	e8 5b e9 ff ff       	call   803040 <get_socket>
  8046e5:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8046e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8046ec:	85 db                	test   %ebx,%ebx
  8046ee:	74 6a                	je     80475a <lwip_listen+0x84>
  8046f0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8046f3:	81 fa ff 00 00 00    	cmp    $0xff,%edx
  8046f9:	7e 05                	jle    804700 <lwip_listen+0x2a>
  8046fb:	ba ff 00 00 00       	mov    $0xff,%edx
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  804700:	89 d0                	mov    %edx,%eax
  804702:	c1 f8 1f             	sar    $0x1f,%eax
  804705:	f7 d0                	not    %eax
  804707:	21 d0                	and    %edx,%eax
  804709:	0f b6 c0             	movzbl %al,%eax
  80470c:	89 44 24 04          	mov    %eax,0x4(%esp)
  804710:	8b 03                	mov    (%ebx),%eax
  804712:	89 04 24             	mov    %eax,(%esp)
  804715:	e8 ec 9b 00 00       	call   80e306 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  80471a:	84 c0                	test   %al,%al
  80471c:	74 26                	je     804744 <lwip_listen+0x6e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80471e:	0f be c0             	movsbl %al,%eax
  804721:	f7 d8                	neg    %eax
  804723:	ba 05 00 00 00       	mov    $0x5,%edx
  804728:	83 f8 0e             	cmp    $0xe,%eax
  80472b:	77 07                	ja     804734 <lwip_listen+0x5e>
  80472d:	8b 14 85 e0 29 81 00 	mov    0x8129e0(,%eax,4),%edx
  804734:	89 53 10             	mov    %edx,0x10(%ebx)
  804737:	89 15 60 e5 b3 00    	mov    %edx,0xb3e560
  80473d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804742:	eb 16                	jmp    80475a <lwip_listen+0x84>
    return -1;
  }

  sock_set_errno(sock, 0);
  804744:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80474b:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  804752:	00 00 00 
  804755:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  80475a:	83 c4 14             	add    $0x14,%esp
  80475d:	5b                   	pop    %ebx
  80475e:	5d                   	pop    %ebp
  80475f:	c3                   	ret    

00804760 <lwip_connect>:
  return 0;
}

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  804760:	55                   	push   %ebp
  804761:	89 e5                	mov    %esp,%ebp
  804763:	53                   	push   %ebx
  804764:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  804767:	8b 45 08             	mov    0x8(%ebp),%eax
  80476a:	e8 d1 e8 ff ff       	call   803040 <get_socket>
  80476f:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804771:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804776:	85 db                	test   %ebx,%ebx
  804778:	0f 84 95 00 00 00    	je     804813 <lwip_connect+0xb3>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80477e:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  804782:	75 09                	jne    80478d <lwip_connect+0x2d>
  804784:	8b 55 0c             	mov    0xc(%ebp),%edx
  804787:	80 7a 01 02          	cmpb   $0x2,0x1(%edx)
  80478b:	74 1c                	je     8047a9 <lwip_connect+0x49>
  80478d:	c7 44 24 08 53 29 81 	movl   $0x812953,0x8(%esp)
  804794:	00 
  804795:	c7 44 24 04 86 01 00 	movl   $0x186,0x4(%esp)
  80479c:	00 
  80479d:	c7 04 24 11 29 81 00 	movl   $0x812911,(%esp)
  8047a4:	e8 03 c1 ff ff       	call   8008ac <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8047a9:	8b 42 04             	mov    0x4(%edx),%eax
  8047ac:	89 45 f8             	mov    %eax,-0x8(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  8047af:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  8047b3:	89 04 24             	mov    %eax,(%esp)
  8047b6:	e8 ea 60 00 00       	call   80a8a5 <ntohs>
  8047bb:	0f b7 c0             	movzwl %ax,%eax
  8047be:	89 44 24 08          	mov    %eax,0x8(%esp)
  8047c2:	8d 45 f8             	lea    -0x8(%ebp),%eax
  8047c5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8047c9:	8b 03                	mov    (%ebx),%eax
  8047cb:	89 04 24             	mov    %eax,(%esp)
  8047ce:	e8 c5 9b 00 00       	call   80e398 <netconn_connect>
  }

  if (err != ERR_OK) {
  8047d3:	84 c0                	test   %al,%al
  8047d5:	74 26                	je     8047fd <lwip_connect+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8047d7:	0f be c0             	movsbl %al,%eax
  8047da:	f7 d8                	neg    %eax
  8047dc:	ba 05 00 00 00       	mov    $0x5,%edx
  8047e1:	83 f8 0e             	cmp    $0xe,%eax
  8047e4:	77 07                	ja     8047ed <lwip_connect+0x8d>
  8047e6:	8b 14 85 e0 29 81 00 	mov    0x8129e0(,%eax,4),%edx
  8047ed:	89 53 10             	mov    %edx,0x10(%ebx)
  8047f0:	89 15 60 e5 b3 00    	mov    %edx,0xb3e560
  8047f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8047fb:	eb 16                	jmp    804813 <lwip_connect+0xb3>
    return -1;
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8047fd:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804804:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  80480b:	00 00 00 
  80480e:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804813:	83 c4 24             	add    $0x24,%esp
  804816:	5b                   	pop    %ebx
  804817:	5d                   	pop    %ebp
  804818:	c3                   	ret    

00804819 <lwip_bind>:
  return newsock;
}

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  804819:	55                   	push   %ebp
  80481a:	89 e5                	mov    %esp,%ebp
  80481c:	53                   	push   %ebx
  80481d:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  804820:	8b 45 08             	mov    0x8(%ebp),%eax
  804823:	e8 18 e8 ff ff       	call   803040 <get_socket>
  804828:	89 c3                	mov    %eax,%ebx
  if (!sock)
  80482a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80482f:	85 db                	test   %ebx,%ebx
  804831:	0f 84 95 00 00 00    	je     8048cc <lwip_bind+0xb3>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  804837:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  80483b:	75 09                	jne    804846 <lwip_bind+0x2d>
  80483d:	8b 55 0c             	mov    0xc(%ebp),%edx
  804840:	80 7a 01 02          	cmpb   $0x2,0x1(%edx)
  804844:	74 1c                	je     804862 <lwip_bind+0x49>
  804846:	c7 44 24 08 71 29 81 	movl   $0x812971,0x8(%esp)
  80484d:	00 
  80484e:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
  804855:	00 
  804856:	c7 04 24 11 29 81 00 	movl   $0x812911,(%esp)
  80485d:	e8 4a c0 ff ff       	call   8008ac <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  804862:	8b 42 04             	mov    0x4(%edx),%eax
  804865:	89 45 f8             	mov    %eax,-0x8(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  804868:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80486c:	89 04 24             	mov    %eax,(%esp)
  80486f:	e8 31 60 00 00       	call   80a8a5 <ntohs>
  804874:	0f b7 c0             	movzwl %ax,%eax
  804877:	89 44 24 08          	mov    %eax,0x8(%esp)
  80487b:	8d 45 f8             	lea    -0x8(%ebp),%eax
  80487e:	89 44 24 04          	mov    %eax,0x4(%esp)
  804882:	8b 03                	mov    (%ebx),%eax
  804884:	89 04 24             	mov    %eax,(%esp)
  804887:	e8 63 9b 00 00       	call   80e3ef <netconn_bind>

  if (err != ERR_OK) {
  80488c:	84 c0                	test   %al,%al
  80488e:	74 26                	je     8048b6 <lwip_bind+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  804890:	0f be c0             	movsbl %al,%eax
  804893:	f7 d8                	neg    %eax
  804895:	ba 05 00 00 00       	mov    $0x5,%edx
  80489a:	83 f8 0e             	cmp    $0xe,%eax
  80489d:	77 07                	ja     8048a6 <lwip_bind+0x8d>
  80489f:	8b 14 85 e0 29 81 00 	mov    0x8129e0(,%eax,4),%edx
  8048a6:	89 53 10             	mov    %edx,0x10(%ebx)
  8048a9:	89 15 60 e5 b3 00    	mov    %edx,0xb3e560
  8048af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8048b4:	eb 16                	jmp    8048cc <lwip_bind+0xb3>
    return -1;
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8048b6:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8048bd:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  8048c4:	00 00 00 
  8048c7:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  8048cc:	83 c4 24             	add    $0x24,%esp
  8048cf:	5b                   	pop    %ebx
  8048d0:	5d                   	pop    %ebp
  8048d1:	c3                   	ret    

008048d2 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8048d2:	55                   	push   %ebp
  8048d3:	89 e5                	mov    %esp,%ebp
  8048d5:	57                   	push   %edi
  8048d6:	56                   	push   %esi
  8048d7:	53                   	push   %ebx
  8048d8:	83 ec 3c             	sub    $0x3c,%esp
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  8048db:	8b 45 08             	mov    0x8(%ebp),%eax
  8048de:	e8 5d e7 ff ff       	call   803040 <get_socket>
  8048e3:	89 c7                	mov    %eax,%edi
  if (!sock)
  8048e5:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  8048ec:	85 c0                	test   %eax,%eax
  8048ee:	0f 84 b3 01 00 00    	je     804aa7 <lwip_accept+0x1d5>
    return -1;

  newconn = netconn_accept(sock->conn);
  8048f4:	8b 00                	mov    (%eax),%eax
  8048f6:	89 04 24             	mov    %eax,(%esp)
  8048f9:	e8 e4 9b 00 00       	call   80e4e2 <netconn_accept>
  8048fe:	89 c6                	mov    %eax,%esi
  if (!newconn) {
  804900:	85 c0                	test   %eax,%eax
  804902:	75 2e                	jne    804932 <lwip_accept+0x60>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  804904:	8b 07                	mov    (%edi),%eax
  804906:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  80490a:	f7 d8                	neg    %eax
  80490c:	ba 05 00 00 00       	mov    $0x5,%edx
  804911:	83 f8 0e             	cmp    $0xe,%eax
  804914:	77 07                	ja     80491d <lwip_accept+0x4b>
  804916:	8b 14 85 e0 29 81 00 	mov    0x8129e0(,%eax,4),%edx
  80491d:	89 57 10             	mov    %edx,0x10(%edi)
  804920:	89 15 60 e5 b3 00    	mov    %edx,0xb3e560
  804926:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  80492d:	e9 75 01 00 00       	jmp    804aa7 <lwip_accept+0x1d5>
    return -1;
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  804932:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804939:	00 
  80493a:	8d 45 ee             	lea    -0x12(%ebp),%eax
  80493d:	89 44 24 08          	mov    %eax,0x8(%esp)
  804941:	8d 45 f0             	lea    -0x10(%ebp),%eax
  804944:	89 44 24 04          	mov    %eax,0x4(%esp)
  804948:	89 34 24             	mov    %esi,(%esp)
  80494b:	e8 f6 9a 00 00       	call   80e446 <netconn_getaddr>
  804950:	89 c3                	mov    %eax,%ebx
  if (err != ERR_OK) {
  804952:	84 c0                	test   %al,%al
  804954:	74 33                	je     804989 <lwip_accept+0xb7>
    netconn_delete(newconn);
  804956:	89 34 24             	mov    %esi,(%esp)
  804959:	e8 ba 9d 00 00       	call   80e718 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  80495e:	0f be c3             	movsbl %bl,%eax
  804961:	f7 d8                	neg    %eax
  804963:	ba 05 00 00 00       	mov    $0x5,%edx
  804968:	83 f8 0e             	cmp    $0xe,%eax
  80496b:	77 07                	ja     804974 <lwip_accept+0xa2>
  80496d:	8b 14 85 e0 29 81 00 	mov    0x8129e0(,%eax,4),%edx
  804974:	89 57 10             	mov    %edx,0x10(%edi)
  804977:	89 15 60 e5 b3 00    	mov    %edx,0xb3e560
  80497d:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  804984:	e9 1e 01 00 00       	jmp    804aa7 <lwip_accept+0x1d5>
    return -1;
  }

  memset(&sin, 0, sizeof(sin));
  804989:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  804990:	00 
  804991:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804998:	00 
  804999:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80499c:	89 04 24             	mov    %eax,(%esp)
  80499f:	e8 ea c7 ff ff       	call   80118e <memset>
  sin.sin_len = sizeof(sin);
  8049a4:	c6 45 dc 10          	movb   $0x10,-0x24(%ebp)
  sin.sin_family = AF_INET;
  8049a8:	c6 45 dd 02          	movb   $0x2,-0x23(%ebp)
  sin.sin_port = htons(port);
  8049ac:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
  8049b0:	89 04 24             	mov    %eax,(%esp)
  8049b3:	e8 d7 5e 00 00       	call   80a88f <htons>
  8049b8:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8049bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8049bf:	89 45 e0             	mov    %eax,-0x20(%ebp)

  if (*addrlen > sizeof(sin))
  8049c2:	8b 45 10             	mov    0x10(%ebp),%eax
  8049c5:	83 38 10             	cmpl   $0x10,(%eax)
  8049c8:	76 06                	jbe    8049d0 <lwip_accept+0xfe>
    *addrlen = sizeof(sin);
  8049ca:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

  SMEMCPY(addr, &sin, *addrlen);
  8049d0:	8b 55 10             	mov    0x10(%ebp),%edx
  8049d3:	8b 02                	mov    (%edx),%eax
  8049d5:	89 44 24 08          	mov    %eax,0x8(%esp)
  8049d9:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8049dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  8049e0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8049e3:	89 04 24             	mov    %eax,(%esp)
  8049e6:	e8 7d c8 ff ff       	call   801268 <memcpy>

  newsock = alloc_socket(newconn);
  8049eb:	89 f0                	mov    %esi,%eax
  8049ed:	e8 59 f1 ff ff       	call   803b4b <alloc_socket>
  8049f2:	89 45 d0             	mov    %eax,-0x30(%ebp)
  if (newsock == -1) {
  8049f5:	83 f8 ff             	cmp    $0xffffffff,%eax
  8049f8:	75 1e                	jne    804a18 <lwip_accept+0x146>
    netconn_delete(newconn);
  8049fa:	89 34 24             	mov    %esi,(%esp)
  8049fd:	e8 16 9d 00 00       	call   80e718 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  804a02:	c7 47 10 17 00 00 00 	movl   $0x17,0x10(%edi)
  804a09:	c7 05 60 e5 b3 00 17 	movl   $0x17,0xb3e560
  804a10:	00 00 00 
  804a13:	e9 8f 00 00 00       	jmp    804aa7 <lwip_accept+0x1d5>
    return -1;
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  804a18:	8b 45 d0             	mov    -0x30(%ebp),%eax
  804a1b:	83 f8 1f             	cmp    $0x1f,%eax
  804a1e:	76 1c                	jbe    804a3c <lwip_accept+0x16a>
  804a20:	c7 44 24 08 8c 29 81 	movl   $0x81298c,0x8(%esp)
  804a27:	00 
  804a28:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  804a2f:	00 
  804a30:	c7 04 24 11 29 81 00 	movl   $0x812911,(%esp)
  804a37:	e8 70 be ff ff       	call   8008ac <_panic>
  newconn->callback = event_callback;
  804a3c:	c7 46 2c bd 39 80 00 	movl   $0x8039bd,0x2c(%esi)
  nsock = &sockets[newsock];
  804a43:	8d 04 80             	lea    (%eax,%eax,4),%eax
  804a46:	8d 1c 85 e0 83 81 00 	lea    0x8183e0(,%eax,4),%ebx
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  804a4d:	85 db                	test   %ebx,%ebx
  804a4f:	75 1c                	jne    804a6d <lwip_accept+0x19b>
  804a51:	c7 44 24 08 a1 29 81 	movl   $0x8129a1,0x8(%esp)
  804a58:	00 
  804a59:	c7 44 24 04 28 01 00 	movl   $0x128,0x4(%esp)
  804a60:	00 
  804a61:	c7 04 24 11 29 81 00 	movl   $0x812911,(%esp)
  804a68:	e8 3f be ff ff       	call   8008ac <_panic>

  sys_sem_wait(socksem);
  804a6d:	a1 64 86 81 00       	mov    0x818664,%eax
  804a72:	89 04 24             	mov    %eax,(%esp)
  804a75:	e8 01 37 00 00       	call   80817b <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  804a7a:	8b 46 1c             	mov    0x1c(%esi),%eax
  804a7d:	f7 d0                	not    %eax
  804a7f:	66 01 43 0a          	add    %ax,0xa(%ebx)
  newconn->socket = newsock;
  804a83:	8b 55 d0             	mov    -0x30(%ebp),%edx
  804a86:	89 56 1c             	mov    %edx,0x1c(%esi)
  sys_sem_signal(socksem);
  804a89:	a1 64 86 81 00       	mov    0x818664,%eax
  804a8e:	89 04 24             	mov    %eax,(%esp)
  804a91:	e8 24 8d 00 00       	call   80d7ba <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  804a96:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  804a9d:	c7 05 60 e5 b3 00 00 	movl   $0x0,0xb3e560
  804aa4:	00 00 00 
  return newsock;
}
  804aa7:	8b 45 d0             	mov    -0x30(%ebp),%eax
  804aaa:	83 c4 3c             	add    $0x3c,%esp
  804aad:	5b                   	pop    %ebx
  804aae:	5e                   	pop    %esi
  804aaf:	5f                   	pop    %edi
  804ab0:	5d                   	pop    %ebp
  804ab1:	c3                   	ret    
	...

00804ac0 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  804ac0:	55                   	push   %ebp
  804ac1:	89 e5                	mov    %esp,%ebp
  804ac3:	83 ec 08             	sub    $0x8,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  804ac6:	8b 45 08             	mov    0x8(%ebp),%eax
  804ac9:	89 04 24             	mov    %eax,(%esp)
  804acc:	e8 a2 2f 00 00       	call   807a73 <pbuf_free>
}
  804ad1:	c9                   	leave  
  804ad2:	c3                   	ret    

00804ad3 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  804ad3:	55                   	push   %ebp
  804ad4:	89 e5                	mov    %esp,%ebp
  804ad6:	83 ec 18             	sub    $0x18,%esp
  lwip_init();
  804ad9:	e8 82 08 00 00       	call   805360 <lwip_init>

  tcpip_init_done = initfunc;
  804ade:	8b 45 08             	mov    0x8(%ebp),%eax
  804ae1:	a3 6c 86 81 00       	mov    %eax,0x81866c
  tcpip_init_done_arg = arg;
  804ae6:	8b 45 0c             	mov    0xc(%ebp),%eax
  804ae9:	a3 70 86 81 00       	mov    %eax,0x818670
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  804aee:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804af5:	e8 a9 8b 00 00       	call   80d6a3 <sys_mbox_new>
  804afa:	a3 3c 80 81 00       	mov    %eax,0x81803c
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  804aff:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  804b06:	00 
  804b07:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804b0e:	00 
  804b0f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804b16:	00 
  804b17:	c7 44 24 04 76 4b 80 	movl   $0x804b76,0x4(%esp)
  804b1e:	00 
  804b1f:	c7 04 24 1c 2a 81 00 	movl   $0x812a1c,(%esp)
  804b26:	e8 f6 88 00 00       	call   80d421 <sys_thread_new>
}
  804b2b:	c9                   	leave  
  804b2c:	c3                   	ret    

00804b2d <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  804b2d:	55                   	push   %ebp
  804b2e:	89 e5                	mov    %esp,%ebp
  804b30:	83 ec 18             	sub    $0x18,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  804b33:	83 3d 74 86 81 00 00 	cmpl   $0x0,0x818674
  804b3a:	75 38                	jne    804b74 <tcp_timer_needed+0x47>
  804b3c:	83 3d c8 e5 b3 00 00 	cmpl   $0x0,0xb3e5c8
  804b43:	75 09                	jne    804b4e <tcp_timer_needed+0x21>
  804b45:	83 3d dc e5 b3 00 00 	cmpl   $0x0,0xb3e5dc
  804b4c:	74 26                	je     804b74 <tcp_timer_needed+0x47>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  804b4e:	c7 05 74 86 81 00 01 	movl   $0x1,0x818674
  804b55:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  804b58:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804b5f:	00 
  804b60:	c7 44 24 04 9f 4f 80 	movl   $0x804f9f,0x4(%esp)
  804b67:	00 
  804b68:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  804b6f:	e8 46 35 00 00       	call   8080ba <sys_timeout>
  }
}
  804b74:	c9                   	leave  
  804b75:	c3                   	ret    

00804b76 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  804b76:	55                   	push   %ebp
  804b77:	89 e5                	mov    %esp,%ebp
  804b79:	53                   	push   %ebx
  804b7a:	83 ec 24             	sub    $0x24,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  804b7d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804b84:	00 
  804b85:	c7 44 24 04 68 4d 80 	movl   $0x804d68,0x4(%esp)
  804b8c:	00 
  804b8d:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  804b94:	e8 21 35 00 00       	call   8080ba <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  804b99:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804ba0:	00 
  804ba1:	c7 44 24 04 3f 4d 80 	movl   $0x804d3f,0x4(%esp)
  804ba8:	00 
  804ba9:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  804bb0:	e8 05 35 00 00       	call   8080ba <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  804bb5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804bbc:	00 
  804bbd:	c7 44 24 04 16 4d 80 	movl   $0x804d16,0x4(%esp)
  804bc4:	00 
  804bc5:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  804bcc:	e8 e9 34 00 00       	call   8080ba <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  804bd1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804bd8:	00 
  804bd9:	c7 44 24 04 ed 4c 80 	movl   $0x804ced,0x4(%esp)
  804be0:	00 
  804be1:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  804be8:	e8 cd 34 00 00       	call   8080ba <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  804bed:	8b 15 6c 86 81 00    	mov    0x81866c,%edx
  804bf3:	85 d2                	test   %edx,%edx
  804bf5:	74 0a                	je     804c01 <tcpip_thread+0x8b>
    tcpip_init_done(tcpip_init_done_arg);
  804bf7:	a1 70 86 81 00       	mov    0x818670,%eax
  804bfc:	89 04 24             	mov    %eax,(%esp)
  804bff:	ff d2                	call   *%edx
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  804c01:	8d 5d f8             	lea    -0x8(%ebp),%ebx
  804c04:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  804c08:	a1 3c 80 81 00       	mov    0x81803c,%eax
  804c0d:	89 04 24             	mov    %eax,(%esp)
  804c10:	e8 86 36 00 00       	call   80829b <sys_mbox_fetch>
    switch (msg->type) {
  804c15:	8b 55 f8             	mov    -0x8(%ebp),%edx
  804c18:	8b 02                	mov    (%edx),%eax
  804c1a:	83 f8 01             	cmp    $0x1,%eax
  804c1d:	74 25                	je     804c44 <tcpip_thread+0xce>
  804c1f:	83 f8 01             	cmp    $0x1,%eax
  804c22:	72 10                	jb     804c34 <tcpip_thread+0xbe>
  804c24:	83 f8 02             	cmp    $0x2,%eax
  804c27:	74 59                	je     804c82 <tcpip_thread+0x10c>
  804c29:	83 f8 03             	cmp    $0x3,%eax
  804c2c:	8d 74 26 00          	lea    0x0(%esi),%esi
  804c30:	75 d2                	jne    804c04 <tcpip_thread+0x8e>
  804c32:	eb 6f                	jmp    804ca3 <tcpip_thread+0x12d>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  804c34:	8b 52 08             	mov    0x8(%edx),%edx
  804c37:	8d 42 04             	lea    0x4(%edx),%eax
  804c3a:	89 04 24             	mov    %eax,(%esp)
  804c3d:	8d 76 00             	lea    0x0(%esi),%esi
  804c40:	ff 12                	call   *(%edx)
  804c42:	eb c0                	jmp    804c04 <tcpip_thread+0x8e>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  804c44:	8b 42 0c             	mov    0xc(%edx),%eax
  804c47:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  804c4b:	74 11                	je     804c5e <tcpip_thread+0xe8>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  804c4d:	89 44 24 04          	mov    %eax,0x4(%esp)
  804c51:	8b 42 08             	mov    0x8(%edx),%eax
  804c54:	89 04 24             	mov    %eax,(%esp)
  804c57:	e8 ed 83 00 00       	call   80d049 <ethernet_input>
  804c5c:	eb 0f                	jmp    804c6d <tcpip_thread+0xf7>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  804c5e:	89 44 24 04          	mov    %eax,0x4(%esp)
  804c62:	8b 42 08             	mov    0x8(%edx),%eax
  804c65:	89 04 24             	mov    %eax,(%esp)
  804c68:	e8 01 4b 00 00       	call   80976e <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  804c6d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  804c70:	89 44 24 04          	mov    %eax,0x4(%esp)
  804c74:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  804c7b:	e8 87 26 00 00       	call   807307 <memp_free>
  804c80:	eb 82                	jmp    804c04 <tcpip_thread+0x8e>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  804c82:	8b 42 0c             	mov    0xc(%edx),%eax
  804c85:	89 04 24             	mov    %eax,(%esp)
  804c88:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  804c8b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  804c8e:	89 44 24 04          	mov    %eax,0x4(%esp)
  804c92:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804c99:	e8 69 26 00 00       	call   807307 <memp_free>
  804c9e:	e9 61 ff ff ff       	jmp    804c04 <tcpip_thread+0x8e>
      break;

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  804ca3:	8b 4a 08             	mov    0x8(%edx),%ecx
  804ca6:	83 f9 ff             	cmp    $0xffffffff,%ecx
  804ca9:	74 18                	je     804cc3 <tcpip_thread+0x14d>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  804cab:	8b 42 10             	mov    0x10(%edx),%eax
  804cae:	89 44 24 08          	mov    %eax,0x8(%esp)
  804cb2:	8b 42 0c             	mov    0xc(%edx),%eax
  804cb5:	89 44 24 04          	mov    %eax,0x4(%esp)
  804cb9:	89 0c 24             	mov    %ecx,(%esp)
  804cbc:	e8 f9 33 00 00       	call   8080ba <sys_timeout>
  804cc1:	eb 12                	jmp    804cd5 <tcpip_thread+0x15f>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  804cc3:	8b 42 10             	mov    0x10(%edx),%eax
  804cc6:	89 44 24 04          	mov    %eax,0x4(%esp)
  804cca:	8b 42 0c             	mov    0xc(%edx),%eax
  804ccd:	89 04 24             	mov    %eax,(%esp)
  804cd0:	e8 58 33 00 00       	call   80802d <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  804cd5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  804cd8:	89 44 24 04          	mov    %eax,0x4(%esp)
  804cdc:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804ce3:	e8 1f 26 00 00       	call   807307 <memp_free>
  804ce8:	e9 17 ff ff ff       	jmp    804c04 <tcpip_thread+0x8e>

00804ced <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  804ced:	55                   	push   %ebp
  804cee:	89 e5                	mov    %esp,%ebp
  804cf0:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  804cf3:	e8 f5 1e 00 00       	call   806bed <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  804cf8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804cff:	00 
  804d00:	c7 44 24 04 ed 4c 80 	movl   $0x804ced,0x4(%esp)
  804d07:	00 
  804d08:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  804d0f:	e8 a6 33 00 00       	call   8080ba <sys_timeout>
}
  804d14:	c9                   	leave  
  804d15:	c3                   	ret    

00804d16 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  804d16:	55                   	push   %ebp
  804d17:	89 e5                	mov    %esp,%ebp
  804d19:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  804d1c:	e8 5e 11 00 00       	call   805e7f <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  804d21:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804d28:	00 
  804d29:	c7 44 24 04 16 4d 80 	movl   $0x804d16,0x4(%esp)
  804d30:	00 
  804d31:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  804d38:	e8 7d 33 00 00       	call   8080ba <sys_timeout>
}
  804d3d:	c9                   	leave  
  804d3e:	c3                   	ret    

00804d3f <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  804d3f:	55                   	push   %ebp
  804d40:	89 e5                	mov    %esp,%ebp
  804d42:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  804d45:	e8 80 80 00 00       	call   80cdca <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  804d4a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804d51:	00 
  804d52:	c7 44 24 04 3f 4d 80 	movl   $0x804d3f,0x4(%esp)
  804d59:	00 
  804d5a:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  804d61:	e8 54 33 00 00       	call   8080ba <sys_timeout>
}
  804d66:	c9                   	leave  
  804d67:	c3                   	ret    

00804d68 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  804d68:	55                   	push   %ebp
  804d69:	89 e5                	mov    %esp,%ebp
  804d6b:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  804d6e:	e8 be 56 00 00       	call   80a431 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  804d73:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804d7a:	00 
  804d7b:	c7 44 24 04 68 4d 80 	movl   $0x804d68,0x4(%esp)
  804d82:	00 
  804d83:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  804d8a:	e8 2b 33 00 00       	call   8080ba <sys_timeout>
}
  804d8f:	c9                   	leave  
  804d90:	c3                   	ret    

00804d91 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  804d91:	55                   	push   %ebp
  804d92:	89 e5                	mov    %esp,%ebp
  804d94:	53                   	push   %ebx
  804d95:	83 ec 34             	sub    $0x34,%esp
  804d98:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  804d9b:	8b 15 3c 80 81 00    	mov    0x81803c,%edx
  804da1:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804da6:	83 fa ff             	cmp    $0xffffffff,%edx
  804da9:	74 34                	je     804ddf <tcpip_apimsg+0x4e>
    msg.type = TCPIP_MSG_API;
  804dab:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    msg.msg.apimsg = apimsg;
  804db2:	89 5d f0             	mov    %ebx,-0x10(%ebp)
    sys_mbox_post(mbox, &msg);
  804db5:	8d 45 e8             	lea    -0x18(%ebp),%eax
  804db8:	89 44 24 04          	mov    %eax,0x4(%esp)
  804dbc:	89 14 24             	mov    %edx,(%esp)
  804dbf:	e8 47 8c 00 00       	call   80da0b <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  804dc4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804dcb:	00 
  804dcc:	8b 43 04             	mov    0x4(%ebx),%eax
  804dcf:	8b 40 10             	mov    0x10(%eax),%eax
  804dd2:	89 04 24             	mov    %eax,(%esp)
  804dd5:	e8 ff 86 00 00       	call   80d4d9 <sys_arch_sem_wait>
  804dda:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  804ddf:	83 c4 34             	add    $0x34,%esp
  804de2:	5b                   	pop    %ebx
  804de3:	5d                   	pop    %ebp
  804de4:	c3                   	ret    

00804de5 <tcpip_timeout>:
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  804de5:	55                   	push   %ebp
  804de6:	89 e5                	mov    %esp,%ebp
  804de8:	83 ec 08             	sub    $0x8,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  804deb:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804df0:	83 3d 3c 80 81 00 ff 	cmpl   $0xffffffff,0x81803c
  804df7:	74 45                	je     804e3e <tcpip_timeout+0x59>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  804df9:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804e00:	e8 45 25 00 00       	call   80734a <memp_malloc>
  804e05:	89 c2                	mov    %eax,%edx
    if (msg == NULL) {
  804e07:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804e0c:	85 d2                	test   %edx,%edx
  804e0e:	74 2e                	je     804e3e <tcpip_timeout+0x59>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  804e10:	c7 02 03 00 00 00    	movl   $0x3,(%edx)
    msg->msg.tmo.msecs = msecs;
  804e16:	8b 45 08             	mov    0x8(%ebp),%eax
  804e19:	89 42 08             	mov    %eax,0x8(%edx)
    msg->msg.tmo.h = h;
  804e1c:	8b 45 0c             	mov    0xc(%ebp),%eax
  804e1f:	89 42 0c             	mov    %eax,0xc(%edx)
    msg->msg.tmo.arg = arg;
  804e22:	8b 45 10             	mov    0x10(%ebp),%eax
  804e25:	89 42 10             	mov    %eax,0x10(%edx)
    sys_mbox_post(mbox, msg);
  804e28:	89 54 24 04          	mov    %edx,0x4(%esp)
  804e2c:	a1 3c 80 81 00       	mov    0x81803c,%eax
  804e31:	89 04 24             	mov    %eax,(%esp)
  804e34:	e8 d2 8b 00 00       	call   80da0b <sys_mbox_post>
  804e39:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  804e3e:	c9                   	leave  
  804e3f:	c3                   	ret    

00804e40 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  804e40:	55                   	push   %ebp
  804e41:	89 e5                	mov    %esp,%ebp
  804e43:	83 ec 18             	sub    $0x18,%esp
  804e46:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  804e49:	89 75 fc             	mov    %esi,-0x4(%ebp)
  804e4c:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  804e50:	ba f7 ff ff ff       	mov    $0xfffffff7,%edx
  804e55:	83 3d 3c 80 81 00 ff 	cmpl   $0xffffffff,0x81803c
  804e5c:	74 74                	je     804ed2 <tcpip_callback_with_block+0x92>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  804e5e:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804e65:	e8 e0 24 00 00       	call   80734a <memp_malloc>
    if (msg == NULL) {
  804e6a:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  804e6f:	85 c0                	test   %eax,%eax
  804e71:	74 5f                	je     804ed2 <tcpip_callback_with_block+0x92>
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  804e73:	89 c6                	mov    %eax,%esi
    if (msg == NULL) {
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  804e75:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  804e7b:	8b 45 08             	mov    0x8(%ebp),%eax
  804e7e:	89 46 08             	mov    %eax,0x8(%esi)
    msg->msg.cb.ctx = ctx;
  804e81:	8b 45 0c             	mov    0xc(%ebp),%eax
  804e84:	89 46 0c             	mov    %eax,0xc(%esi)
    if (block) {
  804e87:	84 db                	test   %bl,%bl
  804e89:	74 18                	je     804ea3 <tcpip_callback_with_block+0x63>
      sys_mbox_post(mbox, msg);
  804e8b:	89 74 24 04          	mov    %esi,0x4(%esp)
  804e8f:	a1 3c 80 81 00       	mov    0x81803c,%eax
  804e94:	89 04 24             	mov    %eax,(%esp)
  804e97:	e8 6f 8b 00 00       	call   80da0b <sys_mbox_post>
  804e9c:	ba 00 00 00 00       	mov    $0x0,%edx
  804ea1:	eb 2f                	jmp    804ed2 <tcpip_callback_with_block+0x92>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  804ea3:	89 74 24 04          	mov    %esi,0x4(%esp)
  804ea7:	a1 3c 80 81 00       	mov    0x81803c,%eax
  804eac:	89 04 24             	mov    %eax,(%esp)
  804eaf:	e8 8e 8a 00 00       	call   80d942 <sys_mbox_trypost>
  804eb4:	ba 00 00 00 00       	mov    $0x0,%edx
  804eb9:	84 c0                	test   %al,%al
  804ebb:	74 15                	je     804ed2 <tcpip_callback_with_block+0x92>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  804ebd:	89 74 24 04          	mov    %esi,0x4(%esp)
  804ec1:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804ec8:	e8 3a 24 00 00       	call   807307 <memp_free>
  804ecd:	ba ff ff ff ff       	mov    $0xffffffff,%edx
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  804ed2:	89 d0                	mov    %edx,%eax
  804ed4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  804ed7:	8b 75 fc             	mov    -0x4(%ebp),%esi
  804eda:	89 ec                	mov    %ebp,%esp
  804edc:	5d                   	pop    %ebp
  804edd:	c3                   	ret    

00804ede <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  804ede:	55                   	push   %ebp
  804edf:	89 e5                	mov    %esp,%ebp
  804ee1:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  804ee4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804eeb:	00 
  804eec:	8b 45 08             	mov    0x8(%ebp),%eax
  804eef:	89 44 24 04          	mov    %eax,0x4(%esp)
  804ef3:	c7 04 24 86 70 80 00 	movl   $0x807086,(%esp)
  804efa:	e8 41 ff ff ff       	call   804e40 <tcpip_callback_with_block>
  804eff:	0f be c0             	movsbl %al,%eax
}
  804f02:	c9                   	leave  
  804f03:	c3                   	ret    

00804f04 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  804f04:	55                   	push   %ebp
  804f05:	89 e5                	mov    %esp,%ebp
  804f07:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  804f0a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804f11:	00 
  804f12:	8b 45 08             	mov    0x8(%ebp),%eax
  804f15:	89 44 24 04          	mov    %eax,0x4(%esp)
  804f19:	c7 04 24 c0 4a 80 00 	movl   $0x804ac0,(%esp)
  804f20:	e8 1b ff ff ff       	call   804e40 <tcpip_callback_with_block>
  804f25:	0f be c0             	movsbl %al,%eax
}
  804f28:	c9                   	leave  
  804f29:	c3                   	ret    

00804f2a <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  804f2a:	55                   	push   %ebp
  804f2b:	89 e5                	mov    %esp,%ebp
  804f2d:	53                   	push   %ebx
  804f2e:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  804f31:	ba f7 ff ff ff       	mov    $0xfffffff7,%edx
  804f36:	83 3d 3c 80 81 00 ff 	cmpl   $0xffffffff,0x81803c
  804f3d:	74 58                	je     804f97 <tcpip_input+0x6d>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  804f3f:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  804f46:	e8 ff 23 00 00       	call   80734a <memp_malloc>
    if (msg == NULL) {
  804f4b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  804f50:	85 c0                	test   %eax,%eax
  804f52:	74 43                	je     804f97 <tcpip_input+0x6d>
tcpip_input(struct pbuf *p, struct netif *inp)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  804f54:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  804f56:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  804f5c:	8b 45 08             	mov    0x8(%ebp),%eax
  804f5f:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  804f62:	8b 45 0c             	mov    0xc(%ebp),%eax
  804f65:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  804f68:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  804f6c:	a1 3c 80 81 00       	mov    0x81803c,%eax
  804f71:	89 04 24             	mov    %eax,(%esp)
  804f74:	e8 c9 89 00 00       	call   80d942 <sys_mbox_trypost>
  804f79:	ba 00 00 00 00       	mov    $0x0,%edx
  804f7e:	84 c0                	test   %al,%al
  804f80:	74 15                	je     804f97 <tcpip_input+0x6d>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  804f82:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  804f86:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  804f8d:	e8 75 23 00 00       	call   807307 <memp_free>
  804f92:	ba ff ff ff ff       	mov    $0xffffffff,%edx
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  804f97:	89 d0                	mov    %edx,%eax
  804f99:	83 c4 14             	add    $0x14,%esp
  804f9c:	5b                   	pop    %ebx
  804f9d:	5d                   	pop    %ebp
  804f9e:	c3                   	ret    

00804f9f <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  804f9f:	55                   	push   %ebp
  804fa0:	89 e5                	mov    %esp,%ebp
  804fa2:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  804fa5:	e8 30 43 00 00       	call   8092da <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  804faa:	83 3d c8 e5 b3 00 00 	cmpl   $0x0,0xb3e5c8
  804fb1:	75 09                	jne    804fbc <tcpip_tcp_timer+0x1d>
  804fb3:	83 3d dc e5 b3 00 00 	cmpl   $0x0,0xb3e5dc
  804fba:	74 1e                	je     804fda <tcpip_tcp_timer+0x3b>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  804fbc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804fc3:	00 
  804fc4:	c7 44 24 04 9f 4f 80 	movl   $0x804f9f,0x4(%esp)
  804fcb:	00 
  804fcc:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  804fd3:	e8 e2 30 00 00       	call   8080ba <sys_timeout>
  804fd8:	eb 0a                	jmp    804fe4 <tcpip_tcp_timer+0x45>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  804fda:	c7 05 74 86 81 00 00 	movl   $0x0,0x818674
  804fe1:	00 00 00 
  }
}
  804fe4:	c9                   	leave  
  804fe5:	c3                   	ret    
	...

00804fe8 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  804fe8:	55                   	push   %ebp
  804fe9:	89 e5                	mov    %esp,%ebp
  804feb:	83 ec 18             	sub    $0x18,%esp
  804fee:	8b 55 08             	mov    0x8(%ebp),%edx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  804ff1:	85 d2                	test   %edx,%edx
  804ff3:	75 1c                	jne    805011 <netbuf_first+0x29>
  804ff5:	c7 44 24 08 29 2a 81 	movl   $0x812a29,0x8(%esp)
  804ffc:	00 
  804ffd:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
  805004:	00 
  805005:	c7 04 24 42 2a 81 00 	movl   $0x812a42,(%esp)
  80500c:	e8 9b b8 ff ff       	call   8008ac <_panic>
  buf->ptr = buf->p;
  805011:	8b 02                	mov    (%edx),%eax
  805013:	89 42 04             	mov    %eax,0x4(%edx)
}
  805016:	c9                   	leave  
  805017:	c3                   	ret    

00805018 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  805018:	55                   	push   %ebp
  805019:	89 e5                	mov    %esp,%ebp
  80501b:	83 ec 18             	sub    $0x18,%esp
  80501e:	8b 55 08             	mov    0x8(%ebp),%edx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  805021:	85 d2                	test   %edx,%edx
  805023:	75 1c                	jne    805041 <netbuf_next+0x29>
  805025:	c7 44 24 08 29 2a 81 	movl   $0x812a29,0x8(%esp)
  80502c:	00 
  80502d:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
  805034:	00 
  805035:	c7 04 24 42 2a 81 00 	movl   $0x812a42,(%esp)
  80503c:	e8 6b b8 ff ff       	call   8008ac <_panic>
  if (buf->ptr->next == NULL) {
  805041:	8b 42 04             	mov    0x4(%edx),%eax
  805044:	8b 00                	mov    (%eax),%eax
  805046:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80504b:	85 c0                	test   %eax,%eax
  80504d:	74 0c                	je     80505b <netbuf_next+0x43>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  80504f:	89 42 04             	mov    %eax,0x4(%edx)
  805052:	83 38 00             	cmpl   $0x0,(%eax)
  805055:	0f 94 c0             	sete   %al
  805058:	0f b6 c8             	movzbl %al,%ecx
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  80505b:	89 c8                	mov    %ecx,%eax
  80505d:	c9                   	leave  
  80505e:	c3                   	ret    

0080505f <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  80505f:	55                   	push   %ebp
  805060:	89 e5                	mov    %esp,%ebp
  805062:	56                   	push   %esi
  805063:	53                   	push   %ebx
  805064:	83 ec 10             	sub    $0x10,%esp
  805067:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80506a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80506d:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  805070:	85 c9                	test   %ecx,%ecx
  805072:	75 1c                	jne    805090 <netbuf_data+0x31>
  805074:	c7 44 24 08 58 2a 81 	movl   $0x812a58,0x8(%esp)
  80507b:	00 
  80507c:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  805083:	00 
  805084:	c7 04 24 42 2a 81 00 	movl   $0x812a42,(%esp)
  80508b:	e8 1c b8 ff ff       	call   8008ac <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  805090:	85 db                	test   %ebx,%ebx
  805092:	75 1c                	jne    8050b0 <netbuf_data+0x51>
  805094:	c7 44 24 08 71 2a 81 	movl   $0x812a71,0x8(%esp)
  80509b:	00 
  80509c:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
  8050a3:	00 
  8050a4:	c7 04 24 42 2a 81 00 	movl   $0x812a42,(%esp)
  8050ab:	e8 fc b7 ff ff       	call   8008ac <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  8050b0:	85 f6                	test   %esi,%esi
  8050b2:	75 1c                	jne    8050d0 <netbuf_data+0x71>
  8050b4:	c7 44 24 08 8e 2a 81 	movl   $0x812a8e,0x8(%esp)
  8050bb:	00 
  8050bc:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  8050c3:	00 
  8050c4:	c7 04 24 42 2a 81 00 	movl   $0x812a42,(%esp)
  8050cb:	e8 dc b7 ff ff       	call   8008ac <_panic>

  if (buf->ptr == NULL) {
  8050d0:	8b 51 04             	mov    0x4(%ecx),%edx
  8050d3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8050d8:	85 d2                	test   %edx,%edx
  8050da:	74 14                	je     8050f0 <netbuf_data+0x91>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  8050dc:	8b 42 04             	mov    0x4(%edx),%eax
  8050df:	89 03                	mov    %eax,(%ebx)
  *len = buf->ptr->len;
  8050e1:	8b 41 04             	mov    0x4(%ecx),%eax
  8050e4:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  8050e8:	66 89 06             	mov    %ax,(%esi)
  8050eb:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  8050f0:	83 c4 10             	add    $0x10,%esp
  8050f3:	5b                   	pop    %ebx
  8050f4:	5e                   	pop    %esi
  8050f5:	5d                   	pop    %ebp
  8050f6:	c3                   	ret    

008050f7 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  8050f7:	55                   	push   %ebp
  8050f8:	89 e5                	mov    %esp,%ebp
  8050fa:	83 ec 18             	sub    $0x18,%esp
  8050fd:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  805100:	89 75 fc             	mov    %esi,-0x4(%ebp)
  805103:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805106:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  805109:	85 db                	test   %ebx,%ebx
  80510b:	75 1c                	jne    805129 <netbuf_chain+0x32>
  80510d:	c7 44 24 08 a7 2a 81 	movl   $0x812aa7,0x8(%esp)
  805114:	00 
  805115:	c7 44 24 04 a6 00 00 	movl   $0xa6,0x4(%esp)
  80511c:	00 
  80511d:	c7 04 24 42 2a 81 00 	movl   $0x812a42,(%esp)
  805124:	e8 83 b7 ff ff       	call   8008ac <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  805129:	85 f6                	test   %esi,%esi
  80512b:	75 1c                	jne    805149 <netbuf_chain+0x52>
  80512d:	c7 44 24 08 c0 2a 81 	movl   $0x812ac0,0x8(%esp)
  805134:	00 
  805135:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  80513c:	00 
  80513d:	c7 04 24 42 2a 81 00 	movl   $0x812a42,(%esp)
  805144:	e8 63 b7 ff ff       	call   8008ac <_panic>
  pbuf_chain(head->p, tail->p);
  805149:	8b 06                	mov    (%esi),%eax
  80514b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80514f:	8b 03                	mov    (%ebx),%eax
  805151:	89 04 24             	mov    %eax,(%esp)
  805154:	e8 88 25 00 00       	call   8076e1 <pbuf_chain>
  head->ptr = head->p;
  805159:	8b 03                	mov    (%ebx),%eax
  80515b:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  80515e:	89 74 24 04          	mov    %esi,0x4(%esp)
  805162:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  805169:	e8 99 21 00 00       	call   807307 <memp_free>
}
  80516e:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  805171:	8b 75 fc             	mov    -0x4(%ebp),%esi
  805174:	89 ec                	mov    %ebp,%esp
  805176:	5d                   	pop    %ebp
  805177:	c3                   	ret    

00805178 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  805178:	55                   	push   %ebp
  805179:	89 e5                	mov    %esp,%ebp
  80517b:	53                   	push   %ebx
  80517c:	83 ec 14             	sub    $0x14,%esp
  80517f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  805182:	85 db                	test   %ebx,%ebx
  805184:	75 1c                	jne    8051a2 <netbuf_free+0x2a>
  805186:	c7 44 24 08 29 2a 81 	movl   $0x812a29,0x8(%esp)
  80518d:	00 
  80518e:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  805195:	00 
  805196:	c7 04 24 42 2a 81 00 	movl   $0x812a42,(%esp)
  80519d:	e8 0a b7 ff ff       	call   8008ac <_panic>
  if (buf->p != NULL) {
  8051a2:	8b 03                	mov    (%ebx),%eax
  8051a4:	85 c0                	test   %eax,%eax
  8051a6:	74 08                	je     8051b0 <netbuf_free+0x38>
    pbuf_free(buf->p);
  8051a8:	89 04 24             	mov    %eax,(%esp)
  8051ab:	e8 c3 28 00 00       	call   807a73 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  8051b0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8051b7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8051bd:	83 c4 14             	add    $0x14,%esp
  8051c0:	5b                   	pop    %ebx
  8051c1:	5d                   	pop    %ebp
  8051c2:	c3                   	ret    

008051c3 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8051c3:	55                   	push   %ebp
  8051c4:	89 e5                	mov    %esp,%ebp
  8051c6:	53                   	push   %ebx
  8051c7:	83 ec 14             	sub    $0x14,%esp
  8051ca:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  8051cd:	85 db                	test   %ebx,%ebx
  8051cf:	74 2b                	je     8051fc <netbuf_delete+0x39>
    if (buf->p != NULL) {
  8051d1:	8b 03                	mov    (%ebx),%eax
  8051d3:	85 c0                	test   %eax,%eax
  8051d5:	74 15                	je     8051ec <netbuf_delete+0x29>
      pbuf_free(buf->p);
  8051d7:	89 04 24             	mov    %eax,(%esp)
  8051da:	e8 94 28 00 00       	call   807a73 <pbuf_free>
      buf->p = buf->ptr = NULL;
  8051df:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8051e6:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
    memp_free(MEMP_NETBUF, buf);
  8051ec:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8051f0:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  8051f7:	e8 0b 21 00 00       	call   807307 <memp_free>
  }
}
  8051fc:	83 c4 14             	add    $0x14,%esp
  8051ff:	5b                   	pop    %ebx
  805200:	5d                   	pop    %ebp
  805201:	c3                   	ret    

00805202 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  805202:	55                   	push   %ebp
  805203:	89 e5                	mov    %esp,%ebp
  805205:	56                   	push   %esi
  805206:	53                   	push   %ebx
  805207:	83 ec 10             	sub    $0x10,%esp
  80520a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80520d:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  805211:	85 db                	test   %ebx,%ebx
  805213:	75 1c                	jne    805231 <netbuf_ref+0x2f>
  805215:	c7 44 24 08 db 2a 81 	movl   $0x812adb,0x8(%esp)
  80521c:	00 
  80521d:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  805224:	00 
  805225:	c7 04 24 42 2a 81 00 	movl   $0x812a42,(%esp)
  80522c:	e8 7b b6 ff ff       	call   8008ac <_panic>
  if (buf->p != NULL) {
  805231:	8b 03                	mov    (%ebx),%eax
  805233:	85 c0                	test   %eax,%eax
  805235:	74 08                	je     80523f <netbuf_ref+0x3d>
    pbuf_free(buf->p);
  805237:	89 04 24             	mov    %eax,(%esp)
  80523a:	e8 34 28 00 00       	call   807a73 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  80523f:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  805246:	00 
  805247:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80524e:	00 
  80524f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805256:	e8 db 2a 00 00       	call   807d36 <pbuf_alloc>
  80525b:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80525d:	85 c0                	test   %eax,%eax
  80525f:	75 0e                	jne    80526f <netbuf_ref+0x6d>
    buf->ptr = NULL;
  805261:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  805268:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80526d:	eb 1a                	jmp    805289 <netbuf_ref+0x87>
    return ERR_MEM;
  }
  buf->p->payload = (void*)dataptr;
  80526f:	8b 55 0c             	mov    0xc(%ebp),%edx
  805272:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  805275:	8b 03                	mov    (%ebx),%eax
  805277:	66 89 70 08          	mov    %si,0x8(%eax)
  80527b:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  80527f:	8b 03                	mov    (%ebx),%eax
  805281:	89 43 04             	mov    %eax,0x4(%ebx)
  805284:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  805289:	83 c4 10             	add    $0x10,%esp
  80528c:	5b                   	pop    %ebx
  80528d:	5e                   	pop    %esi
  80528e:	5d                   	pop    %ebp
  80528f:	c3                   	ret    

00805290 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  805290:	55                   	push   %ebp
  805291:	89 e5                	mov    %esp,%ebp
  805293:	56                   	push   %esi
  805294:	53                   	push   %ebx
  805295:	83 ec 10             	sub    $0x10,%esp
  805298:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80529b:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80529f:	85 db                	test   %ebx,%ebx
  8052a1:	75 1c                	jne    8052bf <netbuf_alloc+0x2f>
  8052a3:	c7 44 24 08 f3 2a 81 	movl   $0x812af3,0x8(%esp)
  8052aa:	00 
  8052ab:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  8052b2:	00 
  8052b3:	c7 04 24 42 2a 81 00 	movl   $0x812a42,(%esp)
  8052ba:	e8 ed b5 ff ff       	call   8008ac <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  8052bf:	8b 03                	mov    (%ebx),%eax
  8052c1:	85 c0                	test   %eax,%eax
  8052c3:	74 08                	je     8052cd <netbuf_alloc+0x3d>
    pbuf_free(buf->p);
  8052c5:	89 04 24             	mov    %eax,(%esp)
  8052c8:	e8 a6 27 00 00       	call   807a73 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  8052cd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8052d4:	00 
  8052d5:	0f b7 c6             	movzwl %si,%eax
  8052d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8052dc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8052e3:	e8 4e 2a 00 00       	call   807d36 <pbuf_alloc>
  8052e8:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8052ea:	ba 00 00 00 00       	mov    $0x0,%edx
  8052ef:	85 c0                	test   %eax,%eax
  8052f1:	74 2a                	je     80531d <netbuf_alloc+0x8d>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8052f3:	66 3b 70 0a          	cmp    0xa(%eax),%si
  8052f7:	76 1c                	jbe    805315 <netbuf_alloc+0x85>
  8052f9:	c7 44 24 08 10 2b 81 	movl   $0x812b10,0x8(%esp)
  805300:	00 
  805301:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  805308:	00 
  805309:	c7 04 24 42 2a 81 00 	movl   $0x812a42,(%esp)
  805310:	e8 97 b5 ff ff       	call   8008ac <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  805315:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  805318:	8b 03                	mov    (%ebx),%eax
  80531a:	8b 50 04             	mov    0x4(%eax),%edx
}
  80531d:	89 d0                	mov    %edx,%eax
  80531f:	83 c4 10             	add    $0x10,%esp
  805322:	5b                   	pop    %ebx
  805323:	5e                   	pop    %esi
  805324:	5d                   	pop    %ebp
  805325:	c3                   	ret    

00805326 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  805326:	55                   	push   %ebp
  805327:	89 e5                	mov    %esp,%ebp
  805329:	83 ec 08             	sub    $0x8,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  80532c:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  805333:	e8 12 20 00 00       	call   80734a <memp_malloc>
  805338:	89 c2                	mov    %eax,%edx
  if (buf != NULL) {
  80533a:	b8 00 00 00 00       	mov    $0x0,%eax
  80533f:	85 d2                	test   %edx,%edx
  805341:	74 16                	je     805359 <netbuf_new+0x33>
struct
netbuf *netbuf_new(void)
{
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  805343:	89 d0                	mov    %edx,%eax
  if (buf != NULL) {
    buf->p = NULL;
  805345:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    buf->ptr = NULL;
  80534b:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    buf->addr = NULL;
  805352:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
    return buf;
  } else {
    return NULL;
  }
}
  805359:	c9                   	leave  
  80535a:	c3                   	ret    
  80535b:	00 00                	add    %al,(%eax)
  80535d:	00 00                	add    %al,(%eax)
	...

00805360 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  805360:	55                   	push   %ebp
  805361:	89 e5                	mov    %esp,%ebp
  805363:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  805366:	e8 85 7d 00 00       	call   80d0f0 <sys_init>
  mem_init();
  80536b:	e8 a1 1e 00 00       	call   807211 <mem_init>
  memp_init();
  805370:	e8 ff 1e 00 00       	call   807274 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  805375:	e8 74 e8 ff ff       	call   803bee <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  80537a:	c9                   	leave  
  80537b:	c3                   	ret    
  80537c:	00 00                	add    %al,(%eax)
	...

00805380 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  805380:	55                   	push   %ebp
  805381:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  805383:	38 10                	cmp    %dl,(%eax)
  805385:	74 06                	je     80538d <dhcp_set_state+0xd>
    dhcp->state = new_state;
  805387:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  805389:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  80538d:	5d                   	pop    %ebp
  80538e:	c3                   	ret    

0080538f <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80538f:	55                   	push   %ebp
  805390:	89 e5                	mov    %esp,%ebp
  805392:	57                   	push   %edi
  805393:	56                   	push   %esi
  805394:	53                   	push   %ebx
  805395:	83 ec 04             	sub    $0x4,%esp
  805398:	89 c6                	mov    %eax,%esi
  80539a:	88 55 f2             	mov    %dl,-0xe(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80539d:	8b 40 14             	mov    0x14(%eax),%eax
  8053a0:	85 c0                	test   %eax,%eax
  8053a2:	0f 84 da 00 00 00    	je     805482 <dhcp_get_option_ptr+0xf3>
  8053a8:	0f b7 7e 18          	movzwl 0x18(%esi),%edi
  8053ac:	66 85 ff             	test   %di,%di
  8053af:	0f 84 cd 00 00 00    	je     805482 <dhcp_get_option_ptr+0xf3>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
  8053b5:	89 c3                	mov    %eax,%ebx
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8053b7:	0f b6 00             	movzbl (%eax),%eax
  8053ba:	3c ff                	cmp    $0xff,%al
  8053bc:	0f 84 c0 00 00 00    	je     805482 <dhcp_get_option_ptr+0xf3>
  8053c2:	89 da                	mov    %ebx,%edx
  8053c4:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  8053c8:	b9 00 00 00 00       	mov    $0x0,%ecx
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  8053cd:	3c 34                	cmp    $0x34,%al
  8053cf:	75 12                	jne    8053e3 <dhcp_get_option_ptr+0x54>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  8053d1:	8d 41 02             	lea    0x2(%ecx),%eax
        overload = options[offset++];
  8053d4:	0f b7 c0             	movzwl %ax,%eax
  8053d7:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8053db:	88 45 f3             	mov    %al,-0xd(%ebp)
  8053de:	83 c1 03             	add    $0x3,%ecx
  8053e1:	eb 17                	jmp    8053fa <dhcp_get_option_ptr+0x6b>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  8053e3:	3a 45 f2             	cmp    -0xe(%ebp),%al
  8053e6:	0f 84 9b 00 00 00    	je     805487 <dhcp_get_option_ptr+0xf8>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  8053ec:	8d 41 01             	lea    0x1(%ecx),%eax
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  8053ef:	0f b7 c0             	movzwl %ax,%eax
  8053f2:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8053f6:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8053fa:	66 39 cf             	cmp    %cx,%di
  8053fd:	76 0d                	jbe    80540c <dhcp_get_option_ptr+0x7d>
  8053ff:	0f b7 c1             	movzwl %cx,%eax
  805402:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  805405:	0f b6 02             	movzbl (%edx),%eax
  805408:	3c ff                	cmp    $0xff,%al
  80540a:	75 c1                	jne    8053cd <dhcp_get_option_ptr+0x3e>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  80540c:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  805410:	74 70                	je     805482 <dhcp_get_option_ptr+0xf3>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  805412:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
  805416:	75 0d                	jne    805425 <dhcp_get_option_ptr+0x96>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  805418:	8b 56 10             	mov    0x10(%esi),%edx
  80541b:	83 c2 6c             	add    $0x6c,%edx
  80541e:	be 80 00 00 00       	mov    $0x80,%esi
  805423:	eb 1e                	jmp    805443 <dhcp_get_option_ptr+0xb4>
        field_len = DHCP_FILE_LEN;
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  805425:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
  805429:	75 0d                	jne    805438 <dhcp_get_option_ptr+0xa9>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80542b:	8b 56 10             	mov    0x10(%esi),%edx
  80542e:	83 c2 2c             	add    $0x2c,%edx
  805431:	be 40 00 00 00       	mov    $0x40,%esi
  805436:	eb 0b                	jmp    805443 <dhcp_get_option_ptr+0xb4>
        field_len = DHCP_SNAME_LEN;
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  805438:	8b 56 10             	mov    0x10(%esi),%edx
  80543b:	83 c2 2c             	add    $0x2c,%edx
  80543e:	be c0 00 00 00       	mov    $0xc0,%esi
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  805443:	0f b6 02             	movzbl (%edx),%eax
  805446:	3c ff                	cmp    $0xff,%al
  805448:	74 38                	je     805482 <dhcp_get_option_ptr+0xf3>
        if (options[offset] == option_type) {
  80544a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80544f:	38 45 f2             	cmp    %al,-0xe(%ebp)
  805452:	75 0e                	jne    805462 <dhcp_get_option_ptr+0xd3>
  805454:	eb 31                	jmp    805487 <dhcp_get_option_ptr+0xf8>
  805456:	38 4d f2             	cmp    %cl,-0xe(%ebp)
  805459:	75 07                	jne    805462 <dhcp_get_option_ptr+0xd3>
  80545b:	89 c2                	mov    %eax,%edx
  80545d:	8d 76 00             	lea    0x0(%esi),%esi
  805460:	eb 25                	jmp    805487 <dhcp_get_option_ptr+0xf8>
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  805462:	8d 43 01             	lea    0x1(%ebx),%eax
          offset += 1 + options[offset];
  805465:	0f b7 c0             	movzwl %ax,%eax
  805468:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
  80546c:	8d 5c 03 02          	lea    0x2(%ebx,%eax,1),%ebx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  805470:	66 39 de             	cmp    %bx,%si
  805473:	76 0d                	jbe    805482 <dhcp_get_option_ptr+0xf3>
  805475:	0f b7 c3             	movzwl %bx,%eax
  805478:	01 d0                	add    %edx,%eax
  80547a:	0f b6 08             	movzbl (%eax),%ecx
  80547d:	80 f9 ff             	cmp    $0xff,%cl
  805480:	75 d4                	jne    805456 <dhcp_get_option_ptr+0xc7>
  805482:	ba 00 00 00 00       	mov    $0x0,%edx
        }
      }
    }
  }
  return NULL;
}
  805487:	89 d0                	mov    %edx,%eax
  805489:	83 c4 04             	add    $0x4,%esp
  80548c:	5b                   	pop    %ebx
  80548d:	5e                   	pop    %esi
  80548e:	5f                   	pop    %edi
  80548f:	5d                   	pop    %ebp
  805490:	c3                   	ret    

00805491 <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  805491:	55                   	push   %ebp
  805492:	89 e5                	mov    %esp,%ebp
  805494:	0f b6 00             	movzbl (%eax),%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
}
  805497:	5d                   	pop    %ebp
  805498:	c3                   	ret    

00805499 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  805499:	55                   	push   %ebp
  80549a:	89 e5                	mov    %esp,%ebp
  80549c:	89 c1                	mov    %eax,%ecx
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  80549e:	0f b6 10             	movzbl (%eax),%edx
  8054a1:	c1 e2 18             	shl    $0x18,%edx
  value |= (u32_t)(*ptr++) << 16;
  8054a4:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  8054a8:	c1 e0 10             	shl    $0x10,%eax
  8054ab:	09 d0                	or     %edx,%eax
  value |= (u32_t)(*ptr++) << 8;
  8054ad:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
  8054b1:	c1 e2 08             	shl    $0x8,%edx
  8054b4:	09 d0                	or     %edx,%eax
  8054b6:	0f b6 51 03          	movzbl 0x3(%ecx),%edx
  8054ba:	09 d0                	or     %edx,%eax
  value |= (u32_t)(*ptr++);
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  8054bc:	5d                   	pop    %ebp
  8054bd:	c3                   	ret    

008054be <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  8054be:	55                   	push   %ebp
  8054bf:	89 e5                	mov    %esp,%ebp
  8054c1:	53                   	push   %ebx
  8054c2:	83 ec 14             	sub    $0x14,%esp
  8054c5:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  8054c7:	85 c0                	test   %eax,%eax
  8054c9:	75 1c                	jne    8054e7 <dhcp_option_trailer+0x29>
  8054cb:	c7 44 24 08 34 2b 81 	movl   $0x812b34,0x8(%esp)
  8054d2:	00 
  8054d3:	c7 44 24 04 80 05 00 	movl   $0x580,0x4(%esp)
  8054da:	00 
  8054db:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  8054e2:	e8 c5 b3 ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  8054e7:	8b 48 20             	mov    0x20(%eax),%ecx
  8054ea:	85 c9                	test   %ecx,%ecx
  8054ec:	75 1c                	jne    80550a <dhcp_option_trailer+0x4c>
  8054ee:	c7 44 24 08 58 2b 81 	movl   $0x812b58,0x8(%esp)
  8054f5:	00 
  8054f6:	c7 44 24 04 81 05 00 	movl   $0x581,0x4(%esp)
  8054fd:	00 
  8054fe:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  805505:	e8 a2 b3 ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80550a:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  80550e:	66 83 fa 43          	cmp    $0x43,%dx
  805512:	76 1c                	jbe    805530 <dhcp_option_trailer+0x72>
  805514:	c7 44 24 08 84 2b 81 	movl   $0x812b84,0x8(%esp)
  80551b:	00 
  80551c:	c7 44 24 04 82 05 00 	movl   $0x582,0x4(%esp)
  805523:	00 
  805524:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  80552b:	e8 7c b3 ff ff       	call   8008ac <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  805530:	0f b7 c2             	movzwl %dx,%eax
  805533:	c6 84 01 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%eax,1)
  80553a:	ff 
  80553b:	8d 4a 01             	lea    0x1(%edx),%ecx
  80553e:	66 89 4b 24          	mov    %cx,0x24(%ebx)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  805542:	66 83 f9 43          	cmp    $0x43,%cx
  805546:	76 1e                	jbe    805566 <dhcp_option_trailer+0xa8>
  805548:	eb 39                	jmp    805583 <dhcp_option_trailer+0xc5>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80554a:	c7 44 24 08 84 2b 81 	movl   $0x812b84,0x8(%esp)
  805551:	00 
  805552:	c7 44 24 04 87 05 00 	movl   $0x587,0x4(%esp)
  805559:	00 
  80555a:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  805561:	e8 46 b3 ff ff       	call   8008ac <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  805566:	8b 53 20             	mov    0x20(%ebx),%edx
  805569:	0f b7 c1             	movzwl %cx,%eax
  80556c:	c6 84 02 f0 00 00 00 	movb   $0x0,0xf0(%edx,%eax,1)
  805573:	00 
  805574:	83 c1 01             	add    $0x1,%ecx
  805577:	66 89 4b 24          	mov    %cx,0x24(%ebx)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80557b:	66 83 f9 44          	cmp    $0x44,%cx
  80557f:	74 07                	je     805588 <dhcp_option_trailer+0xca>
  805581:	eb e3                	jmp    805566 <dhcp_option_trailer+0xa8>
  805583:	f6 c1 03             	test   $0x3,%cl
  805586:	75 c2                	jne    80554a <dhcp_option_trailer+0x8c>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  805588:	83 c4 14             	add    $0x14,%esp
  80558b:	5b                   	pop    %ebx
  80558c:	5d                   	pop    %ebp
  80558d:	8d 76 00             	lea    0x0(%esi),%esi
  805590:	c3                   	ret    

00805591 <dhcp_option_long>:
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  805591:	55                   	push   %ebp
  805592:	89 e5                	mov    %esp,%ebp
  805594:	83 ec 28             	sub    $0x28,%esp
  805597:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80559a:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80559d:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8055a0:	89 c6                	mov    %eax,%esi
  8055a2:	89 d7                	mov    %edx,%edi
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  8055a4:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  8055a8:	0f b7 c3             	movzwl %bx,%eax
  8055ab:	83 c0 04             	add    $0x4,%eax
  8055ae:	83 f8 44             	cmp    $0x44,%eax
  8055b1:	76 1c                	jbe    8055cf <dhcp_option_long+0x3e>
  8055b3:	c7 44 24 08 c4 2b 81 	movl   $0x812bc4,0x8(%esp)
  8055ba:	00 
  8055bb:	c7 44 24 04 74 04 00 	movl   $0x474,0x4(%esp)
  8055c2:	00 
  8055c3:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  8055ca:	e8 dd b2 ff ff       	call   8008ac <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  8055cf:	8b 4e 20             	mov    0x20(%esi),%ecx
  8055d2:	0f b7 d3             	movzwl %bx,%edx
  8055d5:	89 f8                	mov    %edi,%eax
  8055d7:	c1 e8 18             	shr    $0x18,%eax
  8055da:	88 84 11 f0 00 00 00 	mov    %al,0xf0(%ecx,%edx,1)
  8055e1:	8d 43 01             	lea    0x1(%ebx),%eax
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  8055e4:	8b 4e 20             	mov    0x20(%esi),%ecx
  8055e7:	0f b7 c0             	movzwl %ax,%eax
  8055ea:	89 fa                	mov    %edi,%edx
  8055ec:	c1 ea 10             	shr    $0x10,%edx
  8055ef:	88 94 01 f0 00 00 00 	mov    %dl,0xf0(%ecx,%eax,1)
  8055f6:	8d 43 02             	lea    0x2(%ebx),%eax
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  8055f9:	8b 4e 20             	mov    0x20(%esi),%ecx
  8055fc:	0f b7 c0             	movzwl %ax,%eax
  8055ff:	89 45 f0             	mov    %eax,-0x10(%ebp)
  805602:	89 f8                	mov    %edi,%eax
  805604:	0f b6 d4             	movzbl %ah,%edx
  805607:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80560a:	88 94 01 f0 00 00 00 	mov    %dl,0xf0(%ecx,%eax,1)
  805611:	8d 43 03             	lea    0x3(%ebx),%eax
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  805614:	8b 56 20             	mov    0x20(%esi),%edx
  805617:	0f b7 c0             	movzwl %ax,%eax
  80561a:	89 f9                	mov    %edi,%ecx
  80561c:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%edx,%eax,1)
  805623:	8d 43 04             	lea    0x4(%ebx),%eax
  805626:	66 89 46 24          	mov    %ax,0x24(%esi)
}
  80562a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80562d:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805630:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805633:	89 ec                	mov    %ebp,%esp
  805635:	5d                   	pop    %ebp
  805636:	c3                   	ret    

00805637 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  805637:	55                   	push   %ebp
  805638:	89 e5                	mov    %esp,%ebp
  80563a:	83 ec 18             	sub    $0x18,%esp
  80563d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805640:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805643:	89 7d fc             	mov    %edi,-0x4(%ebp)
  805646:	89 c6                	mov    %eax,%esi
  805648:	89 d1                	mov    %edx,%ecx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  80564a:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  80564e:	0f b7 c3             	movzwl %bx,%eax
  805651:	83 c0 02             	add    $0x2,%eax
  805654:	83 f8 44             	cmp    $0x44,%eax
  805657:	76 1c                	jbe    805675 <dhcp_option_short+0x3e>
  805659:	c7 44 24 08 04 2c 81 	movl   $0x812c04,0x8(%esp)
  805660:	00 
  805661:	c7 44 24 04 6c 04 00 	movl   $0x46c,0x4(%esp)
  805668:	00 
  805669:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  805670:	e8 37 b2 ff ff       	call   8008ac <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  805675:	0f b7 d3             	movzwl %bx,%edx
  805678:	0f b6 c5             	movzbl %ch,%eax
  80567b:	8b 7e 20             	mov    0x20(%esi),%edi
  80567e:	88 84 17 f0 00 00 00 	mov    %al,0xf0(%edi,%edx,1)
  805685:	8d 43 01             	lea    0x1(%ebx),%eax
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  805688:	8b 56 20             	mov    0x20(%esi),%edx
  80568b:	0f b7 c0             	movzwl %ax,%eax
  80568e:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%edx,%eax,1)
  805695:	8d 43 02             	lea    0x2(%ebx),%eax
  805698:	66 89 46 24          	mov    %ax,0x24(%esi)
}
  80569c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80569f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8056a2:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8056a5:	89 ec                	mov    %ebp,%esp
  8056a7:	5d                   	pop    %ebp
  8056a8:	c3                   	ret    

008056a9 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  8056a9:	55                   	push   %ebp
  8056aa:	89 e5                	mov    %esp,%ebp
  8056ac:	83 ec 18             	sub    $0x18,%esp
  8056af:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8056b2:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8056b5:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8056b8:	89 c3                	mov    %eax,%ebx
  8056ba:	89 d6                	mov    %edx,%esi
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8056bc:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8056c0:	66 83 f9 43          	cmp    $0x43,%cx
  8056c4:	76 1c                	jbe    8056e2 <dhcp_option_byte+0x39>
  8056c6:	c7 44 24 08 48 2c 81 	movl   $0x812c48,0x8(%esp)
  8056cd:	00 
  8056ce:	c7 44 24 04 65 04 00 	movl   $0x465,0x4(%esp)
  8056d5:	00 
  8056d6:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  8056dd:	e8 ca b1 ff ff       	call   8008ac <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  8056e2:	8b 78 20             	mov    0x20(%eax),%edi
  8056e5:	0f b7 d1             	movzwl %cx,%edx
  8056e8:	89 f0                	mov    %esi,%eax
  8056ea:	88 84 17 f0 00 00 00 	mov    %al,0xf0(%edi,%edx,1)
  8056f1:	8d 41 01             	lea    0x1(%ecx),%eax
  8056f4:	66 89 43 24          	mov    %ax,0x24(%ebx)
}
  8056f8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8056fb:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8056fe:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805701:	89 ec                	mov    %ebp,%esp
  805703:	5d                   	pop    %ebp
  805704:	c3                   	ret    

00805705 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  805705:	55                   	push   %ebp
  805706:	89 e5                	mov    %esp,%ebp
  805708:	83 ec 28             	sub    $0x28,%esp
  80570b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80570e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805711:	89 7d fc             	mov    %edi,-0x4(%ebp)
  805714:	89 c3                	mov    %eax,%ebx
  805716:	88 55 ef             	mov    %dl,-0x11(%ebp)
  805719:	89 ce                	mov    %ecx,%esi
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  80571b:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  80571f:	0f b7 c1             	movzwl %cx,%eax
  805722:	89 45 f0             	mov    %eax,-0x10(%ebp)
  805725:	89 f0                	mov    %esi,%eax
  805727:	0f b6 d0             	movzbl %al,%edx
  80572a:	8b 7d f0             	mov    -0x10(%ebp),%edi
  80572d:	8d 44 17 02          	lea    0x2(%edi,%edx,1),%eax
  805731:	83 f8 44             	cmp    $0x44,%eax
  805734:	76 1c                	jbe    805752 <dhcp_option+0x4d>
  805736:	c7 44 24 08 84 2c 81 	movl   $0x812c84,0x8(%esp)
  80573d:	00 
  80573e:	c7 44 24 04 5a 04 00 	movl   $0x45a,0x4(%esp)
  805745:	00 
  805746:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  80574d:	e8 5a b1 ff ff       	call   8008ac <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  805752:	8b 53 20             	mov    0x20(%ebx),%edx
  805755:	0f b7 c1             	movzwl %cx,%eax
  805758:	89 c7                	mov    %eax,%edi
  80575a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
  80575e:	88 84 3a f0 00 00 00 	mov    %al,0xf0(%edx,%edi,1)
  805765:	8d 41 01             	lea    0x1(%ecx),%eax
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  805768:	8b 53 20             	mov    0x20(%ebx),%edx
  80576b:	0f b7 f8             	movzwl %ax,%edi
  80576e:	89 f0                	mov    %esi,%eax
  805770:	88 84 3a f0 00 00 00 	mov    %al,0xf0(%edx,%edi,1)
  805777:	8d 41 02             	lea    0x2(%ecx),%eax
  80577a:	66 89 43 24          	mov    %ax,0x24(%ebx)
}
  80577e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805781:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805784:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805787:	89 ec                	mov    %ebp,%esp
  805789:	5d                   	pop    %ebp
  80578a:	c3                   	ret    

0080578b <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  80578b:	55                   	push   %ebp
  80578c:	89 e5                	mov    %esp,%ebp
  80578e:	53                   	push   %ebx
  80578f:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  805792:	85 c0                	test   %eax,%eax
  805794:	75 1c                	jne    8057b2 <dhcp_delete_request+0x27>
  805796:	c7 44 24 08 cc 2c 81 	movl   $0x812ccc,0x8(%esp)
  80579d:	00 
  80579e:	c7 44 24 04 69 05 00 	movl   $0x569,0x4(%esp)
  8057a5:	00 
  8057a6:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  8057ad:	e8 fa b0 ff ff       	call   8008ac <_panic>
  dhcp = netif->dhcp;
  8057b2:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  8057b5:	85 db                	test   %ebx,%ebx
  8057b7:	75 1c                	jne    8057d5 <dhcp_delete_request+0x4a>
  8057b9:	c7 44 24 08 f0 2c 81 	movl   $0x812cf0,0x8(%esp)
  8057c0:	00 
  8057c1:	c7 44 24 04 6b 05 00 	movl   $0x56b,0x4(%esp)
  8057c8:	00 
  8057c9:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  8057d0:	e8 d7 b0 ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  8057d5:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8057d8:	85 c0                	test   %eax,%eax
  8057da:	75 1c                	jne    8057f8 <dhcp_delete_request+0x6d>
  8057dc:	c7 44 24 08 14 2d 81 	movl   $0x812d14,0x8(%esp)
  8057e3:	00 
  8057e4:	c7 44 24 04 6c 05 00 	movl   $0x56c,0x4(%esp)
  8057eb:	00 
  8057ec:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  8057f3:	e8 b4 b0 ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  8057f8:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  8057fc:	75 1c                	jne    80581a <dhcp_delete_request+0x8f>
  8057fe:	c7 44 24 08 40 2d 81 	movl   $0x812d40,0x8(%esp)
  805805:	00 
  805806:	c7 44 24 04 6d 05 00 	movl   $0x56d,0x4(%esp)
  80580d:	00 
  80580e:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  805815:	e8 92 b0 ff ff       	call   8008ac <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  80581a:	89 04 24             	mov    %eax,(%esp)
  80581d:	e8 51 22 00 00       	call   807a73 <pbuf_free>
  }
  dhcp->p_out = NULL;
  805822:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  805829:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  805830:	83 c4 14             	add    $0x14,%esp
  805833:	5b                   	pop    %ebx
  805834:	5d                   	pop    %ebp
  805835:	c3                   	ret    

00805836 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  805836:	55                   	push   %ebp
  805837:	89 e5                	mov    %esp,%ebp
  805839:	53                   	push   %ebx
  80583a:	83 ec 04             	sub    $0x4,%esp
  80583d:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  80583f:	8b 40 10             	mov    0x10(%eax),%eax
  805842:	85 c0                	test   %eax,%eax
  805844:	74 0f                	je     805855 <dhcp_free_reply+0x1f>
    mem_free((void *)dhcp->msg_in);
  805846:	89 04 24             	mov    %eax,(%esp)
  805849:	e8 38 18 00 00       	call   807086 <mem_free>
    dhcp->msg_in = NULL;
  80584e:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  }
  if (dhcp->options_in) {
  805855:	8b 43 14             	mov    0x14(%ebx),%eax
  805858:	85 c0                	test   %eax,%eax
  80585a:	74 15                	je     805871 <dhcp_free_reply+0x3b>
    mem_free((void *)dhcp->options_in);
  80585c:	89 04 24             	mov    %eax,(%esp)
  80585f:	e8 22 18 00 00       	call   807086 <mem_free>
    dhcp->options_in = NULL;
  805864:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  80586b:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  805871:	83 c4 04             	add    $0x4,%esp
  805874:	5b                   	pop    %ebx
  805875:	5d                   	pop    %ebp
  805876:	c3                   	ret    

00805877 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  805877:	55                   	push   %ebp
  805878:	89 e5                	mov    %esp,%ebp
  80587a:	56                   	push   %esi
  80587b:	53                   	push   %ebx
  80587c:	83 ec 10             	sub    $0x10,%esp
  80587f:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  805882:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  805885:	85 f6                	test   %esi,%esi
  805887:	75 1c                	jne    8058a5 <dhcp_stop+0x2e>
  805889:	c7 44 24 08 97 2e 81 	movl   $0x812e97,0x8(%esp)
  805890:	00 
  805891:	c7 44 24 04 2c 04 00 	movl   $0x42c,0x4(%esp)
  805898:	00 
  805899:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  8058a0:	e8 07 b0 ff ff       	call   8008ac <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  8058a5:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  8058a9:	85 db                	test   %ebx,%ebx
  8058ab:	74 42                	je     8058ef <dhcp_stop+0x78>
    if (dhcp->pcb != NULL) {
  8058ad:	8b 43 08             	mov    0x8(%ebx),%eax
  8058b0:	85 c0                	test   %eax,%eax
  8058b2:	74 0f                	je     8058c3 <dhcp_stop+0x4c>
      udp_remove(dhcp->pcb);
  8058b4:	89 04 24             	mov    %eax,(%esp)
  8058b7:	e8 00 64 00 00       	call   80bcbc <udp_remove>
      dhcp->pcb = NULL;
  8058bc:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    }
    if (dhcp->p != NULL) {
  8058c3:	8b 43 0c             	mov    0xc(%ebx),%eax
  8058c6:	85 c0                	test   %eax,%eax
  8058c8:	74 0f                	je     8058d9 <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  8058ca:	89 04 24             	mov    %eax,(%esp)
  8058cd:	e8 a1 21 00 00       	call   807a73 <pbuf_free>
      dhcp->p = NULL;
  8058d2:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  8058d9:	89 d8                	mov    %ebx,%eax
  8058db:	e8 56 ff ff ff       	call   805836 <dhcp_free_reply>
    mem_free((void *)dhcp);
  8058e0:	89 1c 24             	mov    %ebx,(%esp)
  8058e3:	e8 9e 17 00 00       	call   807086 <mem_free>
    netif->dhcp = NULL;
  8058e8:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  }
}
  8058ef:	83 c4 10             	add    $0x10,%esp
  8058f2:	5b                   	pop    %ebx
  8058f3:	5e                   	pop    %esi
  8058f4:	5d                   	pop    %ebp
  8058f5:	c3                   	ret    

008058f6 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  8058f6:	55                   	push   %ebp
  8058f7:	89 e5                	mov    %esp,%ebp
  8058f9:	57                   	push   %edi
  8058fa:	56                   	push   %esi
  8058fb:	53                   	push   %ebx
  8058fc:	83 ec 1c             	sub    $0x1c,%esp
  8058ff:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  805902:	85 c0                	test   %eax,%eax
  805904:	75 1c                	jne    805922 <dhcp_create_request+0x2c>
  805906:	c7 44 24 08 6c 2d 81 	movl   $0x812d6c,0x8(%esp)
  80590d:	00 
  80590e:	c7 44 24 04 2d 05 00 	movl   $0x52d,0x4(%esp)
  805915:	00 
  805916:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  80591d:	e8 8a af ff ff       	call   8008ac <_panic>
  dhcp = netif->dhcp;
  805922:	8b 45 f0             	mov    -0x10(%ebp),%eax
  805925:	8b 70 20             	mov    0x20(%eax),%esi
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  805928:	85 f6                	test   %esi,%esi
  80592a:	75 1c                	jne    805948 <dhcp_create_request+0x52>
  80592c:	c7 44 24 08 90 2d 81 	movl   $0x812d90,0x8(%esp)
  805933:	00 
  805934:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp)
  80593b:	00 
  80593c:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  805943:	e8 64 af ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  805948:	83 7e 1c 00          	cmpl   $0x0,0x1c(%esi)
  80594c:	74 1c                	je     80596a <dhcp_create_request+0x74>
  80594e:	c7 44 24 08 b4 2d 81 	movl   $0x812db4,0x8(%esp)
  805955:	00 
  805956:	c7 44 24 04 30 05 00 	movl   $0x530,0x4(%esp)
  80595d:	00 
  80595e:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  805965:	e8 42 af ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  80596a:	83 7e 20 00          	cmpl   $0x0,0x20(%esi)
  80596e:	74 1c                	je     80598c <dhcp_create_request+0x96>
  805970:	c7 44 24 08 e0 2d 81 	movl   $0x812de0,0x8(%esp)
  805977:	00 
  805978:	c7 44 24 04 31 05 00 	movl   $0x531,0x4(%esp)
  80597f:	00 
  805980:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  805987:	e8 20 af ff ff       	call   8008ac <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  80598c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805993:	00 
  805994:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  80599b:	00 
  80599c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8059a3:	e8 8e 23 00 00       	call   807d36 <pbuf_alloc>
  8059a8:	89 46 1c             	mov    %eax,0x1c(%esi)
  if (dhcp->p_out == NULL) {
  8059ab:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8059b0:	85 c0                	test   %eax,%eax
  8059b2:	0f 84 2e 01 00 00    	je     805ae6 <dhcp_create_request+0x1f0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  8059b8:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  8059be:	77 1c                	ja     8059dc <dhcp_create_request+0xe6>
  8059c0:	c7 44 24 08 0c 2e 81 	movl   $0x812e0c,0x8(%esp)
  8059c7:	00 
  8059c8:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  8059cf:	00 
  8059d0:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  8059d7:	e8 d0 ae ff ff       	call   8008ac <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  8059dc:	a1 40 80 81 00       	mov    0x818040,%eax
  8059e1:	89 46 04             	mov    %eax,0x4(%esi)
  8059e4:	83 c0 01             	add    $0x1,%eax
  8059e7:	a3 40 80 81 00       	mov    %eax,0x818040
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  8059ec:	8b 46 1c             	mov    0x1c(%esi),%eax
  8059ef:	8b 40 04             	mov    0x4(%eax),%eax
  8059f2:	89 46 20             	mov    %eax,0x20(%esi)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  8059f5:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  8059f8:	8b 46 20             	mov    0x20(%esi),%eax
  8059fb:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  8059ff:	8b 46 20             	mov    0x20(%esi),%eax
  805a02:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  805a06:	8b 46 20             	mov    0x20(%esi),%eax
  805a09:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  805a0d:	8b 5e 20             	mov    0x20(%esi),%ebx
  805a10:	8b 46 04             	mov    0x4(%esi),%eax
  805a13:	89 04 24             	mov    %eax,(%esp)
  805a16:	e8 a1 4e 00 00       	call   80a8bc <htonl>
  805a1b:	89 43 04             	mov    %eax,0x4(%ebx)
  dhcp->msg_out->secs = 0;
  805a1e:	8b 46 20             	mov    0x20(%esi),%eax
  805a21:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  805a27:	8b 46 20             	mov    0x20(%esi),%eax
  805a2a:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  805a30:	8b 56 20             	mov    0x20(%esi),%edx
  805a33:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  805a36:	8b 41 04             	mov    0x4(%ecx),%eax
  805a39:	89 42 0c             	mov    %eax,0xc(%edx)
  dhcp->msg_out->yiaddr.addr = 0;
  805a3c:	8b 46 20             	mov    0x20(%esi),%eax
  805a3f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  805a46:	8b 46 20             	mov    0x20(%esi),%eax
  805a49:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  805a50:	8b 46 20             	mov    0x20(%esi),%eax
  805a53:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  805a5a:	ba 00 00 00 00       	mov    $0x0,%edx
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  805a5f:	8b 5e 20             	mov    0x20(%esi),%ebx
  805a62:	89 d1                	mov    %edx,%ecx
  805a64:	8b 7d f0             	mov    -0x10(%ebp),%edi
  805a67:	0f b6 47 24          	movzbl 0x24(%edi),%eax
  805a6b:	bf 00 00 00 00       	mov    $0x0,%edi
  805a70:	66 39 d0             	cmp    %dx,%ax
  805a73:	76 08                	jbe    805a7d <dhcp_create_request+0x187>
  805a75:	8b 45 f0             	mov    -0x10(%ebp),%eax
  805a78:	0f b6 7c 02 25       	movzbl 0x25(%edx,%eax,1),%edi
  805a7d:	89 f8                	mov    %edi,%eax
  805a7f:	88 44 0b 1c          	mov    %al,0x1c(%ebx,%ecx,1)
  805a83:	83 c2 01             	add    $0x1,%edx
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  805a86:	83 fa 10             	cmp    $0x10,%edx
  805a89:	75 d4                	jne    805a5f <dhcp_create_request+0x169>
  805a8b:	b2 00                	mov    $0x0,%dl
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  805a8d:	8b 46 20             	mov    0x20(%esi),%eax
  805a90:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  805a95:	83 c2 01             	add    $0x1,%edx
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  805a98:	83 fa 40             	cmp    $0x40,%edx
  805a9b:	75 f0                	jne    805a8d <dhcp_create_request+0x197>
  805a9d:	b2 00                	mov    $0x0,%dl
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  805a9f:	8b 46 20             	mov    0x20(%esi),%eax
  805aa2:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  805aa7:	83 c2 01             	add    $0x1,%edx
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  805aaa:	81 fa 80 00 00 00    	cmp    $0x80,%edx
  805ab0:	75 ed                	jne    805a9f <dhcp_create_request+0x1a9>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  805ab2:	8b 5e 20             	mov    0x20(%esi),%ebx
  805ab5:	c7 04 24 63 53 82 63 	movl   $0x63825363,(%esp)
  805abc:	e8 fb 4d 00 00       	call   80a8bc <htonl>
  805ac1:	89 83 ec 00 00 00    	mov    %eax,0xec(%ebx)
  dhcp->options_out_len = 0;
  805ac7:	66 c7 46 24 00 00    	movw   $0x0,0x24(%esi)
  805acd:	ba 00 00 00 00       	mov    $0x0,%edx
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  805ad2:	8b 46 20             	mov    0x20(%esi),%eax
  805ad5:	88 94 02 f0 00 00 00 	mov    %dl,0xf0(%edx,%eax,1)
  805adc:	83 c2 01             	add    $0x1,%edx
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  805adf:	83 fa 44             	cmp    $0x44,%edx
  805ae2:	75 ee                	jne    805ad2 <dhcp_create_request+0x1dc>
  805ae4:	b2 00                	mov    $0x0,%dl
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  805ae6:	89 d0                	mov    %edx,%eax
  805ae8:	83 c4 1c             	add    $0x1c,%esp
  805aeb:	5b                   	pop    %ebx
  805aec:	5e                   	pop    %esi
  805aed:	5f                   	pop    %edi
  805aee:	5d                   	pop    %ebp
  805aef:	c3                   	ret    

00805af0 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  805af0:	55                   	push   %ebp
  805af1:	89 e5                	mov    %esp,%ebp
  805af3:	57                   	push   %edi
  805af4:	56                   	push   %esi
  805af5:	53                   	push   %ebx
  805af6:	83 ec 1c             	sub    $0x1c,%esp
  805af9:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  805afc:	8b 77 20             	mov    0x20(%edi),%esi
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  805aff:	ba 0d 00 00 00       	mov    $0xd,%edx
  805b04:	89 f0                	mov    %esi,%eax
  805b06:	e8 75 f8 ff ff       	call   805380 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  805b0b:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  805b12:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  805b19:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  805b20:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
  805b27:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  805b2e:	c7 46 54 00 00 00 00 	movl   $0x0,0x54(%esi)
  805b35:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
  805b3c:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
  dhcp->dns_count = 0;
  805b43:	c7 46 40 00 00 00 00 	movl   $0x0,0x40(%esi)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805b4a:	89 f8                	mov    %edi,%eax
  805b4c:	e8 a5 fd ff ff       	call   8058f6 <dhcp_create_request>
  805b51:	88 45 f3             	mov    %al,-0xd(%ebp)
  if (result == ERR_OK) {
  805b54:	84 c0                	test   %al,%al
  805b56:	0f 85 81 00 00 00    	jne    805bdd <dhcp_release+0xed>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805b5c:	b9 01 00 00 00       	mov    $0x1,%ecx
  805b61:	ba 35 00 00 00       	mov    $0x35,%edx
  805b66:	89 f0                	mov    %esi,%eax
  805b68:	e8 98 fb ff ff       	call   805705 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  805b6d:	ba 07 00 00 00       	mov    $0x7,%edx
  805b72:	89 f0                	mov    %esi,%eax
  805b74:	e8 30 fb ff ff       	call   8056a9 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  805b79:	89 f0                	mov    %esi,%eax
  805b7b:	e8 3e f9 ff ff       	call   8054be <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805b80:	0f b7 46 24          	movzwl 0x24(%esi),%eax
  805b84:	66 05 f0 00          	add    $0xf0,%ax
  805b88:	0f b7 c0             	movzwl %ax,%eax
  805b8b:	89 44 24 04          	mov    %eax,0x4(%esp)
  805b8f:	8b 46 1c             	mov    0x1c(%esi),%eax
  805b92:	89 04 24             	mov    %eax,(%esp)
  805b95:	e8 68 20 00 00       	call   807c02 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  805b9a:	8d 5e 2c             	lea    0x2c(%esi),%ebx
  805b9d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805ba4:	00 
  805ba5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805ba9:	8b 46 08             	mov    0x8(%esi),%eax
  805bac:	89 04 24             	mov    %eax,(%esp)
  805baf:	e8 2e 62 00 00       	call   80bde2 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  805bb4:	89 7c 24 10          	mov    %edi,0x10(%esp)
  805bb8:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805bbf:	00 
  805bc0:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  805bc4:	8b 46 1c             	mov    0x1c(%esi),%eax
  805bc7:	89 44 24 04          	mov    %eax,0x4(%esp)
  805bcb:	8b 46 08             	mov    0x8(%esi),%eax
  805bce:	89 04 24             	mov    %eax,(%esp)
  805bd1:	e8 93 62 00 00       	call   80be69 <udp_sendto_if>
    dhcp_delete_request(netif);
  805bd6:	89 f8                	mov    %edi,%eax
  805bd8:	e8 ae fb ff ff       	call   80578b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805bdd:	0f b6 46 01          	movzbl 0x1(%esi),%eax
  805be1:	83 c0 01             	add    $0x1,%eax
  805be4:	88 46 01             	mov    %al,0x1(%esi)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  805be7:	ba 10 27 00 00       	mov    $0x2710,%edx
  805bec:	3c 09                	cmp    $0x9,%al
  805bee:	77 08                	ja     805bf8 <dhcp_release+0x108>
  805bf0:	0f b6 c0             	movzbl %al,%eax
  805bf3:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805bf8:	0f b7 d2             	movzwl %dx,%edx
  805bfb:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  805c01:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805c06:	f7 ea                	imul   %edx
  805c08:	c1 fa 05             	sar    $0x5,%edx
  805c0b:	66 89 56 26          	mov    %dx,0x26(%esi)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  805c0f:	89 3c 24             	mov    %edi,(%esp)
  805c12:	e8 71 18 00 00       	call   807488 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  805c17:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  805c1e:	00 
  805c1f:	89 3c 24             	mov    %edi,(%esp)
  805c22:	e8 ba 18 00 00       	call   8074e1 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  805c27:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  805c2e:	00 
  805c2f:	89 3c 24             	mov    %edi,(%esp)
  805c32:	e8 bb 17 00 00       	call   8073f2 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  805c37:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  805c3e:	00 
  805c3f:	89 3c 24             	mov    %edi,(%esp)
  805c42:	e8 c4 17 00 00       	call   80740b <netif_set_netmask>
  805c47:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
  
  /* TODO: netif_down(netif); */
  return result;
}
  805c4b:	83 c4 1c             	add    $0x1c,%esp
  805c4e:	5b                   	pop    %ebx
  805c4f:	5e                   	pop    %esi
  805c50:	5f                   	pop    %edi
  805c51:	5d                   	pop    %ebp
  805c52:	c3                   	ret    

00805c53 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  805c53:	55                   	push   %ebp
  805c54:	89 e5                	mov    %esp,%ebp
  805c56:	83 ec 28             	sub    $0x28,%esp
  805c59:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805c5c:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805c5f:	89 7d fc             	mov    %edi,-0x4(%ebp)
  805c62:	89 c6                	mov    %eax,%esi
  struct dhcp *dhcp = netif->dhcp;
  805c64:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  805c67:	ba 04 00 00 00       	mov    $0x4,%edx
  805c6c:	89 d8                	mov    %ebx,%eax
  805c6e:	e8 0d f7 ff ff       	call   805380 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805c73:	89 f0                	mov    %esi,%eax
  805c75:	e8 7c fc ff ff       	call   8058f6 <dhcp_create_request>
  805c7a:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  805c7c:	84 c0                	test   %al,%al
  805c7e:	0f 85 a3 00 00 00    	jne    805d27 <dhcp_rebind+0xd4>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805c84:	b9 01 00 00 00       	mov    $0x1,%ecx
  805c89:	ba 35 00 00 00       	mov    $0x35,%edx
  805c8e:	89 d8                	mov    %ebx,%eax
  805c90:	e8 70 fa ff ff       	call   805705 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  805c95:	ba 03 00 00 00       	mov    $0x3,%edx
  805c9a:	89 d8                	mov    %ebx,%eax
  805c9c:	e8 08 fa ff ff       	call   8056a9 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805ca1:	b9 02 00 00 00       	mov    $0x2,%ecx
  805ca6:	ba 39 00 00 00       	mov    $0x39,%edx
  805cab:	89 d8                	mov    %ebx,%eax
  805cad:	e8 53 fa ff ff       	call   805705 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  805cb2:	ba 40 02 00 00       	mov    $0x240,%edx
  805cb7:	89 d8                	mov    %ebx,%eax
  805cb9:	e8 79 f9 ff ff       	call   805637 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  805cbe:	89 d8                	mov    %ebx,%eax
  805cc0:	e8 f9 f7 ff ff       	call   8054be <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805cc5:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  805cc9:	66 05 f0 00          	add    $0xf0,%ax
  805ccd:	0f b7 c0             	movzwl %ax,%eax
  805cd0:	89 44 24 04          	mov    %eax,0x4(%esp)
  805cd4:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805cd7:	89 04 24             	mov    %eax,(%esp)
  805cda:	e8 23 1f 00 00       	call   807c02 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  805cdf:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805ce6:	00 
  805ce7:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  805cee:	00 
  805cef:	8b 43 08             	mov    0x8(%ebx),%eax
  805cf2:	89 04 24             	mov    %eax,(%esp)
  805cf5:	e8 e8 60 00 00       	call   80bde2 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  805cfa:	89 74 24 10          	mov    %esi,0x10(%esp)
  805cfe:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805d05:	00 
  805d06:	c7 44 24 08 b4 37 81 	movl   $0x8137b4,0x8(%esp)
  805d0d:	00 
  805d0e:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805d11:	89 44 24 04          	mov    %eax,0x4(%esp)
  805d15:	8b 43 08             	mov    0x8(%ebx),%eax
  805d18:	89 04 24             	mov    %eax,(%esp)
  805d1b:	e8 49 61 00 00       	call   80be69 <udp_sendto_if>
    dhcp_delete_request(netif);
  805d20:	89 f0                	mov    %esi,%eax
  805d22:	e8 64 fa ff ff       	call   80578b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805d27:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  805d2b:	83 c0 01             	add    $0x1,%eax
  805d2e:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  805d31:	ba 10 27 00 00       	mov    $0x2710,%edx
  805d36:	3c 09                	cmp    $0x9,%al
  805d38:	77 08                	ja     805d42 <dhcp_rebind+0xef>
  805d3a:	0f b6 c0             	movzbl %al,%eax
  805d3d:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805d42:	0f b7 d2             	movzwl %dx,%edx
  805d45:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  805d4b:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805d50:	f7 ea                	imul   %edx
  805d52:	c1 fa 05             	sar    $0x5,%edx
  805d55:	66 89 53 26          	mov    %dx,0x26(%ebx)
  805d59:	89 fa                	mov    %edi,%edx
  805d5b:	0f be c2             	movsbl %dl,%eax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  805d5e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805d61:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805d64:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805d67:	89 ec                	mov    %ebp,%esp
  805d69:	5d                   	pop    %ebp
  805d6a:	c3                   	ret    

00805d6b <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  805d6b:	55                   	push   %ebp
  805d6c:	89 e5                	mov    %esp,%ebp
  805d6e:	83 ec 28             	sub    $0x28,%esp
  805d71:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805d74:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805d77:	89 7d fc             	mov    %edi,-0x4(%ebp)
  805d7a:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  805d7d:	8b 77 20             	mov    0x20(%edi),%esi
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  805d80:	ba 05 00 00 00       	mov    $0x5,%edx
  805d85:	89 f0                	mov    %esi,%eax
  805d87:	e8 f4 f5 ff ff       	call   805380 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805d8c:	89 f8                	mov    %edi,%eax
  805d8e:	e8 63 fb ff ff       	call   8058f6 <dhcp_create_request>
  805d93:	88 45 f3             	mov    %al,-0xd(%ebp)
  if (result == ERR_OK) {
  805d96:	84 c0                	test   %al,%al
  805d98:	0f 85 9e 00 00 00    	jne    805e3c <dhcp_renew+0xd1>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805d9e:	b9 01 00 00 00       	mov    $0x1,%ecx
  805da3:	ba 35 00 00 00       	mov    $0x35,%edx
  805da8:	89 f0                	mov    %esi,%eax
  805daa:	e8 56 f9 ff ff       	call   805705 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  805daf:	ba 03 00 00 00       	mov    $0x3,%edx
  805db4:	89 f0                	mov    %esi,%eax
  805db6:	e8 ee f8 ff ff       	call   8056a9 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805dbb:	b9 02 00 00 00       	mov    $0x2,%ecx
  805dc0:	ba 39 00 00 00       	mov    $0x39,%edx
  805dc5:	89 f0                	mov    %esi,%eax
  805dc7:	e8 39 f9 ff ff       	call   805705 <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  805dcc:	ba 40 02 00 00       	mov    $0x240,%edx
  805dd1:	89 f0                	mov    %esi,%eax
  805dd3:	e8 5f f8 ff ff       	call   805637 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  805dd8:	89 f0                	mov    %esi,%eax
  805dda:	e8 df f6 ff ff       	call   8054be <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805ddf:	0f b7 46 24          	movzwl 0x24(%esi),%eax
  805de3:	66 05 f0 00          	add    $0xf0,%ax
  805de7:	0f b7 c0             	movzwl %ax,%eax
  805dea:	89 44 24 04          	mov    %eax,0x4(%esp)
  805dee:	8b 46 1c             	mov    0x1c(%esi),%eax
  805df1:	89 04 24             	mov    %eax,(%esp)
  805df4:	e8 09 1e 00 00       	call   807c02 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  805df9:	8d 5e 2c             	lea    0x2c(%esi),%ebx
  805dfc:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805e03:	00 
  805e04:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805e08:	8b 46 08             	mov    0x8(%esi),%eax
  805e0b:	89 04 24             	mov    %eax,(%esp)
  805e0e:	e8 cf 5f 00 00       	call   80bde2 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  805e13:	89 7c 24 10          	mov    %edi,0x10(%esp)
  805e17:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805e1e:	00 
  805e1f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  805e23:	8b 46 1c             	mov    0x1c(%esi),%eax
  805e26:	89 44 24 04          	mov    %eax,0x4(%esp)
  805e2a:	8b 46 08             	mov    0x8(%esi),%eax
  805e2d:	89 04 24             	mov    %eax,(%esp)
  805e30:	e8 34 60 00 00       	call   80be69 <udp_sendto_if>
    dhcp_delete_request(netif);
  805e35:	89 f8                	mov    %edi,%eax
  805e37:	e8 4f f9 ff ff       	call   80578b <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805e3c:	0f b6 46 01          	movzbl 0x1(%esi),%eax
  805e40:	83 c0 01             	add    $0x1,%eax
  805e43:	88 46 01             	mov    %al,0x1(%esi)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  805e46:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  805e4b:	3c 09                	cmp    $0x9,%al
  805e4d:	77 08                	ja     805e57 <dhcp_renew+0xec>
  805e4f:	0f b6 c0             	movzbl %al,%eax
  805e52:	66 69 d0 d0 07       	imul   $0x7d0,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805e57:	0f b7 d2             	movzwl %dx,%edx
  805e5a:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  805e60:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805e65:	f7 ea                	imul   %edx
  805e67:	c1 fa 05             	sar    $0x5,%edx
  805e6a:	66 89 56 26          	mov    %dx,0x26(%esi)
  805e6e:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  805e72:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805e75:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805e78:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805e7b:	89 ec                	mov    %ebp,%esp
  805e7d:	5d                   	pop    %ebp
  805e7e:	c3                   	ret    

00805e7f <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  805e7f:	55                   	push   %ebp
  805e80:	89 e5                	mov    %esp,%ebp
  805e82:	53                   	push   %ebx
  805e83:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  805e86:	8b 1d c0 e5 b3 00    	mov    0xb3e5c0,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  805e8c:	85 db                	test   %ebx,%ebx
  805e8e:	74 6b                	je     805efb <dhcp_coarse_tmr+0x7c>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  805e90:	8b 53 20             	mov    0x20(%ebx),%edx
  805e93:	85 d2                	test   %edx,%edx
  805e95:	74 5e                	je     805ef5 <dhcp_coarse_tmr+0x76>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  805e97:	0f b7 42 2a          	movzwl 0x2a(%edx),%eax
  805e9b:	83 e8 01             	sub    $0x1,%eax
  805e9e:	66 89 42 2a          	mov    %ax,0x2a(%edx)
  805ea2:	66 85 c0             	test   %ax,%ax
  805ea5:	75 20                	jne    805ec7 <dhcp_coarse_tmr+0x48>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  805ea7:	8b 43 20             	mov    0x20(%ebx),%eax
  805eaa:	0f b6 00             	movzbl (%eax),%eax
  805ead:	3c 01                	cmp    $0x1,%al
  805eaf:	74 08                	je     805eb9 <dhcp_coarse_tmr+0x3a>
  805eb1:	3c 0a                	cmp    $0xa,%al
  805eb3:	74 04                	je     805eb9 <dhcp_coarse_tmr+0x3a>
  805eb5:	3c 05                	cmp    $0x5,%al
  805eb7:	75 3c                	jne    805ef5 <dhcp_coarse_tmr+0x76>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  805eb9:	89 d8                	mov    %ebx,%eax
  805ebb:	90                   	nop    
  805ebc:	8d 74 26 00          	lea    0x0(%esi),%esi
  805ec0:	e8 8e fd ff ff       	call   805c53 <dhcp_rebind>
  805ec5:	eb 2e                	jmp    805ef5 <dhcp_coarse_tmr+0x76>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  805ec7:	8b 43 20             	mov    0x20(%ebx),%eax
  805eca:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  805ece:	83 ea 01             	sub    $0x1,%edx
  805ed1:	66 89 50 28          	mov    %dx,0x28(%eax)
  805ed5:	66 85 d2             	test   %dx,%dx
  805ed8:	75 1b                	jne    805ef5 <dhcp_coarse_tmr+0x76>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  805eda:	8b 43 20             	mov    0x20(%ebx),%eax
  805edd:	0f b6 00             	movzbl (%eax),%eax
  805ee0:	3c 01                	cmp    $0x1,%al
  805ee2:	74 08                	je     805eec <dhcp_coarse_tmr+0x6d>
  805ee4:	3c 0a                	cmp    $0xa,%al
  805ee6:	74 04                	je     805eec <dhcp_coarse_tmr+0x6d>
  805ee8:	3c 05                	cmp    $0x5,%al
  805eea:	75 09                	jne    805ef5 <dhcp_coarse_tmr+0x76>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  805eec:	89 1c 24             	mov    %ebx,(%esp)
  805eef:	90                   	nop    
  805ef0:	e8 76 fe ff ff       	call   805d6b <dhcp_renew>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  805ef5:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  805ef7:	85 db                	test   %ebx,%ebx
  805ef9:	75 95                	jne    805e90 <dhcp_coarse_tmr+0x11>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  805efb:	83 c4 04             	add    $0x4,%esp
  805efe:	5b                   	pop    %ebx
  805eff:	5d                   	pop    %ebp
  805f00:	c3                   	ret    

00805f01 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  805f01:	55                   	push   %ebp
  805f02:	89 e5                	mov    %esp,%ebp
  805f04:	57                   	push   %edi
  805f05:	56                   	push   %esi
  805f06:	53                   	push   %ebx
  805f07:	83 ec 1c             	sub    $0x1c,%esp
  805f0a:	89 c6                	mov    %eax,%esi
  struct dhcp *dhcp = netif->dhcp;
  805f0c:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  805f0f:	a1 b0 37 81 00       	mov    0x8137b0,%eax
  805f14:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805f17:	89 f0                	mov    %esi,%eax
  805f19:	e8 d8 f9 ff ff       	call   8058f6 <dhcp_create_request>
  805f1e:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  805f20:	84 c0                	test   %al,%al
  805f22:	0f 85 f0 00 00 00    	jne    806018 <dhcp_discover+0x117>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805f28:	b9 01 00 00 00       	mov    $0x1,%ecx
  805f2d:	ba 35 00 00 00       	mov    $0x35,%edx
  805f32:	89 d8                	mov    %ebx,%eax
  805f34:	e8 cc f7 ff ff       	call   805705 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  805f39:	ba 01 00 00 00       	mov    $0x1,%edx
  805f3e:	89 d8                	mov    %ebx,%eax
  805f40:	e8 64 f7 ff ff       	call   8056a9 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805f45:	b9 02 00 00 00       	mov    $0x2,%ecx
  805f4a:	ba 39 00 00 00       	mov    $0x39,%edx
  805f4f:	89 d8                	mov    %ebx,%eax
  805f51:	e8 af f7 ff ff       	call   805705 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  805f56:	ba 40 02 00 00       	mov    $0x240,%edx
  805f5b:	89 d8                	mov    %ebx,%eax
  805f5d:	e8 d5 f6 ff ff       	call   805637 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  805f62:	b9 04 00 00 00       	mov    $0x4,%ecx
  805f67:	ba 37 00 00 00       	mov    $0x37,%edx
  805f6c:	89 d8                	mov    %ebx,%eax
  805f6e:	e8 92 f7 ff ff       	call   805705 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  805f73:	ba 01 00 00 00       	mov    $0x1,%edx
  805f78:	89 d8                	mov    %ebx,%eax
  805f7a:	e8 2a f7 ff ff       	call   8056a9 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  805f7f:	ba 03 00 00 00       	mov    $0x3,%edx
  805f84:	89 d8                	mov    %ebx,%eax
  805f86:	e8 1e f7 ff ff       	call   8056a9 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  805f8b:	ba 1c 00 00 00       	mov    $0x1c,%edx
  805f90:	89 d8                	mov    %ebx,%eax
  805f92:	e8 12 f7 ff ff       	call   8056a9 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  805f97:	ba 06 00 00 00       	mov    $0x6,%edx
  805f9c:	89 d8                	mov    %ebx,%eax
  805f9e:	e8 06 f7 ff ff       	call   8056a9 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  805fa3:	89 d8                	mov    %ebx,%eax
  805fa5:	e8 14 f5 ff ff       	call   8054be <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805faa:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  805fae:	66 05 f0 00          	add    $0xf0,%ax
  805fb2:	0f b7 c0             	movzwl %ax,%eax
  805fb5:	89 44 24 04          	mov    %eax,0x4(%esp)
  805fb9:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805fbc:	89 04 24             	mov    %eax,(%esp)
  805fbf:	e8 3e 1c 00 00       	call   807c02 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  805fc4:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805fcb:	00 
  805fcc:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  805fd3:	00 
  805fd4:	8b 43 08             	mov    0x8(%ebx),%eax
  805fd7:	89 04 24             	mov    %eax,(%esp)
  805fda:	e8 03 5e 00 00       	call   80bde2 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  805fdf:	89 74 24 10          	mov    %esi,0x10(%esp)
  805fe3:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805fea:	00 
  805feb:	c7 44 24 08 b4 37 81 	movl   $0x8137b4,0x8(%esp)
  805ff2:	00 
  805ff3:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805ff6:	89 44 24 04          	mov    %eax,0x4(%esp)
  805ffa:	8b 43 08             	mov    0x8(%ebx),%eax
  805ffd:	89 04 24             	mov    %eax,(%esp)
  806000:	e8 64 5e 00 00       	call   80be69 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  806005:	89 f0                	mov    %esi,%eax
  806007:	e8 7f f7 ff ff       	call   80578b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  80600c:	ba 06 00 00 00       	mov    $0x6,%edx
  806011:	89 d8                	mov    %ebx,%eax
  806013:	e8 68 f3 ff ff       	call   805380 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  806018:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  80601c:	83 c0 01             	add    $0x1,%eax
  80601f:	88 43 01             	mov    %al,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  806022:	ba 10 27 00 00       	mov    $0x2710,%edx
  806027:	3c 03                	cmp    $0x3,%al
  806029:	77 0b                	ja     806036 <dhcp_discover+0x135>
  80602b:	0f b6 c0             	movzbl %al,%eax
  80602e:	83 c0 01             	add    $0x1,%eax
  806031:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  806036:	0f b7 d2             	movzwl %dx,%edx
  806039:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  80603f:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  806044:	f7 ea                	imul   %edx
  806046:	c1 fa 05             	sar    $0x5,%edx
  806049:	66 89 53 26          	mov    %dx,0x26(%ebx)
  80604d:	89 fa                	mov    %edi,%edx
  80604f:	0f be c2             	movsbl %dl,%eax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  806052:	83 c4 1c             	add    $0x1c,%esp
  806055:	5b                   	pop    %ebx
  806056:	5e                   	pop    %esi
  806057:	5f                   	pop    %edi
  806058:	5d                   	pop    %ebp
  806059:	c3                   	ret    

0080605a <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  80605a:	55                   	push   %ebp
  80605b:	89 e5                	mov    %esp,%ebp
  80605d:	83 ec 28             	sub    $0x28,%esp
  806060:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  806063:	89 75 fc             	mov    %esi,-0x4(%ebp)
  806066:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  806069:	85 f6                	test   %esi,%esi
  80606b:	75 1c                	jne    806089 <dhcp_arp_reply+0x2f>
  80606d:	c7 44 24 08 bb 2e 81 	movl   $0x812ebb,0x8(%esp)
  806074:	00 
  806075:	c7 44 24 04 b5 02 00 	movl   $0x2b5,0x4(%esp)
  80607c:	00 
  80607d:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  806084:	e8 23 a8 ff ff       	call   8008ac <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  806089:	8b 5e 20             	mov    0x20(%esi),%ebx
  80608c:	85 db                	test   %ebx,%ebx
  80608e:	0f 84 04 01 00 00    	je     806198 <dhcp_arp_reply+0x13e>
  806094:	80 3b 08             	cmpb   $0x8,(%ebx)
  806097:	0f 85 fb 00 00 00    	jne    806198 <dhcp_arp_reply+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  80609d:	8b 55 0c             	mov    0xc(%ebp),%edx
  8060a0:	8b 02                	mov    (%edx),%eax
  8060a2:	3b 43 30             	cmp    0x30(%ebx),%eax
  8060a5:	0f 85 ed 00 00 00    	jne    806198 <dhcp_arp_reply+0x13e>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8060ab:	ba 0c 00 00 00       	mov    $0xc,%edx
  8060b0:	89 d8                	mov    %ebx,%eax
  8060b2:	e8 c9 f2 ff ff       	call   805380 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8060b7:	89 f0                	mov    %esi,%eax
  8060b9:	e8 38 f8 ff ff       	call   8058f6 <dhcp_create_request>
  if (result == ERR_OK) {
  8060be:	84 c0                	test   %al,%al
  8060c0:	0f 85 c8 00 00 00    	jne    80618e <dhcp_arp_reply+0x134>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8060c6:	b9 01 00 00 00       	mov    $0x1,%ecx
  8060cb:	ba 35 00 00 00       	mov    $0x35,%edx
  8060d0:	89 d8                	mov    %ebx,%eax
  8060d2:	e8 2e f6 ff ff       	call   805705 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  8060d7:	ba 04 00 00 00       	mov    $0x4,%edx
  8060dc:	89 d8                	mov    %ebx,%eax
  8060de:	e8 c6 f5 ff ff       	call   8056a9 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8060e3:	b9 02 00 00 00       	mov    $0x2,%ecx
  8060e8:	ba 39 00 00 00       	mov    $0x39,%edx
  8060ed:	89 d8                	mov    %ebx,%eax
  8060ef:	e8 11 f6 ff ff       	call   805705 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8060f4:	ba 40 02 00 00       	mov    $0x240,%edx
  8060f9:	89 d8                	mov    %ebx,%eax
  8060fb:	e8 37 f5 ff ff       	call   805637 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  806100:	b9 04 00 00 00       	mov    $0x4,%ecx
  806105:	ba 32 00 00 00       	mov    $0x32,%edx
  80610a:	89 d8                	mov    %ebx,%eax
  80610c:	e8 f4 f5 ff ff       	call   805705 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  806111:	8b 43 30             	mov    0x30(%ebx),%eax
  806114:	89 04 24             	mov    %eax,(%esp)
  806117:	e8 d4 49 00 00       	call   80aaf0 <ntohl>
  80611c:	89 c2                	mov    %eax,%edx
  80611e:	89 d8                	mov    %ebx,%eax
  806120:	e8 6c f4 ff ff       	call   805591 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  806125:	89 d8                	mov    %ebx,%eax
  806127:	e8 92 f3 ff ff       	call   8054be <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80612c:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  806130:	66 05 f0 00          	add    $0xf0,%ax
  806134:	0f b7 c0             	movzwl %ax,%eax
  806137:	89 44 24 04          	mov    %eax,0x4(%esp)
  80613b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80613e:	89 04 24             	mov    %eax,(%esp)
  806141:	e8 bc 1a 00 00       	call   807c02 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806146:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80614d:	00 
  80614e:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  806155:	00 
  806156:	8b 43 08             	mov    0x8(%ebx),%eax
  806159:	89 04 24             	mov    %eax,(%esp)
  80615c:	e8 81 5c 00 00       	call   80bde2 <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806161:	89 74 24 10          	mov    %esi,0x10(%esp)
  806165:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80616c:	00 
  80616d:	c7 44 24 08 b4 37 81 	movl   $0x8137b4,0x8(%esp)
  806174:	00 
  806175:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806178:	89 44 24 04          	mov    %eax,0x4(%esp)
  80617c:	8b 43 08             	mov    0x8(%ebx),%eax
  80617f:	89 04 24             	mov    %eax,(%esp)
  806182:	e8 e2 5c 00 00       	call   80be69 <udp_sendto_if>
    dhcp_delete_request(netif);
  806187:	89 f0                	mov    %esi,%eax
  806189:	e8 fd f5 ff ff       	call   80578b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80618e:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  806192:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  806198:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80619b:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80619e:	89 ec                	mov    %ebp,%esp
  8061a0:	5d                   	pop    %ebp
  8061a1:	c3                   	ret    

008061a2 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  8061a2:	55                   	push   %ebp
  8061a3:	89 e5                	mov    %esp,%ebp
  8061a5:	57                   	push   %edi
  8061a6:	56                   	push   %esi
  8061a7:	53                   	push   %ebx
  8061a8:	83 ec 1c             	sub    $0x1c,%esp
  8061ab:	89 c6                	mov    %eax,%esi
  struct dhcp *dhcp = netif->dhcp;
  8061ad:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8061b0:	e8 41 f7 ff ff       	call   8058f6 <dhcp_create_request>
  8061b5:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  8061b7:	84 c0                	test   %al,%al
  8061b9:	0f 85 3a 01 00 00    	jne    8062f9 <dhcp_select+0x157>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8061bf:	b9 01 00 00 00       	mov    $0x1,%ecx
  8061c4:	ba 35 00 00 00       	mov    $0x35,%edx
  8061c9:	89 d8                	mov    %ebx,%eax
  8061cb:	e8 35 f5 ff ff       	call   805705 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8061d0:	ba 03 00 00 00       	mov    $0x3,%edx
  8061d5:	89 d8                	mov    %ebx,%eax
  8061d7:	e8 cd f4 ff ff       	call   8056a9 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8061dc:	b9 02 00 00 00       	mov    $0x2,%ecx
  8061e1:	ba 39 00 00 00       	mov    $0x39,%edx
  8061e6:	89 d8                	mov    %ebx,%eax
  8061e8:	e8 18 f5 ff ff       	call   805705 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8061ed:	ba 40 02 00 00       	mov    $0x240,%edx
  8061f2:	89 d8                	mov    %ebx,%eax
  8061f4:	e8 3e f4 ff ff       	call   805637 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8061f9:	b9 04 00 00 00       	mov    $0x4,%ecx
  8061fe:	ba 32 00 00 00       	mov    $0x32,%edx
  806203:	89 d8                	mov    %ebx,%eax
  806205:	e8 fb f4 ff ff       	call   805705 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80620a:	8b 43 30             	mov    0x30(%ebx),%eax
  80620d:	89 04 24             	mov    %eax,(%esp)
  806210:	e8 db 48 00 00       	call   80aaf0 <ntohl>
  806215:	89 c2                	mov    %eax,%edx
  806217:	89 d8                	mov    %ebx,%eax
  806219:	e8 73 f3 ff ff       	call   805591 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  80621e:	b9 04 00 00 00       	mov    $0x4,%ecx
  806223:	ba 36 00 00 00       	mov    $0x36,%edx
  806228:	89 d8                	mov    %ebx,%eax
  80622a:	e8 d6 f4 ff ff       	call   805705 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  80622f:	8b 43 2c             	mov    0x2c(%ebx),%eax
  806232:	89 04 24             	mov    %eax,(%esp)
  806235:	e8 b6 48 00 00       	call   80aaf0 <ntohl>
  80623a:	89 c2                	mov    %eax,%edx
  80623c:	89 d8                	mov    %ebx,%eax
  80623e:	e8 4e f3 ff ff       	call   805591 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  806243:	b9 04 00 00 00       	mov    $0x4,%ecx
  806248:	ba 37 00 00 00       	mov    $0x37,%edx
  80624d:	89 d8                	mov    %ebx,%eax
  80624f:	e8 b1 f4 ff ff       	call   805705 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  806254:	ba 01 00 00 00       	mov    $0x1,%edx
  806259:	89 d8                	mov    %ebx,%eax
  80625b:	e8 49 f4 ff ff       	call   8056a9 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  806260:	ba 03 00 00 00       	mov    $0x3,%edx
  806265:	89 d8                	mov    %ebx,%eax
  806267:	e8 3d f4 ff ff       	call   8056a9 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80626c:	ba 1c 00 00 00       	mov    $0x1c,%edx
  806271:	89 d8                	mov    %ebx,%eax
  806273:	e8 31 f4 ff ff       	call   8056a9 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  806278:	ba 06 00 00 00       	mov    $0x6,%edx
  80627d:	89 d8                	mov    %ebx,%eax
  80627f:	e8 25 f4 ff ff       	call   8056a9 <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  806284:	89 d8                	mov    %ebx,%eax
  806286:	e8 33 f2 ff ff       	call   8054be <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80628b:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80628f:	66 05 f0 00          	add    $0xf0,%ax
  806293:	0f b7 c0             	movzwl %ax,%eax
  806296:	89 44 24 04          	mov    %eax,0x4(%esp)
  80629a:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80629d:	89 04 24             	mov    %eax,(%esp)
  8062a0:	e8 5d 19 00 00       	call   807c02 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8062a5:	89 74 24 10          	mov    %esi,0x10(%esp)
  8062a9:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8062b0:	00 
  8062b1:	c7 44 24 08 b4 37 81 	movl   $0x8137b4,0x8(%esp)
  8062b8:	00 
  8062b9:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8062bc:	89 44 24 04          	mov    %eax,0x4(%esp)
  8062c0:	8b 43 08             	mov    0x8(%ebx),%eax
  8062c3:	89 04 24             	mov    %eax,(%esp)
  8062c6:	e8 9e 5b 00 00       	call   80be69 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8062cb:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8062d2:	00 
  8062d3:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  8062da:	00 
  8062db:	8b 43 08             	mov    0x8(%ebx),%eax
  8062de:	89 04 24             	mov    %eax,(%esp)
  8062e1:	e8 fc 5a 00 00       	call   80bde2 <udp_connect>
    dhcp_delete_request(netif);
  8062e6:	89 f0                	mov    %esi,%eax
  8062e8:	e8 9e f4 ff ff       	call   80578b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8062ed:	ba 01 00 00 00       	mov    $0x1,%edx
  8062f2:	89 d8                	mov    %ebx,%eax
  8062f4:	e8 87 f0 ff ff       	call   805380 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8062f9:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8062fd:	83 c0 01             	add    $0x1,%eax
  806300:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  806303:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  806308:	3c 03                	cmp    $0x3,%al
  80630a:	77 08                	ja     806314 <dhcp_select+0x172>
  80630c:	0f b6 c0             	movzbl %al,%eax
  80630f:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  806314:	0f b7 d2             	movzwl %dx,%edx
  806317:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  80631d:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  806322:	f7 ea                	imul   %edx
  806324:	c1 fa 05             	sar    $0x5,%edx
  806327:	66 89 53 26          	mov    %dx,0x26(%ebx)
  80632b:	89 fa                	mov    %edi,%edx
  80632d:	0f be c2             	movsbl %dl,%eax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  806330:	83 c4 1c             	add    $0x1c,%esp
  806333:	5b                   	pop    %ebx
  806334:	5e                   	pop    %esi
  806335:	5f                   	pop    %edi
  806336:	5d                   	pop    %ebp
  806337:	c3                   	ret    

00806338 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  806338:	55                   	push   %ebp
  806339:	89 e5                	mov    %esp,%ebp
  80633b:	83 ec 28             	sub    $0x28,%esp
  80633e:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  806341:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806344:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806347:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  80634a:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  80634d:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  806354:	e8 87 09 00 00       	call   806ce0 <mem_malloc>
  if (dhcp == NULL) {
  806359:	85 c0                	test   %eax,%eax
  80635b:	0f 84 3f 01 00 00    	je     8064a0 <dhcp_inform+0x168>
void
dhcp_inform(struct netif *netif)
{
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  806361:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  806363:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  806366:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  80636d:	00 
  80636e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806375:	00 
  806376:	89 04 24             	mov    %eax,(%esp)
  806379:	e8 10 ae ff ff       	call   80118e <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  80637e:	e8 fc 58 00 00       	call   80bc7f <udp_new>
  806383:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  806386:	85 c0                	test   %eax,%eax
  806388:	75 0d                	jne    806397 <dhcp_inform+0x5f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  80638a:	89 1c 24             	mov    %ebx,(%esp)
  80638d:	e8 f4 0c 00 00       	call   807086 <mem_free>
  806392:	e9 09 01 00 00       	jmp    8064a0 <dhcp_inform+0x168>
    return;
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  806397:	89 f0                	mov    %esi,%eax
  806399:	e8 58 f5 ff ff       	call   8058f6 <dhcp_create_request>
  if (result == ERR_OK) {
  80639e:	84 c0                	test   %al,%al
  8063a0:	0f 85 d9 00 00 00    	jne    80647f <dhcp_inform+0x147>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8063a6:	b9 01 00 00 00       	mov    $0x1,%ecx
  8063ab:	ba 35 00 00 00       	mov    $0x35,%edx
  8063b0:	89 d8                	mov    %ebx,%eax
  8063b2:	e8 4e f3 ff ff       	call   805705 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  8063b7:	ba 08 00 00 00       	mov    $0x8,%edx
  8063bc:	89 d8                	mov    %ebx,%eax
  8063be:	e8 e6 f2 ff ff       	call   8056a9 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8063c3:	b9 02 00 00 00       	mov    $0x2,%ecx
  8063c8:	ba 39 00 00 00       	mov    $0x39,%edx
  8063cd:	89 d8                	mov    %ebx,%eax
  8063cf:	e8 31 f3 ff ff       	call   805705 <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  8063d4:	ba 40 02 00 00       	mov    $0x240,%edx
  8063d9:	89 d8                	mov    %ebx,%eax
  8063db:	e8 57 f2 ff ff       	call   805637 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  8063e0:	89 d8                	mov    %ebx,%eax
  8063e2:	e8 d7 f0 ff ff       	call   8054be <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8063e7:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8063eb:	66 05 f0 00          	add    $0xf0,%ax
  8063ef:	0f b7 c0             	movzwl %ax,%eax
  8063f2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8063f6:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8063f9:	89 04 24             	mov    %eax,(%esp)
  8063fc:	e8 01 18 00 00       	call   807c02 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  806401:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  806408:	00 
  806409:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  806410:	00 
  806411:	8b 43 08             	mov    0x8(%ebx),%eax
  806414:	89 04 24             	mov    %eax,(%esp)
  806417:	e8 ec 58 00 00       	call   80bd08 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  80641c:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806423:	00 
  806424:	c7 44 24 04 b4 37 81 	movl   $0x8137b4,0x4(%esp)
  80642b:	00 
  80642c:	8b 43 08             	mov    0x8(%ebx),%eax
  80642f:	89 04 24             	mov    %eax,(%esp)
  806432:	e8 ab 59 00 00       	call   80bde2 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806437:	89 74 24 10          	mov    %esi,0x10(%esp)
  80643b:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806442:	00 
  806443:	c7 44 24 08 b4 37 81 	movl   $0x8137b4,0x8(%esp)
  80644a:	00 
  80644b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80644e:	89 44 24 04          	mov    %eax,0x4(%esp)
  806452:	8b 43 08             	mov    0x8(%ebx),%eax
  806455:	89 04 24             	mov    %eax,(%esp)
  806458:	e8 0c 5a 00 00       	call   80be69 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80645d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806464:	00 
  806465:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  80646c:	00 
  80646d:	8b 43 08             	mov    0x8(%ebx),%eax
  806470:	89 04 24             	mov    %eax,(%esp)
  806473:	e8 6a 59 00 00       	call   80bde2 <udp_connect>
    dhcp_delete_request(netif);
  806478:	89 f0                	mov    %esi,%eax
  80647a:	e8 0c f3 ff ff       	call   80578b <dhcp_delete_request>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  80647f:	8b 43 08             	mov    0x8(%ebx),%eax
  806482:	85 c0                	test   %eax,%eax
  806484:	74 08                	je     80648e <dhcp_inform+0x156>
      udp_remove(dhcp->pcb);
  806486:	89 04 24             	mov    %eax,(%esp)
  806489:	e8 2e 58 00 00       	call   80bcbc <udp_remove>
    }
    dhcp->pcb = NULL;
  80648e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  806495:	89 1c 24             	mov    %ebx,(%esp)
  806498:	e8 e9 0b 00 00       	call   807086 <mem_free>
    netif->dhcp = old_dhcp;
  80649d:	89 7e 20             	mov    %edi,0x20(%esi)
  }
}
  8064a0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8064a3:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8064a6:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8064a9:	89 ec                	mov    %ebp,%esp
  8064ab:	5d                   	pop    %ebp
  8064ac:	c3                   	ret    

008064ad <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  8064ad:	55                   	push   %ebp
  8064ae:	89 e5                	mov    %esp,%ebp
  8064b0:	56                   	push   %esi
  8064b1:	53                   	push   %ebx
  8064b2:	83 ec 10             	sub    $0x10,%esp
  8064b5:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  8064b8:	85 f6                	test   %esi,%esi
  8064ba:	75 1c                	jne    8064d8 <dhcp_start+0x2b>
  8064bc:	c7 44 24 08 bb 2e 81 	movl   $0x812ebb,0x8(%esp)
  8064c3:	00 
  8064c4:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  8064cb:	00 
  8064cc:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  8064d3:	e8 d4 a3 ff ff       	call   8008ac <_panic>
  dhcp = netif->dhcp;
  8064d8:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  8064db:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  8064df:	85 db                	test   %ebx,%ebx
  8064e1:	75 20                	jne    806503 <dhcp_start+0x56>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  8064e3:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  8064ea:	e8 f1 07 00 00       	call   806ce0 <mem_malloc>
  8064ef:	89 c2                	mov    %eax,%edx
    if (dhcp == NULL) {
  8064f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8064f6:	85 d2                	test   %edx,%edx
  8064f8:	0f 84 ad 00 00 00    	je     8065ab <dhcp_start+0xfe>
  netif->flags &= ~NETIF_FLAG_DHCP;

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  8064fe:	89 d3                	mov    %edx,%ebx
    if (dhcp == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  806500:	89 56 20             	mov    %edx,0x20(%esi)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  806503:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  80650a:	00 
  80650b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806512:	00 
  806513:	89 1c 24             	mov    %ebx,(%esp)
  806516:	e8 73 ac ff ff       	call   80118e <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  80651b:	e8 5f 57 00 00       	call   80bc7f <udp_new>
  806520:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  806523:	85 c0                	test   %eax,%eax
  806525:	75 16                	jne    80653d <dhcp_start+0x90>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  806527:	89 1c 24             	mov    %ebx,(%esp)
  80652a:	e8 57 0b 00 00       	call   807086 <mem_free>
    netif->dhcp = dhcp = NULL;
  80652f:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  806536:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80653b:	eb 6e                	jmp    8065ab <dhcp_start+0xfe>
    return ERR_MEM;
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80653d:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  806544:	00 
  806545:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  80654c:	00 
  80654d:	89 04 24             	mov    %eax,(%esp)
  806550:	e8 b3 57 00 00       	call   80bd08 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806555:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80655c:	00 
  80655d:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  806564:	00 
  806565:	8b 43 08             	mov    0x8(%ebx),%eax
  806568:	89 04 24             	mov    %eax,(%esp)
  80656b:	e8 72 58 00 00       	call   80bde2 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  806570:	89 74 24 08          	mov    %esi,0x8(%esp)
  806574:	c7 44 24 04 83 67 80 	movl   $0x806783,0x4(%esp)
  80657b:	00 
  80657c:	8b 43 08             	mov    0x8(%ebx),%eax
  80657f:	89 04 24             	mov    %eax,(%esp)
  806582:	e8 e4 56 00 00       	call   80bc6b <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  806587:	89 f0                	mov    %esi,%eax
  806589:	e8 73 f9 ff ff       	call   805f01 <dhcp_discover>
  if (result != ERR_OK) {
  80658e:	84 c0                	test   %al,%al
  806590:	74 10                	je     8065a2 <dhcp_start+0xf5>
    /* free resources allocated above */
    dhcp_stop(netif);
  806592:	89 34 24             	mov    %esi,(%esp)
  806595:	e8 dd f2 ff ff       	call   805877 <dhcp_stop>
  80659a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80659f:	90                   	nop    
  8065a0:	eb 09                	jmp    8065ab <dhcp_start+0xfe>
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  8065a2:	80 4e 2e 08          	orb    $0x8,0x2e(%esi)
  8065a6:	b8 00 00 00 00       	mov    $0x0,%eax
  return result;
}
  8065ab:	83 c4 10             	add    $0x10,%esp
  8065ae:	5b                   	pop    %ebx
  8065af:	5e                   	pop    %esi
  8065b0:	5d                   	pop    %ebp
  8065b1:	c3                   	ret    

008065b2 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8065b2:	55                   	push   %ebp
  8065b3:	89 e5                	mov    %esp,%ebp
  8065b5:	53                   	push   %ebx
  8065b6:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  8065b9:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8065bc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8065c3:	00 
  8065c4:	8d 53 30             	lea    0x30(%ebx),%edx
  8065c7:	89 54 24 04          	mov    %edx,0x4(%esp)
  8065cb:	89 04 24             	mov    %eax,(%esp)
  8065ce:	e8 ae 62 00 00       	call   80c881 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  8065d3:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8065d7:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  8065dd:	ba 08 00 00 00       	mov    $0x8,%edx
  8065e2:	89 d8                	mov    %ebx,%eax
  8065e4:	e8 97 ed ff ff       	call   805380 <dhcp_set_state>
}
  8065e9:	83 c4 14             	add    $0x14,%esp
  8065ec:	5b                   	pop    %ebx
  8065ed:	5d                   	pop    %ebp
  8065ee:	c3                   	ret    

008065ef <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  8065ef:	55                   	push   %ebp
  8065f0:	89 e5                	mov    %esp,%ebp
  8065f2:	57                   	push   %edi
  8065f3:	56                   	push   %esi
  8065f4:	53                   	push   %ebx
  8065f5:	83 ec 1c             	sub    $0x1c,%esp
  8065f8:	89 c7                	mov    %eax,%edi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  8065fa:	85 c0                	test   %eax,%eax
  8065fc:	75 1c                	jne    80661a <dhcp_bind+0x2b>
  8065fe:	c7 44 24 08 b0 2e 81 	movl   $0x812eb0,0x8(%esp)
  806605:	00 
  806606:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
  80660d:	00 
  80660e:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  806615:	e8 92 a2 ff ff       	call   8008ac <_panic>
  dhcp = netif->dhcp;
  80661a:	8b 70 20             	mov    0x20(%eax),%esi
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80661d:	85 f6                	test   %esi,%esi
  80661f:	75 1c                	jne    80663d <dhcp_bind+0x4e>
  806621:	c7 44 24 08 c9 2e 81 	movl   $0x812ec9,0x8(%esp)
  806628:	00 
  806629:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
  806630:	00 
  806631:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  806638:	e8 6f a2 ff ff       	call   8008ac <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80663d:	8b 46 50             	mov    0x50(%esi),%eax
  806640:	83 f8 ff             	cmp    $0xffffffff,%eax
  806643:	74 2a                	je     80666f <dhcp_bind+0x80>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  806645:	8d 50 1e             	lea    0x1e(%eax),%edx
  806648:	b8 89 88 88 88       	mov    $0x88888889,%eax
  80664d:	f7 e2                	mul    %edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80664f:	89 d0                	mov    %edx,%eax
  806651:	c1 e8 05             	shr    $0x5,%eax
  806654:	3d ff ff 00 00       	cmp    $0xffff,%eax
  806659:	76 05                	jbe    806660 <dhcp_bind+0x71>
  80665b:	b8 ff ff 00 00       	mov    $0xffff,%eax
  806660:	66 89 46 28          	mov    %ax,0x28(%esi)
    if (dhcp->t1_timeout == 0) {
  806664:	66 85 c0             	test   %ax,%ax
  806667:	75 06                	jne    80666f <dhcp_bind+0x80>
      dhcp->t1_timeout = 1;
  806669:	66 c7 46 28 01 00    	movw   $0x1,0x28(%esi)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80666f:	8b 46 54             	mov    0x54(%esi),%eax
  806672:	83 f8 ff             	cmp    $0xffffffff,%eax
  806675:	74 2a                	je     8066a1 <dhcp_bind+0xb2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  806677:	8d 50 1e             	lea    0x1e(%eax),%edx
  80667a:	b8 89 88 88 88       	mov    $0x88888889,%eax
  80667f:	f7 e2                	mul    %edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  806681:	89 d0                	mov    %edx,%eax
  806683:	c1 e8 05             	shr    $0x5,%eax
  806686:	3d ff ff 00 00       	cmp    $0xffff,%eax
  80668b:	76 05                	jbe    806692 <dhcp_bind+0xa3>
  80668d:	b8 ff ff 00 00       	mov    $0xffff,%eax
  806692:	66 89 46 2a          	mov    %ax,0x2a(%esi)
    if (dhcp->t2_timeout == 0) {
  806696:	66 85 c0             	test   %ax,%ax
  806699:	75 06                	jne    8066a1 <dhcp_bind+0xb2>
      dhcp->t2_timeout = 1;
  80669b:	66 c7 46 2a 01 00    	movw   $0x1,0x2a(%esi)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8066a1:	83 fe cc             	cmp    $0xffffffcc,%esi
  8066a4:	0f 84 c4 00 00 00    	je     80676e <dhcp_bind+0x17f>
  8066aa:	8b 46 34             	mov    0x34(%esi),%eax
  8066ad:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  8066b0:	85 c0                	test   %eax,%eax
  8066b2:	75 48                	jne    8066fc <dhcp_bind+0x10d>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  8066b4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8066bb:	e8 30 44 00 00       	call   80aaf0 <ntohl>
  8066c0:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  8066c3:	84 c0                	test   %al,%al
  8066c5:	78 11                	js     8066d8 <dhcp_bind+0xe9>
      sn_mask.addr = htonl(0xff000000);
  8066c7:	c7 04 24 00 00 00 ff 	movl   $0xff000000,(%esp)
  8066ce:	e8 e9 41 00 00       	call   80a8bc <htonl>
  8066d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  8066d6:	eb 24                	jmp    8066fc <dhcp_bind+0x10d>
    } else if (first_octet >= 192) {
  8066d8:	3c bf                	cmp    $0xbf,%al
  8066da:	76 11                	jbe    8066ed <dhcp_bind+0xfe>
      sn_mask.addr = htonl(0xffffff00);
  8066dc:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  8066e3:	e8 d4 41 00 00       	call   80a8bc <htonl>
  8066e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  8066eb:	eb 0f                	jmp    8066fc <dhcp_bind+0x10d>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  8066ed:	c7 04 24 00 00 ff ff 	movl   $0xffff0000,(%esp)
  8066f4:	e8 c3 41 00 00       	call   80a8bc <htonl>
  8066f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8066fc:	83 fe c8             	cmp    $0xffffffc8,%esi
  8066ff:	74 79                	je     80677a <dhcp_bind+0x18b>
  806701:	8b 46 38             	mov    0x38(%esi),%eax
  806704:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  806707:	85 c0                	test   %eax,%eax
  806709:	75 1a                	jne    806725 <dhcp_bind+0x136>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  80670b:	8b 5e 30             	mov    0x30(%esi),%ebx
  80670e:	23 5d f0             	and    -0x10(%ebp),%ebx
  806711:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  806714:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80671b:	e8 9c 41 00 00       	call   80a8bc <htonl>
  806720:	09 d8                	or     %ebx,%eax
  806722:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  806725:	8d 46 30             	lea    0x30(%esi),%eax
  806728:	89 44 24 04          	mov    %eax,0x4(%esp)
  80672c:	89 3c 24             	mov    %edi,(%esp)
  80672f:	e8 ad 0d 00 00       	call   8074e1 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  806734:	8d 45 f0             	lea    -0x10(%ebp),%eax
  806737:	89 44 24 04          	mov    %eax,0x4(%esp)
  80673b:	89 3c 24             	mov    %edi,(%esp)
  80673e:	e8 c8 0c 00 00       	call   80740b <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  806743:	8d 45 ec             	lea    -0x14(%ebp),%eax
  806746:	89 44 24 04          	mov    %eax,0x4(%esp)
  80674a:	89 3c 24             	mov    %edi,(%esp)
  80674d:	e8 a0 0c 00 00       	call   8073f2 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  806752:	89 3c 24             	mov    %edi,(%esp)
  806755:	e8 53 0d 00 00       	call   8074ad <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  80675a:	ba 0a 00 00 00       	mov    $0xa,%edx
  80675f:	89 f0                	mov    %esi,%eax
  806761:	e8 1a ec ff ff       	call   805380 <dhcp_set_state>
}
  806766:	83 c4 1c             	add    $0x1c,%esp
  806769:	5b                   	pop    %ebx
  80676a:	5e                   	pop    %esi
  80676b:	5f                   	pop    %edi
  80676c:	5d                   	pop    %ebp
  80676d:	c3                   	ret    
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80676e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  806775:	e9 3a ff ff ff       	jmp    8066b4 <dhcp_bind+0xc5>
    } else {
      sn_mask.addr = htonl(0xffff0000);
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  80677a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  806781:	eb 88                	jmp    80670b <dhcp_bind+0x11c>

00806783 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  806783:	55                   	push   %ebp
  806784:	89 e5                	mov    %esp,%ebp
  806786:	57                   	push   %edi
  806787:	56                   	push   %esi
  806788:	53                   	push   %ebx
  806789:	83 ec 1c             	sub    $0x1c,%esp
  struct netif *netif = (struct netif *)arg;
  80678c:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  80678f:	8b 47 20             	mov    0x20(%edi),%eax
  806792:	89 45 e8             	mov    %eax,-0x18(%ebp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  806795:	8b 55 10             	mov    0x10(%ebp),%edx
  806798:	8b 5a 04             	mov    0x4(%edx),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  80679b:	89 50 0c             	mov    %edx,0xc(%eax)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80679e:	80 3b 02             	cmpb   $0x2,(%ebx)
  8067a1:	0f 85 12 04 00 00    	jne    806bb9 <dhcp_recv+0x436>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8067a7:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  8067ab:	89 f1                	mov    %esi,%ecx
  8067ad:	84 c9                	test   %cl,%cl
  8067af:	74 2e                	je     8067df <dhcp_recv+0x5c>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  8067b1:	0f b6 47 25          	movzbl 0x25(%edi),%eax
  8067b5:	b9 00 00 00 00       	mov    $0x0,%ecx
  8067ba:	3a 43 1c             	cmp    0x1c(%ebx),%al
  8067bd:	74 17                	je     8067d6 <dhcp_recv+0x53>
  8067bf:	e9 f5 03 00 00       	jmp    806bb9 <dhcp_recv+0x436>
  8067c4:	0f b6 d1             	movzbl %cl,%edx
  8067c7:	0f b6 44 17 25       	movzbl 0x25(%edi,%edx,1),%eax
  8067cc:	3a 44 13 1c          	cmp    0x1c(%ebx,%edx,1),%al
  8067d0:	0f 85 e3 03 00 00    	jne    806bb9 <dhcp_recv+0x436>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8067d6:	83 c1 01             	add    $0x1,%ecx
  8067d9:	89 f0                	mov    %esi,%eax
  8067db:	38 c1                	cmp    %al,%cl
  8067dd:	75 e5                	jne    8067c4 <dhcp_recv+0x41>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  8067df:	8b 43 04             	mov    0x4(%ebx),%eax
  8067e2:	89 04 24             	mov    %eax,(%esp)
  8067e5:	e8 06 43 00 00       	call   80aaf0 <ntohl>
  8067ea:	8b 55 e8             	mov    -0x18(%ebp),%edx
  8067ed:	3b 42 04             	cmp    0x4(%edx),%eax
  8067f0:	0f 85 c3 03 00 00    	jne    806bb9 <dhcp_recv+0x436>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  8067f6:	85 d2                	test   %edx,%edx
  8067f8:	75 1c                	jne    806816 <dhcp_recv+0x93>
  8067fa:	c7 44 24 08 d4 2e 81 	movl   $0x812ed4,0x8(%esp)
  806801:	00 
  806802:	c7 44 24 04 89 04 00 	movl   $0x489,0x4(%esp)
  806809:	00 
  80680a:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  806811:	e8 96 a0 ff ff       	call   8008ac <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  806816:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  806819:	83 79 0c 00          	cmpl   $0x0,0xc(%ecx)
  80681d:	75 1c                	jne    80683b <dhcp_recv+0xb8>
  80681f:	c7 44 24 08 e1 2e 81 	movl   $0x812ee1,0x8(%esp)
  806826:	00 
  806827:	c7 44 24 04 8a 04 00 	movl   $0x48a,0x4(%esp)
  80682e:	00 
  80682f:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  806836:	e8 71 a0 ff ff       	call   8008ac <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80683b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80683e:	e8 f3 ef ff ff       	call   805836 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  806843:	8b 55 e8             	mov    -0x18(%ebp),%edx
  806846:	8b 42 0c             	mov    0xc(%edx),%eax
  806849:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80684d:	66 3d f0 00          	cmp    $0xf0,%ax
  806851:	76 21                	jbe    806874 <dhcp_recv+0xf1>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806853:	66 2d f0 00          	sub    $0xf0,%ax
  806857:	66 89 42 18          	mov    %ax,0x18(%edx)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80685b:	0f b7 c0             	movzwl %ax,%eax
  80685e:	89 04 24             	mov    %eax,(%esp)
  806861:	e8 7a 04 00 00       	call   806ce0 <mem_malloc>
  806866:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  806869:	89 41 14             	mov    %eax,0x14(%ecx)
    if (dhcp->options_in == NULL) {
  80686c:	85 c0                	test   %eax,%eax
  80686e:	0f 84 45 03 00 00    	je     806bb9 <dhcp_recv+0x436>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806874:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  80687b:	e8 60 04 00 00       	call   806ce0 <mem_malloc>
  806880:	8b 55 e8             	mov    -0x18(%ebp),%edx
  806883:	89 42 10             	mov    %eax,0x10(%edx)
  if (dhcp->msg_in == NULL) {
  806886:	85 c0                	test   %eax,%eax
  806888:	75 1a                	jne    8068a4 <dhcp_recv+0x121>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  80688a:	8b 42 14             	mov    0x14(%edx),%eax
  80688d:	89 04 24             	mov    %eax,(%esp)
  806890:	e8 f1 07 00 00       	call   807086 <mem_free>
    dhcp->options_in = NULL;
  806895:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  806898:	c7 41 14 00 00 00 00 	movl   $0x0,0x14(%ecx)
  80689f:	e9 15 03 00 00       	jmp    806bb9 <dhcp_recv+0x436>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8068a4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8068ab:	00 
  8068ac:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  8068b3:	00 
  8068b4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8068b8:	8b 55 e8             	mov    -0x18(%ebp),%edx
  8068bb:	8b 42 0c             	mov    0xc(%edx),%eax
  8068be:	89 04 24             	mov    %eax,(%esp)
  8068c1:	e8 2d 0f 00 00       	call   8077f3 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8068c6:	66 3d f0 00          	cmp    $0xf0,%ax
  8068ca:	74 1c                	je     8068e8 <dhcp_recv+0x165>
  8068cc:	c7 44 24 08 50 2e 81 	movl   $0x812e50,0x8(%esp)
  8068d3:	00 
  8068d4:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
  8068db:	00 
  8068dc:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  8068e3:	e8 c4 9f ff ff       	call   8008ac <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  8068e8:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  8068eb:	8b 51 14             	mov    0x14(%ecx),%edx
  8068ee:	85 d2                	test   %edx,%edx
  8068f0:	0f 84 e0 02 00 00    	je     806bd6 <dhcp_recv+0x453>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8068f6:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  8068fd:	00 
  8068fe:	0f b7 41 18          	movzwl 0x18(%ecx),%eax
  806902:	89 44 24 08          	mov    %eax,0x8(%esp)
  806906:	89 54 24 04          	mov    %edx,0x4(%esp)
  80690a:	8b 41 0c             	mov    0xc(%ecx),%eax
  80690d:	89 04 24             	mov    %eax,(%esp)
  806910:	e8 de 0e 00 00       	call   8077f3 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  806915:	8b 55 e8             	mov    -0x18(%ebp),%edx
  806918:	66 3b 42 18          	cmp    0x18(%edx),%ax
  80691c:	0f 84 b4 02 00 00    	je     806bd6 <dhcp_recv+0x453>
  806922:	c7 44 24 08 f1 2e 81 	movl   $0x812ef1,0x8(%esp)
  806929:	00 
  80692a:	c7 44 24 04 a7 04 00 	movl   $0x4a7,0x4(%esp)
  806931:	00 
  806932:	c7 04 24 82 2e 81 00 	movl   $0x812e82,(%esp)
  806939:	e8 6e 9f ff ff       	call   8008ac <_panic>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  80693e:	83 c0 02             	add    $0x2,%eax
  806941:	e8 4b eb ff ff       	call   805491 <dhcp_get_option_byte>
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  806946:	3c 05                	cmp    $0x5,%al
  806948:	0f 85 a2 01 00 00    	jne    806af0 <dhcp_recv+0x36d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  80694e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  806951:	0f b6 01             	movzbl (%ecx),%eax
  806954:	3c 01                	cmp    $0x1,%al
  806956:	0f 85 74 01 00 00    	jne    806ad0 <dhcp_recv+0x34d>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  80695c:	8b 77 20             	mov    0x20(%edi),%esi
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  80695f:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  dhcp->offered_gw_addr.addr = 0;
  806966:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  dhcp->offered_bc_addr.addr = 0;
  80696d:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  806974:	ba 33 00 00 00       	mov    $0x33,%edx
  806979:	89 f0                	mov    %esi,%eax
  80697b:	e8 0f ea ff ff       	call   80538f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806980:	85 c0                	test   %eax,%eax
  806982:	74 0b                	je     80698f <dhcp_recv+0x20c>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  806984:	83 c0 02             	add    $0x2,%eax
  806987:	e8 0d eb ff ff       	call   805499 <dhcp_get_option_long>
  80698c:	89 46 4c             	mov    %eax,0x4c(%esi)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  80698f:	ba 3a 00 00 00       	mov    $0x3a,%edx
  806994:	89 f0                	mov    %esi,%eax
  806996:	e8 f4 e9 ff ff       	call   80538f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80699b:	85 c0                	test   %eax,%eax
  80699d:	74 0d                	je     8069ac <dhcp_recv+0x229>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  80699f:	83 c0 02             	add    $0x2,%eax
  8069a2:	e8 f2 ea ff ff       	call   805499 <dhcp_get_option_long>
  8069a7:	89 46 50             	mov    %eax,0x50(%esi)
  8069aa:	eb 08                	jmp    8069b4 <dhcp_recv+0x231>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  8069ac:	8b 46 4c             	mov    0x4c(%esi),%eax
  8069af:	d1 e8                	shr    %eax
  8069b1:	89 46 50             	mov    %eax,0x50(%esi)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  8069b4:	ba 3b 00 00 00       	mov    $0x3b,%edx
  8069b9:	89 f0                	mov    %esi,%eax
  8069bb:	e8 cf e9 ff ff       	call   80538f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8069c0:	85 c0                	test   %eax,%eax
  8069c2:	74 0e                	je     8069d2 <dhcp_recv+0x24f>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  8069c4:	83 c0 02             	add    $0x2,%eax
  8069c7:	e8 cd ea ff ff       	call   805499 <dhcp_get_option_long>
  8069cc:	89 46 54             	mov    %eax,0x54(%esi)
  8069cf:	90                   	nop    
  8069d0:	eb 06                	jmp    8069d8 <dhcp_recv+0x255>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  8069d2:	8b 46 4c             	mov    0x4c(%esi),%eax
  8069d5:	89 46 54             	mov    %eax,0x54(%esi)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8069d8:	8b 46 10             	mov    0x10(%esi),%eax
  8069db:	ba 00 00 00 00       	mov    $0x0,%edx
  8069e0:	83 f8 f0             	cmp    $0xfffffff0,%eax
  8069e3:	74 03                	je     8069e8 <dhcp_recv+0x265>
  8069e5:	8b 50 10             	mov    0x10(%eax),%edx
  8069e8:	89 56 30             	mov    %edx,0x30(%esi)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8069eb:	ba 01 00 00 00       	mov    $0x1,%edx
  8069f0:	89 f0                	mov    %esi,%eax
  8069f2:	e8 98 e9 ff ff       	call   80538f <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  8069f7:	85 c0                	test   %eax,%eax
  8069f9:	74 13                	je     806a0e <dhcp_recv+0x28b>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8069fb:	83 c0 02             	add    $0x2,%eax
  8069fe:	e8 96 ea ff ff       	call   805499 <dhcp_get_option_long>
  806a03:	89 04 24             	mov    %eax,(%esp)
  806a06:	e8 b1 3e 00 00       	call   80a8bc <htonl>
  806a0b:	89 46 34             	mov    %eax,0x34(%esi)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  806a0e:	ba 03 00 00 00       	mov    $0x3,%edx
  806a13:	89 f0                	mov    %esi,%eax
  806a15:	e8 75 e9 ff ff       	call   80538f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806a1a:	85 c0                	test   %eax,%eax
  806a1c:	74 13                	je     806a31 <dhcp_recv+0x2ae>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806a1e:	83 c0 02             	add    $0x2,%eax
  806a21:	e8 73 ea ff ff       	call   805499 <dhcp_get_option_long>
  806a26:	89 04 24             	mov    %eax,(%esp)
  806a29:	e8 8e 3e 00 00       	call   80a8bc <htonl>
  806a2e:	89 46 38             	mov    %eax,0x38(%esi)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  806a31:	ba 1c 00 00 00       	mov    $0x1c,%edx
  806a36:	89 f0                	mov    %esi,%eax
  806a38:	e8 52 e9 ff ff       	call   80538f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806a3d:	85 c0                	test   %eax,%eax
  806a3f:	74 13                	je     806a54 <dhcp_recv+0x2d1>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806a41:	83 c0 02             	add    $0x2,%eax
  806a44:	e8 50 ea ff ff       	call   805499 <dhcp_get_option_long>
  806a49:	89 04 24             	mov    %eax,(%esp)
  806a4c:	e8 6b 3e 00 00       	call   80a8bc <htonl>
  806a51:	89 46 3c             	mov    %eax,0x3c(%esi)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  806a54:	ba 06 00 00 00       	mov    $0x6,%edx
  806a59:	89 f0                	mov    %esi,%eax
  806a5b:	e8 2f e9 ff ff       	call   80538f <dhcp_get_option_ptr>
  806a60:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (option_ptr != NULL) {
  806a63:	85 c0                	test   %eax,%eax
  806a65:	74 54                	je     806abb <dhcp_recv+0x338>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  806a67:	83 c0 01             	add    $0x1,%eax
  806a6a:	e8 22 ea ff ff       	call   805491 <dhcp_get_option_byte>
  806a6f:	89 c2                	mov    %eax,%edx
  806a71:	c0 ea 02             	shr    $0x2,%dl
  806a74:	0f b6 c2             	movzbl %dl,%eax
  806a77:	89 46 40             	mov    %eax,0x40(%esi)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  806a7a:	83 f8 02             	cmp    $0x2,%eax
  806a7d:	76 0d                	jbe    806a8c <dhcp_recv+0x309>
      dhcp->dns_count = DHCP_MAX_DNS;
  806a7f:	c7 46 40 02 00 00 00 	movl   $0x2,0x40(%esi)
  806a86:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  806a8a:	eb 06                	jmp    806a92 <dhcp_recv+0x30f>
    for (n = 0; n < dhcp->dns_count; n++) {
  806a8c:	84 d2                	test   %dl,%dl
  806a8e:	75 f6                	jne    806a86 <dhcp_recv+0x303>
  806a90:	eb 29                	jmp    806abb <dhcp_recv+0x338>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  806a92:	0f b6 5d ef          	movzbl -0x11(%ebp),%ebx
  806a96:	8b 55 f0             	mov    -0x10(%ebp),%edx
  806a99:	8d 44 9a 02          	lea    0x2(%edx,%ebx,4),%eax
  806a9d:	e8 f7 e9 ff ff       	call   805499 <dhcp_get_option_long>
  806aa2:	89 04 24             	mov    %eax,(%esp)
  806aa5:	e8 12 3e 00 00       	call   80a8bc <htonl>
  806aaa:	89 44 9e 44          	mov    %eax,0x44(%esi,%ebx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  806aae:	80 45 ef 01          	addb   $0x1,-0x11(%ebp)
  806ab2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
  806ab6:	3b 46 40             	cmp    0x40(%esi),%eax
  806ab9:	72 d7                	jb     806a92 <dhcp_recv+0x30f>
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  806abb:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  806abe:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  806ac4:	89 f8                	mov    %edi,%eax
  806ac6:	e8 e7 fa ff ff       	call   8065b2 <dhcp_check>
  806acb:	e9 e9 00 00 00       	jmp    806bb9 <dhcp_recv+0x436>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  806ad0:	83 e8 03             	sub    $0x3,%eax
  806ad3:	3c 02                	cmp    $0x2,%al
  806ad5:	0f 87 de 00 00 00    	ja     806bb9 <dhcp_recv+0x436>
      dhcp->request_timeout = 0;
  806adb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  806ade:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
      dhcp_bind(netif);
  806ae4:	89 f8                	mov    %edi,%eax
  806ae6:	e8 04 fb ff ff       	call   8065ef <dhcp_bind>
  806aeb:	e9 c9 00 00 00       	jmp    806bb9 <dhcp_recv+0x436>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  806af0:	3c 06                	cmp    $0x6,%al
  806af2:	75 73                	jne    806b67 <dhcp_recv+0x3e4>
  806af4:	8b 55 e8             	mov    -0x18(%ebp),%edx
  806af7:	0f b6 02             	movzbl (%edx),%eax
  806afa:	3c 03                	cmp    $0x3,%al
  806afc:	74 10                	je     806b0e <dhcp_recv+0x38b>
  806afe:	3c 01                	cmp    $0x1,%al
  806b00:	74 0c                	je     806b0e <dhcp_recv+0x38b>
  806b02:	3c 04                	cmp    $0x4,%al
  806b04:	74 08                	je     806b0e <dhcp_recv+0x38b>
  806b06:	3c 05                	cmp    $0x5,%al
  806b08:	0f 85 ab 00 00 00    	jne    806bb9 <dhcp_recv+0x436>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  806b0e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  806b11:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806b17:	8b 5f 20             	mov    0x20(%edi),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  806b1a:	89 3c 24             	mov    %edi,(%esp)
  806b1d:	e8 66 09 00 00       	call   807488 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  806b22:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  806b29:	00 
  806b2a:	89 3c 24             	mov    %edi,(%esp)
  806b2d:	e8 af 09 00 00       	call   8074e1 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  806b32:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  806b39:	00 
  806b3a:	89 3c 24             	mov    %edi,(%esp)
  806b3d:	e8 b0 08 00 00       	call   8073f2 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  806b42:	c7 44 24 04 b0 37 81 	movl   $0x8137b0,0x4(%esp)
  806b49:	00 
  806b4a:	89 3c 24             	mov    %edi,(%esp)
  806b4d:	e8 b9 08 00 00       	call   80740b <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  806b52:	ba 0c 00 00 00       	mov    $0xc,%edx
  806b57:	89 d8                	mov    %ebx,%eax
  806b59:	e8 22 e8 ff ff       	call   805380 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  806b5e:	89 f8                	mov    %edi,%eax
  806b60:	e8 9c f3 ff ff       	call   805f01 <dhcp_discover>
  806b65:	eb 52                	jmp    806bb9 <dhcp_recv+0x436>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  806b67:	3c 02                	cmp    $0x2,%al
  806b69:	75 4e                	jne    806bb9 <dhcp_recv+0x436>
  806b6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  806b6e:	80 38 06             	cmpb   $0x6,(%eax)
  806b71:	75 46                	jne    806bb9 <dhcp_recv+0x436>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  806b73:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806b79:	8b 5f 20             	mov    0x20(%edi),%ebx
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  806b7c:	ba 36 00 00 00       	mov    $0x36,%edx
  806b81:	89 d8                	mov    %ebx,%eax
  806b83:	e8 07 e8 ff ff       	call   80538f <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  806b88:	85 c0                	test   %eax,%eax
  806b8a:	74 2d                	je     806bb9 <dhcp_recv+0x436>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806b8c:	83 c0 02             	add    $0x2,%eax
  806b8f:	e8 05 e9 ff ff       	call   805499 <dhcp_get_option_long>
  806b94:	89 04 24             	mov    %eax,(%esp)
  806b97:	e8 20 3d 00 00       	call   80a8bc <htonl>
  806b9c:	89 43 2c             	mov    %eax,0x2c(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  806b9f:	8b 43 10             	mov    0x10(%ebx),%eax
  806ba2:	ba 00 00 00 00       	mov    $0x0,%edx
  806ba7:	83 f8 f0             	cmp    $0xfffffff0,%eax
  806baa:	74 03                	je     806baf <dhcp_recv+0x42c>
  806bac:	8b 50 10             	mov    0x10(%eax),%edx
  806baf:	89 53 30             	mov    %edx,0x30(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  806bb2:	89 f8                	mov    %edi,%eax
  806bb4:	e8 e9 f5 ff ff       	call   8061a2 <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  806bb9:	8b 55 10             	mov    0x10(%ebp),%edx
  806bbc:	89 14 24             	mov    %edx,(%esp)
  806bbf:	e8 af 0e 00 00       	call   807a73 <pbuf_free>
  dhcp->p = NULL;
  806bc4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  806bc7:	c7 41 0c 00 00 00 00 	movl   $0x0,0xc(%ecx)
}
  806bce:	83 c4 1c             	add    $0x1c,%esp
  806bd1:	5b                   	pop    %ebx
  806bd2:	5e                   	pop    %esi
  806bd3:	5f                   	pop    %edi
  806bd4:	5d                   	pop    %ebp
  806bd5:	c3                   	ret    
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  806bd6:	ba 35 00 00 00       	mov    $0x35,%edx
  806bdb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  806bde:	e8 ac e7 ff ff       	call   80538f <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  806be3:	85 c0                	test   %eax,%eax
  806be5:	0f 85 53 fd ff ff    	jne    80693e <dhcp_recv+0x1bb>
  806beb:	eb cc                	jmp    806bb9 <dhcp_recv+0x436>

00806bed <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  806bed:	55                   	push   %ebp
  806bee:	89 e5                	mov    %esp,%ebp
  806bf0:	53                   	push   %ebx
  806bf1:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  806bf4:	8b 1d c0 e5 b3 00    	mov    0xb3e5c0,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  806bfa:	85 db                	test   %ebx,%ebx
  806bfc:	0f 84 d2 00 00 00    	je     806cd4 <dhcp_fine_tmr+0xe7>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  806c02:	8b 53 20             	mov    0x20(%ebx),%edx
  806c05:	85 d2                	test   %edx,%edx
  806c07:	0f 84 bd 00 00 00    	je     806cca <dhcp_fine_tmr+0xdd>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  806c0d:	0f b7 42 26          	movzwl 0x26(%edx),%eax
  806c11:	66 83 f8 01          	cmp    $0x1,%ax
  806c15:	76 0c                	jbe    806c23 <dhcp_fine_tmr+0x36>
        netif->dhcp->request_timeout--;
  806c17:	83 e8 01             	sub    $0x1,%eax
  806c1a:	66 89 42 26          	mov    %ax,0x26(%edx)
  806c1e:	e9 a7 00 00 00       	jmp    806cca <dhcp_fine_tmr+0xdd>
      }
      else if (netif->dhcp->request_timeout == 1) {
  806c23:	66 83 f8 01          	cmp    $0x1,%ax
  806c27:	0f 85 9d 00 00 00    	jne    806cca <dhcp_fine_tmr+0xdd>
        netif->dhcp->request_timeout--;
  806c2d:	66 c7 42 26 00 00    	movw   $0x0,0x26(%edx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806c33:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  806c36:	0f b6 02             	movzbl (%edx),%eax
  806c39:	3c 0c                	cmp    $0xc,%al
  806c3b:	74 04                	je     806c41 <dhcp_fine_tmr+0x54>
  806c3d:	3c 06                	cmp    $0x6,%al
  806c3f:	75 0c                	jne    806c4d <dhcp_fine_tmr+0x60>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  806c41:	89 d8                	mov    %ebx,%eax
  806c43:	e8 b9 f2 ff ff       	call   805f01 <dhcp_discover>
  806c48:	e9 7d 00 00 00       	jmp    806cca <dhcp_fine_tmr+0xdd>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  806c4d:	3c 01                	cmp    $0x1,%al
  806c4f:	90                   	nop    
  806c50:	75 21                	jne    806c73 <dhcp_fine_tmr+0x86>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  806c52:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  806c56:	77 0a                	ja     806c62 <dhcp_fine_tmr+0x75>
      dhcp_select(netif);
  806c58:	89 d8                	mov    %ebx,%eax
  806c5a:	e8 43 f5 ff ff       	call   8061a2 <dhcp_select>
  806c5f:	90                   	nop    
  806c60:	eb 68                	jmp    806cca <dhcp_fine_tmr+0xdd>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  806c62:	89 1c 24             	mov    %ebx,(%esp)
  806c65:	e8 86 ee ff ff       	call   805af0 <dhcp_release>
      dhcp_discover(netif);
  806c6a:	89 d8                	mov    %ebx,%eax
  806c6c:	e8 90 f2 ff ff       	call   805f01 <dhcp_discover>
  806c71:	eb 57                	jmp    806cca <dhcp_fine_tmr+0xdd>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  806c73:	3c 08                	cmp    $0x8,%al
  806c75:	75 1d                	jne    806c94 <dhcp_fine_tmr+0xa7>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  806c77:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  806c7b:	90                   	nop    
  806c7c:	8d 74 26 00          	lea    0x0(%esi),%esi
  806c80:	77 09                	ja     806c8b <dhcp_fine_tmr+0x9e>
      dhcp_check(netif);
  806c82:	89 d8                	mov    %ebx,%eax
  806c84:	e8 29 f9 ff ff       	call   8065b2 <dhcp_check>
  806c89:	eb 3f                	jmp    806cca <dhcp_fine_tmr+0xdd>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  806c8b:	89 d8                	mov    %ebx,%eax
  806c8d:	e8 5d f9 ff ff       	call   8065ef <dhcp_bind>
  806c92:	eb 36                	jmp    806cca <dhcp_fine_tmr+0xdd>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  806c94:	3c 05                	cmp    $0x5,%al
  806c96:	75 0f                	jne    806ca7 <dhcp_fine_tmr+0xba>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  806c98:	89 1c 24             	mov    %ebx,(%esp)
  806c9b:	90                   	nop    
  806c9c:	8d 74 26 00          	lea    0x0(%esi),%esi
  806ca0:	e8 c6 f0 ff ff       	call   805d6b <dhcp_renew>
  806ca5:	eb 23                	jmp    806cca <dhcp_fine_tmr+0xdd>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  806ca7:	3c 04                	cmp    $0x4,%al
  806ca9:	75 1f                	jne    806cca <dhcp_fine_tmr+0xdd>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  806cab:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  806caf:	90                   	nop    
  806cb0:	77 09                	ja     806cbb <dhcp_fine_tmr+0xce>
      dhcp_rebind(netif);
  806cb2:	89 d8                	mov    %ebx,%eax
  806cb4:	e8 9a ef ff ff       	call   805c53 <dhcp_rebind>
  806cb9:	eb 0f                	jmp    806cca <dhcp_fine_tmr+0xdd>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  806cbb:	89 1c 24             	mov    %ebx,(%esp)
  806cbe:	e8 2d ee ff ff       	call   805af0 <dhcp_release>
      dhcp_discover(netif);
  806cc3:	89 d8                	mov    %ebx,%eax
  806cc5:	e8 37 f2 ff ff       	call   805f01 <dhcp_discover>
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  806cca:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  806ccc:	85 db                	test   %ebx,%ebx
  806cce:	0f 85 2e ff ff ff    	jne    806c02 <dhcp_fine_tmr+0x15>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  806cd4:	83 c4 04             	add    $0x4,%esp
  806cd7:	5b                   	pop    %ebx
  806cd8:	5d                   	pop    %ebp
  806cd9:	c3                   	ret    
  806cda:	00 00                	add    %al,(%eax)
  806cdc:	00 00                	add    %al,(%eax)
	...

00806ce0 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  806ce0:	55                   	push   %ebp
  806ce1:	89 e5                	mov    %esp,%ebp
  806ce3:	57                   	push   %edi
  806ce4:	56                   	push   %esi
  806ce5:	53                   	push   %ebx
  806ce6:	83 ec 1c             	sub    $0x1c,%esp
  806ce9:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  806cec:	85 c0                	test   %eax,%eax
  806cee:	0f 84 cb 01 00 00    	je     806ebf <mem_malloc+0x1df>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  806cf4:	83 c0 03             	add    $0x3,%eax
  806cf7:	83 e0 fc             	and    $0xfffffffc,%eax
  806cfa:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(size < MIN_SIZE_ALIGNED) {
  806cfd:	83 f8 0b             	cmp    $0xb,%eax
  806d00:	77 09                	ja     806d0b <mem_malloc+0x2b>
  806d02:	c7 45 f0 0c 00 00 00 	movl   $0xc,-0x10(%ebp)
  806d09:	eb 0d                	jmp    806d18 <mem_malloc+0x38>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  806d0b:	81 7d f0 00 00 22 00 	cmpl   $0x220000,-0x10(%ebp)
  806d12:	0f 87 a7 01 00 00    	ja     806ebf <mem_malloc+0x1df>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  806d18:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806d1f:	00 
  806d20:	a1 a8 86 a3 00       	mov    0xa386a8,%eax
  806d25:	89 04 24             	mov    %eax,(%esp)
  806d28:	e8 ac 67 00 00       	call   80d4d9 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  806d2d:	a1 a4 86 a3 00       	mov    0xa386a4,%eax
  806d32:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806d35:	8b 15 9c 86 a3 00    	mov    0xa3869c,%edx
  806d3b:	89 55 e8             	mov    %edx,-0x18(%ebp)
  806d3e:	89 c2                	mov    %eax,%edx
  806d40:	2b 55 e8             	sub    -0x18(%ebp),%edx
  806d43:	b8 00 00 22 00       	mov    $0x220000,%eax
  806d48:	89 c7                	mov    %eax,%edi
  806d4a:	2b 7d f0             	sub    -0x10(%ebp),%edi
  806d4d:	39 fa                	cmp    %edi,%edx
  806d4f:	0f 83 56 01 00 00    	jae    806eab <mem_malloc+0x1cb>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  806d55:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  806d58:	01 d1                	add    %edx,%ecx
  806d5a:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  806d5d:	89 cb                	mov    %ecx,%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  806d5f:	80 79 08 00          	cmpb   $0x0,0x8(%ecx)
  806d63:	0f 85 38 01 00 00    	jne    806ea1 <mem_malloc+0x1c1>
  806d69:	8b 31                	mov    (%ecx),%esi
  806d6b:	89 f0                	mov    %esi,%eax
  806d6d:	29 d0                	sub    %edx,%eax
  806d6f:	8d 48 f4             	lea    -0xc(%eax),%ecx
  806d72:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
  806d75:	0f 82 26 01 00 00    	jb     806ea1 <mem_malloc+0x1c1>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  806d7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  806d7e:	83 c0 18             	add    $0x18,%eax
  806d81:	39 c8                	cmp    %ecx,%eax
  806d83:	77 2d                	ja     806db2 <mem_malloc+0xd2>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  806d85:	8b 45 f0             	mov    -0x10(%ebp),%eax
  806d88:	8d 4c 10 0c          	lea    0xc(%eax,%edx,1),%ecx
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  806d8c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  806d8f:	01 c8                	add    %ecx,%eax
          mem2->used = 0;
  806d91:	c6 40 08 00          	movb   $0x0,0x8(%eax)
          mem2->next = mem->next;
  806d95:	89 30                	mov    %esi,(%eax)
          mem2->prev = ptr;
  806d97:	89 50 04             	mov    %edx,0x4(%eax)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  806d9a:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  806d9c:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  806da0:	8b 00                	mov    (%eax),%eax
  806da2:	3d 00 00 22 00       	cmp    $0x220000,%eax
  806da7:	74 0d                	je     806db6 <mem_malloc+0xd6>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  806da9:	8b 55 e8             	mov    -0x18(%ebp),%edx
  806dac:	89 4c 02 04          	mov    %ecx,0x4(%edx,%eax,1)
  806db0:	eb 04                	jmp    806db6 <mem_malloc+0xd6>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  806db2:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  806db6:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
  806db9:	75 67                	jne    806e22 <mem_malloc+0x142>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  806dbb:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806dbe:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
  806dc2:	84 c0                	test   %al,%al
  806dc4:	74 30                	je     806df6 <mem_malloc+0x116>
  806dc6:	8b 15 a0 86 a3 00    	mov    0xa386a0,%edx
  806dcc:	39 d1                	cmp    %edx,%ecx
  806dce:	74 52                	je     806e22 <mem_malloc+0x142>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  806dd0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  806dd3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806dd6:	03 08                	add    (%eax),%ecx
  806dd8:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  806ddb:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
  806ddf:	84 c0                	test   %al,%al
  806de1:	75 08                	jne    806deb <mem_malloc+0x10b>
  806de3:	89 0d a4 86 a3 00    	mov    %ecx,0xa386a4
  806de9:	eb 0b                	jmp    806df6 <mem_malloc+0x116>
  806deb:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  806dee:	0f 84 d2 00 00 00    	je     806ec6 <mem_malloc+0x1e6>
  806df4:	eb da                	jmp    806dd0 <mem_malloc+0xf0>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  806df6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806df9:	3b 15 a0 86 a3 00    	cmp    0xa386a0,%edx
  806dff:	90                   	nop    
  806e00:	74 20                	je     806e22 <mem_malloc+0x142>
  806e02:	84 c0                	test   %al,%al
  806e04:	74 1c                	je     806e22 <mem_malloc+0x142>
  806e06:	c7 44 24 08 0d 2f 81 	movl   $0x812f0d,0x8(%esp)
  806e0d:	00 
  806e0e:	c7 44 24 04 46 02 00 	movl   $0x246,0x4(%esp)
  806e15:	00 
  806e16:	c7 04 24 26 2f 81 00 	movl   $0x812f26,(%esp)
  806e1d:	e8 8a 9a ff ff       	call   8008ac <_panic>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  806e22:	a1 a8 86 a3 00       	mov    0xa386a8,%eax
  806e27:	89 04 24             	mov    %eax,(%esp)
  806e2a:	e8 8b 69 00 00       	call   80d7ba <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  806e2f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  806e32:	8d 44 19 0c          	lea    0xc(%ecx,%ebx,1),%eax
  806e36:	3b 05 a0 86 a3 00    	cmp    0xa386a0,%eax
  806e3c:	76 1c                	jbe    806e5a <mem_malloc+0x17a>
  806e3e:	c7 44 24 08 b0 2f 81 	movl   $0x812fb0,0x8(%esp)
  806e45:	00 
  806e46:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  806e4d:	00 
  806e4e:	c7 04 24 26 2f 81 00 	movl   $0x812f26,(%esp)
  806e55:	e8 52 9a ff ff       	call   8008ac <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  806e5a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  806e5d:	83 c0 0c             	add    $0xc,%eax
  806e60:	a8 03                	test   $0x3,%al
  806e62:	74 1c                	je     806e80 <mem_malloc+0x1a0>
  806e64:	c7 44 24 08 e0 2f 81 	movl   $0x812fe0,0x8(%esp)
  806e6b:	00 
  806e6c:	c7 44 24 04 4d 02 00 	movl   $0x24d,0x4(%esp)
  806e73:	00 
  806e74:	c7 04 24 26 2f 81 00 	movl   $0x812f26,(%esp)
  806e7b:	e8 2c 9a ff ff       	call   8008ac <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  806e80:	f6 c3 03             	test   $0x3,%bl
  806e83:	74 4e                	je     806ed3 <mem_malloc+0x1f3>
  806e85:	c7 44 24 08 10 30 81 	movl   $0x813010,0x8(%esp)
  806e8c:	00 
  806e8d:	c7 44 24 04 4f 02 00 	movl   $0x24f,0x4(%esp)
  806e94:	00 
  806e95:	c7 04 24 26 2f 81 00 	movl   $0x812f26,(%esp)
  806e9c:	e8 0b 9a ff ff       	call   8008ac <_panic>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  806ea1:	8b 13                	mov    (%ebx),%edx
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  806ea3:	39 d7                	cmp    %edx,%edi
  806ea5:	0f 87 aa fe ff ff    	ja     806d55 <mem_malloc+0x75>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  806eab:	a1 a8 86 a3 00       	mov    0xa386a8,%eax
  806eb0:	89 04 24             	mov    %eax,(%esp)
  806eb3:	e8 02 69 00 00       	call   80d7ba <sys_sem_signal>
  806eb8:	b8 00 00 00 00       	mov    $0x0,%eax
  806ebd:	eb 14                	jmp    806ed3 <mem_malloc+0x1f3>
  return NULL;
  806ebf:	b8 00 00 00 00       	mov    $0x0,%eax
  806ec4:	eb 0d                	jmp    806ed3 <mem_malloc+0x1f3>
  806ec6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806ec9:	a3 a4 86 a3 00       	mov    %eax,0xa386a4
  806ece:	e9 4f ff ff ff       	jmp    806e22 <mem_malloc+0x142>
}
  806ed3:	83 c4 1c             	add    $0x1c,%esp
  806ed6:	5b                   	pop    %ebx
  806ed7:	5e                   	pop    %esi
  806ed8:	5f                   	pop    %edi
  806ed9:	5d                   	pop    %ebp
  806eda:	c3                   	ret    

00806edb <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  806edb:	55                   	push   %ebp
  806edc:	89 e5                	mov    %esp,%ebp
  806ede:	83 ec 18             	sub    $0x18,%esp
  806ee1:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  806ee4:	89 75 fc             	mov    %esi,-0x4(%ebp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  806ee7:	8b 45 0c             	mov    0xc(%ebp),%eax
  806eea:	89 c6                	mov    %eax,%esi
  806eec:	0f af 75 08          	imul   0x8(%ebp),%esi
  806ef0:	89 34 24             	mov    %esi,(%esp)
  806ef3:	e8 e8 fd ff ff       	call   806ce0 <mem_malloc>
  806ef8:	89 c3                	mov    %eax,%ebx
  if (p) {
  806efa:	85 c0                	test   %eax,%eax
  806efc:	74 14                	je     806f12 <mem_calloc+0x37>
    /* zero the memory */
    memset(p, 0, count * size);
  806efe:	89 74 24 08          	mov    %esi,0x8(%esp)
  806f02:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806f09:	00 
  806f0a:	89 04 24             	mov    %eax,(%esp)
  806f0d:	e8 7c a2 ff ff       	call   80118e <memset>
  }
  return p;
}
  806f12:	89 d8                	mov    %ebx,%eax
  806f14:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  806f17:	8b 75 fc             	mov    -0x4(%ebp),%esi
  806f1a:	89 ec                	mov    %ebp,%esp
  806f1c:	5d                   	pop    %ebp
  806f1d:	c3                   	ret    

00806f1e <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  806f1e:	55                   	push   %ebp
  806f1f:	89 e5                	mov    %esp,%ebp
  806f21:	83 ec 28             	sub    $0x28,%esp
  806f24:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  806f27:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806f2a:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806f2d:	8b 7d 08             	mov    0x8(%ebp),%edi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  806f30:	8b 45 0c             	mov    0xc(%ebp),%eax
  806f33:	83 c0 03             	add    $0x3,%eax
  806f36:	89 c3                	mov    %eax,%ebx
  806f38:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  806f3b:	83 fb 0b             	cmp    $0xb,%ebx
  806f3e:	77 07                	ja     806f47 <mem_realloc+0x29>
  806f40:	bb 0c 00 00 00       	mov    $0xc,%ebx
  806f45:	eb 12                	jmp    806f59 <mem_realloc+0x3b>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  806f47:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  806f4d:	76 0a                	jbe    806f59 <mem_realloc+0x3b>
  806f4f:	bf 00 00 00 00       	mov    $0x0,%edi
  806f54:	e9 1e 01 00 00       	jmp    807077 <mem_realloc+0x159>
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  806f59:	a1 9c 86 a3 00       	mov    0xa3869c,%eax
  806f5e:	39 c7                	cmp    %eax,%edi
  806f60:	72 08                	jb     806f6a <mem_realloc+0x4c>
  806f62:	3b 3d a0 86 a3 00    	cmp    0xa386a0,%edi
  806f68:	72 1c                	jb     806f86 <mem_realloc+0x68>
  806f6a:	c7 44 24 08 3a 2f 81 	movl   $0x812f3a,0x8(%esp)
  806f71:	00 
  806f72:	c7 44 24 04 79 01 00 	movl   $0x179,0x4(%esp)
  806f79:	00 
  806f7a:	c7 04 24 26 2f 81 00 	movl   $0x812f26,(%esp)
  806f81:	e8 26 99 ff ff       	call   8008ac <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  806f86:	8d 4f f4             	lea    -0xc(%edi),%ecx
  806f89:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  806f8c:	29 c1                	sub    %eax,%ecx
  806f8e:	89 4d ec             	mov    %ecx,-0x14(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  806f91:	8b 47 f4             	mov    -0xc(%edi),%eax
  806f94:	29 c8                	sub    %ecx,%eax
  806f96:	8d 70 f4             	lea    -0xc(%eax),%esi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  806f99:	39 de                	cmp    %ebx,%esi
  806f9b:	73 1c                	jae    806fb9 <mem_realloc+0x9b>
  806f9d:	c7 44 24 08 34 30 81 	movl   $0x813034,0x8(%esp)
  806fa4:	00 
  806fa5:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  806fac:	00 
  806fad:	c7 04 24 26 2f 81 00 	movl   $0x812f26,(%esp)
  806fb4:	e8 f3 98 ff ff       	call   8008ac <_panic>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  806fb9:	39 f3                	cmp    %esi,%ebx
  806fbb:	0f 84 b6 00 00 00    	je     807077 <mem_realloc+0x159>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  806fc1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806fc8:	00 
  806fc9:	a1 a8 86 a3 00       	mov    0xa386a8,%eax
  806fce:	89 04 24             	mov    %eax,(%esp)
  806fd1:	e8 03 65 00 00       	call   80d4d9 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  806fd6:	8b 0d 9c 86 a3 00    	mov    0xa3869c,%ecx
  806fdc:	89 c8                	mov    %ecx,%eax
  806fde:	8b 55 f0             	mov    -0x10(%ebp),%edx
  806fe1:	03 02                	add    (%edx),%eax
  if(mem2->used == 0) {
  806fe3:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  806fe7:	75 42                	jne    80702b <mem_realloc+0x10d>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  806fe9:	8b 30                	mov    (%eax),%esi
  806feb:	89 75 e8             	mov    %esi,-0x18(%ebp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  806fee:	8b 75 ec             	mov    -0x14(%ebp),%esi
  806ff1:	8d 54 33 0c          	lea    0xc(%ebx,%esi,1),%edx
    if (lfree == mem2) {
  806ff5:	39 05 a4 86 a3 00    	cmp    %eax,0xa386a4
  806ffb:	75 08                	jne    807005 <mem_realloc+0xe7>
      lfree = (struct mem *)&ram[ptr2];
  806ffd:	8d 04 11             	lea    (%ecx,%edx,1),%eax
  807000:	a3 a4 86 a3 00       	mov    %eax,0xa386a4
    }
    mem2 = (struct mem *)&ram[ptr2];
  807005:	8d 04 11             	lea    (%ecx,%edx,1),%eax
    mem2->used = 0;
  807008:	c6 40 08 00          	movb   $0x0,0x8(%eax)
    /* restore the next pointer */
    mem2->next = next;
  80700c:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  80700f:	89 18                	mov    %ebx,(%eax)
    /* link it back to mem */
    mem2->prev = ptr;
  807011:	8b 75 ec             	mov    -0x14(%ebp),%esi
  807014:	89 70 04             	mov    %esi,0x4(%eax)
    /* link mem to it */
    mem->next = ptr2;
  807017:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  80701a:	89 13                	mov    %edx,(%ebx)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80701c:	8b 00                	mov    (%eax),%eax
  80701e:	3d 00 00 22 00       	cmp    $0x220000,%eax
  807023:	74 45                	je     80706a <mem_realloc+0x14c>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  807025:	89 54 01 04          	mov    %edx,0x4(%ecx,%eax,1)
  807029:	eb 3f                	jmp    80706a <mem_realloc+0x14c>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  80702b:	8d 43 18             	lea    0x18(%ebx),%eax
  80702e:	39 c6                	cmp    %eax,%esi
  807030:	72 38                	jb     80706a <mem_realloc+0x14c>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  807032:	8b 75 ec             	mov    -0x14(%ebp),%esi
  807035:	8d 5c 33 0c          	lea    0xc(%ebx,%esi,1),%ebx
    mem2 = (struct mem *)&ram[ptr2];
  807039:	8d 14 19             	lea    (%ecx,%ebx,1),%edx
    if (mem2 < lfree) {
  80703c:	3b 15 a4 86 a3 00    	cmp    0xa386a4,%edx
  807042:	73 06                	jae    80704a <mem_realloc+0x12c>
      lfree = mem2;
  807044:	89 15 a4 86 a3 00    	mov    %edx,0xa386a4
    }
    mem2->used = 0;
  80704a:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  80704e:	8b 75 f0             	mov    -0x10(%ebp),%esi
  807051:	8b 06                	mov    (%esi),%eax
  807053:	89 02                	mov    %eax,(%edx)
    mem2->prev = ptr;
  807055:	8b 45 ec             	mov    -0x14(%ebp),%eax
  807058:	89 42 04             	mov    %eax,0x4(%edx)
    mem->next = ptr2;
  80705b:	89 1e                	mov    %ebx,(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80705d:	8b 02                	mov    (%edx),%eax
  80705f:	3d 00 00 22 00       	cmp    $0x220000,%eax
  807064:	74 04                	je     80706a <mem_realloc+0x14c>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  807066:	89 5c 01 04          	mov    %ebx,0x4(%ecx,%eax,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80706a:	a1 a8 86 a3 00       	mov    0xa386a8,%eax
  80706f:	89 04 24             	mov    %eax,(%esp)
  807072:	e8 43 67 00 00       	call   80d7ba <sys_sem_signal>
  return rmem;
}
  807077:	89 f8                	mov    %edi,%eax
  807079:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80707c:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80707f:	8b 7d fc             	mov    -0x4(%ebp),%edi
  807082:	89 ec                	mov    %ebp,%esp
  807084:	5d                   	pop    %ebp
  807085:	c3                   	ret    

00807086 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  807086:	55                   	push   %ebp
  807087:	89 e5                	mov    %esp,%ebp
  807089:	56                   	push   %esi
  80708a:	53                   	push   %ebx
  80708b:	83 ec 10             	sub    $0x10,%esp
  80708e:	8b 45 08             	mov    0x8(%ebp),%eax
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  807091:	85 c0                	test   %eax,%eax
  807093:	0f 84 71 01 00 00    	je     80720a <mem_free+0x184>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  807099:	a8 03                	test   $0x3,%al
  80709b:	74 1c                	je     8070b9 <mem_free+0x33>
  80709d:	c7 44 24 08 58 30 81 	movl   $0x813058,0x8(%esp)
  8070a4:	00 
  8070a5:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  8070ac:	00 
  8070ad:	c7 04 24 26 2f 81 00 	movl   $0x812f26,(%esp)
  8070b4:	e8 f3 97 ff ff       	call   8008ac <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8070b9:	89 c3                	mov    %eax,%ebx
  8070bb:	3b 05 9c 86 a3 00    	cmp    0xa3869c,%eax
  8070c1:	72 08                	jb     8070cb <mem_free+0x45>
  8070c3:	3b 05 a0 86 a3 00    	cmp    0xa386a0,%eax
  8070c9:	72 1c                	jb     8070e7 <mem_free+0x61>
  8070cb:	c7 44 24 08 54 2f 81 	movl   $0x812f54,0x8(%esp)
  8070d2:	00 
  8070d3:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  8070da:	00 
  8070db:	c7 04 24 26 2f 81 00 	movl   $0x812f26,(%esp)
  8070e2:	e8 c5 97 ff ff       	call   8008ac <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8070e7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8070ee:	00 
  8070ef:	a1 a8 86 a3 00       	mov    0xa386a8,%eax
  8070f4:	89 04 24             	mov    %eax,(%esp)
  8070f7:	e8 dd 63 00 00       	call   80d4d9 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8070fc:	8d 43 f4             	lea    -0xc(%ebx),%eax
  8070ff:	89 c1                	mov    %eax,%ecx
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  807101:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  807105:	75 1c                	jne    807123 <mem_free+0x9d>
  807107:	c7 44 24 08 6b 2f 81 	movl   $0x812f6b,0x8(%esp)
  80710e:	00 
  80710f:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  807116:	00 
  807117:	c7 04 24 26 2f 81 00 	movl   $0x812f26,(%esp)
  80711e:	e8 89 97 ff ff       	call   8008ac <_panic>
  /* ... and is now unused. */
  mem->used = 0;
  807123:	c6 40 08 00          	movb   $0x0,0x8(%eax)

  if (mem < lfree) {
  807127:	3b 05 a4 86 a3 00    	cmp    0xa386a4,%eax
  80712d:	73 05                	jae    807134 <mem_free+0xae>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80712f:	a3 a4 86 a3 00       	mov    %eax,0xa386a4
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  807134:	8b 35 9c 86 a3 00    	mov    0xa3869c,%esi
  80713a:	39 f0                	cmp    %esi,%eax
  80713c:	73 1c                	jae    80715a <mem_free+0xd4>
  80713e:	c7 44 24 08 7f 2f 81 	movl   $0x812f7f,0x8(%esp)
  807145:	00 
  807146:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  80714d:	00 
  80714e:	c7 04 24 26 2f 81 00 	movl   $0x812f26,(%esp)
  807155:	e8 52 97 ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80715a:	8b 1d a0 86 a3 00    	mov    0xa386a0,%ebx
  807160:	39 d8                	cmp    %ebx,%eax
  807162:	72 1c                	jb     807180 <mem_free+0xfa>
  807164:	c7 44 24 08 96 2f 81 	movl   $0x812f96,0x8(%esp)
  80716b:	00 
  80716c:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
  807173:	00 
  807174:	c7 04 24 26 2f 81 00 	movl   $0x812f26,(%esp)
  80717b:	e8 2c 97 ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  807180:	8b 01                	mov    (%ecx),%eax
  807182:	3d 00 00 22 00       	cmp    $0x220000,%eax
  807187:	76 1c                	jbe    8071a5 <mem_free+0x11f>
  807189:	c7 44 24 08 7c 30 81 	movl   $0x81307c,0x8(%esp)
  807190:	00 
  807191:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
  807198:	00 
  807199:	c7 04 24 26 2f 81 00 	movl   $0x812f26,(%esp)
  8071a0:	e8 07 97 ff ff       	call   8008ac <_panic>

  nmem = (struct mem *)&ram[mem->next];
  8071a5:	8d 14 06             	lea    (%esi,%eax,1),%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  8071a8:	39 d1                	cmp    %edx,%ecx
  8071aa:	74 26                	je     8071d2 <mem_free+0x14c>
  8071ac:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8071b0:	75 20                	jne    8071d2 <mem_free+0x14c>
  8071b2:	39 d3                	cmp    %edx,%ebx
  8071b4:	74 1c                	je     8071d2 <mem_free+0x14c>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  8071b6:	39 15 a4 86 a3 00    	cmp    %edx,0xa386a4
  8071bc:	75 06                	jne    8071c4 <mem_free+0x13e>
      lfree = mem;
  8071be:	89 0d a4 86 a3 00    	mov    %ecx,0xa386a4
    }
    mem->next = nmem->next;
  8071c4:	8b 02                	mov    (%edx),%eax
  8071c6:	89 01                	mov    %eax,(%ecx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  8071c8:	8b 12                	mov    (%edx),%edx
  8071ca:	89 c8                	mov    %ecx,%eax
  8071cc:	29 f0                	sub    %esi,%eax
  8071ce:	89 44 16 04          	mov    %eax,0x4(%esi,%edx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  8071d2:	89 f3                	mov    %esi,%ebx
  8071d4:	03 59 04             	add    0x4(%ecx),%ebx
  if (pmem != mem && pmem->used == 0) {
  8071d7:	39 d9                	cmp    %ebx,%ecx
  8071d9:	74 22                	je     8071fd <mem_free+0x177>
  8071db:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  8071df:	75 1c                	jne    8071fd <mem_free+0x177>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  8071e1:	3b 0d a4 86 a3 00    	cmp    0xa386a4,%ecx
  8071e7:	75 06                	jne    8071ef <mem_free+0x169>
      lfree = pmem;
  8071e9:	89 1d a4 86 a3 00    	mov    %ebx,0xa386a4
    }
    pmem->next = mem->next;
  8071ef:	8b 01                	mov    (%ecx),%eax
  8071f1:	89 03                	mov    %eax,(%ebx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8071f3:	8b 11                	mov    (%ecx),%edx
  8071f5:	89 d8                	mov    %ebx,%eax
  8071f7:	29 f0                	sub    %esi,%eax
  8071f9:	89 44 16 04          	mov    %eax,0x4(%esi,%edx,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8071fd:	a1 a8 86 a3 00       	mov    0xa386a8,%eax
  807202:	89 04 24             	mov    %eax,(%esp)
  807205:	e8 b0 65 00 00       	call   80d7ba <sys_sem_signal>
}
  80720a:	83 c4 10             	add    $0x10,%esp
  80720d:	5b                   	pop    %ebx
  80720e:	5e                   	pop    %esi
  80720f:	5d                   	pop    %ebp
  807210:	c3                   	ret    

00807211 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  807211:	55                   	push   %ebp
  807212:	89 e5                	mov    %esp,%ebp
  807214:	83 ec 08             	sub    $0x8,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  807217:	b8 83 86 81 00       	mov    $0x818683,%eax
  80721c:	83 e0 fc             	and    $0xfffffffc,%eax
  80721f:	a3 9c 86 a3 00       	mov    %eax,0xa3869c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  807224:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  80722a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  807231:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  807235:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  80723b:	89 15 a0 86 a3 00    	mov    %edx,0xa386a0
  ram_end->used = 1;
  807241:	c6 42 08 01          	movb   $0x1,0x8(%edx)
  ram_end->next = MEM_SIZE_ALIGNED;
  807245:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  80724c:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  80724f:	c7 42 04 00 00 22 00 	movl   $0x220000,0x4(%edx)

  mem_sem = sys_sem_new(1);
  807256:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80725d:	e8 b4 63 00 00       	call   80d616 <sys_sem_new>
  807262:	a3 a8 86 a3 00       	mov    %eax,0xa386a8

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  807267:	a1 9c 86 a3 00       	mov    0xa3869c,%eax
  80726c:	a3 a4 86 a3 00       	mov    %eax,0xa386a4

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  807271:	c9                   	leave  
  807272:	c3                   	ret    
	...

00807274 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  807274:	55                   	push   %ebp
  807275:	89 e5                	mov    %esp,%ebp
  807277:	57                   	push   %edi
  807278:	56                   	push   %esi
  807279:	53                   	push   %ebx
  80727a:	83 ec 08             	sub    $0x8,%esp
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80727d:	b8 03 87 a3 00       	mov    $0xa38703,%eax
  807282:	83 e0 fc             	and    $0xfffffffc,%eax
  807285:	89 45 ec             	mov    %eax,-0x14(%ebp)
  807288:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  80728f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  807292:	c7 04 85 c0 86 a3 00 	movl   $0x0,0xa386c0(,%eax,4)
  807299:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80729d:	0f b7 9c 00 3a 31 81 	movzwl 0x81313a(%eax,%eax,1),%ebx
  8072a4:	00 
  8072a5:	66 85 db             	test   %bx,%bx
  8072a8:	74 4b                	je     8072f5 <memp_init+0x81>
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  8072aa:	0f b7 b4 00 1e 31 81 	movzwl 0x81311e(%eax,%eax,1),%esi
  8072b1:	00 
  8072b2:	bf 00 00 00 00       	mov    $0x0,%edi
  8072b7:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  8072ba:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
  8072bf:	89 39                	mov    %edi,(%ecx)
  8072c1:	8d 04 31             	lea    (%ecx,%esi,1),%eax
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  8072c4:	83 c2 01             	add    $0x1,%edx
  8072c7:	66 39 da             	cmp    %bx,%dx
  8072ca:	74 06                	je     8072d2 <memp_init+0x5e>
  8072cc:	89 cf                	mov    %ecx,%edi
  8072ce:	89 c1                	mov    %eax,%ecx
  8072d0:	eb ed                	jmp    8072bf <memp_init+0x4b>
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  8072d2:	8d 43 ff             	lea    -0x1(%ebx),%eax
  8072d5:	0f b7 c0             	movzwl %ax,%eax
  8072d8:	0f af c6             	imul   %esi,%eax
  8072db:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  8072de:	01 c1                	add    %eax,%ecx
  8072e0:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  8072e3:	8d 14 1e             	lea    (%esi,%ebx,1),%edx
  8072e6:	01 d0                	add    %edx,%eax
  8072e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  8072eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8072ee:	89 0c 85 c0 86 a3 00 	mov    %ecx,0xa386c0(,%eax,4)
  8072f5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  8072f9:	83 7d f0 0e          	cmpl   $0xe,-0x10(%ebp)
  8072fd:	75 90                	jne    80728f <memp_init+0x1b>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  8072ff:	83 c4 08             	add    $0x8,%esp
  807302:	5b                   	pop    %ebx
  807303:	5e                   	pop    %esi
  807304:	5f                   	pop    %edi
  807305:	5d                   	pop    %ebp
  807306:	c3                   	ret    

00807307 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  807307:	55                   	push   %ebp
  807308:	89 e5                	mov    %esp,%ebp
  80730a:	83 ec 18             	sub    $0x18,%esp
  80730d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807310:	8b 55 0c             	mov    0xc(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  807313:	85 d2                	test   %edx,%edx
  807315:	74 31                	je     807348 <memp_free+0x41>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  807317:	f6 c2 03             	test   $0x3,%dl
  80731a:	74 1c                	je     807338 <memp_free+0x31>
  80731c:	c7 44 24 08 a8 30 81 	movl   $0x8130a8,0x8(%esp)
  807323:	00 
  807324:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
  80732b:	00 
  80732c:	c7 04 24 eb 30 81 00 	movl   $0x8130eb,(%esp)
  807333:	e8 74 95 ff ff       	call   8008ac <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  807338:	8b 04 8d c0 86 a3 00 	mov    0xa386c0(,%ecx,4),%eax
  80733f:	89 02                	mov    %eax,(%edx)
  memp_tab[type] = memp;
  807341:	89 14 8d c0 86 a3 00 	mov    %edx,0xa386c0(,%ecx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  807348:	c9                   	leave  
  807349:	c3                   	ret    

0080734a <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80734a:	55                   	push   %ebp
  80734b:	89 e5                	mov    %esp,%ebp
  80734d:	83 ec 18             	sub    $0x18,%esp
  807350:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  807353:	83 f9 0d             	cmp    $0xd,%ecx
  807356:	76 1c                	jbe    807374 <memp_malloc+0x2a>
  807358:	c7 44 24 08 00 31 81 	movl   $0x813100,0x8(%esp)
  80735f:	00 
  807360:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  807367:	00 
  807368:	c7 04 24 eb 30 81 00 	movl   $0x8130eb,(%esp)
  80736f:	e8 38 95 ff ff       	call   8008ac <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  807374:	8b 14 8d c0 86 a3 00 	mov    0xa386c0(,%ecx,4),%edx
  
  if (memp != NULL) {    
  80737b:	85 d2                	test   %edx,%edx
  80737d:	74 2a                	je     8073a9 <memp_malloc+0x5f>
    memp_tab[type] = memp->next;    
  80737f:	8b 02                	mov    (%edx),%eax
  807381:	89 04 8d c0 86 a3 00 	mov    %eax,0xa386c0(,%ecx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  807388:	f6 c2 03             	test   $0x3,%dl
  80738b:	74 1c                	je     8073a9 <memp_malloc+0x5f>
  80738d:	c7 44 24 08 c8 30 81 	movl   $0x8130c8,0x8(%esp)
  807394:	00 
  807395:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
  80739c:	00 
  80739d:	c7 04 24 eb 30 81 00 	movl   $0x8130eb,(%esp)
  8073a4:	e8 03 95 ff ff       	call   8008ac <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  8073a9:	89 d0                	mov    %edx,%eax
  8073ab:	c9                   	leave  
  8073ac:	c3                   	ret    
  8073ad:	00 00                	add    %al,(%eax)
	...

008073b0 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  8073b0:	55                   	push   %ebp
  8073b1:	89 e5                	mov    %esp,%ebp
  8073b3:	53                   	push   %ebx
  8073b4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  8073b7:	ba 00 00 00 00       	mov    $0x0,%edx
  8073bc:	85 db                	test   %ebx,%ebx
  8073be:	74 2d                	je     8073ed <netif_find+0x3d>
    return NULL;
  }

  num = name[2] - '0';
  8073c0:	0f b6 4b 02          	movzbl 0x2(%ebx),%ecx
  8073c4:	83 e9 30             	sub    $0x30,%ecx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8073c7:	8b 15 c0 e5 b3 00    	mov    0xb3e5c0,%edx
  8073cd:	85 d2                	test   %edx,%edx
  8073cf:	74 1c                	je     8073ed <netif_find+0x3d>
    if (num == netif->num &&
  8073d1:	38 4a 31             	cmp    %cl,0x31(%edx)
  8073d4:	75 11                	jne    8073e7 <netif_find+0x37>
  8073d6:	0f b6 03             	movzbl (%ebx),%eax
  8073d9:	3a 42 2f             	cmp    0x2f(%edx),%al
  8073dc:	75 09                	jne    8073e7 <netif_find+0x37>
  8073de:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8073e2:	3a 42 30             	cmp    0x30(%edx),%al
  8073e5:	74 06                	je     8073ed <netif_find+0x3d>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8073e7:	8b 12                	mov    (%edx),%edx
  8073e9:	85 d2                	test   %edx,%edx
  8073eb:	75 e4                	jne    8073d1 <netif_find+0x21>
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  8073ed:	89 d0                	mov    %edx,%eax
  8073ef:	5b                   	pop    %ebx
  8073f0:	5d                   	pop    %ebp
  8073f1:	c3                   	ret    

008073f2 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  8073f2:	55                   	push   %ebp
  8073f3:	89 e5                	mov    %esp,%ebp
  8073f5:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&(netif->gw), gw);
  8073f8:	ba 00 00 00 00       	mov    $0x0,%edx
  8073fd:	85 c0                	test   %eax,%eax
  8073ff:	74 02                	je     807403 <netif_set_gw+0x11>
  807401:	8b 10                	mov    (%eax),%edx
  807403:	8b 45 08             	mov    0x8(%ebp),%eax
  807406:	89 50 0c             	mov    %edx,0xc(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  807409:	5d                   	pop    %ebp
  80740a:	c3                   	ret    

0080740b <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  80740b:	55                   	push   %ebp
  80740c:	89 e5                	mov    %esp,%ebp
  80740e:	8b 45 0c             	mov    0xc(%ebp),%eax
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  807411:	ba 00 00 00 00       	mov    $0x0,%edx
  807416:	85 c0                	test   %eax,%eax
  807418:	74 02                	je     80741c <netif_set_netmask+0x11>
  80741a:	8b 10                	mov    (%eax),%edx
  80741c:	8b 45 08             	mov    0x8(%ebp),%eax
  80741f:	89 50 08             	mov    %edx,0x8(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  807422:	5d                   	pop    %ebp
  807423:	c3                   	ret    

00807424 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  807424:	55                   	push   %ebp
  807425:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  807427:	8b 45 08             	mov    0x8(%ebp),%eax
  80742a:	a3 c4 e5 b3 00       	mov    %eax,0xb3e5c4
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80742f:	5d                   	pop    %ebp
  807430:	c3                   	ret    

00807431 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  807431:	55                   	push   %ebp
  807432:	89 e5                	mov    %esp,%ebp
  807434:	83 ec 04             	sub    $0x4,%esp
  807437:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  80743a:	85 c9                	test   %ecx,%ecx
  80743c:	74 48                	je     807486 <netif_remove+0x55>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80743e:	a1 c0 e5 b3 00       	mov    0xb3e5c0,%eax
  807443:	39 c8                	cmp    %ecx,%eax
  807445:	75 1f                	jne    807466 <netif_remove+0x35>
    netif_list = netif->next;
  807447:	8b 01                	mov    (%ecx),%eax
  807449:	a3 c0 e5 b3 00       	mov    %eax,0xb3e5c0
  80744e:	eb 22                	jmp    807472 <netif_remove+0x41>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  807450:	8b 02                	mov    (%edx),%eax
  807452:	39 c8                	cmp    %ecx,%eax
  807454:	74 0a                	je     807460 <netif_remove+0x2f>
  807456:	89 c2                	mov    %eax,%edx
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  807458:	85 d2                	test   %edx,%edx
  80745a:	75 f4                	jne    807450 <netif_remove+0x1f>
  80745c:	eb 28                	jmp    807486 <netif_remove+0x55>
  80745e:	89 c2                	mov    %eax,%edx
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
  807460:	8b 01                	mov    (%ecx),%eax
  807462:	89 02                	mov    %eax,(%edx)
  807464:	eb 0c                	jmp    807472 <netif_remove+0x41>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  807466:	85 c0                	test   %eax,%eax
  807468:	74 1c                	je     807486 <netif_remove+0x55>
      if (tmpNetif->next == netif) {
  80746a:	8b 10                	mov    (%eax),%edx
  80746c:	39 ca                	cmp    %ecx,%edx
  80746e:	75 e8                	jne    807458 <netif_remove+0x27>
  807470:	eb ec                	jmp    80745e <netif_remove+0x2d>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  807472:	39 0d c4 e5 b3 00    	cmp    %ecx,0xb3e5c4
  807478:	75 0c                	jne    807486 <netif_remove+0x55>
    /* reset default netif */
    netif_set_default(NULL);
  80747a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  807481:	e8 9e ff ff ff       	call   807424 <netif_set_default>
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  807486:	c9                   	leave  
  807487:	c3                   	ret    

00807488 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  807488:	55                   	push   %ebp
  807489:	89 e5                	mov    %esp,%ebp
  80748b:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  80748e:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  807492:	a8 01                	test   $0x1,%al
  807494:	74 06                	je     80749c <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  807496:	83 e0 fe             	and    $0xfffffffe,%eax
  807499:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80749c:	5d                   	pop    %ebp
  80749d:	c3                   	ret    

0080749e <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80749e:	55                   	push   %ebp
  80749f:	89 e5                	mov    %esp,%ebp
  8074a1:	8b 45 08             	mov    0x8(%ebp),%eax
  8074a4:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  8074a8:	83 e0 01             	and    $0x1,%eax
  return (netif->flags & NETIF_FLAG_UP)?1:0;
}
  8074ab:	5d                   	pop    %ebp
  8074ac:	c3                   	ret    

008074ad <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8074ad:	55                   	push   %ebp
  8074ae:	89 e5                	mov    %esp,%ebp
  8074b0:	83 ec 18             	sub    $0x18,%esp
  8074b3:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  8074b6:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  8074ba:	a8 01                	test   $0x1,%al
  8074bc:	75 21                	jne    8074df <netif_set_up+0x32>
    netif->flags |= NETIF_FLAG_UP;
  8074be:	83 c8 01             	or     $0x1,%eax
  8074c1:	88 42 2e             	mov    %al,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  8074c4:	a8 20                	test   $0x20,%al
  8074c6:	74 17                	je     8074df <netif_set_up+0x32>
      etharp_query(netif, &(netif->ip_addr), NULL);
  8074c8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8074cf:	00 
  8074d0:	8d 42 04             	lea    0x4(%edx),%eax
  8074d3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8074d7:	89 14 24             	mov    %edx,(%esp)
  8074da:	e8 a2 53 00 00       	call   80c881 <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
  8074df:	c9                   	leave  
  8074e0:	c3                   	ret    

008074e1 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  8074e1:	55                   	push   %ebp
  8074e2:	89 e5                	mov    %esp,%ebp
  8074e4:	57                   	push   %edi
  8074e5:	56                   	push   %esi
  8074e6:	53                   	push   %ebx
  8074e7:	83 ec 0c             	sub    $0xc,%esp
  8074ea:	8b 75 08             	mov    0x8(%ebp),%esi
  8074ed:	8b 7d 0c             	mov    0xc(%ebp),%edi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  8074f0:	8b 07                	mov    (%edi),%eax
  8074f2:	3b 46 04             	cmp    0x4(%esi),%eax
  8074f5:	74 53                	je     80754a <netif_set_ipaddr+0x69>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  8074f7:	8b 15 c8 e5 b3 00    	mov    0xb3e5c8,%edx
    while (pcb != NULL) {
  8074fd:	85 d2                	test   %edx,%edx
  8074ff:	74 1d                	je     80751e <netif_set_ipaddr+0x3d>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  807501:	8b 02                	mov    (%edx),%eax
  807503:	3b 46 04             	cmp    0x4(%esi),%eax
  807506:	75 0f                	jne    807517 <netif_set_ipaddr+0x36>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  807508:	8b 5a 0c             	mov    0xc(%edx),%ebx
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  80750b:	89 14 24             	mov    %edx,(%esp)
  80750e:	e8 ab 16 00 00       	call   808bbe <tcp_abort>
  807513:	89 da                	mov    %ebx,%edx
  807515:	eb 03                	jmp    80751a <netif_set_ipaddr+0x39>
        pcb = next;
      } else {
        pcb = pcb->next;
  807517:	8b 52 0c             	mov    0xc(%edx),%edx
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  80751a:	85 d2                	test   %edx,%edx
  80751c:	75 e3                	jne    807501 <netif_set_ipaddr+0x20>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80751e:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  807523:	85 c0                	test   %eax,%eax
  807525:	74 23                	je     80754a <netif_set_ipaddr+0x69>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  807527:	85 c0                	test   %eax,%eax
  807529:	74 18                	je     807543 <netif_set_ipaddr+0x62>
  80752b:	8b 10                	mov    (%eax),%edx
  80752d:	85 d2                	test   %edx,%edx
  80752f:	74 12                	je     807543 <netif_set_ipaddr+0x62>
  807531:	3b 56 04             	cmp    0x4(%esi),%edx
  807534:	75 0d                	jne    807543 <netif_set_ipaddr+0x62>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  807536:	ba 00 00 00 00       	mov    $0x0,%edx
  80753b:	85 ff                	test   %edi,%edi
  80753d:	74 02                	je     807541 <netif_set_ipaddr+0x60>
  80753f:	8b 17                	mov    (%edi),%edx
  807541:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  807543:	8b 40 0c             	mov    0xc(%eax),%eax
  807546:	85 c0                	test   %eax,%eax
  807548:	75 dd                	jne    807527 <netif_set_ipaddr+0x46>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80754a:	b8 00 00 00 00       	mov    $0x0,%eax
  80754f:	85 ff                	test   %edi,%edi
  807551:	74 02                	je     807555 <netif_set_ipaddr+0x74>
  807553:	8b 07                	mov    (%edi),%eax
  807555:	89 46 04             	mov    %eax,0x4(%esi)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  807558:	83 c4 0c             	add    $0xc,%esp
  80755b:	5b                   	pop    %ebx
  80755c:	5e                   	pop    %esi
  80755d:	5f                   	pop    %edi
  80755e:	5d                   	pop    %ebp
  80755f:	c3                   	ret    

00807560 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  807560:	55                   	push   %ebp
  807561:	89 e5                	mov    %esp,%ebp
  807563:	53                   	push   %ebx
  807564:	83 ec 14             	sub    $0x14,%esp
  807567:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif_set_ipaddr(netif, ipaddr);
  80756a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80756d:	89 44 24 04          	mov    %eax,0x4(%esp)
  807571:	89 1c 24             	mov    %ebx,(%esp)
  807574:	e8 68 ff ff ff       	call   8074e1 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
  807579:	8b 45 10             	mov    0x10(%ebp),%eax
  80757c:	89 44 24 04          	mov    %eax,0x4(%esp)
  807580:	89 1c 24             	mov    %ebx,(%esp)
  807583:	e8 83 fe ff ff       	call   80740b <netif_set_netmask>
  netif_set_gw(netif, gw);
  807588:	8b 45 14             	mov    0x14(%ebp),%eax
  80758b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80758f:	89 1c 24             	mov    %ebx,(%esp)
  807592:	e8 5b fe ff ff       	call   8073f2 <netif_set_gw>
}
  807597:	83 c4 14             	add    $0x14,%esp
  80759a:	5b                   	pop    %ebx
  80759b:	5d                   	pop    %ebp
  80759c:	c3                   	ret    

0080759d <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  80759d:	55                   	push   %ebp
  80759e:	89 e5                	mov    %esp,%ebp
  8075a0:	53                   	push   %ebx
  8075a1:	83 ec 14             	sub    $0x14,%esp
  8075a4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  8075a7:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  8075ae:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  8075b5:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  8075bc:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  8075c0:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  8075c7:	8b 45 18             	mov    0x18(%ebp),%eax
  8075ca:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  8075cd:	0f b6 05 64 77 b3 00 	movzbl 0xb37764,%eax
  8075d4:	88 43 31             	mov    %al,0x31(%ebx)
  8075d7:	83 c0 01             	add    $0x1,%eax
  8075da:	a2 64 77 b3 00       	mov    %al,0xb37764
  netif->input = input;
  8075df:	8b 45 20             	mov    0x20(%ebp),%eax
  8075e2:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  8075e5:	8b 45 14             	mov    0x14(%ebp),%eax
  8075e8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8075ec:	8b 45 10             	mov    0x10(%ebp),%eax
  8075ef:	89 44 24 08          	mov    %eax,0x8(%esp)
  8075f3:	8b 45 0c             	mov    0xc(%ebp),%eax
  8075f6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8075fa:	89 1c 24             	mov    %ebx,(%esp)
  8075fd:	e8 5e ff ff ff       	call   807560 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  807602:	89 1c 24             	mov    %ebx,(%esp)
  807605:	ff 55 1c             	call   *0x1c(%ebp)
  807608:	84 c0                	test   %al,%al
  80760a:	74 07                	je     807613 <netif_add+0x76>
  80760c:	bb 00 00 00 00       	mov    $0x0,%ebx
  807611:	eb 0d                	jmp    807620 <netif_add+0x83>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  807613:	a1 c0 e5 b3 00       	mov    0xb3e5c0,%eax
  807618:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  80761a:	89 1d c0 e5 b3 00    	mov    %ebx,0xb3e5c0
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  807620:	89 d8                	mov    %ebx,%eax
  807622:	83 c4 14             	add    $0x14,%esp
  807625:	5b                   	pop    %ebx
  807626:	5d                   	pop    %ebp
  807627:	c3                   	ret    
	...

00807630 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  807630:	55                   	push   %ebp
  807631:	89 e5                	mov    %esp,%ebp
  807633:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  while (p != NULL) {
  807636:	b8 00 00 00 00       	mov    $0x0,%eax
  80763b:	85 d2                	test   %edx,%edx
  80763d:	74 0e                	je     80764d <pbuf_clen+0x1d>
  80763f:	b8 00 00 00 00       	mov    $0x0,%eax
    ++len;
  807644:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  807647:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  807649:	85 d2                	test   %edx,%edx
  80764b:	75 f7                	jne    807644 <pbuf_clen+0x14>
  80764d:	0f b6 c0             	movzbl %al,%eax
    ++len;
    p = p->next;
  }
  return len;
}
  807650:	5d                   	pop    %ebp
  807651:	c3                   	ret    

00807652 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  807652:	55                   	push   %ebp
  807653:	89 e5                	mov    %esp,%ebp
  807655:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  807658:	85 c0                	test   %eax,%eax
  80765a:	74 05                	je     807661 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  80765c:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  807661:	5d                   	pop    %ebp
  807662:	c3                   	ret    

00807663 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  807663:	55                   	push   %ebp
  807664:	89 e5                	mov    %esp,%ebp
  807666:	83 ec 18             	sub    $0x18,%esp
  807669:	8b 45 08             	mov    0x8(%ebp),%eax
  80766c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  80766f:	85 c0                	test   %eax,%eax
  807671:	74 0f                	je     807682 <pbuf_cat+0x1f>
  807673:	85 c9                	test   %ecx,%ecx
  807675:	74 0b                	je     807682 <pbuf_cat+0x1f>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807677:	89 c2                	mov    %eax,%edx
  807679:	83 38 00             	cmpl   $0x0,(%eax)
  80767c:	74 31                	je     8076af <pbuf_cat+0x4c>
  80767e:	66 90                	xchg   %ax,%ax
  807680:	eb 1c                	jmp    80769e <pbuf_cat+0x3b>
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807682:	c7 44 24 08 58 31 81 	movl   $0x813158,0x8(%esp)
  807689:	00 
  80768a:	c7 44 24 04 42 02 00 	movl   $0x242,0x4(%esp)
  807691:	00 
  807692:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807699:	e8 0e 92 ff ff       	call   8008ac <_panic>
  80769e:	89 c2                	mov    %eax,%edx
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  8076a0:	0f b7 41 08          	movzwl 0x8(%ecx),%eax
  8076a4:	66 01 42 08          	add    %ax,0x8(%edx)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  8076a8:	8b 12                	mov    (%edx),%edx
  8076aa:	83 3a 00             	cmpl   $0x0,(%edx)
  8076ad:	75 f1                	jne    8076a0 <pbuf_cat+0x3d>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  8076af:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  8076b3:	66 3b 42 0a          	cmp    0xa(%edx),%ax
  8076b7:	74 1c                	je     8076d5 <pbuf_cat+0x72>
  8076b9:	c7 44 24 08 90 31 81 	movl   $0x813190,0x8(%esp)
  8076c0:	00 
  8076c1:	c7 44 24 04 4a 02 00 	movl   $0x24a,0x4(%esp)
  8076c8:	00 
  8076c9:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  8076d0:	e8 d7 91 ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  8076d5:	66 03 41 08          	add    0x8(%ecx),%ax
  8076d9:	66 89 42 08          	mov    %ax,0x8(%edx)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  8076dd:	89 0a                	mov    %ecx,(%edx)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  8076df:	c9                   	leave  
  8076e0:	c3                   	ret    

008076e1 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  8076e1:	55                   	push   %ebp
  8076e2:	89 e5                	mov    %esp,%ebp
  8076e4:	53                   	push   %ebx
  8076e5:	83 ec 14             	sub    $0x14,%esp
  8076e8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  8076eb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8076ef:	8b 45 08             	mov    0x8(%ebp),%eax
  8076f2:	89 04 24             	mov    %eax,(%esp)
  8076f5:	e8 69 ff ff ff       	call   807663 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  8076fa:	89 1c 24             	mov    %ebx,(%esp)
  8076fd:	e8 50 ff ff ff       	call   807652 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  807702:	83 c4 14             	add    $0x14,%esp
  807705:	5b                   	pop    %ebx
  807706:	5d                   	pop    %ebp
  807707:	c3                   	ret    

00807708 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  807708:	55                   	push   %ebp
  807709:	89 e5                	mov    %esp,%ebp
  80770b:	56                   	push   %esi
  80770c:	53                   	push   %ebx
  80770d:	83 ec 10             	sub    $0x10,%esp
  807710:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807713:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  807717:	85 db                	test   %ebx,%ebx
  807719:	75 1c                	jne    807737 <pbuf_header+0x2f>
  80771b:	c7 44 24 08 19 34 81 	movl   $0x813419,0x8(%esp)
  807722:	00 
  807723:	c7 44 24 04 64 01 00 	movl   $0x164,0x4(%esp)
  80772a:	00 
  80772b:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807732:	e8 75 91 ff ff       	call   8008ac <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  807737:	b8 00 00 00 00       	mov    $0x0,%eax
  80773c:	66 85 c9             	test   %cx,%cx
  80773f:	0f 84 a7 00 00 00    	je     8077ec <pbuf_header+0xe4>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  807745:	89 ca                	mov    %ecx,%edx

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  807747:	66 85 c9             	test   %cx,%cx
  80774a:	79 24                	jns    807770 <pbuf_header+0x68>
    increment_magnitude = -header_size_increment;
  80774c:	f7 da                	neg    %edx
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  80774e:	66 3b 53 0a          	cmp    0xa(%ebx),%dx
  807752:	76 1c                	jbe    807770 <pbuf_header+0x68>
  807754:	c7 44 24 08 60 33 81 	movl   $0x813360,0x8(%esp)
  80775b:	00 
  80775c:	c7 44 24 04 6b 01 00 	movl   $0x16b,0x4(%esp)
  807763:	00 
  807764:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  80776b:	e8 3c 91 ff ff       	call   8008ac <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  807770:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  807774:	8b 73 04             	mov    0x4(%ebx),%esi

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  807777:	66 85 c0             	test   %ax,%ax
  80777a:	74 06                	je     807782 <pbuf_header+0x7a>
  80777c:	66 83 f8 03          	cmp    $0x3,%ax
  807780:	75 1b                	jne    80779d <pbuf_header+0x95>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  807782:	0f bf c1             	movswl %cx,%eax
  807785:	89 f2                	mov    %esi,%edx
  807787:	29 c2                	sub    %eax,%edx
  807789:	89 53 04             	mov    %edx,0x4(%ebx)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80778c:	8d 43 10             	lea    0x10(%ebx),%eax
  80778f:	39 c2                	cmp    %eax,%edx
  807791:	73 45                	jae    8077d8 <pbuf_header+0xd0>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  807793:	89 73 04             	mov    %esi,0x4(%ebx)
  807796:	b8 01 00 00 00       	mov    $0x1,%eax
  80779b:	eb 4f                	jmp    8077ec <pbuf_header+0xe4>
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  80779d:	83 e8 01             	sub    $0x1,%eax
  8077a0:	66 83 f8 01          	cmp    $0x1,%ax
  8077a4:	77 16                	ja     8077bc <pbuf_header+0xb4>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  8077a6:	66 85 c9             	test   %cx,%cx
  8077a9:	79 3c                	jns    8077e7 <pbuf_header+0xdf>
  8077ab:	66 3b 53 0a          	cmp    0xa(%ebx),%dx
  8077af:	90                   	nop    
  8077b0:	77 35                	ja     8077e7 <pbuf_header+0xdf>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  8077b2:	0f bf c1             	movswl %cx,%eax
  8077b5:	29 c6                	sub    %eax,%esi
  8077b7:	89 73 04             	mov    %esi,0x4(%ebx)
  8077ba:	eb 1c                	jmp    8077d8 <pbuf_header+0xd0>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  8077bc:	c7 44 24 08 7e 33 81 	movl   $0x81337e,0x8(%esp)
  8077c3:	00 
  8077c4:	c7 44 24 04 9a 01 00 	movl   $0x19a,0x4(%esp)
  8077cb:	00 
  8077cc:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  8077d3:	e8 d4 90 ff ff       	call   8008ac <_panic>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  8077d8:	66 01 4b 0a          	add    %cx,0xa(%ebx)
  p->tot_len += header_size_increment;
  8077dc:	66 01 4b 08          	add    %cx,0x8(%ebx)
  8077e0:	b8 00 00 00 00       	mov    $0x0,%eax
  8077e5:	eb 05                	jmp    8077ec <pbuf_header+0xe4>

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  8077e7:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8077ec:	83 c4 10             	add    $0x10,%esp
  8077ef:	5b                   	pop    %ebx
  8077f0:	5e                   	pop    %esi
  8077f1:	5d                   	pop    %ebp
  8077f2:	c3                   	ret    

008077f3 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  8077f3:	55                   	push   %ebp
  8077f4:	89 e5                	mov    %esp,%ebp
  8077f6:	57                   	push   %edi
  8077f7:	56                   	push   %esi
  8077f8:	53                   	push   %ebx
  8077f9:	83 ec 1c             	sub    $0x1c,%esp
  8077fc:	8b 45 08             	mov    0x8(%ebp),%eax
  8077ff:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  807803:	0f b7 55 14          	movzwl 0x14(%ebp),%edx
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  807807:	85 c0                	test   %eax,%eax
  807809:	75 1c                	jne    807827 <pbuf_copy_partial+0x34>
  80780b:	c7 44 24 08 c0 31 81 	movl   $0x8131c0,0x8(%esp)
  807812:	00 
  807813:	c7 44 24 04 ef 02 00 	movl   $0x2ef,0x4(%esp)
  80781a:	00 
  80781b:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807822:	e8 85 90 ff ff       	call   8008ac <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  807827:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80782b:	75 1c                	jne    807849 <pbuf_copy_partial+0x56>
  80782d:	c7 44 24 08 e4 31 81 	movl   $0x8131e4,0x8(%esp)
  807834:	00 
  807835:	c7 44 24 04 f0 02 00 	movl   $0x2f0,0x4(%esp)
  80783c:	00 
  80783d:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807844:	e8 63 90 ff ff       	call   8008ac <_panic>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  807849:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
  80784f:	66 85 ff             	test   %di,%di
  807852:	74 6c                	je     8078c0 <pbuf_copy_partial+0xcd>
  807854:	89 c6                	mov    %eax,%esi
  807856:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
  80785c:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
    if ((offset != 0) && (offset >= p->len)) {
  807862:	66 85 d2             	test   %dx,%dx
  807865:	74 0e                	je     807875 <pbuf_copy_partial+0x82>
  807867:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80786b:	66 39 d0             	cmp    %dx,%ax
  80786e:	77 05                	ja     807875 <pbuf_copy_partial+0x82>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  807870:	66 29 c2             	sub    %ax,%dx
  807873:	eb 40                	jmp    8078b5 <pbuf_copy_partial+0xc2>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  807875:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807879:	89 c3                	mov    %eax,%ebx
  80787b:	66 29 d3             	sub    %dx,%bx
  80787e:	66 39 fb             	cmp    %di,%bx
  807881:	76 02                	jbe    807885 <pbuf_copy_partial+0x92>
  807883:	89 fb                	mov    %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  807885:	0f b7 c3             	movzwl %bx,%eax
  807888:	89 44 24 08          	mov    %eax,0x8(%esp)
  80788c:	0f b7 c2             	movzwl %dx,%eax
  80788f:	03 46 04             	add    0x4(%esi),%eax
  807892:	89 44 24 04          	mov    %eax,0x4(%esp)
  807896:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
  80789a:	03 45 0c             	add    0xc(%ebp),%eax
  80789d:	89 04 24             	mov    %eax,(%esp)
  8078a0:	e8 c3 99 ff ff       	call   801268 <memcpy>
      copied_total += buf_copy_len;
  8078a5:	66 01 5d f2          	add    %bx,-0xe(%ebp)
      left += buf_copy_len;
  8078a9:	66 01 5d f0          	add    %bx,-0x10(%ebp)
      len -= buf_copy_len;
  8078ad:	66 29 df             	sub    %bx,%di
  8078b0:	ba 00 00 00 00       	mov    $0x0,%edx
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  8078b5:	8b 36                	mov    (%esi),%esi
  8078b7:	66 85 ff             	test   %di,%di
  8078ba:	74 04                	je     8078c0 <pbuf_copy_partial+0xcd>
  8078bc:	85 f6                	test   %esi,%esi
  8078be:	75 a2                	jne    807862 <pbuf_copy_partial+0x6f>
  8078c0:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  8078c4:	83 c4 1c             	add    $0x1c,%esp
  8078c7:	5b                   	pop    %ebx
  8078c8:	5e                   	pop    %esi
  8078c9:	5f                   	pop    %edi
  8078ca:	5d                   	pop    %ebp
  8078cb:	c3                   	ret    

008078cc <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  8078cc:	55                   	push   %ebp
  8078cd:	89 e5                	mov    %esp,%ebp
  8078cf:	57                   	push   %edi
  8078d0:	56                   	push   %esi
  8078d1:	53                   	push   %ebx
  8078d2:	83 ec 1c             	sub    $0x1c,%esp
  8078d5:	8b 7d 08             	mov    0x8(%ebp),%edi
  8078d8:	8b 75 0c             	mov    0xc(%ebp),%esi

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  8078db:	85 ff                	test   %edi,%edi
  8078dd:	0f 94 c2             	sete   %dl
  8078e0:	74 0e                	je     8078f0 <pbuf_copy+0x24>
  8078e2:	85 f6                	test   %esi,%esi
  8078e4:	74 0a                	je     8078f0 <pbuf_copy+0x24>
  8078e6:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8078ea:	66 3b 46 08          	cmp    0x8(%esi),%ax
  8078ee:	73 1c                	jae    80790c <pbuf_copy+0x40>
  8078f0:	c7 44 24 08 0c 32 81 	movl   $0x81320c,0x8(%esp)
  8078f7:	00 
  8078f8:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
  8078ff:	00 
  807900:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807907:	e8 a0 8f ff ff       	call   8008ac <_panic>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  80790c:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
  807912:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
  807918:	84 d2                	test   %dl,%dl
  80791a:	74 22                	je     80793e <pbuf_copy+0x72>
  80791c:	eb 04                	jmp    807922 <pbuf_copy+0x56>
  80791e:	85 ff                	test   %edi,%edi
  807920:	75 1c                	jne    80793e <pbuf_copy+0x72>
  807922:	c7 44 24 08 8c 33 81 	movl   $0x81338c,0x8(%esp)
  807929:	00 
  80792a:	c7 44 24 04 b6 02 00 	movl   $0x2b6,0x4(%esp)
  807931:	00 
  807932:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807939:	e8 6e 8f ff ff       	call   8008ac <_panic>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  80793e:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
  807942:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
  807946:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  80794a:	0f b7 c8             	movzwl %ax,%ecx
  80794d:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
  807951:	29 c1                	sub    %eax,%ecx
  807953:	0f b7 c3             	movzwl %bx,%eax
  807956:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  80795a:	29 d0                	sub    %edx,%eax
  80795c:	39 c1                	cmp    %eax,%ecx
  80795e:	7c 06                	jl     807966 <pbuf_copy+0x9a>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  807960:	66 2b 5d f2          	sub    -0xe(%ebp),%bx
  807964:	eb 08                	jmp    80796e <pbuf_copy+0xa2>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  807966:	0f b7 5d ee          	movzwl -0x12(%ebp),%ebx
  80796a:	66 2b 5d f0          	sub    -0x10(%ebp),%bx
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  80796e:	0f b7 c3             	movzwl %bx,%eax
  807971:	89 44 24 08          	mov    %eax,0x8(%esp)
  807975:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  807979:	03 46 04             	add    0x4(%esi),%eax
  80797c:	89 44 24 04          	mov    %eax,0x4(%esp)
  807980:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
  807984:	03 47 04             	add    0x4(%edi),%eax
  807987:	89 04 24             	mov    %eax,(%esp)
  80798a:	e8 d9 98 ff ff       	call   801268 <memcpy>
    offset_to += len;
  80798f:	66 01 5d f0          	add    %bx,-0x10(%ebp)
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  807993:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
  807997:	66 39 45 f0          	cmp    %ax,-0x10(%ebp)
  80799b:	76 1c                	jbe    8079b9 <pbuf_copy+0xed>
  80799d:	c7 44 24 08 99 33 81 	movl   $0x813399,0x8(%esp)
  8079a4:	00 
  8079a5:	c7 44 24 04 c2 02 00 	movl   $0x2c2,0x4(%esp)
  8079ac:	00 
  8079ad:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  8079b4:	e8 f3 8e ff ff       	call   8008ac <_panic>
    if (offset_to == p_to->len) {
  8079b9:	66 39 45 f0          	cmp    %ax,-0x10(%ebp)
  8079bd:	75 08                	jne    8079c7 <pbuf_copy+0xfb>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  8079bf:	8b 3f                	mov    (%edi),%edi
  8079c1:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
  8079c7:	66 01 5d f2          	add    %bx,-0xe(%ebp)
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  8079cb:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  8079cf:	66 39 45 f2          	cmp    %ax,-0xe(%ebp)
  8079d3:	76 1c                	jbe    8079f1 <pbuf_copy+0x125>
  8079d5:	c7 44 24 08 b0 33 81 	movl   $0x8133b0,0x8(%esp)
  8079dc:	00 
  8079dd:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
  8079e4:	00 
  8079e5:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  8079ec:	e8 bb 8e ff ff       	call   8008ac <_panic>
    if (offset_from >= p_from->len) {
  8079f1:	66 39 45 f2          	cmp    %ax,-0xe(%ebp)
  8079f5:	72 08                	jb     8079ff <pbuf_copy+0x133>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  8079f7:	8b 36                	mov    (%esi),%esi
  8079f9:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  8079ff:	85 f6                	test   %esi,%esi
  807a01:	74 2b                	je     807a2e <pbuf_copy+0x162>
  807a03:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807a07:	66 3b 46 08          	cmp    0x8(%esi),%ax
  807a0b:	75 21                	jne    807a2e <pbuf_copy+0x162>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807a0d:	83 3e 00             	cmpl   $0x0,(%esi)
  807a10:	74 1c                	je     807a2e <pbuf_copy+0x162>
  807a12:	c7 44 24 08 3c 32 81 	movl   $0x81323c,0x8(%esp)
  807a19:	00 
  807a1a:	c7 44 24 04 d2 02 00 	movl   $0x2d2,0x4(%esp)
  807a21:	00 
  807a22:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807a29:	e8 7e 8e ff ff       	call   8008ac <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  807a2e:	85 ff                	test   %edi,%edi
  807a30:	74 2c                	je     807a5e <pbuf_copy+0x192>
  807a32:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
  807a36:	66 3b 47 08          	cmp    0x8(%edi),%ax
  807a3a:	75 22                	jne    807a5e <pbuf_copy+0x192>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807a3c:	83 3f 00             	cmpl   $0x0,(%edi)
  807a3f:	90                   	nop    
  807a40:	74 1c                	je     807a5e <pbuf_copy+0x192>
  807a42:	c7 44 24 08 3c 32 81 	movl   $0x81323c,0x8(%esp)
  807a49:	00 
  807a4a:	c7 44 24 04 d7 02 00 	movl   $0x2d7,0x4(%esp)
  807a51:	00 
  807a52:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807a59:	e8 4e 8e ff ff       	call   8008ac <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  807a5e:	85 f6                	test   %esi,%esi
  807a60:	0f 85 b8 fe ff ff    	jne    80791e <pbuf_copy+0x52>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  807a66:	b8 00 00 00 00       	mov    $0x0,%eax
  807a6b:	83 c4 1c             	add    $0x1c,%esp
  807a6e:	5b                   	pop    %ebx
  807a6f:	5e                   	pop    %esi
  807a70:	5f                   	pop    %edi
  807a71:	5d                   	pop    %ebp
  807a72:	c3                   	ret    

00807a73 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  807a73:	55                   	push   %ebp
  807a74:	89 e5                	mov    %esp,%ebp
  807a76:	56                   	push   %esi
  807a77:	53                   	push   %ebx
  807a78:	83 ec 10             	sub    $0x10,%esp
  807a7b:	8b 55 08             	mov    0x8(%ebp),%edx
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  807a7e:	85 d2                	test   %edx,%edx
  807a80:	75 1c                	jne    807a9e <pbuf_free+0x2b>
    LWIP_ASSERT("p != NULL", p != NULL);
  807a82:	c7 44 24 08 19 34 81 	movl   $0x813419,0x8(%esp)
  807a89:	00 
  807a8a:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp)
  807a91:	00 
  807a92:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807a99:	e8 0e 8e ff ff       	call   8008ac <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  807a9e:	be 00 00 00 00       	mov    $0x0,%esi
  807aa3:	80 7a 0c 03          	cmpb   $0x3,0xc(%edx)
  807aa7:	76 1c                	jbe    807ac5 <pbuf_free+0x52>
  807aa9:	c7 44 24 08 cb 33 81 	movl   $0x8133cb,0x8(%esp)
  807ab0:	00 
  807ab1:	c7 44 24 04 db 01 00 	movl   $0x1db,0x4(%esp)
  807ab8:	00 
  807ab9:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807ac0:	e8 e7 8d ff ff       	call   8008ac <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  807ac5:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
  807ac9:	66 85 c0             	test   %ax,%ax
  807acc:	75 1c                	jne    807aea <pbuf_free+0x77>
  807ace:	c7 44 24 08 e0 33 81 	movl   $0x8133e0,0x8(%esp)
  807ad5:	00 
  807ad6:	c7 44 24 04 e8 01 00 	movl   $0x1e8,0x4(%esp)
  807add:	00 
  807ade:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807ae5:	e8 c2 8d ff ff       	call   8008ac <_panic>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  807aea:	83 e8 01             	sub    $0x1,%eax
  807aed:	66 89 42 0e          	mov    %ax,0xe(%edx)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  807af1:	66 85 c0             	test   %ax,%ax
  807af4:	75 4b                	jne    807b41 <pbuf_free+0xce>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  807af6:	8b 1a                	mov    (%edx),%ebx
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  807af8:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  807afc:	3c 03                	cmp    $0x3,%al
  807afe:	75 12                	jne    807b12 <pbuf_free+0x9f>
        memp_free(MEMP_PBUF_POOL, p);
  807b00:	89 54 24 04          	mov    %edx,0x4(%esp)
  807b04:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  807b0b:	e8 f7 f7 ff ff       	call   807307 <memp_free>
  807b10:	eb 26                	jmp    807b38 <pbuf_free+0xc5>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  807b12:	0f b6 c0             	movzbl %al,%eax
  807b15:	83 e8 01             	sub    $0x1,%eax
  807b18:	66 83 f8 01          	cmp    $0x1,%ax
  807b1c:	77 12                	ja     807b30 <pbuf_free+0xbd>
        memp_free(MEMP_PBUF, p);
  807b1e:	89 54 24 04          	mov    %edx,0x4(%esp)
  807b22:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  807b29:	e8 d9 f7 ff ff       	call   807307 <memp_free>
  807b2e:	eb 08                	jmp    807b38 <pbuf_free+0xc5>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  807b30:	89 14 24             	mov    %edx,(%esp)
  807b33:	e8 4e f5 ff ff       	call   807086 <mem_free>
      }
      count++;
  807b38:	83 c6 01             	add    $0x1,%esi
  807b3b:	89 da                	mov    %ebx,%edx
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  807b3d:	85 db                	test   %ebx,%ebx
  807b3f:	75 84                	jne    807ac5 <pbuf_free+0x52>
  807b41:	89 f2                	mov    %esi,%edx
  807b43:	0f b6 c2             	movzbl %dl,%eax
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  807b46:	83 c4 10             	add    $0x10,%esp
  807b49:	5b                   	pop    %ebx
  807b4a:	5e                   	pop    %esi
  807b4b:	5d                   	pop    %ebp
  807b4c:	c3                   	ret    

00807b4d <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  807b4d:	55                   	push   %ebp
  807b4e:	89 e5                	mov    %esp,%ebp
  807b50:	83 ec 28             	sub    $0x28,%esp
  807b53:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  807b56:	89 75 f8             	mov    %esi,-0x8(%ebp)
  807b59:	89 7d fc             	mov    %edi,-0x4(%ebp)
  807b5c:	8b 75 08             	mov    0x8(%ebp),%esi
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  807b5f:	8b 1e                	mov    (%esi),%ebx
  /* pbuf has successor in chain? */
  if (q != NULL) {
  807b61:	ba 01 00 00 00       	mov    $0x1,%edx
  807b66:	85 db                	test   %ebx,%ebx
  807b68:	74 5c                	je     807bc6 <pbuf_dechain+0x79>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  807b6a:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  807b6e:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  807b72:	0f b7 7e 0a          	movzwl 0xa(%esi),%edi
  807b76:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  807b7a:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  807b7e:	0f b7 cf             	movzwl %di,%ecx
  807b81:	29 ca                	sub    %ecx,%edx
  807b83:	39 d0                	cmp    %edx,%eax
  807b85:	74 1c                	je     807ba3 <pbuf_dechain+0x56>
  807b87:	c7 44 24 08 68 32 81 	movl   $0x813268,0x8(%esp)
  807b8e:	00 
  807b8f:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
  807b96:	00 
  807b97:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807b9e:	e8 09 8d ff ff       	call   8008ac <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  807ba3:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  807ba7:	66 29 f8             	sub    %di,%ax
  807baa:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* decouple pbuf from remainder */
    p->next = NULL;
  807bae:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  807bb4:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807bb8:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  807bbc:	89 1c 24             	mov    %ebx,(%esp)
  807bbf:	e8 af fe ff ff       	call   807a73 <pbuf_free>
  807bc4:	89 c2                	mov    %eax,%edx
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  807bc6:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  807bca:	66 3b 46 0a          	cmp    0xa(%esi),%ax
  807bce:	74 1c                	je     807bec <pbuf_dechain+0x9f>
  807bd0:	c7 44 24 08 f6 33 81 	movl   $0x8133f6,0x8(%esp)
  807bd7:	00 
  807bd8:	c7 44 24 04 91 02 00 	movl   $0x291,0x4(%esp)
  807bdf:	00 
  807be0:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807be7:	e8 c0 8c ff ff       	call   8008ac <_panic>
  return ((tail_gone > 0) ? NULL : q);
  807bec:	80 fa 01             	cmp    $0x1,%dl
  807bef:	19 c0                	sbb    %eax,%eax
  807bf1:	21 c3                	and    %eax,%ebx
}
  807bf3:	89 d8                	mov    %ebx,%eax
  807bf5:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  807bf8:	8b 75 f8             	mov    -0x8(%ebp),%esi
  807bfb:	8b 7d fc             	mov    -0x4(%ebp),%edi
  807bfe:	89 ec                	mov    %ebp,%esp
  807c00:	5d                   	pop    %ebp
  807c01:	c3                   	ret    

00807c02 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  807c02:	55                   	push   %ebp
  807c03:	89 e5                	mov    %esp,%ebp
  807c05:	56                   	push   %esi
  807c06:	53                   	push   %ebx
  807c07:	83 ec 10             	sub    $0x10,%esp
  807c0a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807c0d:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  807c11:	85 db                	test   %ebx,%ebx
  807c13:	75 1c                	jne    807c31 <pbuf_realloc+0x2f>
  807c15:	c7 44 24 08 0b 34 81 	movl   $0x81340b,0x8(%esp)
  807c1c:	00 
  807c1d:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp)
  807c24:	00 
  807c25:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807c2c:	e8 7b 8c ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  807c31:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  807c35:	3c 03                	cmp    $0x3,%al
  807c37:	74 29                	je     807c62 <pbuf_realloc+0x60>
  807c39:	3c 01                	cmp    $0x1,%al
  807c3b:	74 25                	je     807c62 <pbuf_realloc+0x60>
  807c3d:	84 c0                	test   %al,%al
  807c3f:	90                   	nop    
  807c40:	74 20                	je     807c62 <pbuf_realloc+0x60>
  807c42:	3c 02                	cmp    $0x2,%al
  807c44:	74 1c                	je     807c62 <pbuf_realloc+0x60>
  807c46:	c7 44 24 08 23 34 81 	movl   $0x813423,0x8(%esp)
  807c4d:	00 
  807c4e:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
  807c55:	00 
  807c56:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807c5d:	e8 4a 8c ff ff       	call   8008ac <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  807c62:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  807c66:	66 39 c8             	cmp    %cx,%ax
  807c69:	0f 86 c0 00 00 00    	jbe    807d2f <pbuf_realloc+0x12d>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  807c6f:	0f b7 d1             	movzwl %cx,%edx
  807c72:	0f b7 c0             	movzwl %ax,%eax
  807c75:	29 c2                	sub    %eax,%edx
  807c77:	89 d0                	mov    %edx,%eax
  807c79:	89 ce                	mov    %ecx,%esi
  807c7b:	eb 4c                	jmp    807cc9 <pbuf_realloc+0xc7>
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  807c7d:	3d fe ff 00 00       	cmp    $0xfffe,%eax
  807c82:	7e 1c                	jle    807ca0 <pbuf_realloc+0x9e>
  807c84:	c7 44 24 08 3e 34 81 	movl   $0x81343e,0x8(%esp)
  807c8b:	00 
  807c8c:	c7 44 24 04 2b 01 00 	movl   $0x12b,0x4(%esp)
  807c93:	00 
  807c94:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807c9b:	e8 0c 8c ff ff       	call   8008ac <_panic>
    q->tot_len += (u16_t)grow;
  807ca0:	66 01 43 08          	add    %ax,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  807ca4:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  807ca6:	85 db                	test   %ebx,%ebx
  807ca8:	75 1c                	jne    807cc6 <pbuf_realloc+0xc4>
  807caa:	c7 44 24 08 4f 34 81 	movl   $0x81344f,0x8(%esp)
  807cb1:	00 
  807cb2:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  807cb9:	00 
  807cba:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807cc1:	e8 e6 8b ff ff       	call   8008ac <_panic>
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  807cc6:	66 29 ce             	sub    %cx,%si

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  807cc9:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  807ccd:	66 39 ce             	cmp    %cx,%si
  807cd0:	77 ab                	ja     807c7d <pbuf_realloc+0x7b>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  807cd2:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  807cd6:	75 3b                	jne    807d13 <pbuf_realloc+0x111>
  807cd8:	66 39 ce             	cmp    %cx,%si
  807cdb:	74 36                	je     807d13 <pbuf_realloc+0x111>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  807cdd:	0f b7 c6             	movzwl %si,%eax
  807ce0:	03 43 04             	add    0x4(%ebx),%eax
  807ce3:	29 d8                	sub    %ebx,%eax
  807ce5:	89 44 24 04          	mov    %eax,0x4(%esp)
  807ce9:	89 1c 24             	mov    %ebx,(%esp)
  807cec:	e8 2d f2 ff ff       	call   806f1e <mem_realloc>
  807cf1:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  807cf3:	85 c0                	test   %eax,%eax
  807cf5:	75 1c                	jne    807d13 <pbuf_realloc+0x111>
  807cf7:	c7 44 24 08 67 34 81 	movl   $0x813467,0x8(%esp)
  807cfe:	00 
  807cff:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
  807d06:	00 
  807d07:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807d0e:	e8 99 8b ff ff       	call   8008ac <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  807d13:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  807d17:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  807d1b:	8b 03                	mov    (%ebx),%eax
  807d1d:	85 c0                	test   %eax,%eax
  807d1f:	74 08                	je     807d29 <pbuf_realloc+0x127>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  807d21:	89 04 24             	mov    %eax,(%esp)
  807d24:	e8 4a fd ff ff       	call   807a73 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  807d29:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  807d2f:	83 c4 10             	add    $0x10,%esp
  807d32:	5b                   	pop    %ebx
  807d33:	5e                   	pop    %esi
  807d34:	5d                   	pop    %ebp
  807d35:	c3                   	ret    

00807d36 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  807d36:	55                   	push   %ebp
  807d37:	89 e5                	mov    %esp,%ebp
  807d39:	57                   	push   %edi
  807d3a:	56                   	push   %esi
  807d3b:	53                   	push   %ebx
  807d3c:	83 ec 1c             	sub    $0x1c,%esp
  807d3f:	8b 45 08             	mov    0x8(%ebp),%eax
  807d42:	0f b7 5d 0c          	movzwl 0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  807d46:	83 f8 01             	cmp    $0x1,%eax
  807d49:	74 27                	je     807d72 <pbuf_alloc+0x3c>
  807d4b:	ba 14 00 00 00       	mov    $0x14,%edx
  807d50:	83 f8 01             	cmp    $0x1,%eax
  807d53:	72 22                	jb     807d77 <pbuf_alloc+0x41>
  807d55:	83 f8 02             	cmp    $0x2,%eax
  807d58:	74 0a                	je     807d64 <pbuf_alloc+0x2e>
  807d5a:	83 f8 03             	cmp    $0x3,%eax
  807d5d:	8d 76 00             	lea    0x0(%esi),%esi
  807d60:	75 20                	jne    807d82 <pbuf_alloc+0x4c>
  807d62:	eb 3a                	jmp    807d9e <pbuf_alloc+0x68>
  807d64:	b8 00 00 00 00       	mov    $0x0,%eax
  807d69:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  807d70:	eb 08                	jmp    807d7a <pbuf_alloc+0x44>
  807d72:	ba 00 00 00 00       	mov    $0x0,%edx
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  807d77:	8d 42 14             	lea    0x14(%edx),%eax
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  807d7a:	8d 78 0e             	lea    0xe(%eax),%edi
  807d7d:	8d 76 00             	lea    0x0(%esi),%esi
  807d80:	eb 21                	jmp    807da3 <pbuf_alloc+0x6d>
    break;
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  807d82:	c7 44 24 08 82 34 81 	movl   $0x813482,0x8(%esp)
  807d89:	00 
  807d8a:	c7 44 24 04 8a 00 00 	movl   $0x8a,0x4(%esp)
  807d91:	00 
  807d92:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807d99:	e8 0e 8b ff ff       	call   8008ac <_panic>
  807d9e:	bf 00 00 00 00       	mov    $0x0,%edi
    return NULL;
  }

  switch (type) {
  807da3:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  807da7:	77 0f                	ja     807db8 <pbuf_alloc+0x82>
  807da9:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  807dad:	0f 83 ee 01 00 00    	jae    807fa1 <pbuf_alloc+0x26b>
  807db3:	e9 85 01 00 00       	jmp    807f3d <pbuf_alloc+0x207>
  807db8:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  807dbc:	8d 74 26 00          	lea    0x0(%esi),%esi
  807dc0:	0f 85 0b 02 00 00    	jne    807fd1 <pbuf_alloc+0x29b>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  807dc6:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  807dcd:	8d 76 00             	lea    0x0(%esi),%esi
  807dd0:	e8 75 f5 ff ff       	call   80734a <memp_malloc>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  807dd5:	85 c0                	test   %eax,%eax
  807dd7:	0f 84 1c 02 00 00    	je     807ff9 <pbuf_alloc+0x2c3>
  }

  switch (type) {
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  807ddd:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      return NULL;
    }
    p->type = type;
  807ddf:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  807de3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  807de9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  807dec:	0f b7 c7             	movzwl %di,%eax
  807def:	8d 44 06 13          	lea    0x13(%esi,%eax,1),%eax
  807df3:	83 e0 fc             	and    $0xfffffffc,%eax
  807df6:	89 46 04             	mov    %eax,0x4(%esi)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  807df9:	66 89 5e 08          	mov    %bx,0x8(%esi)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  807dfd:	0f b7 cb             	movzwl %bx,%ecx
  807e00:	0f b7 c7             	movzwl %di,%eax
  807e03:	83 c0 03             	add    $0x3,%eax
  807e06:	83 e0 fc             	and    $0xfffffffc,%eax
  807e09:	ba d0 07 00 00       	mov    $0x7d0,%edx
  807e0e:	29 c2                	sub    %eax,%edx
  807e10:	89 d0                	mov    %edx,%eax
  807e12:	39 ca                	cmp    %ecx,%edx
  807e14:	7e 02                	jle    807e18 <pbuf_alloc+0xe2>
  807e16:	89 c8                	mov    %ecx,%eax
  807e18:	66 89 46 0a          	mov    %ax,0xa(%esi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  807e1c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  807e1f:	81 c2 e0 07 00 00    	add    $0x7e0,%edx
  807e25:	89 55 f0             	mov    %edx,-0x10(%ebp)
  807e28:	0f b7 c0             	movzwl %ax,%eax
  807e2b:	03 46 04             	add    0x4(%esi),%eax
  807e2e:	39 d0                	cmp    %edx,%eax
  807e30:	76 1c                	jbe    807e4e <pbuf_alloc+0x118>
  807e32:	c7 44 24 08 bc 32 81 	movl   $0x8132bc,0x8(%esp)
  807e39:	00 
  807e3a:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  807e41:	00 
  807e42:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807e49:	e8 5e 8a ff ff       	call   8008ac <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  807e4e:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  807e54:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807e58:	89 cb                	mov    %ecx,%ebx
  807e5a:	29 c3                	sub    %eax,%ebx
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  807e5c:	85 db                	test   %ebx,%ebx
  807e5e:	0f 8e 89 01 00 00    	jle    807fed <pbuf_alloc+0x2b7>
  807e64:	89 f7                	mov    %esi,%edi
      q = memp_malloc(MEMP_PBUF_POOL);
  807e66:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  807e6d:	e8 d8 f4 ff ff       	call   80734a <memp_malloc>
      if (q == NULL) {
  807e72:	85 c0                	test   %eax,%eax
  807e74:	75 12                	jne    807e88 <pbuf_alloc+0x152>
        /* free chain so far allocated */
        pbuf_free(p);
  807e76:	89 34 24             	mov    %esi,(%esp)
  807e79:	e8 f5 fb ff ff       	call   807a73 <pbuf_free>
  807e7e:	be 00 00 00 00       	mov    $0x0,%esi
  807e83:	e9 76 01 00 00       	jmp    807ffe <pbuf_alloc+0x2c8>
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
      q = memp_malloc(MEMP_PBUF_POOL);
  807e88:	89 c2                	mov    %eax,%edx
        /* free chain so far allocated */
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
  807e8a:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  807e8e:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  807e92:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  807e98:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  807e9a:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  807ea0:	7e 1c                	jle    807ebe <pbuf_alloc+0x188>
  807ea2:	c7 44 24 08 9d 34 81 	movl   $0x81349d,0x8(%esp)
  807ea9:	00 
  807eaa:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  807eb1:	00 
  807eb2:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807eb9:	e8 ee 89 ff ff       	call   8008ac <_panic>
      q->tot_len = (u16_t)rem_len;
  807ebe:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  807ec2:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  807ec7:	66 81 fb cf 07       	cmp    $0x7cf,%bx
  807ecc:	77 02                	ja     807ed0 <pbuf_alloc+0x19a>
  807ece:	89 d8                	mov    %ebx,%eax
  807ed0:	66 89 42 0a          	mov    %ax,0xa(%edx)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  807ed4:	8d 42 10             	lea    0x10(%edx),%eax
  807ed7:	89 42 04             	mov    %eax,0x4(%edx)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  807eda:	a8 03                	test   $0x3,%al
  807edc:	74 1c                	je     807efa <pbuf_alloc+0x1c4>
  807ede:	c7 44 24 08 f0 32 81 	movl   $0x8132f0,0x8(%esp)
  807ee5:	00 
  807ee6:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  807eed:	00 
  807eee:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807ef5:	e8 b2 89 ff ff       	call   8008ac <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  807efa:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807efe:	03 46 04             	add    0x4(%esi),%eax
  807f01:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  807f04:	73 1c                	jae    807f22 <pbuf_alloc+0x1ec>
  807f06:	c7 44 24 08 bc 32 81 	movl   $0x8132bc,0x8(%esp)
  807f0d:	00 
  807f0e:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
  807f15:	00 
  807f16:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807f1d:	e8 8a 89 ff ff       	call   8008ac <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  807f22:	66 c7 42 0e 01 00    	movw   $0x1,0xe(%edx)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  807f28:	0f b7 42 0a          	movzwl 0xa(%edx),%eax
  807f2c:	29 c3                	sub    %eax,%ebx
  807f2e:	89 d7                	mov    %edx,%edi
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  807f30:	85 db                	test   %ebx,%ebx
  807f32:	0f 8e b5 00 00 00    	jle    807fed <pbuf_alloc+0x2b7>
  807f38:	e9 29 ff ff ff       	jmp    807e66 <pbuf_alloc+0x130>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  807f3d:	0f b7 ff             	movzwl %di,%edi
  807f40:	8d 57 13             	lea    0x13(%edi),%edx
  807f43:	83 e2 fc             	and    $0xfffffffc,%edx
  807f46:	0f b7 c3             	movzwl %bx,%eax
  807f49:	83 c0 03             	add    $0x3,%eax
  807f4c:	83 e0 fc             	and    $0xfffffffc,%eax
  807f4f:	01 c2                	add    %eax,%edx
  807f51:	89 14 24             	mov    %edx,(%esp)
  807f54:	e8 87 ed ff ff       	call   806ce0 <mem_malloc>
    if (p == NULL) {
  807f59:	85 c0                	test   %eax,%eax
  807f5b:	0f 84 98 00 00 00    	je     807ff9 <pbuf_alloc+0x2c3>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  807f61:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  807f63:	8d 44 07 13          	lea    0x13(%edi,%eax,1),%eax
  807f67:	83 e0 fc             	and    $0xfffffffc,%eax
  807f6a:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  807f6d:	66 89 5e 08          	mov    %bx,0x8(%esi)
  807f71:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  807f75:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  807f7b:	c6 46 0c 00          	movb   $0x0,0xc(%esi)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
  807f7f:	f6 46 04 03          	testb  $0x3,0x4(%esi)
  807f83:	74 68                	je     807fed <pbuf_alloc+0x2b7>
  807f85:	c7 44 24 08 20 33 81 	movl   $0x813320,0x8(%esp)
  807f8c:	00 
  807f8d:	c7 44 24 04 dd 00 00 	movl   $0xdd,0x4(%esp)
  807f94:	00 
  807f95:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807f9c:	e8 0b 89 ff ff       	call   8008ac <_panic>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  807fa1:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  807fa8:	e8 9d f3 ff ff       	call   80734a <memp_malloc>
    if (p == NULL) {
  807fad:	85 c0                	test   %eax,%eax
  807faf:	74 48                	je     807ff9 <pbuf_alloc+0x2c3>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  807fb1:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  807fb3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  807fba:	66 89 58 08          	mov    %bx,0x8(%eax)
  807fbe:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  807fc2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  807fc8:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  807fcc:	88 46 0c             	mov    %al,0xc(%esi)
  807fcf:	eb 1c                	jmp    807fed <pbuf_alloc+0x2b7>
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  807fd1:	c7 44 24 08 b1 34 81 	movl   $0x8134b1,0x8(%esp)
  807fd8:	00 
  807fd9:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
  807fe0:	00 
  807fe1:	c7 04 24 4b 33 81 00 	movl   $0x81334b,(%esp)
  807fe8:	e8 bf 88 ff ff       	call   8008ac <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  807fed:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  807ff3:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  807ff7:	eb 05                	jmp    807ffe <pbuf_alloc+0x2c8>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  807ff9:	be 00 00 00 00       	mov    $0x0,%esi
}
  807ffe:	89 f0                	mov    %esi,%eax
  808000:	83 c4 1c             	add    $0x1c,%esp
  808003:	5b                   	pop    %ebx
  808004:	5e                   	pop    %esi
  808005:	5f                   	pop    %edi
  808006:	5d                   	pop    %ebp
  808007:	c3                   	ret    
	...

00808010 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  808010:	55                   	push   %ebp
  808011:	89 e5                	mov    %esp,%ebp
  808013:	83 ec 08             	sub    $0x8,%esp
  808016:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  808019:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  80801e:	8b 40 04             	mov    0x4(%eax),%eax
  808021:	8b 00                	mov    (%eax),%eax
  808023:	89 04 24             	mov    %eax,(%esp)
  808026:	e8 8f 57 00 00       	call   80d7ba <sys_sem_signal>
}
  80802b:	c9                   	leave  
  80802c:	c3                   	ret    

0080802d <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80802d:	55                   	push   %ebp
  80802e:	89 e5                	mov    %esp,%ebp
  808030:	57                   	push   %edi
  808031:	56                   	push   %esi
  808032:	53                   	push   %ebx
  808033:	83 ec 0c             	sub    $0xc,%esp
  808036:	8b 75 08             	mov    0x8(%ebp),%esi
  808039:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80803c:	e8 61 52 00 00       	call   80d2a2 <sys_arch_timeouts>
  808041:	89 c3                	mov    %eax,%ebx

  if (timeouts == NULL) {
  808043:	85 c0                	test   %eax,%eax
  808045:	75 1c                	jne    808063 <sys_untimeout+0x36>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  808047:	c7 44 24 08 cc 34 81 	movl   $0x8134cc,0x8(%esp)
  80804e:	00 
  80804f:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  808056:	00 
  808057:	c7 04 24 ec 34 81 00 	movl   $0x8134ec,(%esp)
  80805e:	e8 49 88 ff ff       	call   8008ac <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  808063:	8b 10                	mov    (%eax),%edx
  808065:	85 d2                	test   %edx,%edx
  808067:	74 49                	je     8080b2 <sys_untimeout+0x85>
    return;
  808069:	b9 00 00 00 00       	mov    $0x0,%ecx
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == h) && (t->arg == arg)) {
  80806e:	39 72 08             	cmp    %esi,0x8(%edx)
  808071:	75 31                	jne    8080a4 <sys_untimeout+0x77>
  808073:	39 7a 0c             	cmp    %edi,0xc(%edx)
  808076:	75 2c                	jne    8080a4 <sys_untimeout+0x77>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  808078:	85 c9                	test   %ecx,%ecx
  80807a:	75 06                	jne    808082 <sys_untimeout+0x55>
        timeouts->next = t->next;
  80807c:	8b 02                	mov    (%edx),%eax
  80807e:	89 03                	mov    %eax,(%ebx)
  808080:	eb 04                	jmp    808086 <sys_untimeout+0x59>
      else
        prev_t->next = t->next;
  808082:	8b 02                	mov    (%edx),%eax
  808084:	89 01                	mov    %eax,(%ecx)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  808086:	8b 0a                	mov    (%edx),%ecx
  808088:	85 c9                	test   %ecx,%ecx
  80808a:	74 06                	je     808092 <sys_untimeout+0x65>
        t->next->time += t->time;
  80808c:	8b 42 04             	mov    0x4(%edx),%eax
  80808f:	01 41 04             	add    %eax,0x4(%ecx)
      memp_free(MEMP_SYS_TIMEOUT, t);
  808092:	89 54 24 04          	mov    %edx,0x4(%esp)
  808096:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  80809d:	e8 65 f2 ff ff       	call   807307 <memp_free>
  8080a2:	eb 0e                	jmp    8080b2 <sys_untimeout+0x85>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  8080a4:	8b 02                	mov    (%edx),%eax
  8080a6:	89 d1                	mov    %edx,%ecx
  8080a8:	85 c0                	test   %eax,%eax
  8080aa:	74 06                	je     8080b2 <sys_untimeout+0x85>
  8080ac:	89 c2                	mov    %eax,%edx
  8080ae:	66 90                	xchg   %ax,%ax
  8080b0:	eb bc                	jmp    80806e <sys_untimeout+0x41>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  8080b2:	83 c4 0c             	add    $0xc,%esp
  8080b5:	5b                   	pop    %ebx
  8080b6:	5e                   	pop    %esi
  8080b7:	5f                   	pop    %edi
  8080b8:	5d                   	pop    %ebp
  8080b9:	c3                   	ret    

008080ba <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8080ba:	55                   	push   %ebp
  8080bb:	89 e5                	mov    %esp,%ebp
  8080bd:	56                   	push   %esi
  8080be:	53                   	push   %ebx
  8080bf:	83 ec 10             	sub    $0x10,%esp
  8080c2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  8080c5:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8080cc:	e8 79 f2 ff ff       	call   80734a <memp_malloc>
  if (timeout == NULL) {
  8080d1:	85 c0                	test   %eax,%eax
  8080d3:	75 1c                	jne    8080f1 <sys_timeout+0x37>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  8080d5:	c7 44 24 08 00 35 81 	movl   $0x813500,0x8(%esp)
  8080dc:	00 
  8080dd:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
  8080e4:	00 
  8080e5:	c7 04 24 ec 34 81 00 	movl   $0x8134ec,(%esp)
  8080ec:	e8 bb 87 ff ff       	call   8008ac <_panic>
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  8080f1:	89 c6                	mov    %eax,%esi
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
    return;
  }
  timeout->next = NULL;
  8080f3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8080f9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8080fc:	89 46 08             	mov    %eax,0x8(%esi)
  timeout->arg = arg;
  8080ff:	8b 45 10             	mov    0x10(%ebp),%eax
  808102:	89 46 0c             	mov    %eax,0xc(%esi)
  timeout->time = msecs;
  808105:	89 5e 04             	mov    %ebx,0x4(%esi)

  timeouts = sys_arch_timeouts();
  808108:	e8 95 51 00 00       	call   80d2a2 <sys_arch_timeouts>
  80810d:	89 c2                	mov    %eax,%edx

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  80810f:	85 c0                	test   %eax,%eax
  808111:	75 1c                	jne    80812f <sys_timeout+0x75>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  808113:	c7 44 24 08 1d 35 81 	movl   $0x81351d,0x8(%esp)
  80811a:	00 
  80811b:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
  808122:	00 
  808123:	c7 04 24 ec 34 81 00 	movl   $0x8134ec,(%esp)
  80812a:	e8 7d 87 ff ff       	call   8008ac <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  80812f:	8b 08                	mov    (%eax),%ecx
  808131:	85 c9                	test   %ecx,%ecx
  808133:	75 04                	jne    808139 <sys_timeout+0x7f>
    timeouts->next = timeout;
  808135:	89 30                	mov    %esi,(%eax)
  808137:	eb 3b                	jmp    808174 <sys_timeout+0xba>
    return;
  }

  if (timeouts->next->time > msecs) {
  808139:	8b 41 04             	mov    0x4(%ecx),%eax
  80813c:	39 c3                	cmp    %eax,%ebx
  80813e:	73 23                	jae    808163 <sys_timeout+0xa9>
    timeouts->next->time -= msecs;
  808140:	29 d8                	sub    %ebx,%eax
  808142:	89 41 04             	mov    %eax,0x4(%ecx)
    timeout->next = timeouts->next;
  808145:	8b 02                	mov    (%edx),%eax
  808147:	89 06                	mov    %eax,(%esi)
    timeouts->next = timeout;
  808149:	89 32                	mov    %esi,(%edx)
  80814b:	eb 27                	jmp    808174 <sys_timeout+0xba>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
  80814d:	8b 5a 04             	mov    0x4(%edx),%ebx
  808150:	39 d8                	cmp    %ebx,%eax
  808152:	73 0d                	jae    808161 <sys_timeout+0xa7>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  808154:	29 c3                	sub    %eax,%ebx
  808156:	89 5a 04             	mov    %ebx,0x4(%edx)
        }
        timeout->next = t->next;
  808159:	8b 01                	mov    (%ecx),%eax
  80815b:	89 06                	mov    %eax,(%esi)
        t->next = timeout;
  80815d:	89 31                	mov    %esi,(%ecx)
  80815f:	eb 13                	jmp    808174 <sys_timeout+0xba>
        break;
  808161:	89 d1                	mov    %edx,%ecx
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  808163:	8b 46 04             	mov    0x4(%esi),%eax
  808166:	2b 41 04             	sub    0x4(%ecx),%eax
  808169:	89 46 04             	mov    %eax,0x4(%esi)
      if (t->next == NULL || t->next->time > timeout->time) {
  80816c:	8b 11                	mov    (%ecx),%edx
  80816e:	85 d2                	test   %edx,%edx
  808170:	75 db                	jne    80814d <sys_timeout+0x93>
  808172:	eb e5                	jmp    808159 <sys_timeout+0x9f>
        t->next = timeout;
        break;
      }
    }
  }
}
  808174:	83 c4 10             	add    $0x10,%esp
  808177:	5b                   	pop    %ebx
  808178:	5e                   	pop    %esi
  808179:	5d                   	pop    %ebp
  80817a:	c3                   	ret    

0080817b <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80817b:	55                   	push   %ebp
  80817c:	89 e5                	mov    %esp,%ebp
  80817e:	57                   	push   %edi
  80817f:	56                   	push   %esi
  808180:	53                   	push   %ebx
  808181:	83 ec 0c             	sub    $0xc,%esp
  808184:	8b 7d 08             	mov    0x8(%ebp),%edi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  808187:	e8 16 51 00 00       	call   80d2a2 <sys_arch_timeouts>
  80818c:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  80818e:	85 c0                	test   %eax,%eax
  808190:	74 06                	je     808198 <sys_sem_wait+0x1d>
  808192:	8b 00                	mov    (%eax),%eax
  808194:	85 c0                	test   %eax,%eax
  808196:	75 12                	jne    8081aa <sys_sem_wait+0x2f>
    sys_arch_sem_wait(sem, 0);
  808198:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80819f:	00 
  8081a0:	89 3c 24             	mov    %edi,(%esp)
  8081a3:	e8 31 53 00 00       	call   80d4d9 <sys_arch_sem_wait>
  8081a8:	eb 56                	jmp    808200 <sys_sem_wait+0x85>
  } else {
    if (timeouts->next->time > 0) {
  8081aa:	8b 40 04             	mov    0x4(%eax),%eax
  8081ad:	85 c0                	test   %eax,%eax
  8081af:	74 11                	je     8081c2 <sys_sem_wait+0x47>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  8081b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8081b5:	89 3c 24             	mov    %edi,(%esp)
  8081b8:	e8 1c 53 00 00       	call   80d4d9 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  8081bd:	83 f8 ff             	cmp    $0xffffffff,%eax
  8081c0:	75 27                	jne    8081e9 <sys_sem_wait+0x6e>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  8081c2:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8081c4:	8b 10                	mov    (%eax),%edx
  8081c6:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  8081c8:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8081cb:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8081ce:	89 44 24 04          	mov    %eax,0x4(%esp)
  8081d2:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8081d9:	e8 29 f1 ff ff       	call   807307 <memp_free>
      if (h != NULL) {
  8081de:	85 db                	test   %ebx,%ebx
  8081e0:	74 a5                	je     808187 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  8081e2:	89 34 24             	mov    %esi,(%esp)
  8081e5:	ff d3                	call   *%ebx
  8081e7:	eb 9e                	jmp    808187 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8081e9:	8b 13                	mov    (%ebx),%edx
  8081eb:	8b 4a 04             	mov    0x4(%edx),%ecx
  8081ee:	39 c1                	cmp    %eax,%ecx
  8081f0:	76 07                	jbe    8081f9 <sys_sem_wait+0x7e>
        timeouts->next->time -= time_needed;
  8081f2:	29 c1                	sub    %eax,%ecx
  8081f4:	89 4a 04             	mov    %ecx,0x4(%edx)
  8081f7:	eb 07                	jmp    808200 <sys_sem_wait+0x85>
      } else {
        timeouts->next->time = 0;
  8081f9:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  808200:	83 c4 0c             	add    $0xc,%esp
  808203:	5b                   	pop    %ebx
  808204:	5e                   	pop    %esi
  808205:	5f                   	pop    %edi
  808206:	5d                   	pop    %ebp
  808207:	c3                   	ret    

00808208 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  808208:	55                   	push   %ebp
  808209:	89 e5                	mov    %esp,%ebp
  80820b:	83 ec 28             	sub    $0x28,%esp
  80820e:	8b 55 0c             	mov    0xc(%ebp),%edx
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  808211:	8d 45 08             	lea    0x8(%ebp),%eax
  808214:	89 45 fc             	mov    %eax,-0x4(%ebp)
  sswt_cb.timeflag = 0;
  808217:	66 c7 45 f8 00 00    	movw   $0x0,-0x8(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80821d:	85 d2                	test   %edx,%edx
  80821f:	74 17                	je     808238 <sys_sem_wait_timeout+0x30>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  808221:	8d 45 f8             	lea    -0x8(%ebp),%eax
  808224:	89 44 24 08          	mov    %eax,0x8(%esp)
  808228:	c7 44 24 04 10 80 80 	movl   $0x808010,0x4(%esp)
  80822f:	00 
  808230:	89 14 24             	mov    %edx,(%esp)
  808233:	e8 82 fe ff ff       	call   8080ba <sys_timeout>
  }
  sys_sem_wait(sem);
  808238:	8b 45 08             	mov    0x8(%ebp),%eax
  80823b:	89 04 24             	mov    %eax,(%esp)
  80823e:	e8 38 ff ff ff       	call   80817b <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  808243:	b8 00 00 00 00       	mov    $0x0,%eax
  808248:	66 83 7d f8 00       	cmpw   $0x0,-0x8(%ebp)
  80824d:	75 18                	jne    808267 <sys_sem_wait_timeout+0x5f>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  80824f:	8d 45 f8             	lea    -0x8(%ebp),%eax
  808252:	89 44 24 04          	mov    %eax,0x4(%esp)
  808256:	c7 04 24 10 80 80 00 	movl   $0x808010,(%esp)
  80825d:	e8 cb fd ff ff       	call   80802d <sys_untimeout>
  808262:	b8 01 00 00 00       	mov    $0x1,%eax
    return 1;
  }
}
  808267:	c9                   	leave  
  808268:	c3                   	ret    

00808269 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  808269:	55                   	push   %ebp
  80826a:	89 e5                	mov    %esp,%ebp
  80826c:	53                   	push   %ebx
  80826d:	83 ec 14             	sub    $0x14,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  808270:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808277:	e8 9a 53 00 00       	call   80d616 <sys_sem_new>
  80827c:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  80827e:	8b 45 08             	mov    0x8(%ebp),%eax
  808281:	89 44 24 04          	mov    %eax,0x4(%esp)
  808285:	89 1c 24             	mov    %ebx,(%esp)
  808288:	e8 7b ff ff ff       	call   808208 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  80828d:	89 1c 24             	mov    %ebx,(%esp)
  808290:	e8 eb 4e 00 00       	call   80d180 <sys_sem_free>
}
  808295:	83 c4 14             	add    $0x14,%esp
  808298:	5b                   	pop    %ebx
  808299:	5d                   	pop    %ebp
  80829a:	c3                   	ret    

0080829b <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80829b:	55                   	push   %ebp
  80829c:	89 e5                	mov    %esp,%ebp
  80829e:	57                   	push   %edi
  80829f:	56                   	push   %esi
  8082a0:	53                   	push   %ebx
  8082a1:	83 ec 0c             	sub    $0xc,%esp
  8082a4:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  8082a7:	e8 f6 4f 00 00       	call   80d2a2 <sys_arch_timeouts>
  8082ac:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  8082ae:	85 c0                	test   %eax,%eax
  8082b0:	74 06                	je     8082b8 <sys_mbox_fetch+0x1d>
  8082b2:	8b 00                	mov    (%eax),%eax
  8082b4:	85 c0                	test   %eax,%eax
  8082b6:	75 19                	jne    8082d1 <sys_mbox_fetch+0x36>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  8082b8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8082bf:	00 
  8082c0:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8082c4:	8b 45 08             	mov    0x8(%ebp),%eax
  8082c7:	89 04 24             	mov    %eax,(%esp)
  8082ca:	e8 55 55 00 00       	call   80d824 <sys_arch_mbox_fetch>
  8082cf:	eb 5f                	jmp    808330 <sys_mbox_fetch+0x95>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  8082d1:	8b 40 04             	mov    0x4(%eax),%eax
  8082d4:	85 c0                	test   %eax,%eax
  8082d6:	74 18                	je     8082f0 <sys_mbox_fetch+0x55>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  8082d8:	89 44 24 08          	mov    %eax,0x8(%esp)
  8082dc:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8082e0:	8b 45 08             	mov    0x8(%ebp),%eax
  8082e3:	89 04 24             	mov    %eax,(%esp)
  8082e6:	e8 39 55 00 00       	call   80d824 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  8082eb:	83 f8 ff             	cmp    $0xffffffff,%eax
  8082ee:	75 27                	jne    808317 <sys_mbox_fetch+0x7c>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  8082f0:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8082f2:	8b 10                	mov    (%eax),%edx
  8082f4:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8082f6:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8082f9:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8082fc:	89 44 24 04          	mov    %eax,0x4(%esp)
  808300:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  808307:	e8 fb ef ff ff       	call   807307 <memp_free>
      if (h != NULL) {
  80830c:	85 db                	test   %ebx,%ebx
  80830e:	74 97                	je     8082a7 <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  808310:	89 34 24             	mov    %esi,(%esp)
  808313:	ff d3                	call   *%ebx
  808315:	eb 90                	jmp    8082a7 <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  808317:	8b 13                	mov    (%ebx),%edx
  808319:	8b 4a 04             	mov    0x4(%edx),%ecx
  80831c:	39 c1                	cmp    %eax,%ecx
  80831e:	66 90                	xchg   %ax,%ax
  808320:	76 07                	jbe    808329 <sys_mbox_fetch+0x8e>
        timeouts->next->time -= time_needed;
  808322:	29 c1                	sub    %eax,%ecx
  808324:	89 4a 04             	mov    %ecx,0x4(%edx)
  808327:	eb 07                	jmp    808330 <sys_mbox_fetch+0x95>
      } else {
        timeouts->next->time = 0;
  808329:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  808330:	83 c4 0c             	add    $0xc,%esp
  808333:	5b                   	pop    %ebx
  808334:	5e                   	pop    %esi
  808335:	5f                   	pop    %edi
  808336:	5d                   	pop    %ebp
  808337:	c3                   	ret    
	...

00808340 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  808340:	55                   	push   %ebp
  808341:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  808343:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  808348:	5d                   	pop    %ebp
  808349:	c3                   	ret    

0080834a <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80834a:	55                   	push   %ebp
  80834b:	89 e5                	mov    %esp,%ebp
  80834d:	56                   	push   %esi
  80834e:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80834f:	8b 0d c8 e5 b3 00    	mov    0xb3e5c8,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808355:	8b 1d dc e5 b3 00    	mov    0xb3e5dc,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80835b:	8b 35 d0 e5 b3 00    	mov    0xb3e5d0,%esi
  808361:	0f b7 15 48 80 81 00 	movzwl 0x818048,%edx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  808368:	66 83 c2 01          	add    $0x1,%dx
  80836c:	79 05                	jns    808373 <tcp_new_port+0x29>
  80836e:	ba 00 10 00 00       	mov    $0x1000,%edx
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808373:	85 c9                	test   %ecx,%ecx
  808375:	74 1b                	je     808392 <tcp_new_port+0x48>
    if (pcb->local_port == port) {
      goto again;
  808377:	89 c8                	mov    %ecx,%eax
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  808379:	66 3b 51 1c          	cmp    0x1c(%ecx),%dx
  80837d:	75 09                	jne    808388 <tcp_new_port+0x3e>
  80837f:	90                   	nop    
  808380:	eb e6                	jmp    808368 <tcp_new_port+0x1e>
  808382:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  808386:	74 e0                	je     808368 <tcp_new_port+0x1e>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808388:	8b 40 0c             	mov    0xc(%eax),%eax
  80838b:	85 c0                	test   %eax,%eax
  80838d:	8d 76 00             	lea    0x0(%esi),%esi
  808390:	75 f0                	jne    808382 <tcp_new_port+0x38>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808392:	85 db                	test   %ebx,%ebx
  808394:	74 1c                	je     8083b2 <tcp_new_port+0x68>
    if (pcb->local_port == port) {
      goto again;
  808396:	89 d8                	mov    %ebx,%eax
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  808398:	66 3b 53 1c          	cmp    0x1c(%ebx),%dx
  80839c:	75 0a                	jne    8083a8 <tcp_new_port+0x5e>
  80839e:	66 90                	xchg   %ax,%ax
  8083a0:	eb c6                	jmp    808368 <tcp_new_port+0x1e>
  8083a2:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  8083a6:	74 c0                	je     808368 <tcp_new_port+0x1e>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8083a8:	8b 40 0c             	mov    0xc(%eax),%eax
  8083ab:	85 c0                	test   %eax,%eax
  8083ad:	8d 76 00             	lea    0x0(%esi),%esi
  8083b0:	75 f0                	jne    8083a2 <tcp_new_port+0x58>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8083b2:	85 f6                	test   %esi,%esi
  8083b4:	75 09                	jne    8083bf <tcp_new_port+0x75>
  8083b6:	66 89 15 48 80 81 00 	mov    %dx,0x818048
  8083bd:	eb 21                	jmp    8083e0 <tcp_new_port+0x96>
    if (pcb->local_port == port) {
      goto again;
  8083bf:	89 f0                	mov    %esi,%eax
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  8083c1:	66 3b 56 1c          	cmp    0x1c(%esi),%dx
  8083c5:	75 0b                	jne    8083d2 <tcp_new_port+0x88>
  8083c7:	eb 9f                	jmp    808368 <tcp_new_port+0x1e>
  8083c9:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  8083cd:	8d 76 00             	lea    0x0(%esi),%esi
  8083d0:	74 96                	je     808368 <tcp_new_port+0x1e>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8083d2:	8b 40 0c             	mov    0xc(%eax),%eax
  8083d5:	85 c0                	test   %eax,%eax
  8083d7:	75 f0                	jne    8083c9 <tcp_new_port+0x7f>
  8083d9:	66 89 15 48 80 81 00 	mov    %dx,0x818048
  8083e0:	0f b7 05 48 80 81 00 	movzwl 0x818048,%eax
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  8083e7:	5b                   	pop    %ebx
  8083e8:	5e                   	pop    %esi
  8083e9:	5d                   	pop    %ebp
  8083ea:	c3                   	ret    

008083eb <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8083eb:	55                   	push   %ebp
  8083ec:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  8083ee:	8b 55 0c             	mov    0xc(%ebp),%edx
  8083f1:	8b 45 08             	mov    0x8(%ebp),%eax
  8083f4:	88 50 14             	mov    %dl,0x14(%eax)
}
  8083f7:	5d                   	pop    %ebp
  8083f8:	c3                   	ret    

008083f9 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8083f9:	55                   	push   %ebp
  8083fa:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  8083fc:	8b 55 0c             	mov    0xc(%ebp),%edx
  8083ff:	8b 45 08             	mov    0x8(%ebp),%eax
  808402:	89 50 18             	mov    %edx,0x18(%eax)
}
  808405:	5d                   	pop    %ebp
  808406:	c3                   	ret    

00808407 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  808407:	55                   	push   %ebp
  808408:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  80840a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80840d:	8b 45 08             	mov    0x8(%ebp),%eax
  808410:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  808416:	5d                   	pop    %ebp
  808417:	c3                   	ret    

00808418 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  808418:	55                   	push   %ebp
  808419:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  80841b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80841e:	8b 45 08             	mov    0x8(%ebp),%eax
  808421:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  808427:	5d                   	pop    %ebp
  808428:	c3                   	ret    

00808429 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  808429:	55                   	push   %ebp
  80842a:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  80842c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80842f:	8b 45 08             	mov    0x8(%ebp),%eax
  808432:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  808438:	5d                   	pop    %ebp
  808439:	c3                   	ret    

0080843a <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  80843a:	55                   	push   %ebp
  80843b:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  80843d:	8b 55 0c             	mov    0xc(%ebp),%edx
  808440:	8b 45 08             	mov    0x8(%ebp),%eax
  808443:	89 50 20             	mov    %edx,0x20(%eax)
}
  808446:	5d                   	pop    %ebp
  808447:	c3                   	ret    

00808448 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  808448:	55                   	push   %ebp
  808449:	89 e5                	mov    %esp,%ebp
  80844b:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  80844e:	8b 55 0c             	mov    0xc(%ebp),%edx
  808451:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  808457:	8b 55 10             	mov    0x10(%ebp),%edx
  80845a:	88 50 31             	mov    %dl,0x31(%eax)
}
  80845d:	5d                   	pop    %ebp
  80845e:	c3                   	ret    

0080845f <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  80845f:	55                   	push   %ebp
  808460:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  808462:	a1 44 80 81 00       	mov    0x818044,%eax
  808467:	03 05 cc e5 b3 00    	add    0xb3e5cc,%eax
  80846d:	a3 44 80 81 00       	mov    %eax,0x818044
  return iss;
}
  808472:	5d                   	pop    %ebp
  808473:	c3                   	ret    

00808474 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  808474:	55                   	push   %ebp
  808475:	89 e5                	mov    %esp,%ebp
  808477:	53                   	push   %ebx
  808478:	83 ec 04             	sub    $0x4,%esp
  80847b:	0f b7 5d 08          	movzwl 0x8(%ebp),%ebx
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  80847f:	8b 45 0c             	mov    0xc(%ebp),%eax
  808482:	89 04 24             	mov    %eax,(%esp)
  808485:	e8 0d 12 00 00       	call   809697 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  80848a:	85 c0                	test   %eax,%eax
  80848c:	74 13                	je     8084a1 <tcp_eff_send_mss+0x2d>
  80848e:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  808492:	66 85 c0             	test   %ax,%ax
  808495:	74 0a                	je     8084a1 <tcp_eff_send_mss+0x2d>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  808497:	83 e8 28             	sub    $0x28,%eax
  80849a:	66 39 c3             	cmp    %ax,%bx
  80849d:	76 02                	jbe    8084a1 <tcp_eff_send_mss+0x2d>
  80849f:	89 c3                	mov    %eax,%ebx
  8084a1:	0f b7 c3             	movzwl %bx,%eax
  }
  return sendmss;
}
  8084a4:	83 c4 04             	add    $0x4,%esp
  8084a7:	5b                   	pop    %ebx
  8084a8:	5d                   	pop    %ebp
  8084a9:	c3                   	ret    

008084aa <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  8084aa:	55                   	push   %ebp
  8084ab:	89 e5                	mov    %esp,%ebp
  8084ad:	56                   	push   %esi
  8084ae:	53                   	push   %ebx
  8084af:	83 ec 10             	sub    $0x10,%esp
  8084b2:	8b 75 08             	mov    0x8(%ebp),%esi
  8084b5:	0f b7 5d 0c          	movzwl 0xc(%ebp),%ebx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  8084b9:	0f b7 4e 28          	movzwl 0x28(%esi),%ecx
  8084bd:	0f b7 c3             	movzwl %bx,%eax
  8084c0:	0f b7 d1             	movzwl %cx,%edx
  8084c3:	01 d0                	add    %edx,%eax
  8084c5:	3d c0 5d 00 00       	cmp    $0x5dc0,%eax
  8084ca:	76 0e                	jbe    8084da <tcp_recved+0x30>
    pcb->rcv_wnd = TCP_WND;
  8084cc:	66 c7 46 28 c0 5d    	movw   $0x5dc0,0x28(%esi)
    pcb->rcv_ann_wnd = TCP_WND;
  8084d2:	66 c7 46 2a c0 5d    	movw   $0x5dc0,0x2a(%esi)
  8084d8:	eb 11                	jmp    8084eb <tcp_recved+0x41>
  } else {
    pcb->rcv_wnd += len;
  8084da:	8d 04 0b             	lea    (%ebx,%ecx,1),%eax
  8084dd:	66 89 46 28          	mov    %ax,0x28(%esi)
    if (pcb->rcv_wnd >= pcb->mss) {
  8084e1:	66 3b 46 34          	cmp    0x34(%esi),%ax
  8084e5:	72 04                	jb     8084eb <tcp_recved+0x41>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  8084e7:	66 89 46 2a          	mov    %ax,0x2a(%esi)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  8084eb:	0f b6 46 20          	movzbl 0x20(%esi),%eax
  8084ef:	0f b6 d0             	movzbl %al,%edx
  8084f2:	f6 c2 03             	test   $0x3,%dl
  8084f5:	75 20                	jne    808517 <tcp_recved+0x6d>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  8084f7:	f6 c2 01             	test   $0x1,%dl
  8084fa:	74 13                	je     80850f <tcp_recved+0x65>
  8084fc:	83 e0 fe             	and    $0xfffffffe,%eax
  8084ff:	83 c8 02             	or     $0x2,%eax
  808502:	88 46 20             	mov    %al,0x20(%esi)
  808505:	89 34 24             	mov    %esi,(%esp)
  808508:	e8 2c 2a 00 00       	call   80af39 <tcp_output>
  80850d:	eb 22                	jmp    808531 <tcp_recved+0x87>
  80850f:	83 c8 01             	or     $0x1,%eax
  808512:	88 46 20             	mov    %al,0x20(%esi)
  808515:	eb 1a                	jmp    808531 <tcp_recved+0x87>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  808517:	a8 01                	test   $0x1,%al
  808519:	74 16                	je     808531 <tcp_recved+0x87>
  80851b:	66 81 7e 28 df 2e    	cmpw   $0x2edf,0x28(%esi)
  808521:	76 0e                	jbe    808531 <tcp_recved+0x87>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  808523:	83 c8 02             	or     $0x2,%eax
  808526:	88 46 20             	mov    %al,0x20(%esi)
  808529:	89 34 24             	mov    %esi,(%esp)
  80852c:	e8 08 2a 00 00       	call   80af39 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  808531:	83 c4 10             	add    $0x10,%esp
  808534:	5b                   	pop    %ebx
  808535:	5e                   	pop    %esi
  808536:	5d                   	pop    %ebp
  808537:	c3                   	ret    

00808538 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  808538:	55                   	push   %ebp
  808539:	89 e5                	mov    %esp,%ebp
  80853b:	53                   	push   %ebx
  80853c:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80853f:	8b 1d c8 e5 b3 00    	mov    0xb3e5c8,%ebx
  808545:	85 db                	test   %ebx,%ebx
  808547:	74 67                	je     8085b0 <tcp_fasttmr+0x78>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  808549:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80854f:	85 c0                	test   %eax,%eax
  808551:	74 3c                	je     80858f <tcp_fasttmr+0x57>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  808553:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  808559:	85 d2                	test   %edx,%edx
  80855b:	74 1e                	je     80857b <tcp_fasttmr+0x43>
  80855d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  808564:	00 
  808565:	89 44 24 08          	mov    %eax,0x8(%esp)
  808569:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80856d:	8b 43 18             	mov    0x18(%ebx),%eax
  808570:	89 04 24             	mov    %eax,(%esp)
  808573:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  808575:	84 c0                	test   %al,%al
  808577:	74 0c                	je     808585 <tcp_fasttmr+0x4d>
  808579:	eb 14                	jmp    80858f <tcp_fasttmr+0x57>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80857b:	89 04 24             	mov    %eax,(%esp)
  80857e:	66 90                	xchg   %ax,%ax
  808580:	e8 ee f4 ff ff       	call   807a73 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  808585:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80858c:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  80858f:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  808593:	a8 01                	test   $0x1,%al
  808595:	74 12                	je     8085a9 <tcp_fasttmr+0x71>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  808597:	83 c8 02             	or     $0x2,%eax
  80859a:	88 43 20             	mov    %al,0x20(%ebx)
  80859d:	89 1c 24             	mov    %ebx,(%esp)
  8085a0:	e8 94 29 00 00       	call   80af39 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8085a5:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8085a9:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  8085ac:	85 db                	test   %ebx,%ebx
  8085ae:	75 99                	jne    808549 <tcp_fasttmr+0x11>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  8085b0:	83 c4 14             	add    $0x14,%esp
  8085b3:	5b                   	pop    %ebx
  8085b4:	5d                   	pop    %ebp
  8085b5:	c3                   	ret    

008085b6 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8085b6:	55                   	push   %ebp
  8085b7:	89 e5                	mov    %esp,%ebp
  8085b9:	53                   	push   %ebx
  8085ba:	83 ec 14             	sub    $0x14,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  8085bd:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  8085c4:	e8 81 ed ff ff       	call   80734a <memp_malloc>
  if (cseg == NULL) {
  8085c9:	bb 00 00 00 00       	mov    $0x0,%ebx
  8085ce:	85 c0                	test   %eax,%eax
  8085d0:	74 24                	je     8085f6 <tcp_seg_copy+0x40>
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  8085d2:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  8085d4:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8085db:	00 
  8085dc:	8b 45 08             	mov    0x8(%ebp),%eax
  8085df:	89 44 24 04          	mov    %eax,0x4(%esp)
  8085e3:	89 1c 24             	mov    %ebx,(%esp)
  8085e6:	e8 7d 8c ff ff       	call   801268 <memcpy>
  pbuf_ref(cseg->p);
  8085eb:	8b 43 04             	mov    0x4(%ebx),%eax
  8085ee:	89 04 24             	mov    %eax,(%esp)
  8085f1:	e8 5c f0 ff ff       	call   807652 <pbuf_ref>
  return cseg;
}
  8085f6:	89 d8                	mov    %ebx,%eax
  8085f8:	83 c4 14             	add    $0x14,%esp
  8085fb:	5b                   	pop    %ebx
  8085fc:	5d                   	pop    %ebp
  8085fd:	c3                   	ret    

008085fe <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  8085fe:	55                   	push   %ebp
  8085ff:	89 e5                	mov    %esp,%ebp
  808601:	83 ec 18             	sub    $0x18,%esp
  808604:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  808607:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80860a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  
  if (seg != NULL) {
  80860d:	be 00 00 00 00       	mov    $0x0,%esi
  808612:	85 db                	test   %ebx,%ebx
  808614:	74 26                	je     80863c <tcp_seg_free+0x3e>
    if (seg->p != NULL) {
  808616:	8b 43 04             	mov    0x4(%ebx),%eax
  808619:	be 00 00 00 00       	mov    $0x0,%esi
  80861e:	85 c0                	test   %eax,%eax
  808620:	74 0a                	je     80862c <tcp_seg_free+0x2e>
      count = pbuf_free(seg->p);
  808622:	89 04 24             	mov    %eax,(%esp)
  808625:	e8 49 f4 ff ff       	call   807a73 <pbuf_free>
  80862a:	89 c6                	mov    %eax,%esi
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  80862c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808630:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808637:	e8 cb ec ff ff       	call   807307 <memp_free>
  80863c:	89 f2                	mov    %esi,%edx
  80863e:	0f b6 c2             	movzbl %dl,%eax
  }
  return count;
}
  808641:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808644:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808647:	89 ec                	mov    %ebp,%esp
  808649:	5d                   	pop    %ebp
  80864a:	c3                   	ret    

0080864b <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  80864b:	55                   	push   %ebp
  80864c:	89 e5                	mov    %esp,%ebp
  80864e:	56                   	push   %esi
  80864f:	53                   	push   %ebx
  808650:	83 ec 10             	sub    $0x10,%esp
  808653:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  808656:	be 00 00 00 00       	mov    $0x0,%esi
  80865b:	85 c0                	test   %eax,%eax
  80865d:	74 17                	je     808676 <tcp_segs_free+0x2b>
  80865f:	be 00 00 00 00       	mov    $0x0,%esi
    next = seg->next;
  808664:	8b 18                	mov    (%eax),%ebx
    count += tcp_seg_free(seg);
  808666:	89 04 24             	mov    %eax,(%esp)
  808669:	e8 90 ff ff ff       	call   8085fe <tcp_seg_free>
  80866e:	01 c6                	add    %eax,%esi
  808670:	89 d8                	mov    %ebx,%eax
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  808672:	85 db                	test   %ebx,%ebx
  808674:	75 ee                	jne    808664 <tcp_segs_free+0x19>
  808676:	89 f2                	mov    %esi,%edx
  808678:	0f b6 c2             	movzbl %dl,%eax
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  80867b:	83 c4 10             	add    $0x10,%esp
  80867e:	5b                   	pop    %ebx
  80867f:	5e                   	pop    %esi
  808680:	5d                   	pop    %ebp
  808681:	c3                   	ret    

00808682 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  808682:	55                   	push   %ebp
  808683:	89 e5                	mov    %esp,%ebp
  808685:	53                   	push   %ebx
  808686:	83 ec 04             	sub    $0x4,%esp
  808689:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  80868c:	8b 43 10             	mov    0x10(%ebx),%eax
  80868f:	85 c0                	test   %eax,%eax
  808691:	74 62                	je     8086f5 <tcp_pcb_purge+0x73>
  808693:	83 f8 0a             	cmp    $0xa,%eax
  808696:	74 5d                	je     8086f5 <tcp_pcb_purge+0x73>
  808698:	83 f8 01             	cmp    $0x1,%eax
  80869b:	74 58                	je     8086f5 <tcp_pcb_purge+0x73>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  80869d:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8086a3:	85 c0                	test   %eax,%eax
  8086a5:	74 12                	je     8086b9 <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  8086a7:	89 04 24             	mov    %eax,(%esp)
  8086aa:	e8 c4 f3 ff ff       	call   807a73 <pbuf_free>
      pcb->refused_data = NULL;
  8086af:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8086b6:	00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  8086b9:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  8086bf:	8b 43 7c             	mov    0x7c(%ebx),%eax
  8086c2:	89 04 24             	mov    %eax,(%esp)
  8086c5:	e8 81 ff ff ff       	call   80864b <tcp_segs_free>
    pcb->ooseq = NULL;
  8086ca:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  8086d1:	8b 43 74             	mov    0x74(%ebx),%eax
  8086d4:	89 04 24             	mov    %eax,(%esp)
  8086d7:	e8 6f ff ff ff       	call   80864b <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  8086dc:	8b 43 78             	mov    0x78(%ebx),%eax
  8086df:	89 04 24             	mov    %eax,(%esp)
  8086e2:	e8 64 ff ff ff       	call   80864b <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  8086e7:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  8086ee:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  }
}
  8086f5:	83 c4 04             	add    $0x4,%esp
  8086f8:	5b                   	pop    %ebx
  8086f9:	5d                   	pop    %ebp
  8086fa:	c3                   	ret    

008086fb <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  8086fb:	55                   	push   %ebp
  8086fc:	89 e5                	mov    %esp,%ebp
  8086fe:	53                   	push   %ebx
  8086ff:	83 ec 14             	sub    $0x14,%esp
  808702:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808705:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  808708:	8b 11                	mov    (%ecx),%edx
  80870a:	39 da                	cmp    %ebx,%edx
  80870c:	75 07                	jne    808715 <tcp_pcb_remove+0x1a>
  80870e:	8b 43 0c             	mov    0xc(%ebx),%eax
  808711:	89 01                	mov    %eax,(%ecx)
  808713:	eb 2a                	jmp    80873f <tcp_pcb_remove+0x44>
  808715:	89 15 d4 e5 b3 00    	mov    %edx,0xb3e5d4
  80871b:	85 d2                	test   %edx,%edx
  80871d:	74 20                	je     80873f <tcp_pcb_remove+0x44>
  80871f:	8b 42 0c             	mov    0xc(%edx),%eax
  808722:	85 c0                	test   %eax,%eax
  808724:	0f 84 c0 00 00 00    	je     8087ea <tcp_pcb_remove+0xef>
  80872a:	39 c3                	cmp    %eax,%ebx
  80872c:	75 08                	jne    808736 <tcp_pcb_remove+0x3b>
  80872e:	8b 40 0c             	mov    0xc(%eax),%eax
  808731:	89 42 0c             	mov    %eax,0xc(%edx)
  808734:	eb 09                	jmp    80873f <tcp_pcb_remove+0x44>
  808736:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  80873b:	89 c2                	mov    %eax,%edx
  80873d:	eb e0                	jmp    80871f <tcp_pcb_remove+0x24>
  80873f:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  808746:	89 1c 24             	mov    %ebx,(%esp)
  808749:	e8 34 ff ff ff       	call   808682 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  80874e:	8b 43 10             	mov    0x10(%ebx),%eax
  808751:	83 f8 0a             	cmp    $0xa,%eax
  808754:	74 1b                	je     808771 <tcp_pcb_remove+0x76>
  808756:	83 f8 01             	cmp    $0x1,%eax
  808759:	74 16                	je     808771 <tcp_pcb_remove+0x76>
  80875b:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  80875f:	a8 01                	test   $0x1,%al
  808761:	74 0e                	je     808771 <tcp_pcb_remove+0x76>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  808763:	83 c8 02             	or     $0x2,%eax
  808766:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  808769:	89 1c 24             	mov    %ebx,(%esp)
  80876c:	e8 c8 27 00 00       	call   80af39 <tcp_output>
  }

  if (pcb->state != LISTEN) {
  808771:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  808775:	74 66                	je     8087dd <tcp_pcb_remove+0xe2>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  808777:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  80877b:	74 1c                	je     808799 <tcp_pcb_remove+0x9e>
  80877d:	c7 44 24 08 3b 35 81 	movl   $0x81353b,0x8(%esp)
  808784:	00 
  808785:	c7 44 24 04 b4 04 00 	movl   $0x4b4,0x4(%esp)
  80878c:	00 
  80878d:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  808794:	e8 13 81 ff ff       	call   8008ac <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  808799:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80879d:	74 1c                	je     8087bb <tcp_pcb_remove+0xc0>
  80879f:	c7 44 24 08 67 35 81 	movl   $0x813567,0x8(%esp)
  8087a6:	00 
  8087a7:	c7 44 24 04 b5 04 00 	movl   $0x4b5,0x4(%esp)
  8087ae:	00 
  8087af:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  8087b6:	e8 f1 80 ff ff       	call   8008ac <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  8087bb:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  8087bf:	74 1c                	je     8087dd <tcp_pcb_remove+0xe2>
  8087c1:	c7 44 24 08 80 35 81 	movl   $0x813580,0x8(%esp)
  8087c8:	00 
  8087c9:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp)
  8087d0:	00 
  8087d1:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  8087d8:	e8 cf 80 ff ff       	call   8008ac <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  8087dd:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  8087e4:	83 c4 14             	add    $0x14,%esp
  8087e7:	5b                   	pop    %ebx
  8087e8:	5d                   	pop    %ebp
  8087e9:	c3                   	ret    
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
  8087ea:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  8087ef:	e9 4b ff ff ff       	jmp    80873f <tcp_pcb_remove+0x44>

008087f4 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  8087f4:	55                   	push   %ebp
  8087f5:	89 e5                	mov    %esp,%ebp
  8087f7:	56                   	push   %esi
  8087f8:	53                   	push   %ebx
  8087f9:	83 ec 10             	sub    $0x10,%esp
  8087fc:	8b 75 08             	mov    0x8(%ebp),%esi
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  8087ff:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  808803:	74 1c                	je     808821 <tcp_listen_with_backlog+0x2d>
  808805:	c7 44 24 08 98 35 81 	movl   $0x813598,0x8(%esp)
  80880c:	00 
  80880d:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  808814:	00 
  808815:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  80881c:	e8 8b 80 ff ff       	call   8008ac <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  808821:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  808828:	e8 1d eb ff ff       	call   80734a <memp_malloc>
  if (lpcb == NULL) {
  80882d:	ba 00 00 00 00       	mov    $0x0,%edx
  808832:	85 c0                	test   %eax,%eax
  808834:	0f 84 b3 00 00 00    	je     8088ed <tcp_listen_with_backlog+0xf9>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80883a:	89 c3                	mov    %eax,%ebx
  if (lpcb == NULL) {
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  80883c:	8b 46 18             	mov    0x18(%esi),%eax
  80883f:	89 43 18             	mov    %eax,0x18(%ebx)
  lpcb->local_port = pcb->local_port;
  808842:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808846:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  lpcb->state = LISTEN;
  80884a:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  808851:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808855:	83 c8 02             	or     $0x2,%eax
  808858:	66 89 43 08          	mov    %ax,0x8(%ebx)
  lpcb->ttl = pcb->ttl;
  80885c:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808860:	88 43 0b             	mov    %al,0xb(%ebx)
  lpcb->tos = pcb->tos;
  808863:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  808867:	88 43 0a             	mov    %al,0xa(%ebx)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  80886a:	b8 00 00 00 00       	mov    $0x0,%eax
  80886f:	85 f6                	test   %esi,%esi
  808871:	74 02                	je     808875 <tcp_listen_with_backlog+0x81>
  808873:	8b 06                	mov    (%esi),%eax
  808875:	89 03                	mov    %eax,(%ebx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808877:	8b 15 d8 e5 b3 00    	mov    0xb3e5d8,%edx
  80887d:	39 f2                	cmp    %esi,%edx
  80887f:	75 0a                	jne    80888b <tcp_listen_with_backlog+0x97>
  808881:	8b 46 0c             	mov    0xc(%esi),%eax
  808884:	a3 d8 e5 b3 00       	mov    %eax,0xb3e5d8
  808889:	eb 26                	jmp    8088b1 <tcp_listen_with_backlog+0xbd>
  80888b:	89 15 d4 e5 b3 00    	mov    %edx,0xb3e5d4
  808891:	85 d2                	test   %edx,%edx
  808893:	74 1c                	je     8088b1 <tcp_listen_with_backlog+0xbd>
  808895:	8b 42 0c             	mov    0xc(%edx),%eax
  808898:	85 c0                	test   %eax,%eax
  80889a:	74 4a                	je     8088e6 <tcp_listen_with_backlog+0xf2>
  80889c:	39 c6                	cmp    %eax,%esi
  80889e:	75 08                	jne    8088a8 <tcp_listen_with_backlog+0xb4>
  8088a0:	8b 40 0c             	mov    0xc(%eax),%eax
  8088a3:	89 42 0c             	mov    %eax,0xc(%edx)
  8088a6:	eb 09                	jmp    8088b1 <tcp_listen_with_backlog+0xbd>
  8088a8:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  8088ad:	89 c2                	mov    %eax,%edx
  8088af:	eb e4                	jmp    808895 <tcp_listen_with_backlog+0xa1>
  8088b1:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  memp_free(MEMP_TCP_PCB, pcb);
  8088b8:	89 74 24 04          	mov    %esi,0x4(%esp)
  8088bc:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8088c3:	e8 3f ea ff ff       	call   807307 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  8088c8:	c7 43 20 40 83 80 00 	movl   $0x808340,0x20(%ebx)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  8088cf:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  8088d4:	89 43 0c             	mov    %eax,0xc(%ebx)
  8088d7:	89 1d d0 e5 b3 00    	mov    %ebx,0xb3e5d0
  8088dd:	e8 4b c2 ff ff       	call   804b2d <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  8088e2:	89 da                	mov    %ebx,%edx
  8088e4:	eb 07                	jmp    8088ed <tcp_listen_with_backlog+0xf9>
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8088e6:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  8088eb:	eb c4                	jmp    8088b1 <tcp_listen_with_backlog+0xbd>
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  return (struct tcp_pcb *)lpcb;
}
  8088ed:	89 d0                	mov    %edx,%eax
  8088ef:	83 c4 10             	add    $0x10,%esp
  8088f2:	5b                   	pop    %ebx
  8088f3:	5e                   	pop    %esi
  8088f4:	5d                   	pop    %ebp
  8088f5:	c3                   	ret    

008088f6 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8088f6:	55                   	push   %ebp
  8088f7:	89 e5                	mov    %esp,%ebp
  8088f9:	57                   	push   %edi
  8088fa:	56                   	push   %esi
  8088fb:	53                   	push   %ebx
  8088fc:	83 ec 0c             	sub    $0xc,%esp
  8088ff:	8b 7d 08             	mov    0x8(%ebp),%edi
  808902:	8b 75 0c             	mov    0xc(%ebp),%esi
  808905:	0f b7 4d 10          	movzwl 0x10(%ebp),%ecx
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  808909:	83 7f 10 00          	cmpl   $0x0,0x10(%edi)
  80890d:	74 1c                	je     80892b <tcp_bind+0x35>
  80890f:	c7 44 24 08 bc 35 81 	movl   $0x8135bc,0x8(%esp)
  808916:	00 
  808917:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
  80891e:	00 
  80891f:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  808926:	e8 81 7f ff ff       	call   8008ac <_panic>

  if (port == 0) {
  80892b:	66 85 c9             	test   %cx,%cx
  80892e:	75 07                	jne    808937 <tcp_bind+0x41>
    port = tcp_new_port();
  808930:	e8 15 fa ff ff       	call   80834a <tcp_new_port>
  808935:	89 c1                	mov    %eax,%ecx
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  808937:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
      cpcb != NULL; cpcb = cpcb->next) {
  80893c:	85 c0                	test   %eax,%eax
  80893e:	74 39                	je     808979 <tcp_bind+0x83>
    if (cpcb->local_port == port) {
  808940:	66 39 48 1c          	cmp    %cx,0x1c(%eax)
  808944:	75 2c                	jne    808972 <tcp_bind+0x7c>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808946:	85 c0                	test   %eax,%eax
  808948:	0f 84 e2 00 00 00    	je     808a30 <tcp_bind+0x13a>
  80894e:	8b 18                	mov    (%eax),%ebx
  808950:	85 db                	test   %ebx,%ebx
  808952:	0f 84 d8 00 00 00    	je     808a30 <tcp_bind+0x13a>
  808958:	85 f6                	test   %esi,%esi
  80895a:	0f 84 d0 00 00 00    	je     808a30 <tcp_bind+0x13a>
  808960:	8b 16                	mov    (%esi),%edx
  808962:	85 d2                	test   %edx,%edx
  808964:	0f 84 c6 00 00 00    	je     808a30 <tcp_bind+0x13a>
  80896a:	39 d3                	cmp    %edx,%ebx
  80896c:	0f 84 be 00 00 00    	je     808a30 <tcp_bind+0x13a>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  808972:	8b 40 0c             	mov    0xc(%eax),%eax
  808975:	85 c0                	test   %eax,%eax
  808977:	75 c7                	jne    808940 <tcp_bind+0x4a>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  808979:	a1 c8 e5 b3 00       	mov    0xb3e5c8,%eax
      cpcb != NULL; cpcb = cpcb->next) {
  80897e:	85 c0                	test   %eax,%eax
  808980:	74 37                	je     8089b9 <tcp_bind+0xc3>
    if (cpcb->local_port == port) {
  808982:	66 39 48 1c          	cmp    %cx,0x1c(%eax)
  808986:	75 2a                	jne    8089b2 <tcp_bind+0xbc>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808988:	85 c0                	test   %eax,%eax
  80898a:	0f 84 a0 00 00 00    	je     808a30 <tcp_bind+0x13a>
  808990:	8b 18                	mov    (%eax),%ebx
  808992:	85 db                	test   %ebx,%ebx
  808994:	0f 84 96 00 00 00    	je     808a30 <tcp_bind+0x13a>
  80899a:	85 f6                	test   %esi,%esi
  80899c:	0f 84 8e 00 00 00    	je     808a30 <tcp_bind+0x13a>
  8089a2:	8b 16                	mov    (%esi),%edx
  8089a4:	85 d2                	test   %edx,%edx
  8089a6:	0f 84 84 00 00 00    	je     808a30 <tcp_bind+0x13a>
  8089ac:	39 d3                	cmp    %edx,%ebx
  8089ae:	66 90                	xchg   %ax,%ax
  8089b0:	74 7e                	je     808a30 <tcp_bind+0x13a>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  8089b2:	8b 40 0c             	mov    0xc(%eax),%eax
  8089b5:	85 c0                	test   %eax,%eax
  8089b7:	75 c9                	jne    808982 <tcp_bind+0x8c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8089b9:	a1 d8 e5 b3 00       	mov    0xb3e5d8,%eax
  8089be:	85 c0                	test   %eax,%eax
  8089c0:	74 27                	je     8089e9 <tcp_bind+0xf3>
    if (cpcb->local_port == port) {
  8089c2:	66 39 48 1c          	cmp    %cx,0x1c(%eax)
  8089c6:	75 1a                	jne    8089e2 <tcp_bind+0xec>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8089c8:	85 c0                	test   %eax,%eax
  8089ca:	74 64                	je     808a30 <tcp_bind+0x13a>
  8089cc:	8b 18                	mov    (%eax),%ebx
  8089ce:	85 db                	test   %ebx,%ebx
  8089d0:	74 5e                	je     808a30 <tcp_bind+0x13a>
  8089d2:	85 f6                	test   %esi,%esi
  8089d4:	74 5a                	je     808a30 <tcp_bind+0x13a>
  8089d6:	8b 16                	mov    (%esi),%edx
  8089d8:	85 d2                	test   %edx,%edx
  8089da:	74 54                	je     808a30 <tcp_bind+0x13a>
  8089dc:	39 d3                	cmp    %edx,%ebx
  8089de:	66 90                	xchg   %ax,%ax
  8089e0:	74 4e                	je     808a30 <tcp_bind+0x13a>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8089e2:	8b 40 0c             	mov    0xc(%eax),%eax
  8089e5:	85 c0                	test   %eax,%eax
  8089e7:	75 d9                	jne    8089c2 <tcp_bind+0xcc>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8089e9:	8b 15 dc e5 b3 00    	mov    0xb3e5dc,%edx
  8089ef:	85 d2                	test   %edx,%edx
  8089f1:	74 13                	je     808a06 <tcp_bind+0x110>
    if (cpcb->local_port == port) {
  8089f3:	66 39 4a 1c          	cmp    %cx,0x1c(%edx)
  8089f7:	75 06                	jne    8089ff <tcp_bind+0x109>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  8089f9:	8b 02                	mov    (%edx),%eax
  8089fb:	3b 06                	cmp    (%esi),%eax
  8089fd:	74 31                	je     808a30 <tcp_bind+0x13a>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8089ff:	8b 52 0c             	mov    0xc(%edx),%edx
  808a02:	85 d2                	test   %edx,%edx
  808a04:	75 ed                	jne    8089f3 <tcp_bind+0xfd>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  808a06:	85 f6                	test   %esi,%esi
  808a08:	74 08                	je     808a12 <tcp_bind+0x11c>
  808a0a:	8b 06                	mov    (%esi),%eax
  808a0c:	85 c0                	test   %eax,%eax
  808a0e:	74 02                	je     808a12 <tcp_bind+0x11c>
    pcb->local_ip = *ipaddr;
  808a10:	89 07                	mov    %eax,(%edi)
  }
  pcb->local_port = port;
  808a12:	66 89 4f 1c          	mov    %cx,0x1c(%edi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  808a16:	a1 d8 e5 b3 00       	mov    0xb3e5d8,%eax
  808a1b:	89 47 0c             	mov    %eax,0xc(%edi)
  808a1e:	89 3d d8 e5 b3 00    	mov    %edi,0xb3e5d8
  808a24:	e8 04 c1 ff ff       	call   804b2d <tcp_timer_needed>
  808a29:	b8 00 00 00 00       	mov    $0x0,%eax
  808a2e:	eb 05                	jmp    808a35 <tcp_bind+0x13f>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  808a30:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  808a35:	83 c4 0c             	add    $0xc,%esp
  808a38:	5b                   	pop    %ebx
  808a39:	5e                   	pop    %esi
  808a3a:	5f                   	pop    %edi
  808a3b:	5d                   	pop    %ebp
  808a3c:	c3                   	ret    

00808a3d <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  808a3d:	55                   	push   %ebp
  808a3e:	89 e5                	mov    %esp,%ebp
  808a40:	56                   	push   %esi
  808a41:	53                   	push   %ebx
  808a42:	83 ec 30             	sub    $0x30,%esp
  808a45:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808a48:	8b 75 0c             	mov    0xc(%ebp),%esi
  808a4b:	0f b7 55 10          	movzwl 0x10(%ebp),%edx
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  808a4f:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  808a53:	74 1c                	je     808a71 <tcp_connect+0x34>
  808a55:	c7 44 24 08 e8 35 81 	movl   $0x8135e8,0x8(%esp)
  808a5c:	00 
  808a5d:	c7 44 24 04 ec 01 00 	movl   $0x1ec,0x4(%esp)
  808a64:	00 
  808a65:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  808a6c:	e8 3b 7e ff ff       	call   8008ac <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  808a71:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  808a76:	85 f6                	test   %esi,%esi
  808a78:	0f 84 39 01 00 00    	je     808bb7 <tcp_connect+0x17a>
    pcb->remote_ip = *ipaddr;
  808a7e:	8b 06                	mov    (%esi),%eax
  808a80:	89 43 04             	mov    %eax,0x4(%ebx)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  808a83:	66 89 53 1e          	mov    %dx,0x1e(%ebx)
  if (pcb->local_port == 0) {
  808a87:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  808a8c:	75 09                	jne    808a97 <tcp_connect+0x5a>
    pcb->local_port = tcp_new_port();
  808a8e:	e8 b7 f8 ff ff       	call   80834a <tcp_new_port>
  808a93:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  808a97:	e8 c3 f9 ff ff       	call   80845f <tcp_next_iss>
  pcb->rcv_nxt = 0;
  808a9c:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  808aa3:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  808aa6:	83 e8 01             	sub    $0x1,%eax
  808aa9:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  808aac:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  808aaf:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  808ab5:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  808abb:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  808ac1:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  808ac7:	89 74 24 04          	mov    %esi,0x4(%esp)
  808acb:	c7 04 24 18 02 00 00 	movl   $0x218,(%esp)
  808ad2:	e8 9d f9 ff ff       	call   808474 <tcp_eff_send_mss>
  808ad7:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  808adb:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  808ae1:	0f b7 c0             	movzwl %ax,%eax
  808ae4:	8d 04 80             	lea    (%eax,%eax,4),%eax
  808ae7:	01 c0                	add    %eax,%eax
  808ae9:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  808aed:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  808af4:	8b 45 14             	mov    0x14(%ebp),%eax
  808af7:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808afd:	8b 15 d8 e5 b3 00    	mov    0xb3e5d8,%edx
  808b03:	39 da                	cmp    %ebx,%edx
  808b05:	75 0a                	jne    808b11 <tcp_connect+0xd4>
  808b07:	8b 43 0c             	mov    0xc(%ebx),%eax
  808b0a:	a3 d8 e5 b3 00       	mov    %eax,0xb3e5d8
  808b0f:	eb 2a                	jmp    808b3b <tcp_connect+0xfe>
  808b11:	89 15 d4 e5 b3 00    	mov    %edx,0xb3e5d4
  808b17:	85 d2                	test   %edx,%edx
  808b19:	74 20                	je     808b3b <tcp_connect+0xfe>
  808b1b:	8b 42 0c             	mov    0xc(%edx),%eax
  808b1e:	85 c0                	test   %eax,%eax
  808b20:	0f 84 8a 00 00 00    	je     808bb0 <tcp_connect+0x173>
  808b26:	39 c3                	cmp    %eax,%ebx
  808b28:	75 08                	jne    808b32 <tcp_connect+0xf5>
  808b2a:	8b 40 0c             	mov    0xc(%eax),%eax
  808b2d:	89 42 0c             	mov    %eax,0xc(%edx)
  808b30:	eb 09                	jmp    808b3b <tcp_connect+0xfe>
  808b32:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  808b37:	89 c2                	mov    %eax,%edx
  808b39:	eb e0                	jmp    808b1b <tcp_connect+0xde>
  808b3b:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  TCP_REG(&tcp_active_pcbs, pcb);
  808b42:	a1 c8 e5 b3 00       	mov    0xb3e5c8,%eax
  808b47:	89 43 0c             	mov    %eax,0xc(%ebx)
  808b4a:	89 1d c8 e5 b3 00    	mov    %ebx,0xb3e5c8
  808b50:	e8 d8 bf ff ff       	call   804b2d <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  808b55:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  808b5c:	e8 5b 1d 00 00       	call   80a8bc <htonl>
  808b61:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  808b64:	8d 45 f4             	lea    -0xc(%ebp),%eax
  808b67:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  808b6e:	00 
  808b6f:	89 44 24 14          	mov    %eax,0x14(%esp)
  808b73:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808b7a:	00 
  808b7b:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  808b82:	00 
  808b83:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808b8a:	00 
  808b8b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808b92:	00 
  808b93:	89 1c 24             	mov    %ebx,(%esp)
  808b96:	e8 fa 28 00 00       	call   80b495 <tcp_enqueue>
  808b9b:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  808b9d:	84 c0                	test   %al,%al
  808b9f:	75 08                	jne    808ba9 <tcp_connect+0x16c>
    tcp_output(pcb);
  808ba1:	89 1c 24             	mov    %ebx,(%esp)
  808ba4:	e8 90 23 00 00       	call   80af39 <tcp_output>
  }
  return ret;
  808ba9:	89 f2                	mov    %esi,%edx
  808bab:	0f be c2             	movsbl %dl,%eax
  808bae:	eb 07                	jmp    808bb7 <tcp_connect+0x17a>
  pcb->ssthresh = pcb->mss * 10;
  pcb->state = SYN_SENT;
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808bb0:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  808bb5:	eb 84                	jmp    808b3b <tcp_connect+0xfe>
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  if (ret == ERR_OK) { 
    tcp_output(pcb);
  }
  return ret;
} 
  808bb7:	83 c4 30             	add    $0x30,%esp
  808bba:	5b                   	pop    %ebx
  808bbb:	5e                   	pop    %esi
  808bbc:	5d                   	pop    %ebp
  808bbd:	c3                   	ret    

00808bbe <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  808bbe:	55                   	push   %ebp
  808bbf:	89 e5                	mov    %esp,%ebp
  808bc1:	57                   	push   %edi
  808bc2:	56                   	push   %esi
  808bc3:	53                   	push   %ebx
  808bc4:	83 ec 3c             	sub    $0x3c,%esp
  808bc7:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  808bca:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  808bce:	75 25                	jne    808bf5 <tcp_abort+0x37>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  808bd0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808bd4:	c7 04 24 dc e5 b3 00 	movl   $0xb3e5dc,(%esp)
  808bdb:	e8 1b fb ff ff       	call   8086fb <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  808be0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808be4:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808beb:	e8 17 e7 ff ff       	call   807307 <memp_free>
  808bf0:	e9 d2 00 00 00       	jmp    808cc7 <tcp_abort+0x109>
  } else {
    seqno = pcb->snd_nxt;
  808bf5:	8b 43 54             	mov    0x54(%ebx),%eax
  808bf8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  808bfb:	8b 43 24             	mov    0x24(%ebx),%eax
  808bfe:	89 45 d8             	mov    %eax,-0x28(%ebp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  808c01:	b8 00 00 00 00       	mov    $0x0,%eax
  808c06:	85 db                	test   %ebx,%ebx
  808c08:	74 02                	je     808c0c <tcp_abort+0x4e>
  808c0a:	8b 03                	mov    (%ebx),%eax
  808c0c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  808c0f:	b8 00 00 00 00       	mov    $0x0,%eax
  808c14:	83 fb fc             	cmp    $0xfffffffc,%ebx
  808c17:	74 03                	je     808c1c <tcp_abort+0x5e>
  808c19:	8b 43 04             	mov    0x4(%ebx),%eax
  808c1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    local_port = pcb->local_port;
  808c1f:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  808c23:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    remote_port = pcb->remote_port;
  808c27:	0f b7 7b 1e          	movzwl 0x1e(%ebx),%edi
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  808c2b:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  808c31:	8b 43 18             	mov    0x18(%ebx),%eax
  808c34:	89 45 e0             	mov    %eax,-0x20(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  808c37:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808c3b:	c7 04 24 c8 e5 b3 00 	movl   $0xb3e5c8,(%esp)
  808c42:	e8 b4 fa ff ff       	call   8086fb <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  808c47:	8b 43 78             	mov    0x78(%ebx),%eax
  808c4a:	85 c0                	test   %eax,%eax
  808c4c:	74 08                	je     808c56 <tcp_abort+0x98>
      tcp_segs_free(pcb->unacked);
  808c4e:	89 04 24             	mov    %eax,(%esp)
  808c51:	e8 f5 f9 ff ff       	call   80864b <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  808c56:	8b 43 74             	mov    0x74(%ebx),%eax
  808c59:	85 c0                	test   %eax,%eax
  808c5b:	74 08                	je     808c65 <tcp_abort+0xa7>
      tcp_segs_free(pcb->unsent);
  808c5d:	89 04 24             	mov    %eax,(%esp)
  808c60:	e8 e6 f9 ff ff       	call   80864b <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  808c65:	8b 43 7c             	mov    0x7c(%ebx),%eax
  808c68:	85 c0                	test   %eax,%eax
  808c6a:	74 08                	je     808c74 <tcp_abort+0xb6>
      tcp_segs_free(pcb->ooseq);
  808c6c:	89 04 24             	mov    %eax,(%esp)
  808c6f:	e8 d7 f9 ff ff       	call   80864b <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  808c74:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808c78:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808c7f:	e8 83 e6 ff ff       	call   807307 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  808c84:	85 f6                	test   %esi,%esi
  808c86:	74 10                	je     808c98 <tcp_abort+0xda>
  808c88:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  808c8f:	ff 
  808c90:	8b 45 e0             	mov    -0x20(%ebp),%eax
  808c93:	89 04 24             	mov    %eax,(%esp)
  808c96:	ff d6                	call   *%esi
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  808c98:	0f b7 c7             	movzwl %di,%eax
  808c9b:	89 44 24 14          	mov    %eax,0x14(%esp)
  808c9f:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  808ca3:	89 44 24 10          	mov    %eax,0x10(%esp)
  808ca7:	8d 45 f0             	lea    -0x10(%ebp),%eax
  808caa:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808cae:	8d 45 ec             	lea    -0x14(%ebp),%eax
  808cb1:	89 44 24 08          	mov    %eax,0x8(%esp)
  808cb5:	8b 45 d8             	mov    -0x28(%ebp),%eax
  808cb8:	89 44 24 04          	mov    %eax,0x4(%esp)
  808cbc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  808cbf:	89 04 24             	mov    %eax,(%esp)
  808cc2:	e8 15 21 00 00       	call   80addc <tcp_rst>
  }
}
  808cc7:	83 c4 3c             	add    $0x3c,%esp
  808cca:	5b                   	pop    %ebx
  808ccb:	5e                   	pop    %esi
  808ccc:	5f                   	pop    %edi
  808ccd:	5d                   	pop    %ebp
  808cce:	c3                   	ret    

00808ccf <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  808ccf:	55                   	push   %ebp
  808cd0:	89 e5                	mov    %esp,%ebp
  808cd2:	57                   	push   %edi
  808cd3:	56                   	push   %esi
  808cd4:	53                   	push   %ebx
  808cd5:	83 ec 1c             	sub    $0x1c,%esp
  808cd8:	0f b6 7d 08          	movzbl 0x8(%ebp),%edi
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  808cdc:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808ce3:	e8 62 e6 ff ff       	call   80734a <memp_malloc>
  808ce8:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  808cea:	85 c0                	test   %eax,%eax
  808cec:	0f 85 a8 00 00 00    	jne    808d9a <tcp_alloc+0xcb>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808cf2:	8b 0d dc e5 b3 00    	mov    0xb3e5dc,%ecx
  808cf8:	85 c9                	test   %ecx,%ecx
  808cfa:	0f 85 3f 01 00 00    	jne    808e3f <tcp_alloc+0x170>
  808d00:	eb 22                	jmp    808d24 <tcp_alloc+0x55>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  808d02:	89 f2                	mov    %esi,%edx
  808d04:	2b 50 2c             	sub    0x2c(%eax),%edx
  808d07:	39 da                	cmp    %ebx,%edx
  808d09:	72 06                	jb     808d11 <tcp_alloc+0x42>
  808d0b:	89 d3                	mov    %edx,%ebx
  808d0d:	89 c1                	mov    %eax,%ecx
  808d0f:	89 c8                	mov    %ecx,%eax
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808d11:	8b 40 0c             	mov    0xc(%eax),%eax
  808d14:	85 c0                	test   %eax,%eax
  808d16:	75 ea                	jne    808d02 <tcp_alloc+0x33>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  808d18:	85 c9                	test   %ecx,%ecx
  808d1a:	74 08                	je     808d24 <tcp_alloc+0x55>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  808d1c:	89 0c 24             	mov    %ecx,(%esp)
  808d1f:	e8 9a fe ff ff       	call   808bbe <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  808d24:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808d2b:	e8 1a e6 ff ff       	call   80734a <memp_malloc>
  808d30:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  808d32:	85 c0                	test   %eax,%eax
  808d34:	75 64                	jne    808d9a <tcp_alloc+0xcb>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808d36:	a1 c8 e5 b3 00       	mov    0xb3e5c8,%eax
  808d3b:	85 c0                	test   %eax,%eax
  808d3d:	74 4d                	je     808d8c <tcp_alloc+0xbd>
    if (pcb->prio <= prio &&
  808d3f:	8b 15 cc e5 b3 00    	mov    0xb3e5cc,%edx
  808d45:	89 55 f0             	mov    %edx,-0x10(%ebp)
  808d48:	be 00 00 00 00       	mov    $0x0,%esi
  808d4d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  808d54:	bb 7f 00 00 00       	mov    $0x7f,%ebx
  808d59:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  808d5d:	89 f9                	mov    %edi,%ecx
  808d5f:	38 d1                	cmp    %dl,%cl
  808d61:	72 16                	jb     808d79 <tcp_alloc+0xaa>
  808d63:	38 da                	cmp    %bl,%dl
  808d65:	77 12                	ja     808d79 <tcp_alloc+0xaa>
  808d67:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  808d6a:	2b 48 2c             	sub    0x2c(%eax),%ecx
  808d6d:	3b 4d ec             	cmp    -0x14(%ebp),%ecx
  808d70:	72 07                	jb     808d79 <tcp_alloc+0xaa>
  808d72:	89 c6                	mov    %eax,%esi
  808d74:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  808d77:	89 d3                	mov    %edx,%ebx
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808d79:	8b 40 0c             	mov    0xc(%eax),%eax
  808d7c:	85 c0                	test   %eax,%eax
  808d7e:	75 d9                	jne    808d59 <tcp_alloc+0x8a>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  808d80:	85 f6                	test   %esi,%esi
  808d82:	74 08                	je     808d8c <tcp_alloc+0xbd>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  808d84:	89 34 24             	mov    %esi,(%esp)
  808d87:	e8 32 fe ff ff       	call   808bbe <tcp_abort>
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  808d8c:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808d93:	e8 b2 e5 ff ff       	call   80734a <memp_malloc>
  808d98:	89 c3                	mov    %eax,%ebx
    }
  }
  if (pcb != NULL) {
  808d9a:	85 db                	test   %ebx,%ebx
  808d9c:	0f 84 ad 00 00 00    	je     808e4f <tcp_alloc+0x180>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  808da2:	c7 44 24 08 a8 00 00 	movl   $0xa8,0x8(%esp)
  808da9:	00 
  808daa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808db1:	00 
  808db2:	89 1c 24             	mov    %ebx,(%esp)
  808db5:	e8 d4 83 ff ff       	call   80118e <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  808dba:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  808dbe:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  808dc4:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  808dca:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  808dd0:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  808dd6:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  808dda:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  808dde:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  808de4:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  808dea:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  808df0:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  808df6:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  808dfc:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  808e02:	e8 58 f6 ff ff       	call   80845f <tcp_next_iss>
    pcb->snd_wl2 = iss;
  808e07:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  808e0a:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  808e0d:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  808e10:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  808e13:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  808e16:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  808e1b:	89 43 2c             	mov    %eax,0x2c(%ebx)

    pcb->polltmr = 0;
  808e1e:	c6 43 30 00          	movb   $0x0,0x30(%ebx)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  808e22:	c7 83 88 00 00 00 53 	movl   $0x809453,0x88(%ebx)
  808e29:	94 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  808e2c:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  808e33:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  808e36:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  808e3d:	eb 10                	jmp    808e4f <tcp_alloc+0x180>

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  808e3f:	8b 35 cc e5 b3 00    	mov    0xb3e5cc,%esi
  808e45:	89 f3                	mov    %esi,%ebx
  808e47:	2b 59 2c             	sub    0x2c(%ecx),%ebx
  808e4a:	e9 c0 fe ff ff       	jmp    808d0f <tcp_alloc+0x40>
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  }
  return pcb;
}
  808e4f:	89 d8                	mov    %ebx,%eax
  808e51:	83 c4 1c             	add    $0x1c,%esp
  808e54:	5b                   	pop    %ebx
  808e55:	5e                   	pop    %esi
  808e56:	5f                   	pop    %edi
  808e57:	5d                   	pop    %ebp
  808e58:	c3                   	ret    

00808e59 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  808e59:	55                   	push   %ebp
  808e5a:	89 e5                	mov    %esp,%ebp
  808e5c:	83 ec 08             	sub    $0x8,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  808e5f:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  808e66:	e8 64 fe ff ff       	call   808ccf <tcp_alloc>
}
  808e6b:	c9                   	leave  
  808e6c:	c3                   	ret    

00808e6d <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  808e6d:	55                   	push   %ebp
  808e6e:	89 e5                	mov    %esp,%ebp
  808e70:	57                   	push   %edi
  808e71:	56                   	push   %esi
  808e72:	53                   	push   %ebx
  808e73:	83 ec 1c             	sub    $0x1c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  808e76:	83 05 cc e5 b3 00 01 	addl   $0x1,0xb3e5cc

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  808e7d:	8b 35 c8 e5 b3 00    	mov    0xb3e5c8,%esi
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  808e83:	85 f6                	test   %esi,%esi
  808e85:	0f 84 55 03 00 00    	je     8091e0 <tcp_slowtmr+0x373>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  808e8b:	8b 46 10             	mov    0x10(%esi),%eax
  808e8e:	85 c0                	test   %eax,%eax
  808e90:	74 1e                	je     808eb0 <tcp_slowtmr+0x43>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  808e92:	83 f8 01             	cmp    $0x1,%eax
  808e95:	74 3a                	je     808ed1 <tcp_slowtmr+0x64>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  808e97:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  808e9e:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  808ea2:	83 f8 0a             	cmp    $0xa,%eax
  808ea5:	75 67                	jne    808f0e <tcp_slowtmr+0xa1>
  808ea7:	eb 49                	jmp    808ef2 <tcp_slowtmr+0x85>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  808ea9:	8b 46 10             	mov    0x10(%esi),%eax
  808eac:	85 c0                	test   %eax,%eax
  808eae:	75 1c                	jne    808ecc <tcp_slowtmr+0x5f>
  808eb0:	c7 44 24 08 1c 36 81 	movl   $0x81361c,0x8(%esp)
  808eb7:	00 
  808eb8:	c7 44 24 04 36 02 00 	movl   $0x236,0x4(%esp)
  808ebf:	00 
  808ec0:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  808ec7:	e8 e0 79 ff ff       	call   8008ac <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  808ecc:	83 f8 01             	cmp    $0x1,%eax
  808ecf:	75 1c                	jne    808eed <tcp_slowtmr+0x80>
  808ed1:	c7 44 24 08 48 36 81 	movl   $0x813648,0x8(%esp)
  808ed8:	00 
  808ed9:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
  808ee0:	00 
  808ee1:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  808ee8:	e8 bf 79 ff ff       	call   8008ac <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  808eed:	83 f8 0a             	cmp    $0xa,%eax
  808ef0:	75 1c                	jne    808f0e <tcp_slowtmr+0xa1>
  808ef2:	c7 44 24 08 74 36 81 	movl   $0x813674,0x8(%esp)
  808ef9:	00 
  808efa:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  808f01:	00 
  808f02:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  808f09:	e8 9e 79 ff ff       	call   8008ac <_panic>

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  808f0e:	83 f8 02             	cmp    $0x2,%eax
  808f11:	75 0a                	jne    808f1d <tcp_slowtmr+0xb0>
  808f13:	80 7e 46 06          	cmpb   $0x6,0x46(%esi)
  808f17:	0f 84 93 03 00 00    	je     8092b0 <tcp_slowtmr+0x443>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  808f1d:	bb 01 00 00 00       	mov    $0x1,%ebx
  808f22:	80 7e 46 0c          	cmpb   $0xc,0x46(%esi)
  808f26:	0f 84 ee 00 00 00    	je     80901a <tcp_slowtmr+0x1ad>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  808f2c:	80 be a4 00 00 00 00 	cmpb   $0x0,0xa4(%esi)
  808f33:	74 55                	je     808f8a <tcp_slowtmr+0x11d>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  808f35:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
  808f3b:	83 c0 01             	add    $0x1,%eax
  808f3e:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  808f44:	0f b6 96 a4 00 00 00 	movzbl 0xa4(%esi),%edx
  808f4b:	0f b6 92 a8 37 81 00 	movzbl 0x8137a8(%edx),%edx
  808f52:	39 d0                	cmp    %edx,%eax
  808f54:	0f 82 bb 00 00 00    	jb     809015 <tcp_slowtmr+0x1a8>
          pcb->persist_cnt = 0;
  808f5a:	c7 86 a0 00 00 00 00 	movl   $0x0,0xa0(%esi)
  808f61:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  808f64:	0f b6 86 a4 00 00 00 	movzbl 0xa4(%esi),%eax
  808f6b:	3c 06                	cmp    $0x6,%al
  808f6d:	77 09                	ja     808f78 <tcp_slowtmr+0x10b>
            pcb->persist_backoff++;
  808f6f:	83 c0 01             	add    $0x1,%eax
  808f72:	88 86 a4 00 00 00    	mov    %al,0xa4(%esi)
          }
          tcp_zero_window_probe(pcb);
  808f78:	89 34 24             	mov    %esi,(%esp)
  808f7b:	e8 90 1b 00 00       	call   80ab10 <tcp_zero_window_probe>
  808f80:	bb 00 00 00 00       	mov    $0x0,%ebx
  808f85:	e9 90 00 00 00       	jmp    80901a <tcp_slowtmr+0x1ad>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  808f8a:	0f b7 46 32          	movzwl 0x32(%esi),%eax
  808f8e:	66 85 c0             	test   %ax,%ax
  808f91:	78 07                	js     808f9a <tcp_slowtmr+0x12d>
          ++pcb->rtime;
  808f93:	83 c0 01             	add    $0x1,%eax
  808f96:	66 89 46 32          	mov    %ax,0x32(%esi)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  808f9a:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  808f9e:	74 75                	je     809015 <tcp_slowtmr+0x1a8>
  808fa0:	0f b7 46 32          	movzwl 0x32(%esi),%eax
  808fa4:	66 3b 46 44          	cmp    0x44(%esi),%ax
  808fa8:	7c 6b                	jl     809015 <tcp_slowtmr+0x1a8>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  808faa:	83 7e 10 02          	cmpl   $0x2,0x10(%esi)
  808fae:	74 20                	je     808fd0 <tcp_slowtmr+0x163>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  808fb0:	0f b7 46 40          	movzwl 0x40(%esi),%eax
  808fb4:	66 c1 f8 03          	sar    $0x3,%ax
  808fb8:	98                   	cwtl   
  808fb9:	0f bf 56 42          	movswl 0x42(%esi),%edx
  808fbd:	01 d0                	add    %edx,%eax
  808fbf:	0f b6 56 46          	movzbl 0x46(%esi),%edx
  808fc3:	0f b6 8a 9c 37 81 00 	movzbl 0x81379c(%edx),%ecx
  808fca:	d3 e0                	shl    %cl,%eax
  808fcc:	66 89 46 44          	mov    %ax,0x44(%esi)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  808fd0:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  808fd6:	0f b7 56 5c          	movzwl 0x5c(%esi),%edx
  808fda:	0f b7 46 4e          	movzwl 0x4e(%esi),%eax
  808fde:	66 39 d0             	cmp    %dx,%ax
  808fe1:	76 02                	jbe    808fe5 <tcp_slowtmr+0x178>
  808fe3:	89 d0                	mov    %edx,%eax
  808fe5:	66 d1 e8             	shr    %ax
  808fe8:	66 89 46 50          	mov    %ax,0x50(%esi)
          if (pcb->ssthresh < pcb->mss) {
  808fec:	0f b7 56 34          	movzwl 0x34(%esi),%edx
  808ff0:	66 39 d0             	cmp    %dx,%ax
  808ff3:	73 09                	jae    808ffe <tcp_slowtmr+0x191>
            pcb->ssthresh = pcb->mss * 2;
  808ff5:	0f b7 c2             	movzwl %dx,%eax
  808ff8:	01 c0                	add    %eax,%eax
  808ffa:	66 89 46 50          	mov    %ax,0x50(%esi)
          }
          pcb->cwnd = pcb->mss;
  808ffe:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  809002:	66 89 46 4e          	mov    %ax,0x4e(%esi)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  809006:	89 34 24             	mov    %esi,(%esp)
  809009:	e8 30 24 00 00       	call   80b43e <tcp_rexmit_rto>
  80900e:	bb 00 00 00 00       	mov    $0x0,%ebx
  809013:	eb 05                	jmp    80901a <tcp_slowtmr+0x1ad>
  809015:	bb 00 00 00 00       	mov    $0x0,%ebx
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  80901a:	8b 56 10             	mov    0x10(%esi),%edx
  80901d:	83 fa 06             	cmp    $0x6,%edx
  809020:	75 0e                	jne    809030 <tcp_slowtmr+0x1c3>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  809022:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  809027:	2b 46 2c             	sub    0x2c(%esi),%eax
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80902a:	83 f8 29             	cmp    $0x29,%eax
  80902d:	80 db ff             	sbb    $0xff,%bl
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  809030:	f6 46 08 08          	testb  $0x8,0x8(%esi)
  809034:	74 64                	je     80909a <tcp_slowtmr+0x22d>
  809036:	83 fa 04             	cmp    $0x4,%edx
  809039:	74 05                	je     809040 <tcp_slowtmr+0x1d3>
  80903b:	83 fa 07             	cmp    $0x7,%edx
  80903e:	75 5a                	jne    80909a <tcp_slowtmr+0x22d>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  809040:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  809045:	89 c7                	mov    %eax,%edi
  809047:	2b 7e 2c             	sub    0x2c(%esi),%edi
  80904a:	8b 8e 9c 00 00 00    	mov    0x9c(%esi),%ecx
  809050:	8d 91 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%edx
  809056:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  80905b:	f7 e2                	mul    %edx
  80905d:	c1 ea 05             	shr    $0x5,%edx
  809060:	39 d7                	cmp    %edx,%edi
  809062:	76 0a                	jbe    80906e <tcp_slowtmr+0x201>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  809064:	89 34 24             	mov    %esi,(%esp)
  809067:	e8 52 fb ff ff       	call   808bbe <tcp_abort>
  80906c:	eb 2c                	jmp    80909a <tcp_slowtmr+0x22d>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80906e:	0f b6 96 a5 00 00 00 	movzbl 0xa5(%esi),%edx
  809075:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  80907b:	01 ca                	add    %ecx,%edx
  80907d:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  809082:	f7 e2                	mul    %edx
  809084:	c1 ea 05             	shr    $0x5,%edx
  809087:	39 d7                	cmp    %edx,%edi
  809089:	76 0f                	jbe    80909a <tcp_slowtmr+0x22d>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  80908b:	89 34 24             	mov    %esi,(%esp)
  80908e:	e8 f4 1b 00 00       	call   80ac87 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  809093:	80 86 a5 00 00 00 01 	addb   $0x1,0xa5(%esi)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80909a:	8b 4e 7c             	mov    0x7c(%esi),%ecx
  80909d:	85 c9                	test   %ecx,%ecx
  80909f:	74 25                	je     8090c6 <tcp_slowtmr+0x259>
  8090a1:	8b 15 cc e5 b3 00    	mov    0xb3e5cc,%edx
  8090a7:	2b 56 2c             	sub    0x2c(%esi),%edx
  8090aa:	0f bf 46 44          	movswl 0x44(%esi),%eax
  8090ae:	8d 04 40             	lea    (%eax,%eax,2),%eax
  8090b1:	01 c0                	add    %eax,%eax
  8090b3:	39 c2                	cmp    %eax,%edx
  8090b5:	72 0f                	jb     8090c6 <tcp_slowtmr+0x259>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  8090b7:	89 0c 24             	mov    %ecx,(%esp)
  8090ba:	e8 8c f5 ff ff       	call   80864b <tcp_segs_free>
      pcb->ooseq = NULL;
  8090bf:	c7 46 7c 00 00 00 00 	movl   $0x0,0x7c(%esi)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  8090c6:	8b 56 10             	mov    0x10(%esi),%edx
  8090c9:	83 fa 03             	cmp    $0x3,%edx
  8090cc:	75 12                	jne    8090e0 <tcp_slowtmr+0x273>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  8090ce:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  8090d3:	2b 46 2c             	sub    0x2c(%esi),%eax
  8090d6:	83 f8 28             	cmp    $0x28,%eax
  8090d9:	76 05                	jbe    8090e0 <tcp_slowtmr+0x273>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  8090db:	83 c3 01             	add    $0x1,%ebx
  8090de:	eb 15                	jmp    8090f5 <tcp_slowtmr+0x288>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  8090e0:	83 fa 09             	cmp    $0x9,%edx
  8090e3:	75 10                	jne    8090f5 <tcp_slowtmr+0x288>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8090e5:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  8090ea:	2b 46 2c             	sub    0x2c(%esi),%eax
        ++pcb_remove;
  8090ed:	3d f1 00 00 00       	cmp    $0xf1,%eax
  8090f2:	80 db ff             	sbb    $0xff,%bl
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  8090f5:	84 db                	test   %bl,%bl
  8090f7:	0f 84 9b 00 00 00    	je     809198 <tcp_slowtmr+0x32b>
      tcp_pcb_purge(pcb);      
  8090fd:	89 34 24             	mov    %esi,(%esp)
  809100:	e8 7d f5 ff ff       	call   808682 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  809105:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  809109:	74 2f                	je     80913a <tcp_slowtmr+0x2cd>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80910b:	3b 35 c8 e5 b3 00    	cmp    0xb3e5c8,%esi
  809111:	75 1c                	jne    80912f <tcp_slowtmr+0x2c2>
  809113:	c7 44 24 08 a4 36 81 	movl   $0x8136a4,0x8(%esp)
  80911a:	00 
  80911b:	c7 44 24 04 c1 02 00 	movl   $0x2c1,0x4(%esp)
  809122:	00 
  809123:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  80912a:	e8 7d 77 ff ff       	call   8008ac <_panic>
        prev->next = pcb->next;
  80912f:	8b 46 0c             	mov    0xc(%esi),%eax
  809132:	8b 55 f0             	mov    -0x10(%ebp),%edx
  809135:	89 42 0c             	mov    %eax,0xc(%edx)
  809138:	eb 2d                	jmp    809167 <tcp_slowtmr+0x2fa>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  80913a:	a1 c8 e5 b3 00       	mov    0xb3e5c8,%eax
  80913f:	39 f0                	cmp    %esi,%eax
  809141:	74 1c                	je     80915f <tcp_slowtmr+0x2f2>
  809143:	c7 44 24 08 d0 36 81 	movl   $0x8136d0,0x8(%esp)
  80914a:	00 
  80914b:	c7 44 24 04 c5 02 00 	movl   $0x2c5,0x4(%esp)
  809152:	00 
  809153:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  80915a:	e8 4d 77 ff ff       	call   8008ac <_panic>
        tcp_active_pcbs = pcb->next;
  80915f:	8b 40 0c             	mov    0xc(%eax),%eax
  809162:	a3 c8 e5 b3 00       	mov    %eax,0xb3e5c8
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  809167:	8b 96 98 00 00 00    	mov    0x98(%esi),%edx
  80916d:	85 d2                	test   %edx,%edx
  80916f:	74 10                	je     809181 <tcp_slowtmr+0x314>
  809171:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  809178:	ff 
  809179:	8b 46 18             	mov    0x18(%esi),%eax
  80917c:	89 04 24             	mov    %eax,(%esp)
  80917f:	ff d2                	call   *%edx

      pcb2 = pcb->next;
  809181:	8b 5e 0c             	mov    0xc(%esi),%ebx
      memp_free(MEMP_TCP_PCB, pcb);
  809184:	89 74 24 04          	mov    %esi,0x4(%esp)
  809188:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80918f:	e8 73 e1 ff ff       	call   807307 <memp_free>
  809194:	89 de                	mov    %ebx,%esi
  809196:	eb 40                	jmp    8091d8 <tcp_slowtmr+0x36b>
      pcb = pcb2;
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  809198:	0f b6 46 30          	movzbl 0x30(%esi),%eax
  80919c:	83 c0 01             	add    $0x1,%eax
  80919f:	88 46 30             	mov    %al,0x30(%esi)
      if (pcb->polltmr >= pcb->pollinterval) {
  8091a2:	3a 46 31             	cmp    0x31(%esi),%al
  8091a5:	72 2b                	jb     8091d2 <tcp_slowtmr+0x365>
        pcb->polltmr = 0;
  8091a7:	c6 46 30 00          	movb   $0x0,0x30(%esi)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  8091ab:	8b 96 94 00 00 00    	mov    0x94(%esi),%edx
  8091b1:	85 d2                	test   %edx,%edx
  8091b3:	74 0f                	je     8091c4 <tcp_slowtmr+0x357>
  8091b5:	89 74 24 04          	mov    %esi,0x4(%esp)
  8091b9:	8b 46 18             	mov    0x18(%esi),%eax
  8091bc:	89 04 24             	mov    %eax,(%esp)
  8091bf:	ff d2                	call   *%edx
  8091c1:	88 45 ef             	mov    %al,-0x11(%ebp)
        if (err == ERR_OK) {
  8091c4:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
  8091c8:	75 08                	jne    8091d2 <tcp_slowtmr+0x365>
          tcp_output(pcb);
  8091ca:	89 34 24             	mov    %esi,(%esp)
  8091cd:	e8 67 1d 00 00       	call   80af39 <tcp_output>
        }
      }
      
      prev = pcb;
      pcb = pcb->next;
  8091d2:	89 75 f0             	mov    %esi,-0x10(%ebp)
  8091d5:	8b 76 0c             	mov    0xc(%esi),%esi
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  8091d8:	85 f6                	test   %esi,%esi
  8091da:	0f 85 c9 fc ff ff    	jne    808ea9 <tcp_slowtmr+0x3c>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  8091e0:	8b 35 dc e5 b3 00    	mov    0xb3e5dc,%esi
  while (pcb != NULL) {
  8091e6:	85 f6                	test   %esi,%esi
  8091e8:	0f 84 e4 00 00 00    	je     8092d2 <tcp_slowtmr+0x465>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8091ee:	bf 00 00 00 00       	mov    $0x0,%edi
  8091f3:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  8091f7:	74 25                	je     80921e <tcp_slowtmr+0x3b1>
  8091f9:	eb 07                	jmp    809202 <tcp_slowtmr+0x395>
  8091fb:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  8091ff:	90                   	nop    
  809200:	74 1c                	je     80921e <tcp_slowtmr+0x3b1>
  809202:	c7 44 24 08 fc 36 81 	movl   $0x8136fc,0x8(%esp)
  809209:	00 
  80920a:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
  809211:	00 
  809212:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  809219:	e8 8e 76 ff ff       	call   8008ac <_panic>
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80921e:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  809223:	2b 46 2c             	sub    0x2c(%esi),%eax
  809226:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80922b:	0f 87 8c 00 00 00    	ja     8092bd <tcp_slowtmr+0x450>
      pcb2 = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb);
      pcb = pcb2;
    } else {
      prev = pcb;
      pcb = pcb->next;
  809231:	89 f7                	mov    %esi,%edi
  809233:	8b 76 0c             	mov    0xc(%esi),%esi
  809236:	eb 6e                	jmp    8092a6 <tcp_slowtmr+0x439>
    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      tcp_pcb_purge(pcb);      
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  809238:	3b 35 dc e5 b3 00    	cmp    0xb3e5dc,%esi
  80923e:	75 1c                	jne    80925c <tcp_slowtmr+0x3ef>
  809240:	c7 44 24 08 2c 37 81 	movl   $0x81372c,0x8(%esp)
  809247:	00 
  809248:	c7 44 24 04 f4 02 00 	movl   $0x2f4,0x4(%esp)
  80924f:	00 
  809250:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  809257:	e8 50 76 ff ff       	call   8008ac <_panic>
        prev->next = pcb->next;
  80925c:	8b 46 0c             	mov    0xc(%esi),%eax
  80925f:	89 47 0c             	mov    %eax,0xc(%edi)
  809262:	eb 2d                	jmp    809291 <tcp_slowtmr+0x424>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  809264:	a1 dc e5 b3 00       	mov    0xb3e5dc,%eax
  809269:	39 f0                	cmp    %esi,%eax
  80926b:	74 1c                	je     809289 <tcp_slowtmr+0x41c>
  80926d:	c7 44 24 08 54 37 81 	movl   $0x813754,0x8(%esp)
  809274:	00 
  809275:	c7 44 24 04 f8 02 00 	movl   $0x2f8,0x4(%esp)
  80927c:	00 
  80927d:	c7 04 24 53 35 81 00 	movl   $0x813553,(%esp)
  809284:	e8 23 76 ff ff       	call   8008ac <_panic>
        tcp_tw_pcbs = pcb->next;
  809289:	8b 40 0c             	mov    0xc(%eax),%eax
  80928c:	a3 dc e5 b3 00       	mov    %eax,0xb3e5dc
      }
      pcb2 = pcb->next;
  809291:	8b 5e 0c             	mov    0xc(%esi),%ebx
      memp_free(MEMP_TCP_PCB, pcb);
  809294:	89 74 24 04          	mov    %esi,0x4(%esp)
  809298:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80929f:	e8 63 e0 ff ff       	call   807307 <memp_free>
  8092a4:	89 de                	mov    %ebx,%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  8092a6:	85 f6                	test   %esi,%esi
  8092a8:	0f 85 4d ff ff ff    	jne    8091fb <tcp_slowtmr+0x38e>
  8092ae:	eb 22                	jmp    8092d2 <tcp_slowtmr+0x465>
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  8092b0:	8b 56 10             	mov    0x10(%esi),%edx
  8092b3:	bb 01 00 00 00       	mov    $0x1,%ebx
  8092b8:	e9 73 fd ff ff       	jmp    809030 <tcp_slowtmr+0x1c3>
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      tcp_pcb_purge(pcb);      
  8092bd:	89 34 24             	mov    %esi,(%esp)
  8092c0:	e8 bd f3 ff ff       	call   808682 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  8092c5:	85 ff                	test   %edi,%edi
  8092c7:	0f 85 6b ff ff ff    	jne    809238 <tcp_slowtmr+0x3cb>
  8092cd:	8d 76 00             	lea    0x0(%esi),%esi
  8092d0:	eb 92                	jmp    809264 <tcp_slowtmr+0x3f7>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  8092d2:	83 c4 1c             	add    $0x1c,%esp
  8092d5:	5b                   	pop    %ebx
  8092d6:	5e                   	pop    %esi
  8092d7:	5f                   	pop    %edi
  8092d8:	5d                   	pop    %ebp
  8092d9:	c3                   	ret    

008092da <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  8092da:	55                   	push   %ebp
  8092db:	89 e5                	mov    %esp,%ebp
  8092dd:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  8092e0:	e8 53 f2 ff ff       	call   808538 <tcp_fasttmr>

  if (++tcp_timer & 1) {
  8092e5:	0f b6 05 68 77 b3 00 	movzbl 0xb37768,%eax
  8092ec:	83 c0 01             	add    $0x1,%eax
  8092ef:	a2 68 77 b3 00       	mov    %al,0xb37768
  8092f4:	a8 01                	test   $0x1,%al
  8092f6:	74 05                	je     8092fd <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  8092f8:	e8 70 fb ff ff       	call   808e6d <tcp_slowtmr>
  }
}
  8092fd:	c9                   	leave  
  8092fe:	c3                   	ret    

008092ff <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  8092ff:	55                   	push   %ebp
  809300:	89 e5                	mov    %esp,%ebp
  809302:	53                   	push   %ebx
  809303:	83 ec 14             	sub    $0x14,%esp
  809306:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  809309:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  80930d:	77 0a                	ja     809319 <tcp_close+0x1a>
  80930f:	8b 43 10             	mov    0x10(%ebx),%eax
  809312:	ff 24 85 7c 37 81 00 	jmp    *0x81377c(,%eax,4)
  809319:	bb 00 00 00 00       	mov    $0x0,%ebx
  80931e:	e9 05 01 00 00       	jmp    809428 <tcp_close+0x129>
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  809323:	8b 15 d8 e5 b3 00    	mov    0xb3e5d8,%edx
  809329:	39 da                	cmp    %ebx,%edx
  80932b:	75 0a                	jne    809337 <tcp_close+0x38>
  80932d:	8b 43 0c             	mov    0xc(%ebx),%eax
  809330:	a3 d8 e5 b3 00       	mov    %eax,0xb3e5d8
  809335:	eb 2a                	jmp    809361 <tcp_close+0x62>
  809337:	89 15 d4 e5 b3 00    	mov    %edx,0xb3e5d4
  80933d:	85 d2                	test   %edx,%edx
  80933f:	74 20                	je     809361 <tcp_close+0x62>
  809341:	8b 42 0c             	mov    0xc(%edx),%eax
  809344:	85 c0                	test   %eax,%eax
  809346:	0f 84 f4 00 00 00    	je     809440 <tcp_close+0x141>
  80934c:	39 c3                	cmp    %eax,%ebx
  80934e:	75 08                	jne    809358 <tcp_close+0x59>
  809350:	8b 40 0c             	mov    0xc(%eax),%eax
  809353:	89 42 0c             	mov    %eax,0xc(%edx)
  809356:	eb 09                	jmp    809361 <tcp_close+0x62>
  809358:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  80935d:	89 c2                	mov    %eax,%edx
  80935f:	eb e0                	jmp    809341 <tcp_close+0x42>
  809361:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  809368:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80936c:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809373:	e8 8f df ff ff       	call   807307 <memp_free>
  809378:	b8 00 00 00 00       	mov    $0x0,%eax
  80937d:	e9 c8 00 00 00       	jmp    80944a <tcp_close+0x14b>
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  809382:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809386:	c7 04 24 d0 e5 b3 00 	movl   $0xb3e5d0,(%esp)
  80938d:	e8 69 f3 ff ff       	call   8086fb <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  809392:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809396:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80939d:	e8 65 df ff ff       	call   807307 <memp_free>
  8093a2:	b8 00 00 00 00       	mov    $0x0,%eax
  8093a7:	e9 9e 00 00 00       	jmp    80944a <tcp_close+0x14b>
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  8093ac:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8093b0:	c7 04 24 c8 e5 b3 00 	movl   $0xb3e5c8,(%esp)
  8093b7:	e8 3f f3 ff ff       	call   8086fb <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  8093bc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8093c0:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8093c7:	e8 3b df ff ff       	call   807307 <memp_free>
  8093cc:	b8 00 00 00 00       	mov    $0x0,%eax
  8093d1:	eb 77                	jmp    80944a <tcp_close+0x14b>
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8093d3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8093da:	00 
  8093db:	89 1c 24             	mov    %ebx,(%esp)
  8093de:	e8 1c 28 00 00       	call   80bbff <tcp_send_ctrl>
    if (err == ERR_OK) {
  8093e3:	84 c0                	test   %al,%al
  8093e5:	75 63                	jne    80944a <tcp_close+0x14b>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  8093e7:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  8093ee:	eb 38                	jmp    809428 <tcp_close+0x129>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8093f0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8093f7:	00 
  8093f8:	89 1c 24             	mov    %ebx,(%esp)
  8093fb:	e8 ff 27 00 00       	call   80bbff <tcp_send_ctrl>
    if (err == ERR_OK) {
  809400:	84 c0                	test   %al,%al
  809402:	75 46                	jne    80944a <tcp_close+0x14b>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  809404:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  80940b:	eb 1b                	jmp    809428 <tcp_close+0x129>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80940d:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  809414:	00 
  809415:	89 1c 24             	mov    %ebx,(%esp)
  809418:	e8 e2 27 00 00       	call   80bbff <tcp_send_ctrl>
    if (err == ERR_OK) {
  80941d:	84 c0                	test   %al,%al
  80941f:	75 29                	jne    80944a <tcp_close+0x14b>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  809421:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  809428:	b8 00 00 00 00       	mov    $0x0,%eax
  80942d:	85 db                	test   %ebx,%ebx
  80942f:	74 19                	je     80944a <tcp_close+0x14b>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  809431:	89 1c 24             	mov    %ebx,(%esp)
  809434:	e8 00 1b 00 00       	call   80af39 <tcp_output>
  809439:	b8 00 00 00 00       	mov    $0x0,%eax
  80943e:	eb 0a                	jmp    80944a <tcp_close+0x14b>
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  809440:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  809445:	e9 17 ff ff ff       	jmp    809361 <tcp_close+0x62>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  80944a:	0f be c0             	movsbl %al,%eax
  }
  return err;
}
  80944d:	83 c4 14             	add    $0x14,%esp
  809450:	5b                   	pop    %ebx
  809451:	5d                   	pop    %ebp
  809452:	c3                   	ret    

00809453 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  809453:	55                   	push   %ebp
  809454:	89 e5                	mov    %esp,%ebp
  809456:	83 ec 08             	sub    $0x8,%esp
  809459:	8b 45 10             	mov    0x10(%ebp),%eax
  80945c:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  809460:	85 c0                	test   %eax,%eax
  809462:	74 0f                	je     809473 <tcp_recv_null+0x20>
    pbuf_free(p);
  809464:	89 04 24             	mov    %eax,(%esp)
  809467:	e8 07 e6 ff ff       	call   807a73 <pbuf_free>
  80946c:	b8 00 00 00 00       	mov    $0x0,%eax
  809471:	eb 17                	jmp    80948a <tcp_recv_null+0x37>
  } else if (err == ERR_OK) {
  809473:	b8 00 00 00 00       	mov    $0x0,%eax
  809478:	84 d2                	test   %dl,%dl
  80947a:	75 0e                	jne    80948a <tcp_recv_null+0x37>
    return tcp_close(pcb);
  80947c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80947f:	89 04 24             	mov    %eax,(%esp)
  809482:	e8 78 fe ff ff       	call   8092ff <tcp_close>
  809487:	0f be c0             	movsbl %al,%eax
  }
  return ERR_OK;
}
  80948a:	c9                   	leave  
  80948b:	c3                   	ret    

0080948c <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  80948c:	55                   	push   %ebp
  80948d:	89 e5                	mov    %esp,%ebp
  80948f:	53                   	push   %ebx
  809490:	8b 55 0c             	mov    0xc(%ebp),%edx
  u32_t addr2test;

  addr2test = addr->addr;
  809493:	8b 45 08             	mov    0x8(%ebp),%eax
  809496:	8b 18                	mov    (%eax),%ebx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  809498:	8d 43 ff             	lea    -0x1(%ebx),%eax
  80949b:	b9 01 00 00 00       	mov    $0x1,%ecx
  8094a0:	83 f8 fd             	cmp    $0xfffffffd,%eax
  8094a3:	77 31                	ja     8094d6 <ip_addr_isbroadcast+0x4a>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  8094a5:	f6 42 2e 02          	testb  $0x2,0x2e(%edx)
  8094a9:	74 26                	je     8094d1 <ip_addr_isbroadcast+0x45>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  8094ab:	8b 42 04             	mov    0x4(%edx),%eax
  8094ae:	39 d8                	cmp    %ebx,%eax
  8094b0:	74 1f                	je     8094d1 <ip_addr_isbroadcast+0x45>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  8094b2:	8b 4a 08             	mov    0x8(%edx),%ecx
  8094b5:	89 ca                	mov    %ecx,%edx
  8094b7:	21 da                	and    %ebx,%edx
  8094b9:	21 c8                	and    %ecx,%eax
  8094bb:	39 c2                	cmp    %eax,%edx
  8094bd:	75 12                	jne    8094d1 <ip_addr_isbroadcast+0x45>
  8094bf:	89 c8                	mov    %ecx,%eax
  8094c1:	f7 d0                	not    %eax
  8094c3:	89 c2                	mov    %eax,%edx
  8094c5:	21 da                	and    %ebx,%edx
  8094c7:	39 d0                	cmp    %edx,%eax
  8094c9:	0f 94 c0             	sete   %al
  8094cc:	0f b6 c8             	movzbl %al,%ecx
  8094cf:	eb 05                	jmp    8094d6 <ip_addr_isbroadcast+0x4a>
  8094d1:	b9 00 00 00 00       	mov    $0x0,%ecx
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  8094d6:	89 c8                	mov    %ecx,%eax
  8094d8:	5b                   	pop    %ebx
  8094d9:	5d                   	pop    %ebp
  8094da:	c3                   	ret    
  8094db:	00 00                	add    %al,(%eax)
  8094dd:	00 00                	add    %al,(%eax)
	...

008094e0 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  8094e0:	55                   	push   %ebp
  8094e1:	89 e5                	mov    %esp,%ebp
  8094e3:	83 ec 28             	sub    $0x28,%esp
  8094e6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8094e9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8094ec:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8094ef:	8b 75 08             	mov    0x8(%ebp),%esi
  8094f2:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8094f5:	0f b6 7d 14          	movzbl 0x14(%ebp),%edi
  8094f9:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  8094fd:	88 45 ef             	mov    %al,-0x11(%ebp)
  809500:	0f b6 55 1c          	movzbl 0x1c(%ebp),%edx
  809504:	88 55 ee             	mov    %dl,-0x12(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  809507:	85 db                	test   %ebx,%ebx
  809509:	0f 84 38 01 00 00    	je     809647 <ip_output_if+0x167>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  80950f:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  809516:	00 
  809517:	89 34 24             	mov    %esi,(%esp)
  80951a:	e8 e9 e1 ff ff       	call   807708 <pbuf_header>
  80951f:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  809524:	84 c0                	test   %al,%al
  809526:	0f 85 5c 01 00 00    	jne    809688 <ip_output_if+0x1a8>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  80952c:	8b 46 04             	mov    0x4(%esi),%eax
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  80952f:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  809534:	77 1c                	ja     809552 <ip_output_if+0x72>
  809536:	c7 44 24 08 b8 37 81 	movl   $0x8137b8,0x8(%esp)
  80953d:	00 
  80953e:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
  809545:	00 
  809546:	c7 04 24 e5 37 81 00 	movl   $0x8137e5,(%esp)
  80954d:	e8 5a 73 ff ff       	call   8008ac <_panic>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  809552:	89 45 f0             	mov    %eax,-0x10(%ebp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  809555:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  809559:	89 04 24             	mov    %eax,(%esp)
  80955c:	e8 44 13 00 00       	call   80a8a5 <ntohs>
  809561:	66 25 ff 00          	and    $0xff,%ax
  809565:	89 fa                	mov    %edi,%edx
  809567:	c1 e2 08             	shl    $0x8,%edx
  80956a:	09 c2                	or     %eax,%edx
  80956c:	0f b7 d2             	movzwl %dx,%edx
  80956f:	89 14 24             	mov    %edx,(%esp)
  809572:	e8 18 13 00 00       	call   80a88f <htons>
  809577:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80957a:	66 89 42 08          	mov    %ax,0x8(%edx)
    IPH_PROTO_SET(iphdr, proto);
  80957e:	0f b7 c0             	movzwl %ax,%eax
  809581:	89 04 24             	mov    %eax,(%esp)
  809584:	e8 1c 13 00 00       	call   80a8a5 <ntohs>
  809589:	25 00 ff 00 00       	and    $0xff00,%eax
  80958e:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
  809592:	09 c2                	or     %eax,%edx
  809594:	0f b7 d2             	movzwl %dx,%edx
  809597:	89 14 24             	mov    %edx,(%esp)
  80959a:	e8 f0 12 00 00       	call   80a88f <htons>
  80959f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8095a2:	66 89 42 08          	mov    %ax,0x8(%edx)

    ip_addr_set(&(iphdr->dest), dest);
  8095a6:	8b 03                	mov    (%ebx),%eax
  8095a8:	89 42 10             	mov    %eax,0x10(%edx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  8095ab:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
  8095af:	80 cc 45             	or     $0x45,%ah
  8095b2:	89 04 24             	mov    %eax,(%esp)
  8095b5:	e8 d5 12 00 00       	call   80a88f <htons>
  8095ba:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8095bd:	66 89 02             	mov    %ax,(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  8095c0:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8095c4:	89 04 24             	mov    %eax,(%esp)
  8095c7:	e8 c3 12 00 00       	call   80a88f <htons>
  8095cc:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8095cf:	66 89 42 02          	mov    %ax,0x2(%edx)
    IPH_OFFSET_SET(iphdr, 0);
  8095d3:	66 c7 42 06 00 00    	movw   $0x0,0x6(%edx)
    IPH_ID_SET(iphdr, htons(ip_id));
  8095d9:	0f b7 05 6c 77 b3 00 	movzwl 0xb3776c,%eax
  8095e0:	89 04 24             	mov    %eax,(%esp)
  8095e3:	e8 a7 12 00 00       	call   80a88f <htons>
  8095e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8095eb:	66 89 42 04          	mov    %ax,0x4(%edx)
    ++ip_id;
  8095ef:	66 83 05 6c 77 b3 00 	addw   $0x1,0xb3776c
  8095f6:	01 

    if (ip_addr_isany(src)) {
  8095f7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8095fb:	74 09                	je     809606 <ip_output_if+0x126>
  8095fd:	8b 55 0c             	mov    0xc(%ebp),%edx
  809600:	8b 02                	mov    (%edx),%eax
  809602:	85 c0                	test   %eax,%eax
  809604:	75 19                	jne    80961f <ip_output_if+0x13f>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  809606:	b8 00 00 00 00       	mov    $0x0,%eax
  80960b:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  80960f:	74 06                	je     809617 <ip_output_if+0x137>
  809611:	8b 55 20             	mov    0x20(%ebp),%edx
  809614:	8b 42 04             	mov    0x4(%edx),%eax
  809617:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80961a:	89 42 0c             	mov    %eax,0xc(%edx)
  80961d:	eb 06                	jmp    809625 <ip_output_if+0x145>
    } else {
      ip_addr_set(&(iphdr->src), src);
  80961f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  809622:	89 42 0c             	mov    %eax,0xc(%edx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  809625:	8b 45 f0             	mov    -0x10(%ebp),%eax
  809628:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80962e:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  809635:	00 
  809636:	89 04 24             	mov    %eax,(%esp)
  809639:	e8 39 0f 00 00       	call   80a577 <inet_chksum>
  80963e:	8b 55 f0             	mov    -0x10(%ebp),%edx
  809641:	66 89 42 0a          	mov    %ax,0xa(%edx)
  809645:	eb 06                	jmp    80964d <ip_output_if+0x16d>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  809647:	8b 5e 04             	mov    0x4(%esi),%ebx
  80964a:	83 c3 10             	add    $0x10,%ebx
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  80964d:	8b 55 20             	mov    0x20(%ebp),%edx
  809650:	0f b7 42 2c          	movzwl 0x2c(%edx),%eax
  809654:	66 85 c0             	test   %ax,%ax
  809657:	74 1b                	je     809674 <ip_output_if+0x194>
  809659:	66 3b 46 08          	cmp    0x8(%esi),%ax
  80965d:	73 15                	jae    809674 <ip_output_if+0x194>
    return ip_frag(p,netif,dest);
  80965f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  809663:	89 54 24 04          	mov    %edx,0x4(%esp)
  809667:	89 34 24             	mov    %esi,(%esp)
  80966a:	e8 b1 03 00 00       	call   809a20 <ip_frag>
  80966f:	0f be d0             	movsbl %al,%edx
  809672:	eb 14                	jmp    809688 <ip_output_if+0x1a8>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  809674:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  809678:	89 74 24 04          	mov    %esi,0x4(%esp)
  80967c:	8b 45 20             	mov    0x20(%ebp),%eax
  80967f:	89 04 24             	mov    %eax,(%esp)
  809682:	ff 50 14             	call   *0x14(%eax)
  809685:	0f be d0             	movsbl %al,%edx
  }
}
  809688:	89 d0                	mov    %edx,%eax
  80968a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80968d:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809690:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809693:	89 ec                	mov    %ebp,%esp
  809695:	5d                   	pop    %ebp
  809696:	c3                   	ret    

00809697 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  809697:	55                   	push   %ebp
  809698:	89 e5                	mov    %esp,%ebp
  80969a:	56                   	push   %esi
  80969b:	53                   	push   %ebx
  80969c:	83 ec 10             	sub    $0x10,%esp
  80969f:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8096a2:	8b 1d c0 e5 b3 00    	mov    0xb3e5c0,%ebx
  8096a8:	85 db                	test   %ebx,%ebx
  8096aa:	74 20                	je     8096cc <ip_route+0x35>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  8096ac:	89 1c 24             	mov    %ebx,(%esp)
  8096af:	e8 ea dd ff ff       	call   80749e <netif_is_up>
  8096b4:	84 c0                	test   %al,%al
  8096b6:	74 0e                	je     8096c6 <ip_route+0x2f>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  8096b8:	8b 43 08             	mov    0x8(%ebx),%eax
  8096bb:	89 c2                	mov    %eax,%edx
  8096bd:	23 16                	and    (%esi),%edx
  8096bf:	23 43 04             	and    0x4(%ebx),%eax
  8096c2:	39 c2                	cmp    %eax,%edx
  8096c4:	74 28                	je     8096ee <ip_route+0x57>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8096c6:	8b 1b                	mov    (%ebx),%ebx
  8096c8:	85 db                	test   %ebx,%ebx
  8096ca:	75 e0                	jne    8096ac <ip_route+0x15>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  8096cc:	a1 c4 e5 b3 00       	mov    0xb3e5c4,%eax
  8096d1:	85 c0                	test   %eax,%eax
  8096d3:	74 14                	je     8096e9 <ip_route+0x52>
  8096d5:	89 04 24             	mov    %eax,(%esp)
  8096d8:	e8 c1 dd ff ff       	call   80749e <netif_is_up>
  8096dd:	84 c0                	test   %al,%al
  8096df:	74 08                	je     8096e9 <ip_route+0x52>
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  8096e1:	8b 1d c4 e5 b3 00    	mov    0xb3e5c4,%ebx
  8096e7:	eb 05                	jmp    8096ee <ip_route+0x57>
  8096e9:	bb 00 00 00 00       	mov    $0x0,%ebx
}
  8096ee:	89 d8                	mov    %ebx,%eax
  8096f0:	83 c4 10             	add    $0x10,%esp
  8096f3:	5b                   	pop    %ebx
  8096f4:	5e                   	pop    %esi
  8096f5:	5d                   	pop    %ebp
  8096f6:	c3                   	ret    

008096f7 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  8096f7:	55                   	push   %ebp
  8096f8:	89 e5                	mov    %esp,%ebp
  8096fa:	83 ec 28             	sub    $0x28,%esp
  8096fd:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809700:	89 75 f8             	mov    %esi,-0x8(%ebp)
  809703:	89 7d fc             	mov    %edi,-0x4(%ebp)
  809706:	0f b6 7d 14          	movzbl 0x14(%ebp),%edi
  80970a:	0f b6 75 18          	movzbl 0x18(%ebp),%esi
  80970e:	0f b6 5d 1c          	movzbl 0x1c(%ebp),%ebx
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  809712:	8b 45 10             	mov    0x10(%ebp),%eax
  809715:	89 04 24             	mov    %eax,(%esp)
  809718:	e8 7a ff ff ff       	call   809697 <ip_route>
  80971d:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
  809722:	85 c0                	test   %eax,%eax
  809724:	74 39                	je     80975f <ip_output+0x68>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  809726:	89 44 24 18          	mov    %eax,0x18(%esp)
  80972a:	0f b6 c3             	movzbl %bl,%eax
  80972d:	89 44 24 14          	mov    %eax,0x14(%esp)
  809731:	89 f2                	mov    %esi,%edx
  809733:	0f b6 c2             	movzbl %dl,%eax
  809736:	89 44 24 10          	mov    %eax,0x10(%esp)
  80973a:	89 fa                	mov    %edi,%edx
  80973c:	0f b6 c2             	movzbl %dl,%eax
  80973f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809743:	8b 45 10             	mov    0x10(%ebp),%eax
  809746:	89 44 24 08          	mov    %eax,0x8(%esp)
  80974a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80974d:	89 54 24 04          	mov    %edx,0x4(%esp)
  809751:	8b 45 08             	mov    0x8(%ebp),%eax
  809754:	89 04 24             	mov    %eax,(%esp)
  809757:	e8 84 fd ff ff       	call   8094e0 <ip_output_if>
  80975c:	0f be d0             	movsbl %al,%edx
}
  80975f:	89 d0                	mov    %edx,%eax
  809761:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809764:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809767:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80976a:	89 ec                	mov    %ebp,%esp
  80976c:	5d                   	pop    %ebp
  80976d:	c3                   	ret    

0080976e <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  80976e:	55                   	push   %ebp
  80976f:	89 e5                	mov    %esp,%ebp
  809771:	83 ec 38             	sub    $0x38,%esp
  809774:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809777:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80977a:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80977d:	8b 75 08             	mov    0x8(%ebp),%esi

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  809780:	8b 7e 04             	mov    0x4(%esi),%edi
  if (IPH_V(iphdr) != 4) {
  809783:	0f b7 07             	movzwl (%edi),%eax
  809786:	89 04 24             	mov    %eax,(%esp)
  809789:	e8 17 11 00 00       	call   80a8a5 <ntohs>
  80978e:	66 c1 e8 0c          	shr    $0xc,%ax
  809792:	66 83 f8 04          	cmp    $0x4,%ax
  809796:	74 0d                	je     8097a5 <ip_input+0x37>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  809798:	89 34 24             	mov    %esi,(%esp)
  80979b:	e8 d3 e2 ff ff       	call   807a73 <pbuf_free>
  8097a0:	e9 68 02 00 00       	jmp    809a0d <ip_input+0x29f>
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  8097a5:	0f b7 07             	movzwl (%edi),%eax
  8097a8:	89 04 24             	mov    %eax,(%esp)
  8097ab:	e8 f5 10 00 00       	call   80a8a5 <ntohs>
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  8097b0:	66 c1 e8 06          	shr    $0x6,%ax
  8097b4:	83 e0 3c             	and    $0x3c,%eax
  8097b7:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  8097bb:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  8097bf:	89 04 24             	mov    %eax,(%esp)
  8097c2:	e8 de 10 00 00       	call   80a8a5 <ntohs>
  8097c7:	89 c3                	mov    %eax,%ebx

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  8097c9:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
  8097cd:	66 3b 46 0a          	cmp    0xa(%esi),%ax
  8097d1:	77 06                	ja     8097d9 <ip_input+0x6b>
  8097d3:	66 3b 5e 08          	cmp    0x8(%esi),%bx
  8097d7:	76 0d                	jbe    8097e6 <ip_input+0x78>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  8097d9:	89 34 24             	mov    %esi,(%esp)
  8097dc:	e8 92 e2 ff ff       	call   807a73 <pbuf_free>
  8097e1:	e9 27 02 00 00       	jmp    809a0d <ip_input+0x29f>
    return ERR_OK;
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  8097e6:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
  8097ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  8097ee:	89 3c 24             	mov    %edi,(%esp)
  8097f1:	e8 81 0d 00 00       	call   80a577 <inet_chksum>
  8097f6:	66 85 c0             	test   %ax,%ax
  8097f9:	74 0d                	je     809808 <ip_input+0x9a>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  8097fb:	89 34 24             	mov    %esi,(%esp)
  8097fe:	e8 70 e2 ff ff       	call   807a73 <pbuf_free>
  809803:	e9 05 02 00 00       	jmp    809a0d <ip_input+0x29f>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  809808:	0f b7 c3             	movzwl %bx,%eax
  80980b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80980f:	89 34 24             	mov    %esi,(%esp)
  809812:	e8 eb e3 ff ff       	call   807c02 <pbuf_realloc>
  809817:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80981a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  809821:	8d 47 10             	lea    0x10(%edi),%eax
  809824:	89 45 dc             	mov    %eax,-0x24(%ebp)
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  809827:	89 1c 24             	mov    %ebx,(%esp)
  80982a:	e8 6f dc ff ff       	call   80749e <netif_is_up>
  80982f:	84 c0                	test   %al,%al
  809831:	74 27                	je     80985a <ip_input+0xec>
  809833:	83 fb fc             	cmp    $0xfffffffc,%ebx
  809836:	74 22                	je     80985a <ip_input+0xec>
  809838:	8b 43 04             	mov    0x4(%ebx),%eax
  80983b:	85 c0                	test   %eax,%eax
  80983d:	8d 76 00             	lea    0x0(%esi),%esi
  809840:	74 18                	je     80985a <ip_input+0xec>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  809842:	3b 47 10             	cmp    0x10(%edi),%eax
  809845:	74 47                	je     80988e <ip_input+0x120>
  809847:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80984b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80984e:	89 04 24             	mov    %eax,(%esp)
  809851:	e8 36 fc ff ff       	call   80948c <ip_addr_isbroadcast>
  809856:	84 c0                	test   %al,%al
  809858:	75 34                	jne    80988e <ip_input+0x120>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  80985a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  80985e:	74 0a                	je     80986a <ip_input+0xfc>
        first = 0;
        netif = netif_list;
  809860:	a1 c0 e5 b3 00       	mov    0xb3e5c0,%eax
  809865:	89 45 f0             	mov    %eax,-0x10(%ebp)
  809868:	eb 05                	jmp    80986f <ip_input+0x101>
      } else {
        netif = netif->next;
  80986a:	8b 1b                	mov    (%ebx),%ebx
  80986c:	89 5d f0             	mov    %ebx,-0x10(%ebp)
      }
      if (netif == inp) {
  80986f:	8b 45 0c             	mov    0xc(%ebp),%eax
  809872:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  809875:	75 05                	jne    80987c <ip_input+0x10e>
        netif = netif->next;
  809877:	8b 00                	mov    (%eax),%eax
  809879:	89 45 f0             	mov    %eax,-0x10(%ebp)
  80987c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      }
    } while(netif != NULL);
  809883:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  809887:	74 0c                	je     809895 <ip_input+0x127>
  809889:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  80988c:	eb 99                	jmp    809827 <ip_input+0xb9>
  80988e:	89 5d f0             	mov    %ebx,-0x10(%ebp)
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  809891:	85 db                	test   %ebx,%ebx
  809893:	75 27                	jne    8098bc <ip_input+0x14e>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  809895:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  809899:	89 04 24             	mov    %eax,(%esp)
  80989c:	e8 04 10 00 00       	call   80a8a5 <ntohs>
  8098a1:	3c 11                	cmp    $0x11,%al
  8098a3:	75 17                	jne    8098bc <ip_input+0x14e>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  8098a5:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
  8098a9:	0f b7 44 38 02       	movzwl 0x2(%eax,%edi,1),%eax
  8098ae:	89 04 24             	mov    %eax,(%esp)
  8098b1:	e8 ef 0f 00 00       	call   80a8a5 <ntohs>
  8098b6:	66 83 f8 44          	cmp    $0x44,%ax
  8098ba:	74 4a                	je     809906 <ip_input+0x198>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8098bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8098bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8098c3:	8d 47 0c             	lea    0xc(%edi),%eax
  8098c6:	89 04 24             	mov    %eax,(%esp)
  8098c9:	e8 be fb ff ff       	call   80948c <ip_addr_isbroadcast>
  8098ce:	84 c0                	test   %al,%al
  8098d0:	75 27                	jne    8098f9 <ip_input+0x18b>
  8098d2:	8b 5f 0c             	mov    0xc(%edi),%ebx
  8098d5:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  8098dc:	e8 0f 12 00 00       	call   80aaf0 <ntohl>
  8098e1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8098e4:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8098eb:	e8 00 12 00 00       	call   80aaf0 <ntohl>
  8098f0:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8098f3:	21 da                	and    %ebx,%edx
  8098f5:	39 c2                	cmp    %eax,%edx
  8098f7:	75 13                	jne    80990c <ip_input+0x19e>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  8098f9:	89 34 24             	mov    %esi,(%esp)
  8098fc:	e8 72 e1 ff ff       	call   807a73 <pbuf_free>
  809901:	e9 07 01 00 00       	jmp    809a0d <ip_input+0x29f>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  809906:	8b 45 0c             	mov    0xc(%ebp),%eax
  809909:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  80990c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  809910:	75 0d                	jne    80991f <ip_input+0x1b1>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  809912:	89 34 24             	mov    %esi,(%esp)
  809915:	e8 59 e1 ff ff       	call   807a73 <pbuf_free>
  80991a:	e9 ee 00 00 00       	jmp    809a0d <ip_input+0x29f>
    return ERR_OK;
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  80991f:	0f b7 5f 06          	movzwl 0x6(%edi),%ebx
  809923:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  80992a:	e8 60 0f 00 00       	call   80a88f <htons>
  80992f:	66 85 d8             	test   %bx,%ax
  809932:	74 15                	je     809949 <ip_input+0x1db>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  809934:	89 34 24             	mov    %esi,(%esp)
  809937:	e8 12 05 00 00       	call   809e4e <ip_reass>
  80993c:	89 c6                	mov    %eax,%esi
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  80993e:	85 c0                	test   %eax,%eax
  809940:	0f 84 c7 00 00 00    	je     809a0d <ip_input+0x29f>
      return ERR_OK;
    }
    iphdr = p->payload;
  809946:	8b 78 04             	mov    0x4(%eax),%edi
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  809949:	8b 45 0c             	mov    0xc(%ebp),%eax
  80994c:	89 44 24 04          	mov    %eax,0x4(%esp)
  809950:	89 34 24             	mov    %esi,(%esp)
  809953:	e8 4e 7e 00 00       	call   8117a6 <raw_input>
  809958:	84 c0                	test   %al,%al
  80995a:	0f 85 ad 00 00 00    	jne    809a0d <ip_input+0x29f>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  809960:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  809964:	89 04 24             	mov    %eax,(%esp)
  809967:	e8 39 0f 00 00       	call   80a8a5 <ntohs>
  80996c:	0f b6 c0             	movzbl %al,%eax
  80996f:	83 f8 06             	cmp    $0x6,%eax
  809972:	74 1f                	je     809993 <ip_input+0x225>
  809974:	83 f8 11             	cmp    $0x11,%eax
  809977:	74 09                	je     809982 <ip_input+0x214>
  809979:	83 f8 01             	cmp    $0x1,%eax
  80997c:	75 37                	jne    8099b5 <ip_input+0x247>
  80997e:	66 90                	xchg   %ax,%ax
  809980:	eb 22                	jmp    8099a4 <ip_input+0x236>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  809982:	8b 45 0c             	mov    0xc(%ebp),%eax
  809985:	89 44 24 04          	mov    %eax,0x4(%esp)
  809989:	89 34 24             	mov    %esi,(%esp)
  80998c:	e8 05 27 00 00       	call   80c096 <udp_input>
  809991:	eb 7a                	jmp    809a0d <ip_input+0x29f>
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  809993:	8b 45 0c             	mov    0xc(%ebp),%eax
  809996:	89 44 24 04          	mov    %eax,0x4(%esp)
  80999a:	89 34 24             	mov    %esi,(%esp)
  80999d:	e8 ce 6d 00 00       	call   810770 <tcp_input>
  8099a2:	eb 69                	jmp    809a0d <ip_input+0x29f>
      break;
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  8099a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8099a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8099ab:	89 34 24             	mov    %esi,(%esp)
  8099ae:	e8 cb 80 00 00       	call   811a7e <icmp_input>
  8099b3:	eb 58                	jmp    809a0d <ip_input+0x29f>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8099b5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8099b8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8099bc:	8d 47 10             	lea    0x10(%edi),%eax
  8099bf:	89 04 24             	mov    %eax,(%esp)
  8099c2:	e8 c5 fa ff ff       	call   80948c <ip_addr_isbroadcast>
  8099c7:	84 c0                	test   %al,%al
  8099c9:	75 3a                	jne    809a05 <ip_input+0x297>
  8099cb:	8b 5f 10             	mov    0x10(%edi),%ebx
  8099ce:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  8099d5:	e8 16 11 00 00       	call   80aaf0 <ntohl>
  8099da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8099dd:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8099e4:	e8 07 11 00 00       	call   80aaf0 <ntohl>
  8099e9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8099ec:	21 da                	and    %ebx,%edx
  8099ee:	39 c2                	cmp    %eax,%edx
  8099f0:	74 13                	je     809a05 <ip_input+0x297>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  8099f2:	89 7e 04             	mov    %edi,0x4(%esi)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  8099f5:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  8099fc:	00 
  8099fd:	89 34 24             	mov    %esi,(%esp)
  809a00:	e8 6a 7f 00 00       	call   81196f <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  809a05:	89 34 24             	mov    %esi,(%esp)
  809a08:	e8 66 e0 ff ff       	call   807a73 <pbuf_free>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  809a0d:	b8 00 00 00 00       	mov    $0x0,%eax
  809a12:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809a15:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809a18:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809a1b:	89 ec                	mov    %ebp,%esp
  809a1d:	5d                   	pop    %ebp
  809a1e:	c3                   	ret    
	...

00809a20 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  809a20:	55                   	push   %ebp
  809a21:	89 e5                	mov    %esp,%ebp
  809a23:	57                   	push   %edi
  809a24:	56                   	push   %esi
  809a25:	53                   	push   %ebx
  809a26:	83 ec 4c             	sub    $0x4c,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  809a29:	8b 45 0c             	mov    0xc(%ebp),%eax
  809a2c:	0f b7 58 2c          	movzwl 0x2c(%eax),%ebx
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  809a30:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  809a37:	00 
  809a38:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809a3f:	00 
  809a40:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809a47:	e8 ea e2 ff ff       	call   807d36 <pbuf_alloc>
  809a4c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  if (rambuf == NULL) {
  809a4f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809a54:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  809a58:	0f 84 d1 01 00 00    	je     809c2f <ip_frag+0x20f>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  809a5e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  809a61:	66 89 5a 0a          	mov    %bx,0xa(%edx)
  809a65:	66 89 5a 08          	mov    %bx,0x8(%edx)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  809a69:	b8 a3 77 b3 00       	mov    $0xb377a3,%eax
  809a6e:	83 e0 fc             	and    $0xfffffffc,%eax
  809a71:	89 42 04             	mov    %eax,0x4(%edx)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  809a74:	89 c7                	mov    %eax,%edi
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  809a76:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  809a7d:	00 
  809a7e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809a81:	8b 41 04             	mov    0x4(%ecx),%eax
  809a84:	89 44 24 04          	mov    %eax,0x4(%esp)
  809a88:	89 3c 24             	mov    %edi,(%esp)
  809a8b:	e8 d8 77 ff ff       	call   801268 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  809a90:	0f b7 47 06          	movzwl 0x6(%edi),%eax
  809a94:	89 04 24             	mov    %eax,(%esp)
  809a97:	e8 09 0e 00 00       	call   80a8a5 <ntohs>
  809a9c:	89 c2                	mov    %eax,%edx
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
  809a9e:	66 25 00 20          	and    $0x2000,%ax
  809aa2:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;
  809aa6:	0f b7 c3             	movzwl %bx,%eax
  809aa9:	83 e8 14             	sub    $0x14,%eax
  809aac:	89 45 bc             	mov    %eax,-0x44(%ebp)
  809aaf:	c1 f8 1f             	sar    $0x1f,%eax
  809ab2:	c1 e8 1d             	shr    $0x1d,%eax
  809ab5:	03 45 bc             	add    -0x44(%ebp),%eax
  809ab8:	c1 e8 03             	shr    $0x3,%eax
  809abb:	66 89 45 c8          	mov    %ax,-0x38(%ebp)

  while (left) {
  809abf:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809ac2:	0f b7 41 08          	movzwl 0x8(%ecx),%eax
  809ac6:	66 83 e8 14          	sub    $0x14,%ax
  809aca:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  809ace:	0f 84 4b 01 00 00    	je     809c1f <ip_frag+0x1ff>
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  809ad4:	66 81 e2 ff 1f       	and    $0x1fff,%dx
  809ad9:	66 89 55 de          	mov    %dx,-0x22(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  809add:	0f b7 55 c8          	movzwl -0x38(%ebp),%edx
  809ae1:	c1 e2 03             	shl    $0x3,%edx
  809ae4:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
  809ae8:	66 c7 45 e4 14 00    	movw   $0x14,-0x1c(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  809aee:	8d 4f 14             	lea    0x14(%edi),%ecx
  809af1:	89 4d b8             	mov    %ecx,-0x48(%ebp)
  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    last = (left <= mtu - IP_HLEN);
  809af4:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  809af8:	39 45 bc             	cmp    %eax,-0x44(%ebp)
  809afb:	0f 9d c0             	setge  %al
  809afe:	0f b6 c0             	movzbl %al,%eax
  809b01:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  809b05:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  809b09:	66 25 ff 1f          	and    $0x1fff,%ax
  809b0d:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
  809b11:	09 c3                	or     %eax,%ebx
    if (!last)
  809b13:	0f b7 75 dc          	movzwl -0x24(%ebp),%esi
  809b17:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  809b1c:	75 07                	jne    809b25 <ip_frag+0x105>
      tmp = tmp | IP_MF;
  809b1e:	80 cf 20             	or     $0x20,%bh
  809b21:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  809b25:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  809b29:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809b2d:	0f b7 c6             	movzwl %si,%eax
  809b30:	89 44 24 08          	mov    %eax,0x8(%esp)
  809b34:	8b 45 b8             	mov    -0x48(%ebp),%eax
  809b37:	89 44 24 04          	mov    %eax,0x4(%esp)
  809b3b:	8b 55 08             	mov    0x8(%ebp),%edx
  809b3e:	89 14 24             	mov    %edx,(%esp)
  809b41:	e8 ad dc ff ff       	call   8077f3 <pbuf_copy_partial>
  809b46:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  809b4a:	0f b7 c3             	movzwl %bx,%eax
  809b4d:	89 04 24             	mov    %eax,(%esp)
  809b50:	e8 3a 0d 00 00       	call   80a88f <htons>
  809b55:	66 89 47 06          	mov    %ax,0x6(%edi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  809b59:	8d 46 14             	lea    0x14(%esi),%eax
  809b5c:	0f b7 c0             	movzwl %ax,%eax
  809b5f:	89 04 24             	mov    %eax,(%esp)
  809b62:	e8 28 0d 00 00       	call   80a88f <htons>
  809b67:	66 89 47 02          	mov    %ax,0x2(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  809b6b:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  809b71:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  809b78:	00 
  809b79:	89 3c 24             	mov    %edi,(%esp)
  809b7c:	e8 f6 09 00 00       	call   80a577 <inet_chksum>
  809b81:	66 89 47 0a          	mov    %ax,0xa(%edi)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  809b85:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  809b8a:	74 19                	je     809ba5 <ip_frag+0x185>
      pbuf_realloc(rambuf, left + IP_HLEN);
  809b8c:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  809b90:	83 c0 14             	add    $0x14,%eax
  809b93:	0f b7 c0             	movzwl %ax,%eax
  809b96:	89 44 24 04          	mov    %eax,0x4(%esp)
  809b9a:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  809b9d:	89 0c 24             	mov    %ecx,(%esp)
  809ba0:	e8 5d e0 ff ff       	call   807c02 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  809ba5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809bac:	00 
  809bad:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809bb4:	00 
  809bb5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809bbc:	e8 75 e1 ff ff       	call   807d36 <pbuf_alloc>
  809bc1:	89 c3                	mov    %eax,%ebx
    if (header != NULL) {
  809bc3:	85 c0                	test   %eax,%eax
  809bc5:	74 46                	je     809c0d <ip_frag+0x1ed>
      pbuf_chain(header, rambuf);
  809bc7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  809bca:	89 44 24 04          	mov    %eax,0x4(%esp)
  809bce:	89 1c 24             	mov    %ebx,(%esp)
  809bd1:	e8 0b db ff ff       	call   8076e1 <pbuf_chain>
      netif->output(netif, header, dest);
  809bd6:	8b 55 10             	mov    0x10(%ebp),%edx
  809bd9:	89 54 24 08          	mov    %edx,0x8(%esp)
  809bdd:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809be1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  809be4:	89 0c 24             	mov    %ecx,(%esp)
  809be7:	ff 51 14             	call   *0x14(%ecx)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  809bea:	89 1c 24             	mov    %ebx,(%esp)
  809bed:	e8 81 de ff ff       	call   807a73 <pbuf_free>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  809bf2:	66 29 75 dc          	sub    %si,-0x24(%ebp)
  809bf6:	74 27                	je     809c1f <ip_frag+0x1ff>

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  809bf8:	0f b7 45 c2          	movzwl -0x3e(%ebp),%eax
  809bfc:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  809c00:	0f b7 55 c8          	movzwl -0x38(%ebp),%edx
  809c04:	66 01 55 de          	add    %dx,-0x22(%ebp)
  809c08:	e9 e7 fe ff ff       	jmp    809af4 <ip_frag+0xd4>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  809c0d:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  809c10:	89 0c 24             	mov    %ecx,(%esp)
  809c13:	e8 5b de ff ff       	call   807a73 <pbuf_free>
  809c18:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809c1d:	eb 10                	jmp    809c2f <ip_frag+0x20f>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  809c1f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  809c22:	89 04 24             	mov    %eax,(%esp)
  809c25:	e8 49 de ff ff       	call   807a73 <pbuf_free>
  809c2a:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  809c2f:	83 c4 4c             	add    $0x4c,%esp
  809c32:	5b                   	pop    %ebx
  809c33:	5e                   	pop    %esi
  809c34:	5f                   	pop    %edi
  809c35:	5d                   	pop    %ebp
  809c36:	c3                   	ret    

00809c37 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  809c37:	55                   	push   %ebp
  809c38:	89 e5                	mov    %esp,%ebp
  809c3a:	83 ec 18             	sub    $0x18,%esp
  809c3d:	89 c1                	mov    %eax,%ecx
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  809c3f:	39 05 80 77 b3 00    	cmp    %eax,0xb37780
  809c45:	75 09                	jne    809c50 <ip_reass_dequeue_datagram+0x19>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  809c47:	8b 00                	mov    (%eax),%eax
  809c49:	a3 80 77 b3 00       	mov    %eax,0xb37780
  809c4e:	eb 24                	jmp    809c74 <ip_reass_dequeue_datagram+0x3d>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  809c50:	85 d2                	test   %edx,%edx
  809c52:	75 1c                	jne    809c70 <ip_reass_dequeue_datagram+0x39>
  809c54:	c7 44 24 08 fd 37 81 	movl   $0x8137fd,0x8(%esp)
  809c5b:	00 
  809c5c:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
  809c63:	00 
  809c64:	c7 04 24 16 38 81 00 	movl   $0x813816,(%esp)
  809c6b:	e8 3c 6c ff ff       	call   8008ac <_panic>
    prev->next = ipr->next;
  809c70:	8b 00                	mov    (%eax),%eax
  809c72:	89 02                	mov    %eax,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  809c74:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  809c78:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  809c7f:	e8 83 d6 ff ff       	call   807307 <memp_free>
}
  809c84:	c9                   	leave  
  809c85:	c3                   	ret    

00809c86 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  809c86:	55                   	push   %ebp
  809c87:	89 e5                	mov    %esp,%ebp
  809c89:	57                   	push   %edi
  809c8a:	56                   	push   %esi
  809c8b:	53                   	push   %ebx
  809c8c:	83 ec 1c             	sub    $0x1c,%esp
  809c8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  809c92:	89 55 ec             	mov    %edx,-0x14(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  809c95:	39 c2                	cmp    %eax,%edx
  809c97:	75 1c                	jne    809cb5 <ip_reass_free_complete_datagram+0x2f>
  809c99:	c7 44 24 08 33 38 81 	movl   $0x813833,0x8(%esp)
  809ca0:	00 
  809ca1:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  809ca8:	00 
  809ca9:	c7 04 24 16 38 81 00 	movl   $0x813816,(%esp)
  809cb0:	e8 f7 6b ff ff       	call   8008ac <_panic>
  if (prev != NULL) {
  809cb5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  809cb9:	74 26                	je     809ce1 <ip_reass_free_complete_datagram+0x5b>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  809cbb:	8b 55 f0             	mov    -0x10(%ebp),%edx
  809cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
  809cc1:	39 10                	cmp    %edx,(%eax)
  809cc3:	74 1c                	je     809ce1 <ip_reass_free_complete_datagram+0x5b>
  809cc5:	c7 44 24 08 3f 38 81 	movl   $0x81383f,0x8(%esp)
  809ccc:	00 
  809ccd:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  809cd4:	00 
  809cd5:	c7 04 24 16 38 81 00 	movl   $0x813816,(%esp)
  809cdc:	e8 cb 6b ff ff       	call   8008ac <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  809ce1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  809ce4:	8b 58 04             	mov    0x4(%eax),%ebx
  809ce7:	8b 43 04             	mov    0x4(%ebx),%eax
  if (iprh->start == 0) {
  809cea:	bf 00 00 00 00       	mov    $0x0,%edi
  809cef:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  809cf4:	75 47                	jne    809d3d <ip_reass_free_complete_datagram+0xb7>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  809cf6:	8b 00                	mov    (%eax),%eax
  809cf8:	8b 55 f0             	mov    -0x10(%ebp),%edx
  809cfb:	89 42 04             	mov    %eax,0x4(%edx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  809cfe:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  809d05:	00 
  809d06:	89 d0                	mov    %edx,%eax
  809d08:	83 c0 08             	add    $0x8,%eax
  809d0b:	89 44 24 04          	mov    %eax,0x4(%esp)
  809d0f:	8b 43 04             	mov    0x4(%ebx),%eax
  809d12:	89 04 24             	mov    %eax,(%esp)
  809d15:	e8 4e 75 ff ff       	call   801268 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  809d1a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  809d21:	00 
  809d22:	89 1c 24             	mov    %ebx,(%esp)
  809d25:	e8 36 7b 00 00       	call   811860 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  809d2a:	89 1c 24             	mov    %ebx,(%esp)
  809d2d:	e8 fe d8 ff ff       	call   807630 <pbuf_clen>
  809d32:	0f b6 f8             	movzbl %al,%edi
    pbuf_free(p);
  809d35:	89 1c 24             	mov    %ebx,(%esp)
  809d38:	e8 36 dd ff ff       	call   807a73 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  809d3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  809d40:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  809d43:	85 db                	test   %ebx,%ebx
  809d45:	74 22                	je     809d69 <ip_reass_free_complete_datagram+0xe3>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  809d47:	8b 43 04             	mov    0x4(%ebx),%eax
  809d4a:	8b 30                	mov    (%eax),%esi
    pbufs_freed += pbuf_clen(pcur);
  809d4c:	89 1c 24             	mov    %ebx,(%esp)
  809d4f:	e8 dc d8 ff ff       	call   807630 <pbuf_clen>
  809d54:	0f b6 c0             	movzbl %al,%eax
  809d57:	01 c7                	add    %eax,%edi
    pbuf_free(pcur);    
  809d59:	89 1c 24             	mov    %ebx,(%esp)
  809d5c:	e8 12 dd ff ff       	call   807a73 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  809d61:	85 f6                	test   %esi,%esi
  809d63:	74 04                	je     809d69 <ip_reass_free_complete_datagram+0xe3>
  809d65:	89 f3                	mov    %esi,%ebx
  809d67:	eb de                	jmp    809d47 <ip_reass_free_complete_datagram+0xc1>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  809d69:	8b 55 ec             	mov    -0x14(%ebp),%edx
  809d6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  809d6f:	e8 c3 fe ff ff       	call   809c37 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  809d74:	0f b7 15 84 77 b3 00 	movzwl 0xb37784,%edx
  809d7b:	0f b7 c2             	movzwl %dx,%eax
  809d7e:	39 f8                	cmp    %edi,%eax
  809d80:	7d 1c                	jge    809d9e <ip_reass_free_complete_datagram+0x118>
  809d82:	c7 44 24 08 51 38 81 	movl   $0x813851,0x8(%esp)
  809d89:	00 
  809d8a:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  809d91:	00 
  809d92:	c7 04 24 16 38 81 00 	movl   $0x813816,(%esp)
  809d99:	e8 0e 6b ff ff       	call   8008ac <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  809d9e:	89 d0                	mov    %edx,%eax
  809da0:	66 29 f8             	sub    %di,%ax
  809da3:	66 a3 84 77 b3 00    	mov    %ax,0xb37784

  return pbufs_freed;
}
  809da9:	89 f8                	mov    %edi,%eax
  809dab:	83 c4 1c             	add    $0x1c,%esp
  809dae:	5b                   	pop    %ebx
  809daf:	5e                   	pop    %esi
  809db0:	5f                   	pop    %edi
  809db1:	5d                   	pop    %ebp
  809db2:	c3                   	ret    

00809db3 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  809db3:	55                   	push   %ebp
  809db4:	89 e5                	mov    %esp,%ebp
  809db6:	57                   	push   %edi
  809db7:	56                   	push   %esi
  809db8:	53                   	push   %ebx
  809db9:	83 ec 1c             	sub    $0x1c,%esp
  809dbc:	89 45 e8             	mov    %eax,-0x18(%ebp)
  809dbf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  809dc2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  809dc9:	8b 0d 80 77 b3 00    	mov    0xb37780,%ecx
    while (r != NULL) {
  809dcf:	85 c9                	test   %ecx,%ecx
  809dd1:	74 70                	je     809e43 <ip_reass_remove_oldest_datagram+0x90>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  809dd3:	8b 45 e8             	mov    -0x18(%ebp),%eax
  809dd6:	8b 78 0c             	mov    0xc(%eax),%edi
  809dd9:	bb 00 00 00 00       	mov    $0x0,%ebx
  809dde:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  809de5:	be 00 00 00 00       	mov    $0x0,%esi
  809dea:	39 79 14             	cmp    %edi,0x14(%ecx)
  809ded:	75 15                	jne    809e04 <ip_reass_remove_oldest_datagram+0x51>
  809def:	8b 41 18             	mov    0x18(%ecx),%eax
  809df2:	8b 55 e8             	mov    -0x18(%ebp),%edx
  809df5:	3b 42 10             	cmp    0x10(%edx),%eax
  809df8:	75 0a                	jne    809e04 <ip_reass_remove_oldest_datagram+0x51>
  809dfa:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  809dfe:	66 3b 42 04          	cmp    0x4(%edx),%ax
  809e02:	74 12                	je     809e16 <ip_reass_remove_oldest_datagram+0x63>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  809e04:	83 c6 01             	add    $0x1,%esi
        if (oldest == NULL) {
  809e07:	85 db                	test   %ebx,%ebx
  809e09:	74 09                	je     809e14 <ip_reass_remove_oldest_datagram+0x61>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
  809e0b:	0f b6 41 1f          	movzbl 0x1f(%ecx),%eax
  809e0f:	3a 43 1f             	cmp    0x1f(%ebx),%al
  809e12:	77 02                	ja     809e16 <ip_reass_remove_oldest_datagram+0x63>
  809e14:	89 cb                	mov    %ecx,%ebx
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  809e16:	8b 01                	mov    (%ecx),%eax
  809e18:	89 ca                	mov    %ecx,%edx
  809e1a:	85 c0                	test   %eax,%eax
  809e1c:	74 07                	je     809e25 <ip_reass_remove_oldest_datagram+0x72>
  809e1e:	89 c1                	mov    %eax,%ecx
  809e20:	89 55 ec             	mov    %edx,-0x14(%ebp)
  809e23:	eb c5                	jmp    809dea <ip_reass_remove_oldest_datagram+0x37>
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  809e25:	85 db                	test   %ebx,%ebx
  809e27:	74 0d                	je     809e36 <ip_reass_remove_oldest_datagram+0x83>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  809e29:	8b 55 ec             	mov    -0x14(%ebp),%edx
  809e2c:	89 d8                	mov    %ebx,%eax
  809e2e:	e8 53 fe ff ff       	call   809c86 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  809e33:	01 45 f0             	add    %eax,-0x10(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  809e36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809e39:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  809e3c:	7d 05                	jge    809e43 <ip_reass_remove_oldest_datagram+0x90>
  809e3e:	83 fe 01             	cmp    $0x1,%esi
  809e41:	7f 86                	jg     809dc9 <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
}
  809e43:	8b 45 f0             	mov    -0x10(%ebp),%eax
  809e46:	83 c4 1c             	add    $0x1c,%esp
  809e49:	5b                   	pop    %ebx
  809e4a:	5e                   	pop    %esi
  809e4b:	5f                   	pop    %edi
  809e4c:	5d                   	pop    %ebp
  809e4d:	c3                   	ret    

00809e4e <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  809e4e:	55                   	push   %ebp
  809e4f:	89 e5                	mov    %esp,%ebp
  809e51:	57                   	push   %edi
  809e52:	56                   	push   %esi
  809e53:	53                   	push   %ebx
  809e54:	83 ec 5c             	sub    $0x5c,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  809e57:	8b 45 08             	mov    0x8(%ebp),%eax
  809e5a:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  809e5d:	0f b7 03             	movzwl (%ebx),%eax
  809e60:	89 04 24             	mov    %eax,(%esp)
  809e63:	e8 3d 0a 00 00       	call   80a8a5 <ntohs>
  809e68:	c1 e8 06             	shr    $0x6,%eax
  809e6b:	83 e0 3c             	and    $0x3c,%eax
  809e6e:	83 f8 14             	cmp    $0x14,%eax
  809e71:	0f 85 9e 04 00 00    	jne    80a315 <ip_reass+0x4c7>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  809e77:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809e7b:	89 04 24             	mov    %eax,(%esp)
  809e7e:	e8 22 0a 00 00       	call   80a8a5 <ntohs>
  809e83:	66 89 45 b4          	mov    %ax,-0x4c(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  809e87:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  809e8b:	89 04 24             	mov    %eax,(%esp)
  809e8e:	e8 12 0a 00 00       	call   80a8a5 <ntohs>
  809e93:	66 89 45 b6          	mov    %ax,-0x4a(%ebp)
  809e97:	0f b7 03             	movzwl (%ebx),%eax
  809e9a:	89 04 24             	mov    %eax,(%esp)
  809e9d:	e8 03 0a 00 00       	call   80a8a5 <ntohs>
  809ea2:	66 89 45 b8          	mov    %ax,-0x48(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  809ea6:	8b 55 08             	mov    0x8(%ebp),%edx
  809ea9:	89 14 24             	mov    %edx,(%esp)
  809eac:	e8 7f d7 ff ff       	call   807630 <pbuf_clen>
  809eb1:	88 45 d3             	mov    %al,-0x2d(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  809eb4:	0f b6 f8             	movzbl %al,%edi
  809eb7:	0f b7 05 84 77 b3 00 	movzwl 0xb37784,%eax
  809ebe:	8d 04 07             	lea    (%edi,%eax,1),%eax
  809ec1:	83 f8 0a             	cmp    $0xa,%eax
  809ec4:	7e 24                	jle    809eea <ip_reass+0x9c>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  809ec6:	89 fa                	mov    %edi,%edx
  809ec8:	89 d8                	mov    %ebx,%eax
  809eca:	e8 e4 fe ff ff       	call   809db3 <ip_reass_remove_oldest_datagram>
  809ecf:	85 c0                	test   %eax,%eax
  809ed1:	0f 84 3e 04 00 00    	je     80a315 <ip_reass+0x4c7>
  809ed7:	0f b7 05 84 77 b3 00 	movzwl 0xb37784,%eax
  809ede:	8d 04 07             	lea    (%edi,%eax,1),%eax
  809ee1:	83 f8 0a             	cmp    $0xa,%eax
  809ee4:	0f 8f 2b 04 00 00    	jg     80a315 <ip_reass+0x4c7>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  809eea:	8b 35 80 77 b3 00    	mov    0xb37780,%esi
  809ef0:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  809ef7:	85 f6                	test   %esi,%esi
  809ef9:	74 35                	je     809f30 <ip_reass+0xe2>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  809efb:	8b 53 0c             	mov    0xc(%ebx),%edx
  809efe:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  809f05:	39 56 14             	cmp    %edx,0x14(%esi)
  809f08:	75 16                	jne    809f20 <ip_reass+0xd2>
  809f0a:	8b 46 18             	mov    0x18(%esi),%eax
  809f0d:	3b 43 10             	cmp    0x10(%ebx),%eax
  809f10:	75 0e                	jne    809f20 <ip_reass+0xd2>
  809f12:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  809f16:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  809f1a:	0f 84 8c 00 00 00    	je     809fac <ip_reass+0x15e>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  809f20:	8b 06                	mov    (%esi),%eax
  809f22:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  809f25:	85 c0                	test   %eax,%eax
  809f27:	74 04                	je     809f2d <ip_reass+0xdf>
  809f29:	89 c6                	mov    %eax,%esi
  809f2b:	eb d8                	jmp    809f05 <ip_reass+0xb7>
  809f2d:	89 75 d4             	mov    %esi,-0x2c(%ebp)
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  809f30:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  809f37:	e8 0e d4 ff ff       	call   80734a <memp_malloc>
  809f3c:	89 c6                	mov    %eax,%esi
  if (ipr == NULL) {
  809f3e:	85 c0                	test   %eax,%eax
  809f40:	75 28                	jne    809f6a <ip_reass+0x11c>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  809f42:	89 fa                	mov    %edi,%edx
  809f44:	89 d8                	mov    %ebx,%eax
  809f46:	e8 68 fe ff ff       	call   809db3 <ip_reass_remove_oldest_datagram>
  809f4b:	39 c7                	cmp    %eax,%edi
  809f4d:	7f 0e                	jg     809f5d <ip_reass+0x10f>
      ipr = memp_malloc(MEMP_REASSDATA);
  809f4f:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  809f56:	e8 ef d3 ff ff       	call   80734a <memp_malloc>
  809f5b:	89 c6                	mov    %eax,%esi
    }
    if (ipr == NULL)
  809f5d:	85 f6                	test   %esi,%esi
  809f5f:	0f 85 f0 03 00 00    	jne    80a355 <ip_reass+0x507>
  809f65:	e9 ab 03 00 00       	jmp    80a315 <ip_reass+0x4c7>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  809f6a:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  809f71:	00 
  809f72:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809f79:	00 
  809f7a:	89 04 24             	mov    %eax,(%esp)
  809f7d:	e8 0c 72 ff ff       	call   80118e <memset>
  ipr->timer = IP_REASS_MAXAGE;
  809f82:	c6 46 1f 03          	movb   $0x3,0x1f(%esi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  809f86:	a1 80 77 b3 00       	mov    0xb37780,%eax
  809f8b:	89 06                	mov    %eax,(%esi)
  reassdatagrams = ipr;
  809f8d:	89 35 80 77 b3 00    	mov    %esi,0xb37780
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  809f93:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  809f9a:	00 
  809f9b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809f9f:	8d 46 08             	lea    0x8(%esi),%eax
  809fa2:	89 04 24             	mov    %eax,(%esp)
  809fa5:	e8 be 72 ff ff       	call   801268 <memcpy>
  809faa:	eb 3b                	jmp    809fe7 <ip_reass+0x199>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  809fac:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809fb0:	89 04 24             	mov    %eax,(%esp)
  809fb3:	e8 ed 08 00 00       	call   80a8a5 <ntohs>
  809fb8:	66 a9 ff 1f          	test   $0x1fff,%ax
  809fbc:	75 29                	jne    809fe7 <ip_reass+0x199>
  809fbe:	0f b7 46 0e          	movzwl 0xe(%esi),%eax
  809fc2:	89 04 24             	mov    %eax,(%esp)
  809fc5:	e8 db 08 00 00       	call   80a8a5 <ntohs>
  809fca:	66 a9 ff 1f          	test   $0x1fff,%ax
  809fce:	74 17                	je     809fe7 <ip_reass+0x199>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  809fd0:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  809fd7:	00 
  809fd8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809fdc:	8d 46 08             	lea    0x8(%esi),%eax
  809fdf:	89 04 24             	mov    %eax,(%esp)
  809fe2:	e8 81 72 ff ff       	call   801268 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  809fe7:	0f b6 45 d3          	movzbl -0x2d(%ebp),%eax
  809feb:	66 01 05 84 77 b3 00 	add    %ax,0xb37784

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  809ff2:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809ff6:	89 04 24             	mov    %eax,(%esp)
  809ff9:	e8 a7 08 00 00       	call   80a8a5 <ntohs>
  809ffe:	f6 c4 20             	test   $0x20,%ah
  80a001:	75 20                	jne    80a023 <ip_reass+0x1d5>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  80a003:	80 4e 1e 01          	orb    $0x1,0x1e(%esi)
    ipr->datagram_len = offset + len;
  80a007:	0f b7 4d b4          	movzwl -0x4c(%ebp),%ecx
  80a00b:	0f b7 45 b6          	movzwl -0x4a(%ebp),%eax
  80a00f:	8d 14 c8             	lea    (%eax,%ecx,8),%edx
  80a012:	0f b7 45 b8          	movzwl -0x48(%ebp),%eax
  80a016:	c1 e8 06             	shr    $0x6,%eax
  80a019:	83 e0 3c             	and    $0x3c,%eax
  80a01c:	66 29 c2             	sub    %ax,%dx
  80a01f:	66 89 56 1c          	mov    %dx,0x1c(%esi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  80a023:	8b 55 08             	mov    0x8(%ebp),%edx
  80a026:	8b 5a 04             	mov    0x4(%edx),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80a029:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80a02d:	89 04 24             	mov    %eax,(%esp)
  80a030:	e8 70 08 00 00       	call   80a8a5 <ntohs>
  80a035:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  80a039:	0f b7 03             	movzwl (%ebx),%eax
  80a03c:	89 04 24             	mov    %eax,(%esp)
  80a03f:	e8 61 08 00 00       	call   80a8a5 <ntohs>
  80a044:	89 c7                	mov    %eax,%edi
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80a046:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80a04a:	89 04 24             	mov    %eax,(%esp)
  80a04d:	e8 53 08 00 00       	call   80a8a5 <ntohs>
  80a052:	25 ff 1f 00 00       	and    $0x1fff,%eax
  80a057:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  80a05e:	8b 45 08             	mov    0x8(%ebp),%eax
  80a061:	8b 40 04             	mov    0x4(%eax),%eax
  80a064:	89 45 dc             	mov    %eax,-0x24(%ebp)
  iprh->next_pbuf = NULL;
  80a067:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  iprh->start = offset;
  80a06d:	66 89 48 04          	mov    %cx,0x4(%eax)
  iprh->end = offset + len;
  80a071:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  80a075:	01 ca                	add    %ecx,%edx
  80a077:	89 f8                	mov    %edi,%eax
  80a079:	c1 e8 06             	shr    $0x6,%eax
  80a07c:	83 e0 3c             	and    $0x3c,%eax
  80a07f:	66 29 c2             	sub    %ax,%dx
  80a082:	89 d0                	mov    %edx,%eax
  80a084:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80a087:	66 89 42 06          	mov    %ax,0x6(%edx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  80a08b:	8b 56 04             	mov    0x4(%esi),%edx
  80a08e:	85 d2                	test   %edx,%edx
  80a090:	0f 84 7e 03 00 00    	je     80a414 <ip_reass+0x5c6>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80a096:	8b 7a 04             	mov    0x4(%edx),%edi
    if (iprh->start < iprh_tmp->start) {
  80a099:	89 cb                	mov    %ecx,%ebx
  80a09b:	0f b7 4f 04          	movzwl 0x4(%edi),%ecx
  80a09f:	66 39 cb             	cmp    %cx,%bx
  80a0a2:	0f 82 f2 02 00 00    	jb     80a39a <ip_reass+0x54c>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  80a0a8:	66 39 cb             	cmp    %cx,%bx
  80a0ab:	0f 84 d8 01 00 00    	je     80a289 <ip_reass+0x43b>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
  80a0b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80a0b6:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  80a0bd:	66 3b 5f 06          	cmp    0x6(%edi),%bx
  80a0c1:	73 62                	jae    80a125 <ip_reass+0x2d7>
  80a0c3:	e9 c1 01 00 00       	jmp    80a289 <ip_reass+0x43b>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80a0c8:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  80a0cb:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  80a0cf:	66 39 d9             	cmp    %bx,%cx
  80a0d2:	76 3a                	jbe    80a10e <ip_reass+0x2c0>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  80a0d4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80a0d7:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  80a0d9:	85 ff                	test   %edi,%edi
  80a0db:	74 26                	je     80a103 <ip_reass+0x2b5>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  80a0dd:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
  80a0e1:	66 3b 47 06          	cmp    0x6(%edi),%ax
  80a0e5:	0f 82 9e 01 00 00    	jb     80a289 <ip_reass+0x43b>
  80a0eb:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
  80a0ef:	66 3b 42 04          	cmp    0x4(%edx),%ax
  80a0f3:	0f 87 90 01 00 00    	ja     80a289 <ip_reass+0x43b>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  80a0f9:	8b 45 08             	mov    0x8(%ebp),%eax
  80a0fc:	89 07                	mov    %eax,(%edi)
  80a0fe:	e9 9a 00 00 00       	jmp    80a19d <ip_reass+0x34f>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  80a103:	8b 55 08             	mov    0x8(%ebp),%edx
  80a106:	89 56 04             	mov    %edx,0x4(%esi)
  80a109:	e9 8f 00 00 00       	jmp    80a19d <ip_reass+0x34f>
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  80a10e:	66 39 d9             	cmp    %bx,%cx
  80a111:	0f 84 72 01 00 00    	je     80a289 <ip_reass+0x43b>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  80a117:	66 39 5a 06          	cmp    %bx,0x6(%edx)
  80a11b:	0f 87 68 01 00 00    	ja     80a289 <ip_reass+0x43b>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
  80a121:	89 f8                	mov    %edi,%eax
  80a123:	89 d7                	mov    %edx,%edi
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  80a125:	85 c0                	test   %eax,%eax
  80a127:	74 10                	je     80a139 <ip_reass+0x2eb>
        if (iprh_prev->end != iprh_tmp->start) {
  80a129:	66 3b 48 06          	cmp    0x6(%eax),%cx
  80a12d:	0f 95 c0             	setne  %al
  80a130:	0f b6 c0             	movzbl %al,%eax
  80a133:	83 e8 01             	sub    $0x1,%eax
  80a136:	21 45 d8             	and    %eax,-0x28(%ebp)
           * and the previous fragment */
          valid = 0;
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  80a139:	8b 07                	mov    (%edi),%eax
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  80a13b:	85 c0                	test   %eax,%eax
  80a13d:	75 89                	jne    80a0c8 <ip_reass+0x27a>
  80a13f:	e9 f4 01 00 00       	jmp    80a338 <ip_reass+0x4ea>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  80a144:	66 39 5f 06          	cmp    %bx,0x6(%edi)
  80a148:	76 1c                	jbe    80a166 <ip_reass+0x318>
  80a14a:	c7 44 24 08 6c 38 81 	movl   $0x81386c,0x8(%esp)
  80a151:	00 
  80a152:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp)
  80a159:	00 
  80a15a:	c7 04 24 16 38 81 00 	movl   $0x813816,(%esp)
  80a161:	e8 46 67 ff ff       	call   8008ac <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  80a166:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a169:	89 0f                	mov    %ecx,(%edi)
      if (iprh_prev->end != iprh->start) {
  80a16b:	0f b7 47 06          	movzwl 0x6(%edi),%eax
  80a16f:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80a172:	66 3b 42 04          	cmp    0x4(%edx),%ax
  80a176:	75 1e                	jne    80a196 <ip_reass+0x348>
  80a178:	eb 23                	jmp    80a19d <ip_reass+0x34f>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  80a17a:	c7 44 24 08 98 38 81 	movl   $0x813898,0x8(%esp)
  80a181:	00 
  80a182:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  80a189:	00 
  80a18a:	c7 04 24 16 38 81 00 	movl   $0x813816,(%esp)
  80a191:	e8 16 67 ff ff       	call   8008ac <_panic>
  80a196:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  80a19d:	f6 46 1e 01          	testb  $0x1,0x1e(%esi)
  80a1a1:	0f 84 85 01 00 00    	je     80a32c <ip_reass+0x4de>
    /* and had no wholes so far */
    if (valid) {
  80a1a7:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80a1ab:	0f 84 7b 01 00 00    	je     80a32c <ip_reass+0x4de>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  80a1b1:	8b 5e 04             	mov    0x4(%esi),%ebx
  80a1b4:	8b 7b 04             	mov    0x4(%ebx),%edi
  80a1b7:	66 83 7f 04 00       	cmpw   $0x0,0x4(%edi)
  80a1bc:	0f 85 6a 01 00 00    	jne    80a32c <ip_reass+0x4de>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  80a1c2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80a1c5:	8b 01                	mov    (%ecx),%eax
        while (q != NULL) {
  80a1c7:	85 c0                	test   %eax,%eax
  80a1c9:	0f 84 76 01 00 00    	je     80a345 <ip_reass+0x4f7>
          iprh = (struct ip_reass_helper*)q->payload;
  80a1cf:	8b 48 04             	mov    0x4(%eax),%ecx
          if (iprh_prev->end != iprh->start) {
  80a1d2:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80a1d5:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a1d9:	66 3b 41 04          	cmp    0x4(%ecx),%ax
  80a1dd:	74 18                	je     80a1f7 <ip_reass+0x3a9>
  80a1df:	e9 48 01 00 00       	jmp    80a32c <ip_reass+0x4de>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80a1e4:	8b 50 04             	mov    0x4(%eax),%edx
          if (iprh_prev->end != iprh->start) {
  80a1e7:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
  80a1eb:	66 3b 42 04          	cmp    0x4(%edx),%ax
  80a1ef:	0f 85 37 01 00 00    	jne    80a32c <ip_reass+0x4de>
  80a1f5:	89 d1                	mov    %edx,%ecx
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  80a1f7:	8b 01                	mov    (%ecx),%eax
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  80a1f9:	85 c0                	test   %eax,%eax
  80a1fb:	75 e7                	jne    80a1e4 <ip_reass+0x396>
  80a1fd:	e9 46 01 00 00       	jmp    80a348 <ip_reass+0x4fa>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80a202:	c7 44 24 08 8a 38 81 	movl   $0x81388a,0x8(%esp)
  80a209:	00 
  80a20a:	c7 44 24 04 ac 01 00 	movl   $0x1ac,0x4(%esp)
  80a211:	00 
  80a212:	c7 04 24 16 38 81 00 	movl   $0x813816,(%esp)
  80a219:	e8 8e 66 ff ff       	call   8008ac <_panic>
          LWIP_ASSERT("sanity check",
  80a21e:	39 f9                	cmp    %edi,%ecx
  80a220:	75 1c                	jne    80a23e <ip_reass+0x3f0>
  80a222:	c7 44 24 08 8a 38 81 	movl   $0x81388a,0x8(%esp)
  80a229:	00 
  80a22a:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp)
  80a231:	00 
  80a232:	c7 04 24 16 38 81 00 	movl   $0x813816,(%esp)
  80a239:	e8 6e 66 ff ff       	call   8008ac <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80a23e:	83 39 00             	cmpl   $0x0,(%ecx)
  80a241:	74 1c                	je     80a25f <ip_reass+0x411>
  80a243:	c7 44 24 08 d0 38 81 	movl   $0x8138d0,0x8(%esp)
  80a24a:	00 
  80a24b:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
  80a252:	00 
  80a253:	c7 04 24 16 38 81 00 	movl   $0x813816,(%esp)
  80a25a:	e8 4d 66 ff ff       	call   8008ac <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  80a25f:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
  80a263:	66 3b 46 1c          	cmp    0x1c(%esi),%ax
  80a267:	0f 84 3e 01 00 00    	je     80a3ab <ip_reass+0x55d>
  80a26d:	c7 44 24 08 f4 38 81 	movl   $0x8138f4,0x8(%esp)
  80a274:	00 
  80a275:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80a27c:	00 
  80a27d:	c7 04 24 16 38 81 00 	movl   $0x813816,(%esp)
  80a284:	e8 23 66 ff ff       	call   8008ac <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  80a289:	0f b7 1d 84 77 b3 00 	movzwl 0xb37784,%ebx
  80a290:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a293:	89 0c 24             	mov    %ecx,(%esp)
  80a296:	e8 95 d3 ff ff       	call   807630 <pbuf_clen>
  80a29b:	0f b6 c0             	movzbl %al,%eax
  80a29e:	66 29 c3             	sub    %ax,%bx
  80a2a1:	66 89 1d 84 77 b3 00 	mov    %bx,0xb37784
  pbuf_free(new_p);
  80a2a8:	8b 45 08             	mov    0x8(%ebp),%eax
  80a2ab:	89 04 24             	mov    %eax,(%esp)
  80a2ae:	e8 c0 d7 ff ff       	call   807a73 <pbuf_free>
  80a2b3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80a2ba:	e9 67 01 00 00       	jmp    80a426 <ip_reass+0x5d8>

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
  80a2bf:	8b 5f 04             	mov    0x4(%edi),%ebx

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  80a2c2:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80a2c9:	ff 
  80a2ca:	89 3c 24             	mov    %edi,(%esp)
  80a2cd:	e8 36 d4 ff ff       	call   807708 <pbuf_header>
      pbuf_cat(p, r);
  80a2d2:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a2d6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a2d9:	89 14 24             	mov    %edx,(%esp)
  80a2dc:	e8 82 d3 ff ff       	call   807663 <pbuf_cat>
      r = iprh->next_pbuf;
  80a2e1:	8b 3b                	mov    (%ebx),%edi
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80a2e3:	85 ff                	test   %edi,%edi
  80a2e5:	75 d8                	jne    80a2bf <ip_reass+0x471>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  80a2e7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80a2ea:	89 f0                	mov    %esi,%eax
  80a2ec:	e8 46 f9 ff ff       	call   809c37 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  80a2f1:	0f b7 1d 84 77 b3 00 	movzwl 0xb37784,%ebx
  80a2f8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80a2fb:	89 0c 24             	mov    %ecx,(%esp)
  80a2fe:	e8 2d d3 ff ff       	call   807630 <pbuf_clen>
  80a303:	0f b6 c0             	movzbl %al,%eax
  80a306:	66 29 c3             	sub    %ax,%bx
  80a309:	66 89 1d 84 77 b3 00 	mov    %bx,0xb37784
  80a310:	e9 11 01 00 00       	jmp    80a426 <ip_reass+0x5d8>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  80a315:	8b 45 08             	mov    0x8(%ebp),%eax
  80a318:	89 04 24             	mov    %eax,(%esp)
  80a31b:	e8 53 d7 ff ff       	call   807a73 <pbuf_free>
  80a320:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80a327:	e9 fa 00 00 00       	jmp    80a426 <ip_reass+0x5d8>
  return NULL;
  80a32c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80a333:	e9 ee 00 00 00       	jmp    80a426 <ip_reass+0x5d8>
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  80a338:	85 ff                	test   %edi,%edi
  80a33a:	0f 85 04 fe ff ff    	jne    80a144 <ip_reass+0x2f6>
  80a340:	e9 35 fe ff ff       	jmp    80a17a <ip_reass+0x32c>
  80a345:	8b 4d dc             	mov    -0x24(%ebp),%ecx
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80a348:	85 db                	test   %ebx,%ebx
  80a34a:	0f 85 ce fe ff ff    	jne    80a21e <ip_reass+0x3d0>
  80a350:	e9 ad fe ff ff       	jmp    80a202 <ip_reass+0x3b4>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  80a355:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80a35c:	00 
  80a35d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80a364:	00 
  80a365:	89 34 24             	mov    %esi,(%esp)
  80a368:	e8 21 6e ff ff       	call   80118e <memset>
  ipr->timer = IP_REASS_MAXAGE;
  80a36d:	c6 46 1f 03          	movb   $0x3,0x1f(%esi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  80a371:	a1 80 77 b3 00       	mov    0xb37780,%eax
  80a376:	89 06                	mov    %eax,(%esi)
  reassdatagrams = ipr;
  80a378:	89 35 80 77 b3 00    	mov    %esi,0xb37780
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  80a37e:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a385:	00 
  80a386:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a38a:	8d 46 08             	lea    0x8(%esi),%eax
  80a38d:	89 04 24             	mov    %eax,(%esp)
  80a390:	e8 d3 6e ff ff       	call   801268 <memcpy>
  80a395:	e9 4d fc ff ff       	jmp    809fe7 <ip_reass+0x199>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  80a39a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80a39d:	89 11                	mov    %edx,(%ecx)
  80a39f:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
  80a3a6:	e9 58 fd ff ff       	jmp    80a103 <ip_reass+0x2b5>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  80a3ab:	83 c0 14             	add    $0x14,%eax
  80a3ae:	66 89 46 1c          	mov    %ax,0x1c(%esi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  80a3b2:	8b 46 04             	mov    0x4(%esi),%eax
  80a3b5:	8b 58 04             	mov    0x4(%eax),%ebx
  80a3b8:	8b 3b                	mov    (%ebx),%edi

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  80a3ba:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a3c1:	00 
  80a3c2:	8d 46 08             	lea    0x8(%esi),%eax
  80a3c5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a3c9:	89 1c 24             	mov    %ebx,(%esp)
  80a3cc:	e8 97 6e ff ff       	call   801268 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  80a3d1:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80a3d5:	89 04 24             	mov    %eax,(%esp)
  80a3d8:	e8 b2 04 00 00       	call   80a88f <htons>
  80a3dd:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(fraghdr, 0);
  80a3e1:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_CHKSUM_SET(fraghdr, 0);
  80a3e7:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  80a3ed:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80a3f4:	00 
  80a3f5:	89 1c 24             	mov    %ebx,(%esp)
  80a3f8:	e8 7a 01 00 00       	call   80a577 <inet_chksum>
  80a3fd:	66 89 43 0a          	mov    %ax,0xa(%ebx)

    p = ipr->p;
  80a401:	8b 46 04             	mov    0x4(%esi),%eax
  80a404:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80a407:	85 ff                	test   %edi,%edi
  80a409:	0f 85 b0 fe ff ff    	jne    80a2bf <ip_reass+0x471>
  80a40f:	e9 d3 fe ff ff       	jmp    80a2e7 <ip_reass+0x499>
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  80a414:	8b 55 08             	mov    0x8(%ebp),%edx
  80a417:	89 56 04             	mov    %edx,0x4(%esi)
  80a41a:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
  80a421:	e9 77 fd ff ff       	jmp    80a19d <ip_reass+0x34f>
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
  80a426:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a429:	83 c4 5c             	add    $0x5c,%esp
  80a42c:	5b                   	pop    %ebx
  80a42d:	5e                   	pop    %esi
  80a42e:	5f                   	pop    %edi
  80a42f:	5d                   	pop    %ebp
  80a430:	c3                   	ret    

0080a431 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  80a431:	55                   	push   %ebp
  80a432:	89 e5                	mov    %esp,%ebp
  80a434:	56                   	push   %esi
  80a435:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  80a436:	8b 0d 80 77 b3 00    	mov    0xb37780,%ecx
  while (r != NULL) {
  80a43c:	85 c9                	test   %ecx,%ecx
  80a43e:	74 2a                	je     80a46a <ip_reass_tmr+0x39>
  80a440:	be 00 00 00 00       	mov    $0x0,%esi
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  80a445:	0f b6 41 1f          	movzbl 0x1f(%ecx),%eax
  80a449:	84 c0                	test   %al,%al
  80a44b:	74 0c                	je     80a459 <ip_reass_tmr+0x28>
      r->timer--;
  80a44d:	83 e8 01             	sub    $0x1,%eax
  80a450:	88 41 1f             	mov    %al,0x1f(%ecx)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
      r = r->next;
  80a453:	89 ce                	mov    %ecx,%esi
  80a455:	8b 09                	mov    (%ecx),%ecx
  80a457:	eb 0d                	jmp    80a466 <ip_reass_tmr+0x35>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  80a459:	8b 19                	mov    (%ecx),%ebx
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  80a45b:	89 f2                	mov    %esi,%edx
  80a45d:	89 c8                	mov    %ecx,%eax
  80a45f:	e8 22 f8 ff ff       	call   809c86 <ip_reass_free_complete_datagram>
  80a464:	89 d9                	mov    %ebx,%ecx
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  80a466:	85 c9                	test   %ecx,%ecx
  80a468:	75 db                	jne    80a445 <ip_reass_tmr+0x14>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  80a46a:	5b                   	pop    %ebx
  80a46b:	5e                   	pop    %esi
  80a46c:	5d                   	pop    %ebp
  80a46d:	c3                   	ret    
	...

0080a470 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80a470:	55                   	push   %ebp
  80a471:	89 e5                	mov    %esp,%ebp
  80a473:	56                   	push   %esi
  80a474:	53                   	push   %ebx
  80a475:	83 ec 10             	sub    $0x10,%esp
  80a478:	89 d3                	mov    %edx,%ebx
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  80a47a:	89 c1                	mov    %eax,%ecx
  while (len > 1) {
  80a47c:	be 00 00 00 00       	mov    $0x0,%esi
  80a481:	66 83 fa 01          	cmp    $0x1,%dx
  80a485:	76 22                	jbe    80a4a9 <lwip_standard_chksum+0x39>
  80a487:	be 00 00 00 00       	mov    $0x0,%esi
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80a48c:	0f b6 01             	movzbl (%ecx),%eax
  80a48f:	c1 e0 08             	shl    $0x8,%eax
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  80a492:	0f b6 51 01          	movzbl 0x1(%ecx),%edx
  80a496:	09 d0                	or     %edx,%eax
  80a498:	83 c1 02             	add    $0x2,%ecx
    octetptr++;
    acc += src;
  80a49b:	0f b7 c0             	movzwl %ax,%eax
  80a49e:	01 c6                	add    %eax,%esi
    len -= 2;
  80a4a0:	83 eb 02             	sub    $0x2,%ebx
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80a4a3:	66 83 fb 01          	cmp    $0x1,%bx
  80a4a7:	77 e3                	ja     80a48c <lwip_standard_chksum+0x1c>
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  80a4a9:	66 85 db             	test   %bx,%bx
  80a4ac:	74 0b                	je     80a4b9 <lwip_standard_chksum+0x49>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    acc += src;
  80a4ae:	0f b6 01             	movzbl (%ecx),%eax
  80a4b1:	c1 e0 08             	shl    $0x8,%eax
  80a4b4:	0f b7 c0             	movzwl %ax,%eax
  80a4b7:	01 c6                	add    %eax,%esi
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a4b9:	89 f2                	mov    %esi,%edx
  80a4bb:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a4c1:	89 f0                	mov    %esi,%eax
  80a4c3:	c1 e8 10             	shr    $0x10,%eax
  80a4c6:	8d 04 02             	lea    (%edx,%eax,1),%eax
  if ((acc & 0xffff0000) != 0) {
  80a4c9:	a9 00 00 ff ff       	test   $0xffff0000,%eax
  80a4ce:	74 09                	je     80a4d9 <lwip_standard_chksum+0x69>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a4d0:	0f b7 d0             	movzwl %ax,%edx
  80a4d3:	c1 e8 10             	shr    $0x10,%eax
  80a4d6:	8d 04 02             	lea    (%edx,%eax,1),%eax
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  80a4d9:	0f b7 c0             	movzwl %ax,%eax
  80a4dc:	89 04 24             	mov    %eax,(%esp)
  80a4df:	e8 ab 03 00 00       	call   80a88f <htons>
  80a4e4:	0f b7 c0             	movzwl %ax,%eax
}
  80a4e7:	83 c4 10             	add    $0x10,%esp
  80a4ea:	5b                   	pop    %ebx
  80a4eb:	5e                   	pop    %esi
  80a4ec:	5d                   	pop    %ebp
  80a4ed:	c3                   	ret    

0080a4ee <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  80a4ee:	55                   	push   %ebp
  80a4ef:	89 e5                	mov    %esp,%ebp
  80a4f1:	57                   	push   %edi
  80a4f2:	56                   	push   %esi
  80a4f3:	53                   	push   %ebx
  80a4f4:	83 ec 0c             	sub    $0xc,%esp
  80a4f7:	8b 45 08             	mov    0x8(%ebp),%eax
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80a4fa:	be 00 00 00 00       	mov    $0x0,%esi
  80a4ff:	85 c0                	test   %eax,%eax
  80a501:	74 65                	je     80a568 <inet_chksum_pbuf+0x7a>
  80a503:	89 c3                	mov    %eax,%ebx
  80a505:	be 00 00 00 00       	mov    $0x0,%esi
  80a50a:	bf 00 00 00 00       	mov    $0x0,%edi
    acc += LWIP_CHKSUM(q->payload, q->len);
  80a50f:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80a513:	8b 43 04             	mov    0x4(%ebx),%eax
  80a516:	e8 55 ff ff ff       	call   80a470 <lwip_standard_chksum>
  80a51b:	0f b7 c0             	movzwl %ax,%eax
  80a51e:	01 f0                	add    %esi,%eax
    acc = FOLD_U32T(acc);
  80a520:	0f b7 d0             	movzwl %ax,%edx
  80a523:	c1 e8 10             	shr    $0x10,%eax
  80a526:	8d 34 02             	lea    (%edx,%eax,1),%esi
    if (q->len % 2 != 0) {
  80a529:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a52d:	74 1c                	je     80a54b <inet_chksum_pbuf+0x5d>
      swapped = 1 - swapped;
  80a52f:	b8 01 00 00 00       	mov    $0x1,%eax
  80a534:	89 fa                	mov    %edi,%edx
  80a536:	28 d0                	sub    %dl,%al
  80a538:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80a53a:	89 f0                	mov    %esi,%eax
  80a53c:	0f b6 d4             	movzbl %ah,%edx
  80a53f:	25 ff 00 00 00       	and    $0xff,%eax
  80a544:	c1 e0 08             	shl    $0x8,%eax
  80a547:	89 d6                	mov    %edx,%esi
  80a549:	09 c6                	or     %eax,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80a54b:	8b 1b                	mov    (%ebx),%ebx
  80a54d:	85 db                	test   %ebx,%ebx
  80a54f:	75 be                	jne    80a50f <inet_chksum_pbuf+0x21>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  80a551:	89 fa                	mov    %edi,%edx
  80a553:	84 d2                	test   %dl,%dl
  80a555:	74 11                	je     80a568 <inet_chksum_pbuf+0x7a>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a557:	89 f0                	mov    %esi,%eax
  80a559:	0f b6 d4             	movzbl %ah,%edx
  80a55c:	25 ff 00 00 00       	and    $0xff,%eax
  80a561:	c1 e0 08             	shl    $0x8,%eax
  80a564:	89 d6                	mov    %edx,%esi
  80a566:	09 c6                	or     %eax,%esi
  80a568:	89 f0                	mov    %esi,%eax
  80a56a:	f7 d0                	not    %eax
  80a56c:	0f b7 c0             	movzwl %ax,%eax
  }
  return (u16_t)~(acc & 0xffffUL);
}
  80a56f:	83 c4 0c             	add    $0xc,%esp
  80a572:	5b                   	pop    %ebx
  80a573:	5e                   	pop    %esi
  80a574:	5f                   	pop    %edi
  80a575:	5d                   	pop    %ebp
  80a576:	c3                   	ret    

0080a577 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  80a577:	55                   	push   %ebp
  80a578:	89 e5                	mov    %esp,%ebp
  80a57a:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  80a57d:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  80a581:	8b 45 08             	mov    0x8(%ebp),%eax
  80a584:	e8 e7 fe ff ff       	call   80a470 <lwip_standard_chksum>
  80a589:	f7 d0                	not    %eax
  80a58b:	0f b7 c0             	movzwl %ax,%eax
}
  80a58e:	c9                   	leave  
  80a58f:	c3                   	ret    

0080a590 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  80a590:	55                   	push   %ebp
  80a591:	89 e5                	mov    %esp,%ebp
  80a593:	57                   	push   %edi
  80a594:	56                   	push   %esi
  80a595:	53                   	push   %ebx
  80a596:	83 ec 0c             	sub    $0xc,%esp
  80a599:	8b 45 08             	mov    0x8(%ebp),%eax
  80a59c:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  80a5a0:	88 55 f1             	mov    %dl,-0xf(%ebp)
  80a5a3:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80a5a7:	66 89 55 ee          	mov    %dx,-0x12(%ebp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80a5ab:	be 00 00 00 00       	mov    $0x0,%esi
  80a5b0:	85 c0                	test   %eax,%eax
  80a5b2:	74 65                	je     80a619 <inet_chksum_pseudo+0x89>
  80a5b4:	89 c3                	mov    %eax,%ebx
  80a5b6:	be 00 00 00 00       	mov    $0x0,%esi
  80a5bb:	bf 00 00 00 00       	mov    $0x0,%edi
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  80a5c0:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80a5c4:	8b 43 04             	mov    0x4(%ebx),%eax
  80a5c7:	e8 a4 fe ff ff       	call   80a470 <lwip_standard_chksum>
  80a5cc:	0f b7 c0             	movzwl %ax,%eax
  80a5cf:	01 f0                	add    %esi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  80a5d1:	0f b7 d0             	movzwl %ax,%edx
  80a5d4:	c1 e8 10             	shr    $0x10,%eax
  80a5d7:	8d 34 02             	lea    (%edx,%eax,1),%esi
    if (q->len % 2 != 0) {
  80a5da:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a5de:	74 1c                	je     80a5fc <inet_chksum_pseudo+0x6c>
      swapped = 1 - swapped;
  80a5e0:	b8 01 00 00 00       	mov    $0x1,%eax
  80a5e5:	89 fa                	mov    %edi,%edx
  80a5e7:	28 d0                	sub    %dl,%al
  80a5e9:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80a5eb:	89 f0                	mov    %esi,%eax
  80a5ed:	0f b6 d4             	movzbl %ah,%edx
  80a5f0:	25 ff 00 00 00       	and    $0xff,%eax
  80a5f5:	c1 e0 08             	shl    $0x8,%eax
  80a5f8:	89 d6                	mov    %edx,%esi
  80a5fa:	09 c6                	or     %eax,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80a5fc:	8b 1b                	mov    (%ebx),%ebx
  80a5fe:	85 db                	test   %ebx,%ebx
  80a600:	75 be                	jne    80a5c0 <inet_chksum_pseudo+0x30>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80a602:	89 fa                	mov    %edi,%edx
  80a604:	84 d2                	test   %dl,%dl
  80a606:	74 11                	je     80a619 <inet_chksum_pseudo+0x89>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a608:	89 f0                	mov    %esi,%eax
  80a60a:	0f b6 d4             	movzbl %ah,%edx
  80a60d:	25 ff 00 00 00       	and    $0xff,%eax
  80a612:	c1 e0 08             	shl    $0x8,%eax
  80a615:	89 d6                	mov    %edx,%esi
  80a617:	09 c6                	or     %eax,%esi
  }
  acc += (src->addr & 0xffffUL);
  80a619:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a61c:	8b 18                	mov    (%eax),%ebx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80a61e:	8b 45 10             	mov    0x10(%ebp),%eax
  80a621:	8b 38                	mov    (%eax),%edi
  acc += ((dest->addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
  80a623:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
  80a627:	89 04 24             	mov    %eax,(%esp)
  80a62a:	e8 60 02 00 00       	call   80a88f <htons>
  80a62f:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  acc += (u32_t)htons(proto_len);
  80a633:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
  80a637:	89 04 24             	mov    %eax,(%esp)
  80a63a:	e8 50 02 00 00       	call   80a88f <htons>
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80a63f:	89 fa                	mov    %edi,%edx
  80a641:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a647:	0f b7 cb             	movzwl %bx,%ecx
  80a64a:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  80a64c:	c1 eb 10             	shr    $0x10,%ebx
  80a64f:	01 da                	add    %ebx,%edx
  acc += (dest->addr & 0xffffUL);
  80a651:	89 f9                	mov    %edi,%ecx
  80a653:	c1 e9 10             	shr    $0x10,%ecx
  80a656:	01 ca                	add    %ecx,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  80a658:	01 f2                	add    %esi,%edx
  acc += (u32_t)htons((u16_t)proto);
  80a65a:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  80a65e:	01 ca                	add    %ecx,%edx
  acc += (u32_t)htons(proto_len);
  80a660:	0f b7 c0             	movzwl %ax,%eax
  80a663:	01 c2                	add    %eax,%edx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80a665:	0f b7 c2             	movzwl %dx,%eax
  80a668:	c1 ea 10             	shr    $0x10,%edx
  80a66b:	01 d0                	add    %edx,%eax
  80a66d:	89 c2                	mov    %eax,%edx
  80a66f:	c1 ea 10             	shr    $0x10,%edx
  80a672:	01 d0                	add    %edx,%eax
  80a674:	f7 d0                	not    %eax
  80a676:	0f b7 c0             	movzwl %ax,%eax
  acc = FOLD_U32T(acc);
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  80a679:	83 c4 0c             	add    $0xc,%esp
  80a67c:	5b                   	pop    %ebx
  80a67d:	5e                   	pop    %esi
  80a67e:	5f                   	pop    %edi
  80a67f:	5d                   	pop    %ebp
  80a680:	c3                   	ret    

0080a681 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80a681:	55                   	push   %ebp
  80a682:	89 e5                	mov    %esp,%ebp
  80a684:	57                   	push   %edi
  80a685:	56                   	push   %esi
  80a686:	53                   	push   %ebx
  80a687:	83 ec 1c             	sub    $0x1c,%esp
  80a68a:	8b 45 08             	mov    0x8(%ebp),%eax
  80a68d:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  80a691:	88 55 eb             	mov    %dl,-0x15(%ebp)
  80a694:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80a698:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
  80a69c:	0f b7 7d 1c          	movzwl 0x1c(%ebp),%edi
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80a6a0:	85 c0                	test   %eax,%eax
  80a6a2:	74 05                	je     80a6a9 <inet_chksum_pseudo_partial+0x28>
  80a6a4:	66 85 ff             	test   %di,%di
  80a6a7:	75 0c                	jne    80a6b5 <inet_chksum_pseudo_partial+0x34>
  80a6a9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  80a6b0:	e9 ba 00 00 00       	jmp    80a76f <inet_chksum_pseudo_partial+0xee>
  80a6b5:	89 c6                	mov    %eax,%esi
  80a6b7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  80a6be:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  80a6c2:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
    if (chklen > chksum_len) {
  80a6c6:	66 39 fb             	cmp    %di,%bx
  80a6c9:	0f 87 88 00 00 00    	ja     80a757 <inet_chksum_pseudo_partial+0xd6>
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80a6cf:	0f b7 d3             	movzwl %bx,%edx
  80a6d2:	8b 46 04             	mov    0x4(%esi),%eax
  80a6d5:	e8 96 fd ff ff       	call   80a470 <lwip_standard_chksum>
    chksum_len -= chklen;
  80a6da:	66 29 df             	sub    %bx,%di
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  80a6dd:	66 81 ff fe 7f       	cmp    $0x7ffe,%di
  80a6e2:	76 1c                	jbe    80a700 <inet_chksum_pseudo_partial+0x7f>
  80a6e4:	c7 44 24 08 21 39 81 	movl   $0x813921,0x8(%esp)
  80a6eb:	00 
  80a6ec:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  80a6f3:	00 
  80a6f4:	c7 04 24 2c 39 81 00 	movl   $0x81392c,(%esp)
  80a6fb:	e8 ac 61 ff ff       	call   8008ac <_panic>
      (void *)q, (void *)q->next));
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80a700:	0f b7 c0             	movzwl %ax,%eax
  80a703:	03 45 ec             	add    -0x14(%ebp),%eax
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  80a706:	0f b7 d0             	movzwl %ax,%edx
  80a709:	c1 e8 10             	shr    $0x10,%eax
  80a70c:	01 c2                	add    %eax,%edx
  80a70e:	89 55 ec             	mov    %edx,-0x14(%ebp)
    if (q->len % 2 != 0) {
  80a711:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  80a715:	74 1a                	je     80a731 <inet_chksum_pseudo_partial+0xb0>
      swapped = 1 - swapped;
  80a717:	b8 01 00 00 00       	mov    $0x1,%eax
  80a71c:	2a 45 f3             	sub    -0xd(%ebp),%al
  80a71f:	88 45 f3             	mov    %al,-0xd(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80a722:	0f b6 d6             	movzbl %dh,%edx
  80a725:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  80a729:	c1 e0 08             	shl    $0x8,%eax
  80a72c:	09 c2                	or     %eax,%edx
  80a72e:	89 55 ec             	mov    %edx,-0x14(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80a731:	8b 36                	mov    (%esi),%esi
  80a733:	85 f6                	test   %esi,%esi
  80a735:	74 05                	je     80a73c <inet_chksum_pseudo_partial+0xbb>
  80a737:	66 85 ff             	test   %di,%di
  80a73a:	75 86                	jne    80a6c2 <inet_chksum_pseudo_partial+0x41>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80a73c:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  80a740:	74 2d                	je     80a76f <inet_chksum_pseudo_partial+0xee>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a742:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80a745:	0f b6 d4             	movzbl %ah,%edx
  80a748:	25 ff 00 00 00       	and    $0xff,%eax
  80a74d:	c1 e0 08             	shl    $0x8,%eax
  80a750:	09 c2                	or     %eax,%edx
  80a752:	89 55 ec             	mov    %edx,-0x14(%ebp)
  80a755:	eb 18                	jmp    80a76f <inet_chksum_pseudo_partial+0xee>
      (void *)q, (void *)q->next));
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80a757:	0f b7 d7             	movzwl %di,%edx
  80a75a:	8b 46 04             	mov    0x4(%esi),%eax
  80a75d:	e8 0e fd ff ff       	call   80a470 <lwip_standard_chksum>
  80a762:	0f b7 c0             	movzwl %ax,%eax
  80a765:	03 45 ec             	add    -0x14(%ebp),%eax
  80a768:	bf 00 00 00 00       	mov    $0x0,%edi
  80a76d:	eb 97                	jmp    80a706 <inet_chksum_pseudo_partial+0x85>
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80a76f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a772:	8b 1a                	mov    (%edx),%ebx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80a774:	8b 45 10             	mov    0x10(%ebp),%eax
  80a777:	8b 30                	mov    (%eax),%esi
  acc += ((dest->addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
  80a779:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
  80a77d:	89 04 24             	mov    %eax,(%esp)
  80a780:	e8 0a 01 00 00       	call   80a88f <htons>
  80a785:	89 c7                	mov    %eax,%edi
  acc += (u32_t)htons(proto_len);
  80a787:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
  80a78b:	89 04 24             	mov    %eax,(%esp)
  80a78e:	e8 fc 00 00 00       	call   80a88f <htons>
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80a793:	89 f2                	mov    %esi,%edx
  80a795:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a79b:	0f b7 cb             	movzwl %bx,%ecx
  80a79e:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  80a7a0:	c1 eb 10             	shr    $0x10,%ebx
  80a7a3:	01 da                	add    %ebx,%edx
  acc += (dest->addr & 0xffffUL);
  80a7a5:	89 f1                	mov    %esi,%ecx
  80a7a7:	c1 e9 10             	shr    $0x10,%ecx
  80a7aa:	01 ca                	add    %ecx,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  80a7ac:	03 55 ec             	add    -0x14(%ebp),%edx
  acc += (u32_t)htons((u16_t)proto);
  80a7af:	0f b7 cf             	movzwl %di,%ecx
  80a7b2:	01 ca                	add    %ecx,%edx
  acc += (u32_t)htons(proto_len);
  80a7b4:	0f b7 c0             	movzwl %ax,%eax
  80a7b7:	01 c2                	add    %eax,%edx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80a7b9:	0f b7 c2             	movzwl %dx,%eax
  80a7bc:	c1 ea 10             	shr    $0x10,%edx
  80a7bf:	01 d0                	add    %edx,%eax
  80a7c1:	89 c2                	mov    %eax,%edx
  80a7c3:	c1 ea 10             	shr    $0x10,%edx
  80a7c6:	01 d0                	add    %edx,%eax
  80a7c8:	f7 d0                	not    %eax
  80a7ca:	0f b7 c0             	movzwl %ax,%eax
  acc = FOLD_U32T(acc);
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  80a7cd:	83 c4 1c             	add    $0x1c,%esp
  80a7d0:	5b                   	pop    %ebx
  80a7d1:	5e                   	pop    %esi
  80a7d2:	5f                   	pop    %edi
  80a7d3:	5d                   	pop    %ebp
  80a7d4:	c3                   	ret    
	...

0080a7e0 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80a7e0:	55                   	push   %ebp
  80a7e1:	89 e5                	mov    %esp,%ebp
  80a7e3:	57                   	push   %edi
  80a7e4:	56                   	push   %esi
  80a7e5:	53                   	push   %ebx
  80a7e6:	83 ec 18             	sub    $0x18,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  80a7e9:	8b 45 08             	mov    0x8(%ebp),%eax
  80a7ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  80a7ef:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80a7f2:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80a7f5:	be 00 00 00 00       	mov    $0x0,%esi
  80a7fa:	bf 7c 7d b3 00       	mov    $0xb37d7c,%edi
  80a7ff:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  80a803:	eb 02                	jmp    80a807 <inet_ntoa+0x27>
  for(n = 0; n < 4; n++) {
  80a805:	89 c6                	mov    %eax,%esi
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80a807:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80a80a:	0f b6 0a             	movzbl (%edx),%ecx
      *ap /= (u8_t)10;
  80a80d:	b8 cd ff ff ff       	mov    $0xffffffcd,%eax
  80a812:	f6 e1                	mul    %cl
  80a814:	89 c2                	mov    %eax,%edx
  80a816:	66 c1 ea 08          	shr    $0x8,%dx
  80a81a:	c0 ea 03             	shr    $0x3,%dl
  80a81d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80a820:	88 10                	mov    %dl,(%eax)
      inv[i++] = '0' + rem;
  80a822:	89 f0                	mov    %esi,%eax
  80a824:	0f b6 d8             	movzbl %al,%ebx
  80a827:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80a82a:	01 c0                	add    %eax,%eax
  80a82c:	28 c1                	sub    %al,%cl
  80a82e:	83 c1 30             	add    $0x30,%ecx
  80a831:	88 4c 1d ed          	mov    %cl,-0x13(%ebp,%ebx,1)
  80a835:	8d 46 01             	lea    0x1(%esi),%eax
    } while(*ap);
  80a838:	84 d2                	test   %dl,%dl
  80a83a:	75 c9                	jne    80a805 <inet_ntoa+0x25>
    while(i--)
  80a83c:	89 f1                	mov    %esi,%ecx
  80a83e:	80 f9 ff             	cmp    $0xff,%cl
  80a841:	74 20                	je     80a863 <inet_ntoa+0x83>
  80a843:	89 fa                	mov    %edi,%edx
      *rp++ = inv[i];
  80a845:	0f b6 c1             	movzbl %cl,%eax
  80a848:	0f b6 44 05 ed       	movzbl -0x13(%ebp,%eax,1),%eax
  80a84d:	88 02                	mov    %al,(%edx)
  80a84f:	83 c2 01             	add    $0x1,%edx
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  80a852:	83 e9 01             	sub    $0x1,%ecx
  80a855:	80 f9 ff             	cmp    $0xff,%cl
  80a858:	75 eb                	jne    80a845 <inet_ntoa+0x65>
  80a85a:	89 f2                	mov    %esi,%edx
  80a85c:	0f b6 c2             	movzbl %dl,%eax
  80a85f:	8d 7c 07 01          	lea    0x1(%edi,%eax,1),%edi
      *rp++ = inv[i];
    *rp++ = '.';
  80a863:	c6 07 2e             	movb   $0x2e,(%edi)
  80a866:	83 c7 01             	add    $0x1,%edi
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  80a869:	80 45 e3 01          	addb   $0x1,-0x1d(%ebp)
  80a86d:	80 7d e3 03          	cmpb   $0x3,-0x1d(%ebp)
  80a871:	77 0b                	ja     80a87e <inet_ntoa+0x9e>
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  80a873:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
  80a877:	b8 00 00 00 00       	mov    $0x0,%eax
  80a87c:	eb 87                	jmp    80a805 <inet_ntoa+0x25>
  }
  *--rp = 0;
  80a87e:	c6 47 ff 00          	movb   $0x0,-0x1(%edi)
  return str;
}
  80a882:	b8 7c 7d b3 00       	mov    $0xb37d7c,%eax
  80a887:	83 c4 18             	add    $0x18,%esp
  80a88a:	5b                   	pop    %ebx
  80a88b:	5e                   	pop    %esi
  80a88c:	5f                   	pop    %edi
  80a88d:	5d                   	pop    %ebp
  80a88e:	c3                   	ret    

0080a88f <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  80a88f:	55                   	push   %ebp
  80a890:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  80a892:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80a896:	89 c2                	mov    %eax,%edx
  80a898:	c1 ea 08             	shr    $0x8,%edx
  80a89b:	c1 e0 08             	shl    $0x8,%eax
  80a89e:	09 d0                	or     %edx,%eax
  80a8a0:	0f b7 c0             	movzwl %ax,%eax
}
  80a8a3:	5d                   	pop    %ebp
  80a8a4:	c3                   	ret    

0080a8a5 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  80a8a5:	55                   	push   %ebp
  80a8a6:	89 e5                	mov    %esp,%ebp
  80a8a8:	83 ec 04             	sub    $0x4,%esp
  return htons(n);
  80a8ab:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80a8af:	89 04 24             	mov    %eax,(%esp)
  80a8b2:	e8 d8 ff ff ff       	call   80a88f <htons>
  80a8b7:	0f b7 c0             	movzwl %ax,%eax
}
  80a8ba:	c9                   	leave  
  80a8bb:	c3                   	ret    

0080a8bc <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  80a8bc:	55                   	push   %ebp
  80a8bd:	89 e5                	mov    %esp,%ebp
  80a8bf:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a8c2:	89 c8                	mov    %ecx,%eax
  80a8c4:	25 00 ff 00 00       	and    $0xff00,%eax
  80a8c9:	c1 e0 08             	shl    $0x8,%eax
  80a8cc:	89 ca                	mov    %ecx,%edx
  80a8ce:	c1 e2 18             	shl    $0x18,%edx
  80a8d1:	09 d0                	or     %edx,%eax
  80a8d3:	89 ca                	mov    %ecx,%edx
  80a8d5:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  80a8db:	c1 ea 08             	shr    $0x8,%edx
  80a8de:	09 d0                	or     %edx,%eax
  80a8e0:	c1 e9 18             	shr    $0x18,%ecx
  80a8e3:	09 c8                	or     %ecx,%eax
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  80a8e5:	5d                   	pop    %ebp
  80a8e6:	c3                   	ret    

0080a8e7 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  80a8e7:	55                   	push   %ebp
  80a8e8:	89 e5                	mov    %esp,%ebp
  80a8ea:	57                   	push   %edi
  80a8eb:	56                   	push   %esi
  80a8ec:	53                   	push   %ebx
  80a8ed:	83 ec 24             	sub    $0x24,%esp
  80a8f0:	8b 55 08             	mov    0x8(%ebp),%edx
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  80a8f3:	0f be 32             	movsbl (%edx),%esi
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80a8f6:	8d 46 d0             	lea    -0x30(%esi),%eax
  80a8f9:	3c 09                	cmp    $0x9,%al
  80a8fb:	0f 87 c0 01 00 00    	ja     80aac1 <inet_aton+0x1da>
  80a901:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80a904:	89 45 e0             	mov    %eax,-0x20(%ebp)
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80a907:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80a90a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
     */
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
  80a90d:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
  80a914:	83 fe 30             	cmp    $0x30,%esi
  80a917:	75 24                	jne    80a93d <inet_aton+0x56>
      c = *++cp;
  80a919:	83 c2 01             	add    $0x1,%edx
  80a91c:	0f be 32             	movsbl (%edx),%esi
      if (c == 'x' || c == 'X') {
  80a91f:	83 fe 78             	cmp    $0x78,%esi
  80a922:	74 0c                	je     80a930 <inet_aton+0x49>
  80a924:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  80a92b:	83 fe 58             	cmp    $0x58,%esi
  80a92e:	75 0d                	jne    80a93d <inet_aton+0x56>
        base = 16;
        c = *++cp;
  80a930:	83 c2 01             	add    $0x1,%edx
  80a933:	0f be 32             	movsbl (%edx),%esi
  80a936:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
  80a93d:	8d 5a 01             	lea    0x1(%edx),%ebx
  80a940:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80a947:	eb 03                	jmp    80a94c <inet_aton+0x65>
  80a949:	83 c3 01             	add    $0x1,%ebx
  80a94c:	8d 7b ff             	lea    -0x1(%ebx),%edi
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  80a94f:	89 f1                	mov    %esi,%ecx
  80a951:	8d 41 d0             	lea    -0x30(%ecx),%eax
  80a954:	3c 09                	cmp    $0x9,%al
  80a956:	77 13                	ja     80a96b <inet_aton+0x84>
        val = (val * base) + (int)(c - '0');
  80a958:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80a95b:	0f af 45 d8          	imul   -0x28(%ebp),%eax
  80a95f:	8d 74 06 d0          	lea    -0x30(%esi,%eax,1),%esi
  80a963:	89 75 d8             	mov    %esi,-0x28(%ebp)
        c = *++cp;
  80a966:	0f be 33             	movsbl (%ebx),%esi
  80a969:	eb de                	jmp    80a949 <inet_aton+0x62>
      } else if (base == 16 && isxdigit(c)) {
  80a96b:	83 7d dc 10          	cmpl   $0x10,-0x24(%ebp)
  80a96f:	75 2c                	jne    80a99d <inet_aton+0xb6>
  80a971:	8d 51 9f             	lea    -0x61(%ecx),%edx
  80a974:	80 fa 05             	cmp    $0x5,%dl
  80a977:	76 07                	jbe    80a980 <inet_aton+0x99>
  80a979:	8d 41 bf             	lea    -0x41(%ecx),%eax
  80a97c:	3c 05                	cmp    $0x5,%al
  80a97e:	77 1d                	ja     80a99d <inet_aton+0xb6>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  80a980:	80 fa 1a             	cmp    $0x1a,%dl
  80a983:	19 c0                	sbb    %eax,%eax
  80a985:	83 e0 20             	and    $0x20,%eax
  80a988:	29 c6                	sub    %eax,%esi
  80a98a:	8d 46 c9             	lea    -0x37(%esi),%eax
  80a98d:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80a990:	c1 e2 04             	shl    $0x4,%edx
  80a993:	09 d0                	or     %edx,%eax
  80a995:	89 45 d8             	mov    %eax,-0x28(%ebp)
        c = *++cp;
  80a998:	0f be 33             	movsbl (%ebx),%esi
  80a99b:	eb ac                	jmp    80a949 <inet_aton+0x62>
      } else
        break;
    }
    if (c == '.') {
  80a99d:	83 fe 2e             	cmp    $0x2e,%esi
  80a9a0:	75 2c                	jne    80a9ce <inet_aton+0xe7>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80a9a2:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a9a5:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
  80a9a8:	0f 86 13 01 00 00    	jbe    80aac1 <inet_aton+0x1da>
        return (0);
      *pp++ = val;
  80a9ae:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a9b1:	89 02                	mov    %eax,(%edx)
      c = *++cp;
  80a9b3:	8d 57 01             	lea    0x1(%edi),%edx
  80a9b6:	0f be 77 01          	movsbl 0x1(%edi),%esi
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80a9ba:	8d 46 d0             	lea    -0x30(%esi),%eax
  80a9bd:	3c 09                	cmp    $0x9,%al
  80a9bf:	0f 87 fc 00 00 00    	ja     80aac1 <inet_aton+0x1da>
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
  80a9c5:	83 45 e0 04          	addl   $0x4,-0x20(%ebp)
  80a9c9:	e9 3f ff ff ff       	jmp    80a90d <inet_aton+0x26>
  80a9ce:	8b 5d d8             	mov    -0x28(%ebp),%ebx
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80a9d1:	85 f6                	test   %esi,%esi
  80a9d3:	74 36                	je     80aa0b <inet_aton+0x124>
  80a9d5:	80 f9 1f             	cmp    $0x1f,%cl
  80a9d8:	0f 86 e3 00 00 00    	jbe    80aac1 <inet_aton+0x1da>
  80a9de:	89 f2                	mov    %esi,%edx
  80a9e0:	84 d2                	test   %dl,%dl
  80a9e2:	0f 88 d9 00 00 00    	js     80aac1 <inet_aton+0x1da>
  80a9e8:	83 fe 20             	cmp    $0x20,%esi
  80a9eb:	74 1e                	je     80aa0b <inet_aton+0x124>
  80a9ed:	83 fe 0c             	cmp    $0xc,%esi
  80a9f0:	74 19                	je     80aa0b <inet_aton+0x124>
  80a9f2:	83 fe 0a             	cmp    $0xa,%esi
  80a9f5:	74 14                	je     80aa0b <inet_aton+0x124>
  80a9f7:	83 fe 0d             	cmp    $0xd,%esi
  80a9fa:	74 0f                	je     80aa0b <inet_aton+0x124>
  80a9fc:	83 fe 09             	cmp    $0x9,%esi
  80a9ff:	90                   	nop    
  80aa00:	74 09                	je     80aa0b <inet_aton+0x124>
  80aa02:	83 fe 0b             	cmp    $0xb,%esi
  80aa05:	0f 85 b6 00 00 00    	jne    80aac1 <inet_aton+0x1da>
    return (0);
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  80aa0b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  switch (n) {
  80aa0e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80aa11:	29 c2                	sub    %eax,%edx
  80aa13:	89 d0                	mov    %edx,%eax
  80aa15:	c1 f8 02             	sar    $0x2,%eax
  80aa18:	83 c0 01             	add    $0x1,%eax
  80aa1b:	83 f8 02             	cmp    $0x2,%eax
  80aa1e:	74 24                	je     80aa44 <inet_aton+0x15d>
  80aa20:	83 f8 02             	cmp    $0x2,%eax
  80aa23:	7f 0d                	jg     80aa32 <inet_aton+0x14b>
  80aa25:	85 c0                	test   %eax,%eax
  80aa27:	0f 84 94 00 00 00    	je     80aac1 <inet_aton+0x1da>
  80aa2d:	8d 76 00             	lea    0x0(%esi),%esi
  80aa30:	eb 6d                	jmp    80aa9f <inet_aton+0x1b8>
  80aa32:	83 f8 03             	cmp    $0x3,%eax
  80aa35:	74 28                	je     80aa5f <inet_aton+0x178>
  80aa37:	83 f8 04             	cmp    $0x4,%eax
  80aa3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80aa40:	75 5d                	jne    80aa9f <inet_aton+0x1b8>
  80aa42:	eb 38                	jmp    80aa7c <inet_aton+0x195>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  80aa44:	81 fb ff ff ff 00    	cmp    $0xffffff,%ebx
  80aa4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80aa50:	77 6f                	ja     80aac1 <inet_aton+0x1da>
      return (0);
    val |= parts[0] << 24;
  80aa52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80aa55:	c1 e0 18             	shl    $0x18,%eax
  80aa58:	09 c3                	or     %eax,%ebx
  80aa5a:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  80aa5d:	eb 40                	jmp    80aa9f <inet_aton+0x1b8>
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  80aa5f:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  80aa65:	77 5a                	ja     80aac1 <inet_aton+0x1da>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  80aa67:	8b 55 e8             	mov    -0x18(%ebp),%edx
  80aa6a:	c1 e2 10             	shl    $0x10,%edx
  80aa6d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80aa70:	c1 e0 18             	shl    $0x18,%eax
  80aa73:	09 c2                	or     %eax,%edx
  80aa75:	09 da                	or     %ebx,%edx
  80aa77:	89 55 d8             	mov    %edx,-0x28(%ebp)
  80aa7a:	eb 23                	jmp    80aa9f <inet_aton+0x1b8>
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  80aa7c:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  80aa82:	77 3d                	ja     80aac1 <inet_aton+0x1da>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  80aa84:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80aa87:	c1 e0 10             	shl    $0x10,%eax
  80aa8a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80aa8d:	c1 e2 18             	shl    $0x18,%edx
  80aa90:	09 d0                	or     %edx,%eax
  80aa92:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80aa95:	c1 e2 08             	shl    $0x8,%edx
  80aa98:	09 d0                	or     %edx,%eax
  80aa9a:	09 d8                	or     %ebx,%eax
  80aa9c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    break;
  }
  if (addr)
  80aa9f:	b8 01 00 00 00       	mov    $0x1,%eax
  80aaa4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80aaa8:	74 1c                	je     80aac6 <inet_aton+0x1df>
    addr->s_addr = htonl(val);
  80aaaa:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80aaad:	89 04 24             	mov    %eax,(%esp)
  80aab0:	e8 07 fe ff ff       	call   80a8bc <htonl>
  80aab5:	8b 55 0c             	mov    0xc(%ebp),%edx
  80aab8:	89 02                	mov    %eax,(%edx)
  80aaba:	b8 01 00 00 00       	mov    $0x1,%eax
  80aabf:	eb 05                	jmp    80aac6 <inet_aton+0x1df>
  80aac1:	b8 00 00 00 00       	mov    $0x0,%eax
  return (1);
}
  80aac6:	83 c4 24             	add    $0x24,%esp
  80aac9:	5b                   	pop    %ebx
  80aaca:	5e                   	pop    %esi
  80aacb:	5f                   	pop    %edi
  80aacc:	5d                   	pop    %ebp
  80aacd:	c3                   	ret    

0080aace <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  80aace:	55                   	push   %ebp
  80aacf:	89 e5                	mov    %esp,%ebp
  80aad1:	83 ec 18             	sub    $0x18,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  80aad4:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80aad7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80aadb:	8b 45 08             	mov    0x8(%ebp),%eax
  80aade:	89 04 24             	mov    %eax,(%esp)
  80aae1:	e8 01 fe ff ff       	call   80a8e7 <inet_aton>
  80aae6:	83 f8 01             	cmp    $0x1,%eax
  80aae9:	19 c0                	sbb    %eax,%eax
  80aaeb:	0b 45 fc             	or     -0x4(%ebp),%eax
    return (val.s_addr);
  }
  return (INADDR_NONE);
}
  80aaee:	c9                   	leave  
  80aaef:	c3                   	ret    

0080aaf0 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  80aaf0:	55                   	push   %ebp
  80aaf1:	89 e5                	mov    %esp,%ebp
  80aaf3:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  80aaf6:	8b 45 08             	mov    0x8(%ebp),%eax
  80aaf9:	89 04 24             	mov    %eax,(%esp)
  80aafc:	e8 bb fd ff ff       	call   80a8bc <htonl>
}
  80ab01:	c9                   	leave  
  80ab02:	c3                   	ret    
	...

0080ab10 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  80ab10:	55                   	push   %ebp
  80ab11:	89 e5                	mov    %esp,%ebp
  80ab13:	57                   	push   %edi
  80ab14:	56                   	push   %esi
  80ab15:	53                   	push   %ebx
  80ab16:	83 ec 2c             	sub    $0x2c,%esp
  80ab19:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  80ab1c:	8b 46 78             	mov    0x78(%esi),%eax
  80ab1f:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(seg == NULL)
  80ab22:	85 c0                	test   %eax,%eax
  80ab24:	75 0e                	jne    80ab34 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  80ab26:	8b 56 74             	mov    0x74(%esi),%edx
  80ab29:	89 55 f0             	mov    %edx,-0x10(%ebp)

  if(seg == NULL)
  80ab2c:	85 d2                	test   %edx,%edx
  80ab2e:	0f 84 4b 01 00 00    	je     80ac7f <tcp_zero_window_probe+0x16f>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  80ab34:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ab3b:	00 
  80ab3c:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  80ab43:	00 
  80ab44:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ab4b:	e8 e6 d1 ff ff       	call   807d36 <pbuf_alloc>
  80ab50:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80ab52:	85 c0                	test   %eax,%eax
  80ab54:	0f 84 25 01 00 00    	je     80ac7f <tcp_zero_window_probe+0x16f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80ab5a:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80ab5f:	77 1c                	ja     80ab7d <tcp_zero_window_probe+0x6d>
  80ab61:	c7 44 24 08 50 39 81 	movl   $0x813950,0x8(%esp)
  80ab68:	00 
  80ab69:	c7 44 24 04 8d 03 00 	movl   $0x38d,0x4(%esp)
  80ab70:	00 
  80ab71:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80ab78:	e8 2f 5d ff ff       	call   8008ac <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80ab7d:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80ab80:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80ab84:	89 04 24             	mov    %eax,(%esp)
  80ab87:	e8 03 fd ff ff       	call   80a88f <htons>
  80ab8c:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80ab8f:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80ab93:	89 04 24             	mov    %eax,(%esp)
  80ab96:	e8 f4 fc ff ff       	call   80a88f <htons>
  80ab9b:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  80ab9f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  80aba2:	8b 41 10             	mov    0x10(%ecx),%eax
  80aba5:	8b 40 04             	mov    0x4(%eax),%eax
  80aba8:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80abab:	8b 46 24             	mov    0x24(%esi),%eax
  80abae:	89 04 24             	mov    %eax,(%esp)
  80abb1:	e8 06 fd ff ff       	call   80a8bc <htonl>
  80abb6:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80abb9:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80abbd:	89 04 24             	mov    %eax,(%esp)
  80abc0:	e8 e0 fc ff ff       	call   80a8a5 <ntohs>
  80abc5:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80abca:	89 04 24             	mov    %eax,(%esp)
  80abcd:	e8 bd fc ff ff       	call   80a88f <htons>
  80abd2:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80abd6:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80abda:	89 04 24             	mov    %eax,(%esp)
  80abdd:	e8 ad fc ff ff       	call   80a88f <htons>
  80abe2:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80abe6:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80abec:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80abf0:	89 04 24             	mov    %eax,(%esp)
  80abf3:	e8 ad fc ff ff       	call   80a8a5 <ntohs>
  80abf8:	83 e0 3f             	and    $0x3f,%eax
  80abfb:	80 cc 50             	or     $0x50,%ah
  80abfe:	89 04 24             	mov    %eax,(%esp)
  80ac01:	e8 89 fc ff ff       	call   80a88f <htons>
  80ac06:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80ac0a:	8b 57 04             	mov    0x4(%edi),%edx
  80ac0d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  80ac10:	8b 41 08             	mov    0x8(%ecx),%eax
  80ac13:	0f b6 00             	movzbl (%eax),%eax
  80ac16:	88 42 14             	mov    %al,0x14(%edx)

  tcphdr->chksum = 0;
  80ac19:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80ac1f:	8d 46 04             	lea    0x4(%esi),%eax
  80ac22:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80ac25:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80ac29:	89 44 24 10          	mov    %eax,0x10(%esp)
  80ac2d:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80ac34:	00 
  80ac35:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80ac38:	89 54 24 08          	mov    %edx,0x8(%esp)
  80ac3c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ac40:	89 3c 24             	mov    %edi,(%esp)
  80ac43:	e8 48 f9 ff ff       	call   80a590 <inet_chksum_pseudo>
  80ac48:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80ac4c:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80ac53:	00 
  80ac54:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80ac5b:	00 
  80ac5c:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80ac60:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ac64:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  80ac67:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80ac6b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ac6f:	89 3c 24             	mov    %edi,(%esp)
  80ac72:	e8 80 ea ff ff       	call   8096f7 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80ac77:	89 3c 24             	mov    %edi,(%esp)
  80ac7a:	e8 f4 cd ff ff       	call   807a73 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80ac7f:	83 c4 2c             	add    $0x2c,%esp
  80ac82:	5b                   	pop    %ebx
  80ac83:	5e                   	pop    %esi
  80ac84:	5f                   	pop    %edi
  80ac85:	5d                   	pop    %ebp
  80ac86:	c3                   	ret    

0080ac87 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80ac87:	55                   	push   %ebp
  80ac88:	89 e5                	mov    %esp,%ebp
  80ac8a:	57                   	push   %edi
  80ac8b:	56                   	push   %esi
  80ac8c:	53                   	push   %ebx
  80ac8d:	83 ec 1c             	sub    $0x1c,%esp
  80ac90:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80ac93:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ac9a:	00 
  80ac9b:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80aca2:	00 
  80aca3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80acaa:	e8 87 d0 ff ff       	call   807d36 <pbuf_alloc>
  80acaf:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80acb1:	85 c0                	test   %eax,%eax
  80acb3:	0f 84 1b 01 00 00    	je     80add4 <tcp_keepalive+0x14d>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80acb9:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80acbe:	77 1c                	ja     80acdc <tcp_keepalive+0x55>
  80acc0:	c7 44 24 08 50 39 81 	movl   $0x813950,0x8(%esp)
  80acc7:	00 
  80acc8:	c7 44 24 04 3a 03 00 	movl   $0x33a,0x4(%esp)
  80accf:	00 
  80acd0:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80acd7:	e8 d0 5b ff ff       	call   8008ac <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80acdc:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80acdf:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80ace3:	89 04 24             	mov    %eax,(%esp)
  80ace6:	e8 a4 fb ff ff       	call   80a88f <htons>
  80aceb:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80acee:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80acf2:	89 04 24             	mov    %eax,(%esp)
  80acf5:	e8 95 fb ff ff       	call   80a88f <htons>
  80acfa:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  80acfe:	8b 46 54             	mov    0x54(%esi),%eax
  80ad01:	83 e8 01             	sub    $0x1,%eax
  80ad04:	89 04 24             	mov    %eax,(%esp)
  80ad07:	e8 b0 fb ff ff       	call   80a8bc <htonl>
  80ad0c:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80ad0f:	8b 46 24             	mov    0x24(%esi),%eax
  80ad12:	89 04 24             	mov    %eax,(%esp)
  80ad15:	e8 a2 fb ff ff       	call   80a8bc <htonl>
  80ad1a:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80ad1d:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80ad21:	89 04 24             	mov    %eax,(%esp)
  80ad24:	e8 7c fb ff ff       	call   80a8a5 <ntohs>
  80ad29:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80ad2e:	89 04 24             	mov    %eax,(%esp)
  80ad31:	e8 59 fb ff ff       	call   80a88f <htons>
  80ad36:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80ad3a:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80ad3e:	89 04 24             	mov    %eax,(%esp)
  80ad41:	e8 49 fb ff ff       	call   80a88f <htons>
  80ad46:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80ad4a:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80ad50:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80ad54:	89 04 24             	mov    %eax,(%esp)
  80ad57:	e8 49 fb ff ff       	call   80a8a5 <ntohs>
  80ad5c:	83 e0 3f             	and    $0x3f,%eax
  80ad5f:	80 cc 50             	or     $0x50,%ah
  80ad62:	89 04 24             	mov    %eax,(%esp)
  80ad65:	e8 25 fb ff ff       	call   80a88f <htons>
  80ad6a:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80ad6e:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80ad74:	8d 46 04             	lea    0x4(%esi),%eax
  80ad77:	89 45 f0             	mov    %eax,-0x10(%ebp)
  80ad7a:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80ad7e:	89 44 24 10          	mov    %eax,0x10(%esp)
  80ad82:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80ad89:	00 
  80ad8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80ad8d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ad91:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ad95:	89 3c 24             	mov    %edi,(%esp)
  80ad98:	e8 f3 f7 ff ff       	call   80a590 <inet_chksum_pseudo>
  80ad9d:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80ada1:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80ada8:	00 
  80ada9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80adb0:	00 
  80adb1:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80adb5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80adb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80adbc:	89 44 24 08          	mov    %eax,0x8(%esp)
  80adc0:	89 74 24 04          	mov    %esi,0x4(%esp)
  80adc4:	89 3c 24             	mov    %edi,(%esp)
  80adc7:	e8 2b e9 ff ff       	call   8096f7 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80adcc:	89 3c 24             	mov    %edi,(%esp)
  80adcf:	e8 9f cc ff ff       	call   807a73 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80add4:	83 c4 1c             	add    $0x1c,%esp
  80add7:	5b                   	pop    %ebx
  80add8:	5e                   	pop    %esi
  80add9:	5f                   	pop    %edi
  80adda:	5d                   	pop    %ebp
  80addb:	c3                   	ret    

0080addc <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  80addc:	55                   	push   %ebp
  80addd:	89 e5                	mov    %esp,%ebp
  80addf:	57                   	push   %edi
  80ade0:	56                   	push   %esi
  80ade1:	53                   	push   %ebx
  80ade2:	83 ec 1c             	sub    $0x1c,%esp
  80ade5:	0f b7 7d 18          	movzwl 0x18(%ebp),%edi
  80ade9:	0f b7 45 1c          	movzwl 0x1c(%ebp),%eax
  80aded:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80adf1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80adf8:	00 
  80adf9:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80ae00:	00 
  80ae01:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ae08:	e8 29 cf ff ff       	call   807d36 <pbuf_alloc>
  80ae0d:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  80ae0f:	85 c0                	test   %eax,%eax
  80ae11:	0f 84 1a 01 00 00    	je     80af31 <tcp_rst+0x155>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80ae17:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80ae1c:	77 1c                	ja     80ae3a <tcp_rst+0x5e>
  80ae1e:	c7 44 24 08 50 39 81 	movl   $0x813950,0x8(%esp)
  80ae25:	00 
  80ae26:	c7 44 24 04 be 02 00 	movl   $0x2be,0x4(%esp)
  80ae2d:	00 
  80ae2e:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80ae35:	e8 72 5a ff ff       	call   8008ac <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80ae3a:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  80ae3d:	0f b7 c7             	movzwl %di,%eax
  80ae40:	89 04 24             	mov    %eax,(%esp)
  80ae43:	e8 47 fa ff ff       	call   80a88f <htons>
  80ae48:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  80ae4b:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  80ae4f:	89 04 24             	mov    %eax,(%esp)
  80ae52:	e8 38 fa ff ff       	call   80a88f <htons>
  80ae57:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  80ae5b:	8b 45 08             	mov    0x8(%ebp),%eax
  80ae5e:	89 04 24             	mov    %eax,(%esp)
  80ae61:	e8 56 fa ff ff       	call   80a8bc <htonl>
  80ae66:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  80ae69:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ae6c:	89 04 24             	mov    %eax,(%esp)
  80ae6f:	e8 48 fa ff ff       	call   80a8bc <htonl>
  80ae74:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  80ae77:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80ae7b:	89 04 24             	mov    %eax,(%esp)
  80ae7e:	e8 22 fa ff ff       	call   80a8a5 <ntohs>
  80ae83:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80ae88:	83 c8 14             	or     $0x14,%eax
  80ae8b:	89 04 24             	mov    %eax,(%esp)
  80ae8e:	e8 fc f9 ff ff       	call   80a88f <htons>
  80ae93:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  80ae97:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80ae9e:	e8 ec f9 ff ff       	call   80a88f <htons>
  80aea3:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80aea7:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80aead:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80aeb1:	89 04 24             	mov    %eax,(%esp)
  80aeb4:	e8 ec f9 ff ff       	call   80a8a5 <ntohs>
  80aeb9:	83 e0 3f             	and    $0x3f,%eax
  80aebc:	80 cc 50             	or     $0x50,%ah
  80aebf:	89 04 24             	mov    %eax,(%esp)
  80aec2:	e8 c8 f9 ff ff       	call   80a88f <htons>
  80aec7:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80aecb:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  80aed1:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80aed5:	89 44 24 10          	mov    %eax,0x10(%esp)
  80aed9:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80aee0:	00 
  80aee1:	8b 45 14             	mov    0x14(%ebp),%eax
  80aee4:	89 44 24 08          	mov    %eax,0x8(%esp)
  80aee8:	8b 45 10             	mov    0x10(%ebp),%eax
  80aeeb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80aeef:	89 34 24             	mov    %esi,(%esp)
  80aef2:	e8 99 f6 ff ff       	call   80a590 <inet_chksum_pseudo>
  80aef7:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  80aefb:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80af02:	00 
  80af03:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80af0a:	00 
  80af0b:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80af12:	00 
  80af13:	8b 45 14             	mov    0x14(%ebp),%eax
  80af16:	89 44 24 08          	mov    %eax,0x8(%esp)
  80af1a:	8b 45 10             	mov    0x10(%ebp),%eax
  80af1d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80af21:	89 34 24             	mov    %esi,(%esp)
  80af24:	e8 ce e7 ff ff       	call   8096f7 <ip_output>
  pbuf_free(p);
  80af29:	89 34 24             	mov    %esi,(%esp)
  80af2c:	e8 42 cb ff ff       	call   807a73 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  80af31:	83 c4 1c             	add    $0x1c,%esp
  80af34:	5b                   	pop    %ebx
  80af35:	5e                   	pop    %esi
  80af36:	5f                   	pop    %edi
  80af37:	5d                   	pop    %ebp
  80af38:	c3                   	ret    

0080af39 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  80af39:	55                   	push   %ebp
  80af3a:	89 e5                	mov    %esp,%ebp
  80af3c:	57                   	push   %edi
  80af3d:	56                   	push   %esi
  80af3e:	53                   	push   %ebx
  80af3f:	83 ec 3c             	sub    $0x3c,%esp
  80af42:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80af45:	b8 00 00 00 00       	mov    $0x0,%eax
  80af4a:	39 3d e4 e5 b3 00    	cmp    %edi,0xb3e5e4
  80af50:	0f 84 95 04 00 00    	je     80b3eb <tcp_output+0x4b2>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  80af56:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80af5a:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80af5e:	0f b7 c8             	movzwl %ax,%ecx
  80af61:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  80af64:	66 39 d0             	cmp    %dx,%ax
  80af67:	72 06                	jb     80af6f <tcp_output+0x36>
  80af69:	0f b7 d2             	movzwl %dx,%edx
  80af6c:	89 55 ec             	mov    %edx,-0x14(%ebp)

  seg = pcb->unsent;
  80af6f:	8b 77 74             	mov    0x74(%edi),%esi

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80af72:	8b 47 78             	mov    0x78(%edi),%eax
  80af75:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if (useg != NULL) {
  80af78:	85 c0                	test   %eax,%eax
  80af7a:	74 0e                	je     80af8a <tcp_output+0x51>
    for (; useg->next != NULL; useg = useg->next);
  80af7c:	8b 55 e8             	mov    -0x18(%ebp),%edx
  80af7f:	8b 02                	mov    (%edx),%eax
  80af81:	85 c0                	test   %eax,%eax
  80af83:	74 05                	je     80af8a <tcp_output+0x51>
  80af85:	89 45 e8             	mov    %eax,-0x18(%ebp)
  80af88:	eb f2                	jmp    80af7c <tcp_output+0x43>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80af8a:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  80af8e:	74 25                	je     80afb5 <tcp_output+0x7c>
  80af90:	85 f6                	test   %esi,%esi
  80af92:	74 31                	je     80afc5 <tcp_output+0x8c>
  80af94:	8b 46 10             	mov    0x10(%esi),%eax
  80af97:	8b 40 04             	mov    0x4(%eax),%eax
  80af9a:	89 04 24             	mov    %eax,(%esp)
  80af9d:	e8 4e fb ff ff       	call   80aaf0 <ntohl>
  80afa2:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80afa6:	2b 57 48             	sub    0x48(%edi),%edx
  80afa9:	01 c2                	add    %eax,%edx
  80afab:	39 55 ec             	cmp    %edx,-0x14(%ebp)
  80afae:	72 15                	jb     80afc5 <tcp_output+0x8c>
  80afb0:	e9 c1 03 00 00       	jmp    80b376 <tcp_output+0x43d>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80afb5:	85 f6                	test   %esi,%esi
  80afb7:	0f 85 b9 03 00 00    	jne    80b376 <tcp_output+0x43d>
  80afbd:	8d 76 00             	lea    0x0(%esi),%esi
  80afc0:	e9 10 04 00 00       	jmp    80b3d5 <tcp_output+0x49c>
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80afc5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80afcc:	00 
  80afcd:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80afd4:	00 
  80afd5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80afdc:	e8 55 cd ff ff       	call   807d36 <pbuf_alloc>
  80afe1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (p == NULL) {
  80afe4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80afe9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80afed:	0f 84 f8 03 00 00    	je     80b3eb <tcp_output+0x4b2>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80aff3:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  80aff7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80affa:	8b 59 04             	mov    0x4(%ecx),%ebx
    tcphdr->src = htons(pcb->local_port);
  80affd:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80b001:	89 04 24             	mov    %eax,(%esp)
  80b004:	e8 86 f8 ff ff       	call   80a88f <htons>
  80b009:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  80b00c:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  80b010:	89 04 24             	mov    %eax,(%esp)
  80b013:	e8 77 f8 ff ff       	call   80a88f <htons>
  80b018:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  80b01c:	8b 47 54             	mov    0x54(%edi),%eax
  80b01f:	89 04 24             	mov    %eax,(%esp)
  80b022:	e8 95 f8 ff ff       	call   80a8bc <htonl>
  80b027:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b02a:	8b 47 24             	mov    0x24(%edi),%eax
  80b02d:	89 04 24             	mov    %eax,(%esp)
  80b030:	e8 87 f8 ff ff       	call   80a8bc <htonl>
  80b035:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  80b038:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b03c:	89 04 24             	mov    %eax,(%esp)
  80b03f:	e8 61 f8 ff ff       	call   80a8a5 <ntohs>
  80b044:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80b049:	83 c8 10             	or     $0x10,%eax
  80b04c:	89 04 24             	mov    %eax,(%esp)
  80b04f:	e8 3b f8 ff ff       	call   80a88f <htons>
  80b054:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b058:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80b05c:	89 04 24             	mov    %eax,(%esp)
  80b05f:	e8 2b f8 ff ff       	call   80a88f <htons>
  80b064:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  80b068:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80b06e:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b072:	89 04 24             	mov    %eax,(%esp)
  80b075:	e8 2b f8 ff ff       	call   80a8a5 <ntohs>
  80b07a:	83 e0 3f             	and    $0x3f,%eax
  80b07d:	80 cc 50             	or     $0x50,%ah
  80b080:	89 04 24             	mov    %eax,(%esp)
  80b083:	e8 07 f8 ff ff       	call   80a88f <htons>
  80b088:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80b08c:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80b092:	8d 77 04             	lea    0x4(%edi),%esi
  80b095:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b098:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80b09c:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b0a0:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b0a7:	00 
  80b0a8:	89 74 24 08          	mov    %esi,0x8(%esp)
  80b0ac:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80b0b0:	89 14 24             	mov    %edx,(%esp)
  80b0b3:	e8 d8 f4 ff ff       	call   80a590 <inet_chksum_pseudo>
  80b0b8:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80b0bc:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b0c3:	00 
  80b0c4:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80b0c8:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b0cc:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80b0d0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b0d4:	89 74 24 08          	mov    %esi,0x8(%esp)
  80b0d8:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80b0dc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80b0df:	89 0c 24             	mov    %ecx,(%esp)
  80b0e2:	e8 10 e6 ff ff       	call   8096f7 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80b0e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b0ea:	89 04 24             	mov    %eax,(%esp)
  80b0ed:	e8 81 c9 ff ff       	call   807a73 <pbuf_free>
  80b0f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80b0f7:	e9 ef 02 00 00       	jmp    80b3eb <tcp_output+0x4b2>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80b0fc:	8b 46 10             	mov    0x10(%esi),%eax
  80b0ff:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b103:	89 04 24             	mov    %eax,(%esp)
  80b106:	e8 9a f7 ff ff       	call   80a8a5 <ntohs>
  80b10b:	a8 04                	test   $0x4,%al
  80b10d:	74 1c                	je     80b12b <tcp_output+0x1f2>
  80b10f:	c7 44 24 08 0c 3b 81 	movl   $0x813b0c,0x8(%esp)
  80b116:	00 
  80b117:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
  80b11e:	00 
  80b11f:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80b126:	e8 81 57 ff ff       	call   8008ac <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80b12b:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b12f:	74 1d                	je     80b14e <tcp_output+0x215>
  80b131:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80b135:	f6 c2 40             	test   $0x40,%dl
  80b138:	75 14                	jne    80b14e <tcp_output+0x215>
  80b13a:	8b 47 74             	mov    0x74(%edi),%eax
  80b13d:	85 c0                	test   %eax,%eax
  80b13f:	0f 84 9b 02 00 00    	je     80b3e0 <tcp_output+0x4a7>
  80b145:	83 38 00             	cmpl   $0x0,(%eax)
  80b148:	0f 84 92 02 00 00    	je     80b3e0 <tcp_output+0x4a7>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  80b14e:	8b 06                	mov    (%esi),%eax
  80b150:	89 47 74             	mov    %eax,0x74(%edi)

    if (pcb->state != SYN_SENT) {
  80b153:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  80b157:	74 25                	je     80b17e <tcp_output+0x245>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  80b159:	8b 5e 10             	mov    0x10(%esi),%ebx
  80b15c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b160:	89 04 24             	mov    %eax,(%esp)
  80b163:	e8 3d f7 ff ff       	call   80a8a5 <ntohs>
  80b168:	83 c8 10             	or     $0x10,%eax
  80b16b:	0f b7 c0             	movzwl %ax,%eax
  80b16e:	89 04 24             	mov    %eax,(%esp)
  80b171:	e8 19 f7 ff ff       	call   80a88f <htons>
  80b176:	66 89 43 0c          	mov    %ax,0xc(%ebx)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80b17a:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b17e:	8b 5e 10             	mov    0x10(%esi),%ebx
  80b181:	8b 47 24             	mov    0x24(%edi),%eax
  80b184:	89 04 24             	mov    %eax,(%esp)
  80b187:	e8 30 f7 ff ff       	call   80a8bc <htonl>
  80b18c:	89 43 08             	mov    %eax,0x8(%ebx)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b18f:	8b 5e 10             	mov    0x10(%esi),%ebx
  80b192:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80b196:	89 04 24             	mov    %eax,(%esp)
  80b199:	e8 f1 f6 ff ff       	call   80a88f <htons>
  80b19e:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80b1a2:	89 7d f0             	mov    %edi,-0x10(%ebp)
  80b1a5:	85 ff                	test   %edi,%edi
  80b1a7:	74 05                	je     80b1ae <tcp_output+0x275>
  80b1a9:	83 3f 00             	cmpl   $0x0,(%edi)
  80b1ac:	75 22                	jne    80b1d0 <tcp_output+0x297>
    netif = ip_route(&(pcb->remote_ip));
  80b1ae:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80b1b1:	89 14 24             	mov    %edx,(%esp)
  80b1b4:	e8 de e4 ff ff       	call   809697 <ip_route>
    if (netif == NULL) {
  80b1b9:	85 c0                	test   %eax,%eax
  80b1bb:	0f 84 c3 00 00 00    	je     80b284 <tcp_output+0x34b>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  80b1c1:	ba 00 00 00 00       	mov    $0x0,%edx
  80b1c6:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80b1c9:	74 03                	je     80b1ce <tcp_output+0x295>
  80b1cb:	8b 50 04             	mov    0x4(%eax),%edx
  80b1ce:	89 17                	mov    %edx,(%edi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  80b1d0:	66 83 7f 32 ff       	cmpw   $0xffffffff,0x32(%edi)
  80b1d5:	75 06                	jne    80b1dd <tcp_output+0x2a4>
    pcb->rtime = 0;
  80b1d7:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

  if (pcb->rttest == 0) {
  80b1dd:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  80b1e1:	75 19                	jne    80b1fc <tcp_output+0x2c3>
    pcb->rttest = tcp_ticks;
  80b1e3:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  80b1e8:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  80b1eb:	8b 46 10             	mov    0x10(%esi),%eax
  80b1ee:	8b 40 04             	mov    0x4(%eax),%eax
  80b1f1:	89 04 24             	mov    %eax,(%esp)
  80b1f4:	e8 f7 f8 ff ff       	call   80aaf0 <ntohl>
  80b1f9:	89 47 3c             	mov    %eax,0x3c(%edi)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  80b1fc:	8b 46 04             	mov    0x4(%esi),%eax
  80b1ff:	8b 56 10             	mov    0x10(%esi),%edx
  80b202:	66 2b 50 04          	sub    0x4(%eax),%dx

  seg->p->len -= len;
  80b206:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  80b20a:	8b 46 04             	mov    0x4(%esi),%eax
  80b20d:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  80b211:	8b 56 04             	mov    0x4(%esi),%edx
  80b214:	8b 46 10             	mov    0x10(%esi),%eax
  80b217:	89 42 04             	mov    %eax,0x4(%edx)

  seg->tcphdr->chksum = 0;
  80b21a:	8b 46 10             	mov    0x10(%esi),%eax
  80b21d:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80b223:	8b 5e 10             	mov    0x10(%esi),%ebx
  80b226:	8b 56 04             	mov    0x4(%esi),%edx
  80b229:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80b22d:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b231:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b238:	00 
  80b239:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80b23c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80b240:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80b243:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b247:	89 14 24             	mov    %edx,(%esp)
  80b24a:	e8 41 f3 ff ff       	call   80a590 <inet_chksum_pseudo>
  80b24f:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80b253:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b25a:	00 
  80b25b:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80b25f:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b263:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80b267:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b26b:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80b26e:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b272:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  80b275:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80b279:	8b 46 04             	mov    0x4(%esi),%eax
  80b27c:	89 04 24             	mov    %eax,(%esp)
  80b27f:	e8 73 e4 ff ff       	call   8096f7 <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  80b284:	8b 46 10             	mov    0x10(%esi),%eax
  80b287:	8b 40 04             	mov    0x4(%eax),%eax
  80b28a:	89 04 24             	mov    %eax,(%esp)
  80b28d:	e8 5e f8 ff ff       	call   80aaf0 <ntohl>
  80b292:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80b295:	0f b7 5e 0c          	movzwl 0xc(%esi),%ebx
  80b299:	8b 46 10             	mov    0x10(%esi),%eax
  80b29c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b2a0:	89 04 24             	mov    %eax,(%esp)
  80b2a3:	e8 fd f5 ff ff       	call   80a8a5 <ntohs>
  80b2a8:	a8 01                	test   $0x1,%al
  80b2aa:	75 18                	jne    80b2c4 <tcp_output+0x38b>
  80b2ac:	8b 46 10             	mov    0x10(%esi),%eax
  80b2af:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b2b3:	89 04 24             	mov    %eax,(%esp)
  80b2b6:	e8 ea f5 ff ff       	call   80a8a5 <ntohs>
  80b2bb:	ba 00 00 00 00       	mov    $0x0,%edx
  80b2c0:	a8 02                	test   $0x2,%al
  80b2c2:	74 05                	je     80b2c9 <tcp_output+0x390>
  80b2c4:	ba 01 00 00 00       	mov    $0x1,%edx
  80b2c9:	0f b7 c3             	movzwl %bx,%eax
  80b2cc:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80b2cf:	03 45 e0             	add    -0x20(%ebp),%eax
  80b2d2:	89 47 54             	mov    %eax,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  80b2d5:	39 47 58             	cmp    %eax,0x58(%edi)
  80b2d8:	79 03                	jns    80b2dd <tcp_output+0x3a4>
      pcb->snd_max = pcb->snd_nxt;
  80b2da:	89 47 58             	mov    %eax,0x58(%edi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  80b2dd:	0f b7 5e 0c          	movzwl 0xc(%esi),%ebx
  80b2e1:	8b 46 10             	mov    0x10(%esi),%eax
  80b2e4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b2e8:	89 04 24             	mov    %eax,(%esp)
  80b2eb:	e8 b5 f5 ff ff       	call   80a8a5 <ntohs>
  80b2f0:	a8 01                	test   $0x1,%al
  80b2f2:	75 18                	jne    80b30c <tcp_output+0x3d3>
  80b2f4:	8b 46 10             	mov    0x10(%esi),%eax
  80b2f7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b2fb:	89 04 24             	mov    %eax,(%esp)
  80b2fe:	e8 a2 f5 ff ff       	call   80a8a5 <ntohs>
  80b303:	ba 00 00 00 00       	mov    $0x0,%edx
  80b308:	a8 02                	test   $0x2,%al
  80b30a:	74 05                	je     80b311 <tcp_output+0x3d8>
  80b30c:	ba 01 00 00 00       	mov    $0x1,%edx
  80b311:	0f b7 c3             	movzwl %bx,%eax
  80b314:	01 c2                	add    %eax,%edx
  80b316:	74 4d                	je     80b365 <tcp_output+0x42c>
      seg->next = NULL;
  80b318:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  80b31e:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b322:	75 08                	jne    80b32c <tcp_output+0x3f3>
        pcb->unacked = seg;
  80b324:	89 77 78             	mov    %esi,0x78(%edi)
  80b327:	89 75 e8             	mov    %esi,-0x18(%ebp)
  80b32a:	eb 41                	jmp    80b36d <tcp_output+0x434>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  80b32c:	8b 46 10             	mov    0x10(%esi),%eax
  80b32f:	8b 40 04             	mov    0x4(%eax),%eax
  80b332:	89 04 24             	mov    %eax,(%esp)
  80b335:	e8 b6 f7 ff ff       	call   80aaf0 <ntohl>
  80b33a:	89 c3                	mov    %eax,%ebx
  80b33c:	8b 55 e8             	mov    -0x18(%ebp),%edx
  80b33f:	8b 42 10             	mov    0x10(%edx),%eax
  80b342:	8b 40 04             	mov    0x4(%eax),%eax
  80b345:	89 04 24             	mov    %eax,(%esp)
  80b348:	e8 a3 f7 ff ff       	call   80aaf0 <ntohl>
  80b34d:	39 c3                	cmp    %eax,%ebx
  80b34f:	79 0a                	jns    80b35b <tcp_output+0x422>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  80b351:	8b 47 78             	mov    0x78(%edi),%eax
  80b354:	89 06                	mov    %eax,(%esi)
          pcb->unacked = seg;
  80b356:	89 77 78             	mov    %esi,0x78(%edi)
  80b359:	eb 12                	jmp    80b36d <tcp_output+0x434>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  80b35b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  80b35e:	89 31                	mov    %esi,(%ecx)
  80b360:	89 75 e8             	mov    %esi,-0x18(%ebp)
  80b363:	eb 08                	jmp    80b36d <tcp_output+0x434>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  80b365:	89 34 24             	mov    %esi,(%esp)
  80b368:	e8 91 d2 ff ff       	call   8085fe <tcp_seg_free>
    }
    seg = pcb->unsent;
  80b36d:	8b 77 74             	mov    0x74(%edi),%esi
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80b370:	85 f6                	test   %esi,%esi
  80b372:	74 61                	je     80b3d5 <tcp_output+0x49c>
  80b374:	eb 06                	jmp    80b37c <tcp_output+0x443>

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80b376:	8d 47 04             	lea    0x4(%edi),%eax
  80b379:	89 45 dc             	mov    %eax,-0x24(%ebp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80b37c:	8b 46 10             	mov    0x10(%esi),%eax
  80b37f:	8b 40 04             	mov    0x4(%eax),%eax
  80b382:	89 04 24             	mov    %eax,(%esp)
  80b385:	e8 66 f7 ff ff       	call   80aaf0 <ntohl>
  80b38a:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80b38e:	2b 57 48             	sub    0x48(%edi),%edx
  80b391:	01 c2                	add    %eax,%edx
  80b393:	39 55 ec             	cmp    %edx,-0x14(%ebp)
  80b396:	0f 83 60 fd ff ff    	jae    80b0fc <tcp_output+0x1c3>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80b39c:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80b3a3:	75 30                	jne    80b3d5 <tcp_output+0x49c>
  80b3a5:	8b 46 10             	mov    0x10(%esi),%eax
  80b3a8:	8b 40 04             	mov    0x4(%eax),%eax
  80b3ab:	89 04 24             	mov    %eax,(%esp)
  80b3ae:	e8 3d f7 ff ff       	call   80aaf0 <ntohl>
  80b3b3:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80b3b7:	2b 57 48             	sub    0x48(%edi),%edx
  80b3ba:	01 c2                	add    %eax,%edx
  80b3bc:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80b3c0:	39 c2                	cmp    %eax,%edx
  80b3c2:	76 11                	jbe    80b3d5 <tcp_output+0x49c>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  80b3c4:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  80b3cb:	00 00 00 
    pcb->persist_backoff = 1;
  80b3ce:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  80b3d5:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  80b3d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3de:	eb 0b                	jmp    80b3eb <tcp_output+0x4b2>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80b3e0:	f6 c2 a0             	test   $0xa0,%dl
  80b3e3:	0f 85 65 fd ff ff    	jne    80b14e <tcp_output+0x215>
  80b3e9:	eb b1                	jmp    80b39c <tcp_output+0x463>
    pcb->persist_backoff = 1;
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
  80b3eb:	83 c4 3c             	add    $0x3c,%esp
  80b3ee:	5b                   	pop    %ebx
  80b3ef:	5e                   	pop    %esi
  80b3f0:	5f                   	pop    %edi
  80b3f1:	5d                   	pop    %ebp
  80b3f2:	c3                   	ret    

0080b3f3 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  80b3f3:	55                   	push   %ebp
  80b3f4:	89 e5                	mov    %esp,%ebp
  80b3f6:	53                   	push   %ebx
  80b3f7:	83 ec 04             	sub    $0x4,%esp
  80b3fa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b3fd:	8b 4b 78             	mov    0x78(%ebx),%ecx
  80b400:	85 c9                	test   %ecx,%ecx
  80b402:	74 34                	je     80b438 <tcp_rexmit+0x45>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  80b404:	8b 11                	mov    (%ecx),%edx
  pcb->unacked->next = pcb->unsent;
  80b406:	8b 43 74             	mov    0x74(%ebx),%eax
  80b409:	89 01                	mov    %eax,(%ecx)
  pcb->unsent = pcb->unacked;
  80b40b:	8b 43 78             	mov    0x78(%ebx),%eax
  80b40e:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80b411:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b414:	8b 40 10             	mov    0x10(%eax),%eax
  80b417:	8b 40 04             	mov    0x4(%eax),%eax
  80b41a:	89 04 24             	mov    %eax,(%esp)
  80b41d:	e8 ce f6 ff ff       	call   80aaf0 <ntohl>
  80b422:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  80b425:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80b429:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80b430:	89 1c 24             	mov    %ebx,(%esp)
  80b433:	e8 01 fb ff ff       	call   80af39 <tcp_output>
}
  80b438:	83 c4 04             	add    $0x4,%esp
  80b43b:	5b                   	pop    %ebx
  80b43c:	5d                   	pop    %ebp
  80b43d:	c3                   	ret    

0080b43e <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  80b43e:	55                   	push   %ebp
  80b43f:	89 e5                	mov    %esp,%ebp
  80b441:	53                   	push   %ebx
  80b442:	83 ec 04             	sub    $0x4,%esp
  80b445:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b448:	8b 53 78             	mov    0x78(%ebx),%edx
  80b44b:	85 d2                	test   %edx,%edx
  80b44d:	74 40                	je     80b48f <tcp_rexmit_rto+0x51>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  80b44f:	8b 02                	mov    (%edx),%eax
  80b451:	85 c0                	test   %eax,%eax
  80b453:	74 04                	je     80b459 <tcp_rexmit_rto+0x1b>
  80b455:	89 c2                	mov    %eax,%edx
  80b457:	eb f6                	jmp    80b44f <tcp_rexmit_rto+0x11>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  80b459:	8b 43 74             	mov    0x74(%ebx),%eax
  80b45c:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  80b45e:	8b 43 78             	mov    0x78(%ebx),%eax
  80b461:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  80b464:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b46b:	8b 40 10             	mov    0x10(%eax),%eax
  80b46e:	8b 40 04             	mov    0x4(%eax),%eax
  80b471:	89 04 24             	mov    %eax,(%esp)
  80b474:	e8 77 f6 ff ff       	call   80aaf0 <ntohl>
  80b479:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  80b47c:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  80b480:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  80b487:	89 1c 24             	mov    %ebx,(%esp)
  80b48a:	e8 aa fa ff ff       	call   80af39 <tcp_output>
}
  80b48f:	83 c4 04             	add    $0x4,%esp
  80b492:	5b                   	pop    %ebx
  80b493:	5d                   	pop    %ebp
  80b494:	c3                   	ret    

0080b495 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  80b495:	55                   	push   %ebp
  80b496:	89 e5                	mov    %esp,%ebp
  80b498:	57                   	push   %edi
  80b499:	56                   	push   %esi
  80b49a:	53                   	push   %ebx
  80b49b:	83 ec 6c             	sub    $0x6c,%esp
  80b49e:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b4a1:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  80b4a5:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  80b4a9:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  80b4ad:	88 4d c7             	mov    %cl,-0x39(%ebp)
  80b4b0:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  80b4b4:	88 45 a8             	mov    %al,-0x58(%ebp)
  80b4b7:	0f b6 4d 20          	movzbl 0x20(%ebp),%ecx
  80b4bb:	88 4d a7             	mov    %cl,-0x59(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  80b4be:	66 83 7d c8 00       	cmpw   $0x0,-0x38(%ebp)
  80b4c3:	74 20                	je     80b4e5 <tcp_enqueue+0x50>
  80b4c5:	84 c9                	test   %cl,%cl
  80b4c7:	74 1c                	je     80b4e5 <tcp_enqueue+0x50>
  80b4c9:	c7 44 24 08 80 39 81 	movl   $0x813980,0x8(%esp)
  80b4d0:	00 
  80b4d1:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  80b4d8:	00 
  80b4d9:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80b4e0:	e8 c7 53 ff ff       	call   8008ac <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  80b4e5:	85 d2                	test   %edx,%edx
  80b4e7:	0f 95 45 ca          	setne  -0x36(%ebp)
  80b4eb:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80b4ef:	0f 95 45 cb          	setne  -0x35(%ebp)
  80b4f3:	80 7d ca 00          	cmpb   $0x0,-0x36(%ebp)
  80b4f7:	74 22                	je     80b51b <tcp_enqueue+0x86>
  80b4f9:	80 7d cb 00          	cmpb   $0x0,-0x35(%ebp)
  80b4fd:	74 1c                	je     80b51b <tcp_enqueue+0x86>
  80b4ff:	c7 44 24 08 c0 39 81 	movl   $0x8139c0,0x8(%esp)
  80b506:	00 
  80b507:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
  80b50e:	00 
  80b50f:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80b516:	e8 91 53 ff ff       	call   8008ac <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80b51b:	0f b7 4d c8          	movzwl -0x38(%ebp),%ecx
  80b51f:	8b 45 08             	mov    0x8(%ebp),%eax
  80b522:	66 3b 48 6e          	cmp    0x6e(%eax),%cx
  80b526:	76 0e                	jbe    80b536 <tcp_enqueue+0xa1>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  80b528:	80 48 20 80          	orb    $0x80,0x20(%eax)
  80b52c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b531:	e9 42 06 00 00       	jmp    80bb78 <tcp_enqueue+0x6e3>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  80b536:	8b 45 08             	mov    0x8(%ebp),%eax
  80b539:	8b 40 68             	mov    0x68(%eax),%eax
  80b53c:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  80b53f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80b542:	0f b7 49 70          	movzwl 0x70(%ecx),%ecx
  80b546:	66 89 4d e2          	mov    %cx,-0x1e(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80b54a:	66 83 f9 1f          	cmp    $0x1f,%cx
  80b54e:	76 11                	jbe    80b561 <tcp_enqueue+0xcc>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  80b550:	8b 45 08             	mov    0x8(%ebp),%eax
  80b553:	80 48 20 80          	orb    $0x80,0x20(%eax)
  80b557:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b55c:	e9 17 06 00 00       	jmp    80bb78 <tcp_enqueue+0x6e3>
    return ERR_MEM;
  }
  if (queuelen != 0) {
  80b561:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  80b566:	74 33                	je     80b59b <tcp_enqueue+0x106>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80b568:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80b56b:	83 79 78 00          	cmpl   $0x0,0x78(%ecx)
  80b56f:	0f 85 b3 05 00 00    	jne    80bb28 <tcp_enqueue+0x693>
  80b575:	83 79 74 00          	cmpl   $0x0,0x74(%ecx)
  80b579:	0f 85 a9 05 00 00    	jne    80bb28 <tcp_enqueue+0x693>
  80b57f:	c7 44 24 08 08 3a 81 	movl   $0x813a08,0x8(%esp)
  80b586:	00 
  80b587:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  80b58e:	00 
  80b58f:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80b596:	e8 11 53 ff ff       	call   8008ac <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  80b59b:	8b 45 08             	mov    0x8(%ebp),%eax
  80b59e:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b5a2:	75 0a                	jne    80b5ae <tcp_enqueue+0x119>
  80b5a4:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  80b5a8:	0f 84 7a 05 00 00    	je     80bb28 <tcp_enqueue+0x693>
  80b5ae:	c7 44 24 08 44 3a 81 	movl   $0x813a44,0x8(%esp)
  80b5b5:	00 
  80b5b6:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  80b5bd:	00 
  80b5be:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80b5c5:	e8 e2 52 ff ff       	call   8008ac <_panic>
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  80b5ca:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  80b5ce:	01 45 d4             	add    %eax,-0x2c(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  80b5d1:	01 45 dc             	add    %eax,-0x24(%ebp)
  80b5d4:	89 f3                	mov    %esi,%ebx
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80b5d6:	8b 55 08             	mov    0x8(%ebp),%edx
  80b5d9:	0f b7 7a 34          	movzwl 0x34(%edx),%edi

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80b5dd:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80b5e4:	e8 61 bd ff ff       	call   80734a <memp_malloc>
    if (seg == NULL) {
  80b5e9:	85 c0                	test   %eax,%eax
  80b5eb:	0f 84 df 04 00 00    	je     80bad0 <tcp_enqueue+0x63b>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80b5f1:	89 c6                	mov    %eax,%esi
    if (seg == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  80b5f3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  80b5f9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  80b600:	80 7d cf 00          	cmpb   $0x0,-0x31(%ebp)
  80b604:	74 05                	je     80b60b <tcp_enqueue+0x176>
  80b606:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80b609:	eb 22                	jmp    80b62d <tcp_enqueue+0x198>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  80b60b:	85 db                	test   %ebx,%ebx
  80b60d:	75 1c                	jne    80b62b <tcp_enqueue+0x196>
  80b60f:	c7 44 24 08 23 3b 81 	movl   $0x813b23,0x8(%esp)
  80b616:	00 
  80b617:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80b61e:	00 
  80b61f:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80b626:	e8 81 52 ff ff       	call   8008ac <_panic>
      useg->next = seg;
  80b62b:	89 03                	mov    %eax,(%ebx)
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80b62d:	0f b7 4d d8          	movzwl -0x28(%ebp),%ecx
  80b631:	66 89 4d da          	mov    %cx,-0x26(%ebp)
  80b635:	66 39 f9             	cmp    %di,%cx
  80b638:	76 04                	jbe    80b63e <tcp_enqueue+0x1a9>
  80b63a:	66 89 7d da          	mov    %di,-0x26(%ebp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  80b63e:	80 7d cb 00          	cmpb   $0x0,-0x35(%ebp)
  80b642:	74 6c                	je     80b6b0 <tcp_enqueue+0x21b>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80b644:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b64b:	00 
  80b64c:	0f b6 45 a7          	movzbl -0x59(%ebp),%eax
  80b650:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b654:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b65b:	e8 d6 c6 ff ff       	call   807d36 <pbuf_alloc>
  80b660:	89 c2                	mov    %eax,%edx
  80b662:	89 46 04             	mov    %eax,0x4(%esi)
  80b665:	85 c0                	test   %eax,%eax
  80b667:	0f 84 63 04 00 00    	je     80bad0 <tcp_enqueue+0x63b>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80b66d:	0f b6 45 a7          	movzbl -0x59(%ebp),%eax
  80b671:	66 39 42 0a          	cmp    %ax,0xa(%edx)
  80b675:	73 1c                	jae    80b693 <tcp_enqueue+0x1fe>
  80b677:	c7 44 24 08 78 3a 81 	movl   $0x813a78,0x8(%esp)
  80b67e:	00 
  80b67f:	c7 44 24 04 df 00 00 	movl   $0xdf,0x4(%esp)
  80b686:	00 
  80b687:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80b68e:	e8 19 52 ff ff       	call   8008ac <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  80b693:	89 14 24             	mov    %edx,(%esp)
  80b696:	e8 95 bf ff ff       	call   807630 <pbuf_clen>
  80b69b:	0f b6 c0             	movzbl %al,%eax
  80b69e:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      seg->dataptr = seg->p->payload;
  80b6a2:	8b 46 04             	mov    0x4(%esi),%eax
  80b6a5:	8b 40 04             	mov    0x4(%eax),%eax
  80b6a8:	89 46 08             	mov    %eax,0x8(%esi)
  80b6ab:	e9 1e 01 00 00       	jmp    80b7ce <tcp_enqueue+0x339>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80b6b0:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
  80b6b4:	0f 84 8f 00 00 00    	je     80b749 <tcp_enqueue+0x2b4>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  80b6ba:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b6c1:	00 
  80b6c2:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  80b6c6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b6ca:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b6d1:	e8 60 c6 ff ff       	call   807d36 <pbuf_alloc>
  80b6d6:	89 46 04             	mov    %eax,0x4(%esi)
  80b6d9:	85 c0                	test   %eax,%eax
  80b6db:	0f 84 ef 03 00 00    	je     80bad0 <tcp_enqueue+0x63b>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  80b6e1:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
  80b6e5:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  80b6e9:	76 1c                	jbe    80b707 <tcp_enqueue+0x272>
  80b6eb:	c7 44 24 08 a0 3a 81 	movl   $0x813aa0,0x8(%esp)
  80b6f2:	00 
  80b6f3:	c7 44 24 04 ea 00 00 	movl   $0xea,0x4(%esp)
  80b6fa:	00 
  80b6fb:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80b702:	e8 a5 51 ff ff       	call   8008ac <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80b707:	89 04 24             	mov    %eax,(%esp)
  80b70a:	e8 21 bf ff ff       	call   807630 <pbuf_clen>
  80b70f:	89 c3                	mov    %eax,%ebx
      if (arg != NULL) {
  80b711:	80 7d ca 00          	cmpb   $0x0,-0x36(%ebp)
  80b715:	74 1d                	je     80b734 <tcp_enqueue+0x29f>
        MEMCPY(seg->p->payload, ptr, seglen);
  80b717:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  80b71b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b71f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80b722:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80b726:	8b 46 04             	mov    0x4(%esi),%eax
  80b729:	8b 40 04             	mov    0x4(%eax),%eax
  80b72c:	89 04 24             	mov    %eax,(%esp)
  80b72f:	e8 34 5b ff ff       	call   801268 <memcpy>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80b734:	0f b6 c3             	movzbl %bl,%eax
  80b737:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      if (arg != NULL) {
        MEMCPY(seg->p->payload, ptr, seglen);
      }
      seg->dataptr = seg->p->payload;
  80b73b:	8b 46 04             	mov    0x4(%esi),%eax
  80b73e:	8b 40 04             	mov    0x4(%eax),%eax
  80b741:	89 46 08             	mov    %eax,0x8(%esi)
  80b744:	e9 85 00 00 00       	jmp    80b7ce <tcp_enqueue+0x339>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  80b749:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80b750:	00 
  80b751:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  80b755:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b759:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b760:	e8 d1 c5 ff ff       	call   807d36 <pbuf_alloc>
  80b765:	89 c3                	mov    %eax,%ebx
  80b767:	85 c0                	test   %eax,%eax
  80b769:	0f 84 61 03 00 00    	je     80bad0 <tcp_enqueue+0x63b>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
      /* reference the non-volatile payload data */
      p->payload = ptr;
  80b76f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b772:	89 43 04             	mov    %eax,0x4(%ebx)
      seg->dataptr = ptr;
  80b775:	89 46 08             	mov    %eax,0x8(%esi)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  80b778:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b77f:	00 
  80b780:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80b787:	00 
  80b788:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b78f:	e8 a2 c5 ff ff       	call   807d36 <pbuf_alloc>
  80b794:	89 46 04             	mov    %eax,0x4(%esi)
  80b797:	85 c0                	test   %eax,%eax
  80b799:	75 0d                	jne    80b7a8 <tcp_enqueue+0x313>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  80b79b:	89 1c 24             	mov    %ebx,(%esp)
  80b79e:	e8 d0 c2 ff ff       	call   807a73 <pbuf_free>
  80b7a3:	e9 28 03 00 00       	jmp    80bad0 <tcp_enqueue+0x63b>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
      }
      queuelen += pbuf_clen(seg->p);
  80b7a8:	89 04 24             	mov    %eax,(%esp)
  80b7ab:	e8 80 be ff ff       	call   807630 <pbuf_clen>
  80b7b0:	0f b6 c0             	movzbl %al,%eax
  80b7b3:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  80b7b7:	8d 54 02 01          	lea    0x1(%edx,%eax,1),%edx
  80b7bb:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  80b7bf:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80b7c3:	8b 46 04             	mov    0x4(%esi),%eax
  80b7c6:	89 04 24             	mov    %eax,(%esp)
  80b7c9:	e8 95 be ff ff       	call   807663 <pbuf_cat>
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80b7ce:	66 83 7d e2 20       	cmpw   $0x20,-0x1e(%ebp)
  80b7d3:	0f 87 f7 02 00 00    	ja     80bad0 <tcp_enqueue+0x63b>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  80b7d9:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
  80b7dd:	66 89 4e 0c          	mov    %cx,0xc(%esi)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  80b7e1:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b7e8:	00 
  80b7e9:	8b 46 04             	mov    0x4(%esi),%eax
  80b7ec:	89 04 24             	mov    %eax,(%esp)
  80b7ef:	e8 14 bf ff ff       	call   807708 <pbuf_header>
  80b7f4:	84 c0                	test   %al,%al
  80b7f6:	0f 85 d4 02 00 00    	jne    80bad0 <tcp_enqueue+0x63b>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  80b7fc:	8b 46 04             	mov    0x4(%esi),%eax
  80b7ff:	8b 58 04             	mov    0x4(%eax),%ebx
  80b802:	89 5e 10             	mov    %ebx,0x10(%esi)
    seg->tcphdr->src = htons(pcb->local_port);
  80b805:	8b 55 08             	mov    0x8(%ebp),%edx
  80b808:	0f b7 42 1c          	movzwl 0x1c(%edx),%eax
  80b80c:	89 04 24             	mov    %eax,(%esp)
  80b80f:	e8 7b f0 ff ff       	call   80a88f <htons>
  80b814:	66 89 03             	mov    %ax,(%ebx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  80b817:	8b 5e 10             	mov    0x10(%esi),%ebx
  80b81a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80b81d:	0f b7 41 1e          	movzwl 0x1e(%ecx),%eax
  80b821:	89 04 24             	mov    %eax,(%esp)
  80b824:	e8 66 f0 ff ff       	call   80a88f <htons>
  80b829:	66 89 43 02          	mov    %ax,0x2(%ebx)
    seg->tcphdr->seqno = htonl(seqno);
  80b82d:	8b 5e 10             	mov    0x10(%esi),%ebx
  80b830:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80b833:	89 04 24             	mov    %eax,(%esp)
  80b836:	e8 81 f0 ff ff       	call   80a8bc <htonl>
  80b83b:	89 43 04             	mov    %eax,0x4(%ebx)
    seg->tcphdr->urgp = 0;
  80b83e:	8b 46 10             	mov    0x10(%esi),%eax
  80b841:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80b847:	8b 5e 10             	mov    0x10(%esi),%ebx
  80b84a:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b84e:	89 04 24             	mov    %eax,(%esp)
  80b851:	e8 4f f0 ff ff       	call   80a8a5 <ntohs>
  80b856:	83 e0 c0             	and    $0xffffffc0,%eax
  80b859:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
  80b85d:	09 d0                	or     %edx,%eax
  80b85f:	0f b7 c0             	movzwl %ax,%eax
  80b862:	89 04 24             	mov    %eax,(%esp)
  80b865:	e8 25 f0 ff ff       	call   80a88f <htons>
  80b86a:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  80b86e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80b872:	75 23                	jne    80b897 <tcp_enqueue+0x402>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  80b874:	8b 5e 10             	mov    0x10(%esi),%ebx
  80b877:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b87b:	89 04 24             	mov    %eax,(%esp)
  80b87e:	e8 22 f0 ff ff       	call   80a8a5 <ntohs>
  80b883:	83 e0 3f             	and    $0x3f,%eax
  80b886:	80 cc 50             	or     $0x50,%ah
  80b889:	89 04 24             	mov    %eax,(%esp)
  80b88c:	e8 fe ef ff ff       	call   80a88f <htons>
  80b891:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  80b895:	eb 3f                	jmp    80b8d6 <tcp_enqueue+0x441>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80b897:	8b 5e 10             	mov    0x10(%esi),%ebx
  80b89a:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b89e:	89 04 24             	mov    %eax,(%esp)
  80b8a1:	e8 ff ef ff ff       	call   80a8a5 <ntohs>
  80b8a6:	83 e0 3f             	and    $0x3f,%eax
  80b8a9:	66 0b 45 cc          	or     -0x34(%ebp),%ax
  80b8ad:	0f b7 c0             	movzwl %ax,%eax
  80b8b0:	89 04 24             	mov    %eax,(%esp)
  80b8b3:	e8 d7 ef ff ff       	call   80a88f <htons>
  80b8b8:	66 89 43 0c          	mov    %ax,0xc(%ebx)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  80b8bc:	0f b6 45 a7          	movzbl -0x59(%ebp),%eax
  80b8c0:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b8c4:	8b 55 1c             	mov    0x1c(%ebp),%edx
  80b8c7:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b8cb:	8b 46 08             	mov    0x8(%esi),%eax
  80b8ce:	89 04 24             	mov    %eax,(%esp)
  80b8d1:	e8 92 59 ff ff       	call   801268 <memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  80b8d6:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
  80b8da:	66 29 4d d8          	sub    %cx,-0x28(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  80b8de:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80b8e2:	0f 94 45 cf          	sete   -0x31(%ebp)
  80b8e6:	0f 84 de fc ff ff    	je     80b5ca <tcp_enqueue+0x135>
  80b8ec:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
  80b8f1:	0f 85 d3 fc ff ff    	jne    80b5ca <tcp_enqueue+0x135>
  80b8f7:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  80b8fa:	8b 45 08             	mov    0x8(%ebp),%eax
  80b8fd:	8b 58 74             	mov    0x74(%eax),%ebx
  80b900:	85 db                	test   %ebx,%ebx
  80b902:	0f 84 0a 01 00 00    	je     80ba12 <tcp_enqueue+0x57d>
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  80b908:	8b 03                	mov    (%ebx),%eax
  80b90a:	85 c0                	test   %eax,%eax
  80b90c:	74 04                	je     80b912 <tcp_enqueue+0x47d>
  80b90e:	89 c3                	mov    %eax,%ebx
  80b910:	eb f6                	jmp    80b908 <tcp_enqueue+0x473>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80b912:	85 db                	test   %ebx,%ebx
  80b914:	0f 84 f8 00 00 00    	je     80ba12 <tcp_enqueue+0x57d>
  80b91a:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80b91e:	8b 43 10             	mov    0x10(%ebx),%eax
  80b921:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b925:	89 04 24             	mov    %eax,(%esp)
  80b928:	e8 78 ef ff ff       	call   80a8a5 <ntohs>
  80b92d:	a8 01                	test   $0x1,%al
  80b92f:	75 18                	jne    80b949 <tcp_enqueue+0x4b4>
  80b931:	8b 43 10             	mov    0x10(%ebx),%eax
  80b934:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b938:	89 04 24             	mov    %eax,(%esp)
  80b93b:	e8 65 ef ff ff       	call   80a8a5 <ntohs>
  80b940:	ba 00 00 00 00       	mov    $0x0,%edx
  80b945:	a8 02                	test   $0x2,%al
  80b947:	74 05                	je     80b94e <tcp_enqueue+0x4b9>
  80b949:	ba 01 00 00 00       	mov    $0x1,%edx
  80b94e:	0f b7 c7             	movzwl %di,%eax
  80b951:	01 c2                	add    %eax,%edx
  80b953:	0f 84 0b 02 00 00    	je     80bb64 <tcp_enqueue+0x6cf>
  80b959:	8b 43 10             	mov    0x10(%ebx),%eax
  80b95c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b960:	89 04 24             	mov    %eax,(%esp)
  80b963:	e8 3d ef ff ff       	call   80a8a5 <ntohs>
  80b968:	a8 03                	test   $0x3,%al
  80b96a:	0f 85 f4 01 00 00    	jne    80bb64 <tcp_enqueue+0x6cf>
  80b970:	f6 45 c7 03          	testb  $0x3,-0x39(%ebp)
  80b974:	0f 85 ea 01 00 00    	jne    80bb64 <tcp_enqueue+0x6cf>
  80b97a:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b97d:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80b981:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b985:	01 d0                	add    %edx,%eax
  80b987:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80b98a:	0f b7 51 34          	movzwl 0x34(%ecx),%edx
  80b98e:	39 d0                	cmp    %edx,%eax
  80b990:	0f 8f ce 01 00 00    	jg     80bb64 <tcp_enqueue+0x6cf>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  80b996:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80b99d:	ff 
  80b99e:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b9a1:	8b 42 04             	mov    0x4(%edx),%eax
  80b9a4:	89 04 24             	mov    %eax,(%esp)
  80b9a7:	e8 5c bd ff ff       	call   807708 <pbuf_header>
  80b9ac:	84 c0                	test   %al,%al
  80b9ae:	74 1c                	je     80b9cc <tcp_enqueue+0x537>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80b9b0:	c7 44 24 08 30 3b 81 	movl   $0x813b30,0x8(%esp)
  80b9b7:	00 
  80b9b8:	c7 44 24 04 52 01 00 	movl   $0x152,0x4(%esp)
  80b9bf:	00 
  80b9c0:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80b9c7:	e8 e0 4e ff ff       	call   8008ac <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  80b9cc:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80b9cf:	8b 41 04             	mov    0x4(%ecx),%eax
  80b9d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b9d6:	8b 43 04             	mov    0x4(%ebx),%eax
  80b9d9:	89 04 24             	mov    %eax,(%esp)
  80b9dc:	e8 82 bc ff ff       	call   807663 <pbuf_cat>
    useg->len += queue->len;
  80b9e1:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b9e4:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80b9e8:	66 01 43 0c          	add    %ax,0xc(%ebx)
    useg->next = queue->next;
  80b9ec:	8b 02                	mov    (%edx),%eax
  80b9ee:	89 03                	mov    %eax,(%ebx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  80b9f0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80b9f3:	39 ca                	cmp    %ecx,%edx
  80b9f5:	0f 94 c0             	sete   %al
  80b9f8:	0f b6 c0             	movzbl %al,%eax
  80b9fb:	83 e8 01             	sub    $0x1,%eax
  80b9fe:	21 c6                	and    %eax,%esi
      seg = NULL;
    }
    memp_free(MEMP_TCP_SEG, queue);
  80ba00:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ba04:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80ba0b:	e8 f7 b8 ff ff       	call   807307 <memp_free>
  80ba10:	eb 09                	jmp    80ba1b <tcp_enqueue+0x586>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  80ba12:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80ba15:	8b 45 08             	mov    0x8(%ebp),%eax
  80ba18:	89 50 74             	mov    %edx,0x74(%eax)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  80ba1b:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
  80ba1f:	a8 02                	test   $0x2,%al
  80ba21:	75 0a                	jne    80ba2d <tcp_enqueue+0x598>
  80ba23:	a8 01                	test   $0x1,%al
  80ba25:	0f 85 43 01 00 00    	jne    80bb6e <tcp_enqueue+0x6d9>
  80ba2b:	eb 12                	jmp    80ba3f <tcp_enqueue+0x5aa>
    ++len;
  80ba2d:	66 83 45 c8 01       	addw   $0x1,-0x38(%ebp)
  }
  if (flags & TCP_FIN) {
  80ba32:	f6 45 c7 01          	testb  $0x1,-0x39(%ebp)
  80ba36:	74 07                	je     80ba3f <tcp_enqueue+0x5aa>
    pcb->flags |= TF_FIN;
  80ba38:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ba3b:	80 49 20 20          	orb    $0x20,0x20(%ecx)
  }
  pcb->snd_lbb += len;
  80ba3f:	0f b7 45 c8          	movzwl -0x38(%ebp),%eax
  80ba43:	8b 55 08             	mov    0x8(%ebp),%edx
  80ba46:	01 42 68             	add    %eax,0x68(%edx)

  pcb->snd_buf -= len;
  80ba49:	0f b7 4d c8          	movzwl -0x38(%ebp),%ecx
  80ba4d:	66 29 4a 6e          	sub    %cx,0x6e(%edx)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  80ba51:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80ba55:	66 89 42 70          	mov    %ax,0x70(%edx)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  80ba59:	66 85 c0             	test   %ax,%ax
  80ba5c:	74 28                	je     80ba86 <tcp_enqueue+0x5f1>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80ba5e:	83 7a 78 00          	cmpl   $0x0,0x78(%edx)
  80ba62:	75 22                	jne    80ba86 <tcp_enqueue+0x5f1>
  80ba64:	83 7a 74 00          	cmpl   $0x0,0x74(%edx)
  80ba68:	75 1c                	jne    80ba86 <tcp_enqueue+0x5f1>
  80ba6a:	c7 44 24 08 d4 3a 81 	movl   $0x813ad4,0x8(%esp)
  80ba71:	00 
  80ba72:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
  80ba79:	00 
  80ba7a:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80ba81:	e8 26 4e ff ff       	call   8008ac <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  80ba86:	85 f6                	test   %esi,%esi
  80ba88:	0f 84 93 00 00 00    	je     80bb21 <tcp_enqueue+0x68c>
  80ba8e:	66 83 7d da 00       	cmpw   $0x0,-0x26(%ebp)
  80ba93:	0f 84 88 00 00 00    	je     80bb21 <tcp_enqueue+0x68c>
  80ba99:	8b 5e 10             	mov    0x10(%esi),%ebx
  80ba9c:	85 db                	test   %ebx,%ebx
  80ba9e:	66 90                	xchg   %ax,%ax
  80baa0:	74 7f                	je     80bb21 <tcp_enqueue+0x68c>
  80baa2:	f6 45 a8 02          	testb  $0x2,-0x58(%ebp)
  80baa6:	75 79                	jne    80bb21 <tcp_enqueue+0x68c>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  80baa8:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80baac:	89 04 24             	mov    %eax,(%esp)
  80baaf:	e8 f1 ed ff ff       	call   80a8a5 <ntohs>
  80bab4:	83 c8 08             	or     $0x8,%eax
  80bab7:	0f b7 c0             	movzwl %ax,%eax
  80baba:	89 04 24             	mov    %eax,(%esp)
  80babd:	e8 cd ed ff ff       	call   80a88f <htons>
  80bac2:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  80bac6:	b8 00 00 00 00       	mov    $0x0,%eax
  80bacb:	e9 a8 00 00 00       	jmp    80bb78 <tcp_enqueue+0x6e3>
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  80bad0:	8b 55 08             	mov    0x8(%ebp),%edx
  80bad3:	80 4a 20 80          	orb    $0x80,0x20(%edx)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  80bad7:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80badb:	74 0b                	je     80bae8 <tcp_enqueue+0x653>
    tcp_segs_free(queue);
  80badd:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80bae0:	89 0c 24             	mov    %ecx,(%esp)
  80bae3:	e8 63 cb ff ff       	call   80864b <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  80bae8:	8b 45 08             	mov    0x8(%ebp),%eax
  80baeb:	66 83 78 70 00       	cmpw   $0x0,0x70(%eax)
  80baf0:	74 28                	je     80bb1a <tcp_enqueue+0x685>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  80baf2:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80baf6:	75 22                	jne    80bb1a <tcp_enqueue+0x685>
  80baf8:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  80bafc:	75 1c                	jne    80bb1a <tcp_enqueue+0x685>
  80bafe:	c7 44 24 08 d4 3a 81 	movl   $0x813ad4,0x8(%esp)
  80bb05:	00 
  80bb06:	c7 44 24 04 8d 01 00 	movl   $0x18d,0x4(%esp)
  80bb0d:	00 
  80bb0e:	c7 04 24 f4 3a 81 00 	movl   $0x813af4,(%esp)
  80bb15:	e8 92 4d ff ff       	call   8008ac <_panic>
  80bb1a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bb1f:	eb 57                	jmp    80bb78 <tcp_enqueue+0x6e3>
  80bb21:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb26:	eb 50                	jmp    80bb78 <tcp_enqueue+0x6e3>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80bb28:	0f b6 45 a7          	movzbl -0x59(%ebp),%eax
  80bb2c:	c0 e8 02             	shr    $0x2,%al
  80bb2f:	c1 e0 0c             	shl    $0xc,%eax
  80bb32:	66 05 00 50          	add    $0x5000,%ax
  80bb36:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
  80bb3a:	0f b7 4d c8          	movzwl -0x38(%ebp),%ecx
  80bb3e:	66 89 4d d8          	mov    %cx,-0x28(%ebp)
  80bb42:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80bb45:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bb4a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  80bb51:	c6 45 cf 01          	movb   $0x1,-0x31(%ebp)
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80bb55:	0f b6 45 a8          	movzbl -0x58(%ebp),%eax
  80bb59:	83 e0 01             	and    $0x1,%eax
  80bb5c:	89 45 a0             	mov    %eax,-0x60(%ebp)
  80bb5f:	e9 72 fa ff ff       	jmp    80b5d6 <tcp_enqueue+0x141>
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  80bb64:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80bb67:	89 13                	mov    %edx,(%ebx)
  80bb69:	e9 ad fe ff ff       	jmp    80ba1b <tcp_enqueue+0x586>
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    ++len;
  80bb6e:	66 83 45 c8 01       	addw   $0x1,-0x38(%ebp)
  80bb73:	e9 c0 fe ff ff       	jmp    80ba38 <tcp_enqueue+0x5a3>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  80bb78:	83 c4 6c             	add    $0x6c,%esp
  80bb7b:	5b                   	pop    %ebx
  80bb7c:	5e                   	pop    %esi
  80bb7d:	5f                   	pop    %edi
  80bb7e:	5d                   	pop    %ebp
  80bb7f:	c3                   	ret    

0080bb80 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  80bb80:	55                   	push   %ebp
  80bb81:	89 e5                	mov    %esp,%ebp
  80bb83:	83 ec 28             	sub    $0x28,%esp
  80bb86:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80bb89:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80bb8c:	8b 75 08             	mov    0x8(%ebp),%esi
  80bb8f:	0f b7 4d 10          	movzwl 0x10(%ebp),%ecx
  80bb93:	0f b6 5d 14          	movzbl 0x14(%ebp),%ebx
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  80bb97:	8b 56 10             	mov    0x10(%esi),%edx
  80bb9a:	83 fa 04             	cmp    $0x4,%edx
  80bb9d:	74 14                	je     80bbb3 <tcp_write+0x33>
  80bb9f:	83 fa 07             	cmp    $0x7,%edx
  80bba2:	74 0f                	je     80bbb3 <tcp_write+0x33>
  80bba4:	83 fa 02             	cmp    $0x2,%edx
  80bba7:	74 0a                	je     80bbb3 <tcp_write+0x33>
  80bba9:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  80bbae:	83 fa 03             	cmp    $0x3,%edx
  80bbb1:	75 42                	jne    80bbf5 <tcp_write+0x75>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  80bbb3:	b8 00 00 00 00       	mov    $0x0,%eax
  80bbb8:	66 85 c9             	test   %cx,%cx
  80bbbb:	74 38                	je     80bbf5 <tcp_write+0x75>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  80bbbd:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80bbc4:	00 
  80bbc5:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80bbcc:	00 
  80bbcd:	0f b6 c3             	movzbl %bl,%eax
  80bbd0:	89 44 24 10          	mov    %eax,0x10(%esp)
  80bbd4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80bbdb:	00 
  80bbdc:	0f b7 c1             	movzwl %cx,%eax
  80bbdf:	89 44 24 08          	mov    %eax,0x8(%esp)
  80bbe3:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bbe6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bbea:	89 34 24             	mov    %esi,(%esp)
  80bbed:	e8 a3 f8 ff ff       	call   80b495 <tcp_enqueue>
  80bbf2:	0f be c0             	movsbl %al,%eax
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  }
}
  80bbf5:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80bbf8:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80bbfb:	89 ec                	mov    %ebp,%esp
  80bbfd:	5d                   	pop    %ebp
  80bbfe:	c3                   	ret    

0080bbff <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  80bbff:	55                   	push   %ebp
  80bc00:	89 e5                	mov    %esp,%ebp
  80bc02:	83 ec 28             	sub    $0x28,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  80bc05:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80bc0c:	00 
  80bc0d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80bc14:	00 
  80bc15:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  80bc1c:	00 
  80bc1d:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80bc21:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80bc25:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bc2c:	00 
  80bc2d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bc34:	00 
  80bc35:	8b 45 08             	mov    0x8(%ebp),%eax
  80bc38:	89 04 24             	mov    %eax,(%esp)
  80bc3b:	e8 55 f8 ff ff       	call   80b495 <tcp_enqueue>
  80bc40:	0f be c0             	movsbl %al,%eax
}
  80bc43:	c9                   	leave  
  80bc44:	c3                   	ret    
	...

0080bc50 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  80bc50:	55                   	push   %ebp
  80bc51:	89 e5                	mov    %esp,%ebp
  80bc53:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  80bc56:	8b 15 b0 37 81 00    	mov    0x8137b0,%edx
  80bc5c:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  80bc5f:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  80bc65:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  80bc69:	5d                   	pop    %ebp
  80bc6a:	c3                   	ret    

0080bc6b <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80bc6b:	55                   	push   %ebp
  80bc6c:	89 e5                	mov    %esp,%ebp
  80bc6e:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80bc71:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bc74:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  80bc77:	8b 55 10             	mov    0x10(%ebp),%edx
  80bc7a:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80bc7d:	5d                   	pop    %ebp
  80bc7e:	c3                   	ret    

0080bc7f <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  80bc7f:	55                   	push   %ebp
  80bc80:	89 e5                	mov    %esp,%ebp
  80bc82:	53                   	push   %ebx
  80bc83:	83 ec 14             	sub    $0x14,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  80bc86:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80bc8d:	e8 b8 b6 ff ff       	call   80734a <memp_malloc>
  80bc92:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  80bc94:	85 c0                	test   %eax,%eax
  80bc96:	74 1c                	je     80bcb4 <udp_new+0x35>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  80bc98:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80bc9f:	00 
  80bca0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bca7:	00 
  80bca8:	89 04 24             	mov    %eax,(%esp)
  80bcab:	e8 de 54 ff ff       	call   80118e <memset>
    pcb->ttl = UDP_TTL;
  80bcb0:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  }
  return pcb;
}
  80bcb4:	89 d8                	mov    %ebx,%eax
  80bcb6:	83 c4 14             	add    $0x14,%esp
  80bcb9:	5b                   	pop    %ebx
  80bcba:	5d                   	pop    %ebp
  80bcbb:	c3                   	ret    

0080bcbc <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  80bcbc:	55                   	push   %ebp
  80bcbd:	89 e5                	mov    %esp,%ebp
  80bcbf:	83 ec 08             	sub    $0x8,%esp
  80bcc2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  80bcc5:	8b 15 e0 e5 b3 00    	mov    0xb3e5e0,%edx
  80bccb:	39 ca                	cmp    %ecx,%edx
  80bccd:	74 06                	je     80bcd5 <udp_remove+0x19>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80bccf:	85 d2                	test   %edx,%edx
  80bcd1:	75 0e                	jne    80bce1 <udp_remove+0x25>
  80bcd3:	eb 21                	jmp    80bcf6 <udp_remove+0x3a>

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  80bcd5:	8b 42 0c             	mov    0xc(%edx),%eax
  80bcd8:	a3 e0 e5 b3 00       	mov    %eax,0xb3e5e0
  80bcdd:	eb 17                	jmp    80bcf6 <udp_remove+0x3a>
  80bcdf:	89 c2                	mov    %eax,%edx
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80bce1:	8b 42 0c             	mov    0xc(%edx),%eax
  80bce4:	85 c0                	test   %eax,%eax
  80bce6:	74 0e                	je     80bcf6 <udp_remove+0x3a>
  80bce8:	39 c1                	cmp    %eax,%ecx
  80bcea:	75 f3                	jne    80bcdf <udp_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80bcec:	8b 41 0c             	mov    0xc(%ecx),%eax
  80bcef:	89 42 0c             	mov    %eax,0xc(%edx)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80bcf2:	85 c0                	test   %eax,%eax
  80bcf4:	75 e9                	jne    80bcdf <udp_remove+0x23>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  80bcf6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80bcfa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80bd01:	e8 01 b6 ff ff       	call   807307 <memp_free>
}
  80bd06:	c9                   	leave  
  80bd07:	c3                   	ret    

0080bd08 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80bd08:	55                   	push   %ebp
  80bd09:	89 e5                	mov    %esp,%ebp
  80bd0b:	57                   	push   %edi
  80bd0c:	56                   	push   %esi
  80bd0d:	53                   	push   %ebx
  80bd0e:	83 ec 1c             	sub    $0x1c,%esp
  80bd11:	8b 55 08             	mov    0x8(%ebp),%edx
  80bd14:	8b 75 0c             	mov    0xc(%ebp),%esi
  80bd17:	0f b7 4d 10          	movzwl 0x10(%ebp),%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80bd1b:	a1 e0 e5 b3 00       	mov    0xb3e5e0,%eax
  80bd20:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bd25:	85 c0                	test   %eax,%eax
  80bd27:	74 35                	je     80bd5e <udp_bind+0x56>
  80bd29:	bb 00 00 00 00       	mov    $0x0,%ebx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  80bd2e:	39 c2                	cmp    %eax,%edx
  80bd30:	75 25                	jne    80bd57 <udp_bind+0x4f>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80bd32:	84 db                	test   %bl,%bl
  80bd34:	74 1c                	je     80bd52 <udp_bind+0x4a>
  80bd36:	c7 44 24 08 44 3b 81 	movl   $0x813b44,0x8(%esp)
  80bd3d:	00 
  80bd3e:	c7 44 24 04 41 02 00 	movl   $0x241,0x4(%esp)
  80bd45:	00 
  80bd46:	c7 04 24 50 3b 81 00 	movl   $0x813b50,(%esp)
  80bd4d:	e8 5a 4b ff ff       	call   8008ac <_panic>
  80bd52:	bb 01 00 00 00       	mov    $0x1,%ebx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80bd57:	8b 40 0c             	mov    0xc(%eax),%eax
  80bd5a:	85 c0                	test   %eax,%eax
  80bd5c:	75 d0                	jne    80bd2e <udp_bind+0x26>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  80bd5e:	b8 00 00 00 00       	mov    $0x0,%eax
  80bd63:	85 f6                	test   %esi,%esi
  80bd65:	74 02                	je     80bd69 <udp_bind+0x61>
  80bd67:	8b 06                	mov    (%esi),%eax
  80bd69:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  80bd6b:	66 85 c9             	test   %cx,%cx
  80bd6e:	75 48                	jne    80bdb8 <udp_bind+0xb0>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  80bd70:	a1 e0 e5 b3 00       	mov    0xb3e5e0,%eax
  80bd75:	89 45 f0             	mov    %eax,-0x10(%ebp)
  80bd78:	89 c7                	mov    %eax,%edi
  80bd7a:	b9 00 10 00 00       	mov    $0x1000,%ecx
  80bd7f:	eb 1a                	jmp    80bd9b <udp_bind+0x93>
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
      if (ipcb->local_port == port) {
  80bd81:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80bd84:	66 39 48 12          	cmp    %cx,0x12(%eax)
  80bd88:	75 08                	jne    80bd92 <udp_bind+0x8a>
        /* port is already used by another udp_pcb */
        port++;
  80bd8a:	83 c1 01             	add    $0x1,%ecx
  80bd8d:	89 7d f0             	mov    %edi,-0x10(%ebp)
  80bd90:	eb 09                	jmp    80bd9b <udp_bind+0x93>
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  80bd92:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80bd95:	8b 40 0c             	mov    0xc(%eax),%eax
  80bd98:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80bd9b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  80bd9f:	0f 95 c0             	setne  %al
  80bda2:	89 c6                	mov    %eax,%esi
  80bda4:	74 07                	je     80bdad <udp_bind+0xa5>
  80bda6:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  80bdab:	75 d4                	jne    80bd81 <udp_bind+0x79>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  80bdad:	bf f5 ff ff ff       	mov    $0xfffffff5,%edi
  80bdb2:	89 f0                	mov    %esi,%eax
  80bdb4:	84 c0                	test   %al,%al
  80bdb6:	75 20                	jne    80bdd8 <udp_bind+0xd0>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  80bdb8:	66 89 4a 12          	mov    %cx,0x12(%edx)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  80bdbc:	bf 00 00 00 00       	mov    $0x0,%edi
  80bdc1:	84 db                	test   %bl,%bl
  80bdc3:	75 13                	jne    80bdd8 <udp_bind+0xd0>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  80bdc5:	a1 e0 e5 b3 00       	mov    0xb3e5e0,%eax
  80bdca:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  80bdcd:	89 15 e0 e5 b3 00    	mov    %edx,0xb3e5e0
  80bdd3:	bf 00 00 00 00       	mov    $0x0,%edi
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  80bdd8:	89 f8                	mov    %edi,%eax
  80bdda:	83 c4 1c             	add    $0x1c,%esp
  80bddd:	5b                   	pop    %ebx
  80bdde:	5e                   	pop    %esi
  80bddf:	5f                   	pop    %edi
  80bde0:	5d                   	pop    %ebp
  80bde1:	c3                   	ret    

0080bde2 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80bde2:	55                   	push   %ebp
  80bde3:	89 e5                	mov    %esp,%ebp
  80bde5:	57                   	push   %edi
  80bde6:	56                   	push   %esi
  80bde7:	53                   	push   %ebx
  80bde8:	83 ec 0c             	sub    $0xc,%esp
  80bdeb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bdee:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80bdf1:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  80bdf5:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80bdfa:	75 1b                	jne    80be17 <udp_connect+0x35>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80bdfc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80be03:	00 
  80be04:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80be08:	89 1c 24             	mov    %ebx,(%esp)
  80be0b:	e8 f8 fe ff ff       	call   80bd08 <udp_bind>
    if (err != ERR_OK)
      return err;
  80be10:	0f be d0             	movsbl %al,%edx
{
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    if (err != ERR_OK)
  80be13:	84 c0                	test   %al,%al
  80be15:	75 48                	jne    80be5f <udp_connect+0x7d>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  80be17:	b8 00 00 00 00       	mov    $0x0,%eax
  80be1c:	85 ff                	test   %edi,%edi
  80be1e:	74 02                	je     80be22 <udp_connect+0x40>
  80be20:	8b 07                	mov    (%edi),%eax
  80be22:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  80be25:	66 89 73 14          	mov    %si,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  80be29:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80be2d:	8b 15 e0 e5 b3 00    	mov    0xb3e5e0,%edx
  80be33:	85 d2                	test   %edx,%edx
  80be35:	74 13                	je     80be4a <udp_connect+0x68>
    if (pcb == ipcb) {
  80be37:	89 d0                	mov    %edx,%eax
  80be39:	39 d3                	cmp    %edx,%ebx
  80be3b:	75 06                	jne    80be43 <udp_connect+0x61>
  80be3d:	eb 1b                	jmp    80be5a <udp_connect+0x78>
  80be3f:	39 c3                	cmp    %eax,%ebx
  80be41:	74 17                	je     80be5a <udp_connect+0x78>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80be43:	8b 40 0c             	mov    0xc(%eax),%eax
  80be46:	85 c0                	test   %eax,%eax
  80be48:	75 f5                	jne    80be3f <udp_connect+0x5d>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  80be4a:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  80be4d:	89 1d e0 e5 b3 00    	mov    %ebx,0xb3e5e0
  80be53:	ba 00 00 00 00       	mov    $0x0,%edx
  80be58:	eb 05                	jmp    80be5f <udp_connect+0x7d>
  return ERR_OK;
  80be5a:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80be5f:	89 d0                	mov    %edx,%eax
  80be61:	83 c4 0c             	add    $0xc,%esp
  80be64:	5b                   	pop    %ebx
  80be65:	5e                   	pop    %esi
  80be66:	5f                   	pop    %edi
  80be67:	5d                   	pop    %ebp
  80be68:	c3                   	ret    

0080be69 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  80be69:	55                   	push   %ebp
  80be6a:	89 e5                	mov    %esp,%ebp
  80be6c:	57                   	push   %edi
  80be6d:	56                   	push   %esi
  80be6e:	53                   	push   %ebx
  80be6f:	83 ec 1c             	sub    $0x1c,%esp
  80be72:	0f b7 7d 14          	movzwl 0x14(%ebp),%edi
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  80be76:	8b 45 08             	mov    0x8(%ebp),%eax
  80be79:	66 83 78 12 00       	cmpw   $0x0,0x12(%eax)
  80be7e:	75 1f                	jne    80be9f <udp_sendto_if+0x36>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80be80:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80be87:	00 
  80be88:	89 44 24 04          	mov    %eax,0x4(%esp)
  80be8c:	89 04 24             	mov    %eax,(%esp)
  80be8f:	e8 74 fe ff ff       	call   80bd08 <udp_bind>
    if (err != ERR_OK) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
  80be94:	0f be d0             	movsbl %al,%edx

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    if (err != ERR_OK) {
  80be97:	84 c0                	test   %al,%al
  80be99:	0f 85 6d 01 00 00    	jne    80c00c <udp_sendto_if+0x1a3>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  80be9f:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80bea6:	00 
  80bea7:	8b 55 0c             	mov    0xc(%ebp),%edx
  80beaa:	89 14 24             	mov    %edx,(%esp)
  80bead:	e8 56 b8 ff ff       	call   807708 <pbuf_header>
  80beb2:	8b 75 0c             	mov    0xc(%ebp),%esi
  80beb5:	84 c0                	test   %al,%al
  80beb7:	74 3a                	je     80bef3 <udp_sendto_if+0x8a>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  80beb9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bec0:	00 
  80bec1:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80bec8:	00 
  80bec9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80bed0:	e8 61 be ff ff       	call   807d36 <pbuf_alloc>
  80bed5:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80bed7:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80bedc:	85 c0                	test   %eax,%eax
  80bede:	0f 84 28 01 00 00    	je     80c00c <udp_sendto_if+0x1a3>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80bee4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bee7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80beeb:	89 34 24             	mov    %esi,(%esp)
  80beee:	e8 ee b7 ff ff       	call   8076e1 <pbuf_chain>
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  80bef3:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  80bef8:	77 1c                	ja     80bf16 <udp_sendto_if+0xad>
  80befa:	c7 44 24 08 78 3b 81 	movl   $0x813b78,0x8(%esp)
  80bf01:	00 
  80bf02:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80bf09:	00 
  80bf0a:	c7 04 24 50 3b 81 00 	movl   $0x813b50,(%esp)
  80bf11:	e8 96 49 ff ff       	call   8008ac <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  80bf16:	8b 5e 04             	mov    0x4(%esi),%ebx
  udphdr->src = htons(pcb->local_port);
  80bf19:	8b 55 08             	mov    0x8(%ebp),%edx
  80bf1c:	0f b7 42 12          	movzwl 0x12(%edx),%eax
  80bf20:	89 04 24             	mov    %eax,(%esp)
  80bf23:	e8 67 e9 ff ff       	call   80a88f <htons>
  80bf28:	66 89 03             	mov    %ax,(%ebx)
  udphdr->dest = htons(dst_port);
  80bf2b:	0f b7 c7             	movzwl %di,%eax
  80bf2e:	89 04 24             	mov    %eax,(%esp)
  80bf31:	e8 59 e9 ff ff       	call   80a88f <htons>
  80bf36:	66 89 43 02          	mov    %ax,0x2(%ebx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  80bf3a:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80bf40:	8b 7d 08             	mov    0x8(%ebp),%edi
  80bf43:	85 ff                	test   %edi,%edi
  80bf45:	74 06                	je     80bf4d <udp_sendto_if+0xe4>
  80bf47:	8b 07                	mov    (%edi),%eax
  80bf49:	85 c0                	test   %eax,%eax
  80bf4b:	75 08                	jne    80bf55 <udp_sendto_if+0xec>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80bf4d:	8b 7d 18             	mov    0x18(%ebp),%edi
  80bf50:	83 c7 04             	add    $0x4,%edi
  80bf53:	eb 28                	jmp    80bf7d <udp_sendto_if+0x114>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80bf55:	8b 55 18             	mov    0x18(%ebp),%edx
  80bf58:	3b 42 04             	cmp    0x4(%edx),%eax
  80bf5b:	74 20                	je     80bf7d <udp_sendto_if+0x114>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  80bf5d:	ba f7 ff ff ff       	mov    $0xfffffff7,%edx
  80bf62:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80bf65:	0f 84 a1 00 00 00    	je     80c00c <udp_sendto_if+0x1a3>
        /* free the header pbuf */
        pbuf_free(q);
  80bf6b:	89 34 24             	mov    %esi,(%esp)
  80bf6e:	e8 00 bb ff ff       	call   807a73 <pbuf_free>
  80bf73:	ba f7 ff ff ff       	mov    $0xfffffff7,%edx
  80bf78:	e9 8f 00 00 00       	jmp    80c00c <udp_sendto_if+0x1a3>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  80bf7d:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80bf81:	89 04 24             	mov    %eax,(%esp)
  80bf84:	e8 06 e9 ff ff       	call   80a88f <htons>
  80bf89:	66 89 43 04          	mov    %ax,0x4(%ebx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  80bf8d:	8b 45 08             	mov    0x8(%ebp),%eax
  80bf90:	f6 40 10 01          	testb  $0x1,0x10(%eax)
  80bf94:	75 2f                	jne    80bfc5 <udp_sendto_if+0x15c>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80bf96:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80bf9a:	89 44 24 10          	mov    %eax,0x10(%esp)
  80bf9e:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80bfa5:	00 
  80bfa6:	8b 55 10             	mov    0x10(%ebp),%edx
  80bfa9:	89 54 24 08          	mov    %edx,0x8(%esp)
  80bfad:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80bfb1:	89 34 24             	mov    %esi,(%esp)
  80bfb4:	e8 d7 e5 ff ff       	call   80a590 <inet_chksum_pseudo>
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  80bfb9:	66 83 f8 01          	cmp    $0x1,%ax
  80bfbd:	19 d2                	sbb    %edx,%edx
  80bfbf:	09 d0                	or     %edx,%eax
  80bfc1:	66 89 43 06          	mov    %ax,0x6(%ebx)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  80bfc5:	8b 45 18             	mov    0x18(%ebp),%eax
  80bfc8:	89 44 24 18          	mov    %eax,0x18(%esp)
  80bfcc:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  80bfd3:	00 
  80bfd4:	8b 55 08             	mov    0x8(%ebp),%edx
  80bfd7:	0f b6 42 0a          	movzbl 0xa(%edx),%eax
  80bfdb:	89 44 24 10          	mov    %eax,0x10(%esp)
  80bfdf:	0f b6 42 0b          	movzbl 0xb(%edx),%eax
  80bfe3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80bfe7:	8b 45 10             	mov    0x10(%ebp),%eax
  80bfea:	89 44 24 08          	mov    %eax,0x8(%esp)
  80bfee:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80bff2:	89 34 24             	mov    %esi,(%esp)
  80bff5:	e8 e6 d4 ff ff       	call   8094e0 <ip_output_if>
  80bffa:	89 c3                	mov    %eax,%ebx
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  80bffc:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80bfff:	74 08                	je     80c009 <udp_sendto_if+0x1a0>
    /* free the header pbuf */
    pbuf_free(q);
  80c001:	89 34 24             	mov    %esi,(%esp)
  80c004:	e8 6a ba ff ff       	call   807a73 <pbuf_free>
    q = NULL;
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  80c009:	0f be d3             	movsbl %bl,%edx
}
  80c00c:	89 d0                	mov    %edx,%eax
  80c00e:	83 c4 1c             	add    $0x1c,%esp
  80c011:	5b                   	pop    %ebx
  80c012:	5e                   	pop    %esi
  80c013:	5f                   	pop    %edi
  80c014:	5d                   	pop    %ebp
  80c015:	c3                   	ret    

0080c016 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  80c016:	55                   	push   %ebp
  80c017:	89 e5                	mov    %esp,%ebp
  80c019:	83 ec 28             	sub    $0x28,%esp
  80c01c:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80c01f:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80c022:	8b 75 10             	mov    0x10(%ebp),%esi
  80c025:	0f b7 5d 14          	movzwl 0x14(%ebp),%ebx

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  80c029:	89 34 24             	mov    %esi,(%esp)
  80c02c:	e8 66 d6 ff ff       	call   809697 <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  80c031:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
  80c036:	85 c0                	test   %eax,%eax
  80c038:	74 24                	je     80c05e <udp_sendto+0x48>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  80c03a:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c03e:	0f b7 c3             	movzwl %bx,%eax
  80c041:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80c045:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c049:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c04c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c050:	8b 45 08             	mov    0x8(%ebp),%eax
  80c053:	89 04 24             	mov    %eax,(%esp)
  80c056:	e8 0e fe ff ff       	call   80be69 <udp_sendto_if>
  80c05b:	0f be d0             	movsbl %al,%edx
}
  80c05e:	89 d0                	mov    %edx,%eax
  80c060:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80c063:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80c066:	89 ec                	mov    %ebp,%esp
  80c068:	5d                   	pop    %ebp
  80c069:	c3                   	ret    

0080c06a <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  80c06a:	55                   	push   %ebp
  80c06b:	89 e5                	mov    %esp,%ebp
  80c06d:	83 ec 18             	sub    $0x18,%esp
  80c070:	8b 55 08             	mov    0x8(%ebp),%edx
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  80c073:	0f b7 42 14          	movzwl 0x14(%edx),%eax
  80c077:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80c07b:	8d 42 04             	lea    0x4(%edx),%eax
  80c07e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c082:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c085:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c089:	89 14 24             	mov    %edx,(%esp)
  80c08c:	e8 85 ff ff ff       	call   80c016 <udp_sendto>
  80c091:	0f be c0             	movsbl %al,%eax
}
  80c094:	c9                   	leave  
  80c095:	c3                   	ret    

0080c096 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  80c096:	55                   	push   %ebp
  80c097:	89 e5                	mov    %esp,%ebp
  80c099:	57                   	push   %edi
  80c09a:	56                   	push   %esi
  80c09b:	53                   	push   %ebx
  80c09c:	83 ec 2c             	sub    $0x2c,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  80c09f:	8b 45 08             	mov    0x8(%ebp),%eax
  80c0a2:	8b 40 04             	mov    0x4(%eax),%eax
  80c0a5:	89 45 e8             	mov    %eax,-0x18(%ebp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  80c0a8:	8b 55 08             	mov    0x8(%ebp),%edx
  80c0ab:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  80c0af:	0f b7 00             	movzwl (%eax),%eax
  80c0b2:	89 04 24             	mov    %eax,(%esp)
  80c0b5:	e8 eb e7 ff ff       	call   80a8a5 <ntohs>
  80c0ba:	c1 e8 06             	shr    $0x6,%eax
  80c0bd:	83 e0 3c             	and    $0x3c,%eax
  80c0c0:	83 c0 08             	add    $0x8,%eax
  80c0c3:	39 c3                	cmp    %eax,%ebx
  80c0c5:	7c 2a                	jl     80c0f1 <udp_input+0x5b>
  80c0c7:	8b 55 e8             	mov    -0x18(%ebp),%edx
  80c0ca:	0f b7 02             	movzwl (%edx),%eax
  80c0cd:	89 04 24             	mov    %eax,(%esp)
  80c0d0:	e8 d0 e7 ff ff       	call   80a8a5 <ntohs>
  80c0d5:	c1 e8 06             	shr    $0x6,%eax
  80c0d8:	83 e0 3c             	and    $0x3c,%eax
  80c0db:	f7 d8                	neg    %eax
  80c0dd:	98                   	cwtl   
  80c0de:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c0e2:	8b 45 08             	mov    0x8(%ebp),%eax
  80c0e5:	89 04 24             	mov    %eax,(%esp)
  80c0e8:	e8 1b b6 ff ff       	call   807708 <pbuf_header>
  80c0ed:	84 c0                	test   %al,%al
  80c0ef:	74 10                	je     80c101 <udp_input+0x6b>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  80c0f1:	8b 55 08             	mov    0x8(%ebp),%edx
  80c0f4:	89 14 24             	mov    %edx,(%esp)
  80c0f7:	e8 77 b9 ff ff       	call   807a73 <pbuf_free>
  80c0fc:	e9 f4 02 00 00       	jmp    80c3f5 <udp_input+0x35f>
    goto end;
  }

  udphdr = (struct udp_hdr *)p->payload;
  80c101:	8b 45 08             	mov    0x8(%ebp),%eax
  80c104:	8b 40 04             	mov    0x4(%eax),%eax
  80c107:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80c10a:	0f b7 00             	movzwl (%eax),%eax
  80c10d:	89 04 24             	mov    %eax,(%esp)
  80c110:	e8 90 e7 ff ff       	call   80a8a5 <ntohs>
  80c115:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
  dest = ntohs(udphdr->dest);
  80c119:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c11c:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80c120:	89 04 24             	mov    %eax,(%esp)
  80c123:	e8 7d e7 ff ff       	call   80a8a5 <ntohs>
  80c128:	89 c7                	mov    %eax,%edi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  80c12a:	66 83 f8 44          	cmp    $0x44,%ax
  80c12e:	75 49                	jne    80c179 <udp_input+0xe3>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  80c130:	66 83 7d ee 43       	cmpw   $0x43,-0x12(%ebp)
  80c135:	0f 85 f2 00 00 00    	jne    80c22d <udp_input+0x197>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  80c13b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c13e:	8b 42 20             	mov    0x20(%edx),%eax
  80c141:	85 c0                	test   %eax,%eax
  80c143:	0f 84 e4 00 00 00    	je     80c22d <udp_input+0x197>
  80c149:	8b 58 08             	mov    0x8(%eax),%ebx
  80c14c:	85 db                	test   %ebx,%ebx
  80c14e:	0f 84 de 00 00 00    	je     80c232 <udp_input+0x19c>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  80c154:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80c157:	0f 84 e7 00 00 00    	je     80c244 <udp_input+0x1ae>
  80c15d:	8b 43 04             	mov    0x4(%ebx),%eax
  80c160:	85 c0                	test   %eax,%eax
  80c162:	0f 84 dc 00 00 00    	je     80c244 <udp_input+0x1ae>
  80c168:	8b 55 e8             	mov    -0x18(%ebp),%edx
  80c16b:	3b 42 0c             	cmp    0xc(%edx),%eax
  80c16e:	0f 85 b9 00 00 00    	jne    80c22d <udp_input+0x197>
  80c174:	e9 cb 00 00 00       	jmp    80c244 <udp_input+0x1ae>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80c179:	8b 1d e0 e5 b3 00    	mov    0xb3e5e0,%ebx
  80c17f:	85 db                	test   %ebx,%ebx
  80c181:	0f 84 ab 00 00 00    	je     80c232 <udp_input+0x19c>
  80c187:	be 00 00 00 00       	mov    $0x0,%esi
  80c18c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c193:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80c196:	83 c0 10             	add    $0x10,%eax
  80c199:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80c19c:	66 3b 7b 12          	cmp    0x12(%ebx),%di
  80c1a0:	75 72                	jne    80c214 <udp_input+0x17e>
  80c1a2:	85 db                	test   %ebx,%ebx
  80c1a4:	74 24                	je     80c1ca <udp_input+0x134>
  80c1a6:	8b 03                	mov    (%ebx),%eax
  80c1a8:	85 c0                	test   %eax,%eax
  80c1aa:	74 1e                	je     80c1ca <udp_input+0x134>
  80c1ac:	8b 55 e8             	mov    -0x18(%ebp),%edx
  80c1af:	3b 42 10             	cmp    0x10(%edx),%eax
  80c1b2:	74 16                	je     80c1ca <udp_input+0x134>
  80c1b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c1b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c1bb:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80c1be:	89 14 24             	mov    %edx,(%esp)
  80c1c1:	e8 c6 d2 ff ff       	call   80948c <ip_addr_isbroadcast>
  80c1c6:	84 c0                	test   %al,%al
  80c1c8:	74 4a                	je     80c214 <udp_input+0x17e>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  80c1ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  80c1ce:	0f 85 f8 01 00 00    	jne    80c3cc <udp_input+0x336>
  80c1d4:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  80c1d8:	0f 84 eb 01 00 00    	je     80c3c9 <udp_input+0x333>
  80c1de:	66 90                	xchg   %ax,%ax
  80c1e0:	e9 e7 01 00 00       	jmp    80c3cc <udp_input+0x336>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  80c1e5:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80c1e8:	74 10                	je     80c1fa <udp_input+0x164>
  80c1ea:	8b 43 04             	mov    0x4(%ebx),%eax
  80c1ed:	85 c0                	test   %eax,%eax
  80c1ef:	90                   	nop    
  80c1f0:	74 08                	je     80c1fa <udp_input+0x164>
  80c1f2:	8b 55 e8             	mov    -0x18(%ebp),%edx
  80c1f5:	3b 42 0c             	cmp    0xc(%edx),%eax
  80c1f8:	75 1a                	jne    80c214 <udp_input+0x17e>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  80c1fa:	85 f6                	test   %esi,%esi
  80c1fc:	74 46                	je     80c244 <udp_input+0x1ae>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  80c1fe:	8b 43 0c             	mov    0xc(%ebx),%eax
  80c201:	89 46 0c             	mov    %eax,0xc(%esi)
          pcb->next = udp_pcbs;
  80c204:	a1 e0 e5 b3 00       	mov    0xb3e5e0,%eax
  80c209:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  80c20c:	89 1d e0 e5 b3 00    	mov    %ebx,0xb3e5e0
  80c212:	eb 30                	jmp    80c244 <udp_input+0x1ae>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80c214:	8b 43 0c             	mov    0xc(%ebx),%eax
  80c217:	89 de                	mov    %ebx,%esi
  80c219:	85 c0                	test   %eax,%eax
  80c21b:	0f 84 be 01 00 00    	je     80c3df <udp_input+0x349>
  80c221:	89 c3                	mov    %eax,%ebx
  80c223:	e9 74 ff ff ff       	jmp    80c19c <udp_input+0x106>
  80c228:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  80c22b:	eb 05                	jmp    80c232 <udp_input+0x19c>
  80c22d:	bb 00 00 00 00       	mov    $0x0,%ebx
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  80c232:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c235:	8b 42 04             	mov    0x4(%edx),%eax
  80c238:	8b 55 e8             	mov    -0x18(%ebp),%edx
  80c23b:	3b 42 10             	cmp    0x10(%edx),%eax
  80c23e:	0f 85 78 01 00 00    	jne    80c3bc <udp_input+0x326>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  80c244:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c247:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  80c24c:	74 44                	je     80c292 <udp_input+0x1fc>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80c24e:	8b 55 08             	mov    0x8(%ebp),%edx
  80c251:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80c255:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c259:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80c260:	00 
  80c261:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80c264:	83 c0 10             	add    $0x10,%eax
  80c267:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c26b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80c26e:	83 c0 0c             	add    $0xc,%eax
  80c271:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c275:	89 14 24             	mov    %edx,(%esp)
  80c278:	e8 13 e3 ff ff       	call   80a590 <inet_chksum_pseudo>
  80c27d:	66 85 c0             	test   %ax,%ax
  80c280:	74 10                	je     80c292 <udp_input+0x1fc>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  80c282:	8b 45 08             	mov    0x8(%ebp),%eax
  80c285:	89 04 24             	mov    %eax,(%esp)
  80c288:	e8 e6 b7 ff ff       	call   807a73 <pbuf_free>
  80c28d:	e9 63 01 00 00       	jmp    80c3f5 <udp_input+0x35f>
          goto end;
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  80c292:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  80c299:	ff 
  80c29a:	8b 55 08             	mov    0x8(%ebp),%edx
  80c29d:	89 14 24             	mov    %edx,(%esp)
  80c2a0:	e8 63 b4 ff ff       	call   807708 <pbuf_header>
  80c2a5:	84 c0                	test   %al,%al
  80c2a7:	74 1c                	je     80c2c5 <udp_input+0x22f>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80c2a9:	c7 44 24 08 30 3b 81 	movl   $0x813b30,0x8(%esp)
  80c2b0:	00 
  80c2b1:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  80c2b8:	00 
  80c2b9:	c7 04 24 50 3b 81 00 	movl   $0x813b50,(%esp)
  80c2c0:	e8 e7 45 ff ff       	call   8008ac <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  80c2c5:	85 db                	test   %ebx,%ebx
  80c2c7:	74 41                	je     80c30a <udp_input+0x274>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  80c2c9:	8b 53 18             	mov    0x18(%ebx),%edx
  80c2cc:	85 d2                	test   %edx,%edx
  80c2ce:	74 2a                	je     80c2fa <udp_input+0x264>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  80c2d0:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
  80c2d4:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c2d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80c2db:	83 c0 0c             	add    $0xc,%eax
  80c2de:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80c2e2:	8b 45 08             	mov    0x8(%ebp),%eax
  80c2e5:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c2e9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c2ed:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80c2f0:	89 04 24             	mov    %eax,(%esp)
  80c2f3:	ff d2                	call   *%edx
  80c2f5:	e9 fb 00 00 00       	jmp    80c3f5 <udp_input+0x35f>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  80c2fa:	8b 55 08             	mov    0x8(%ebp),%edx
  80c2fd:	89 14 24             	mov    %edx,(%esp)
  80c300:	e8 6e b7 ff ff       	call   807a73 <pbuf_free>
  80c305:	e9 eb 00 00 00       	jmp    80c3f5 <udp_input+0x35f>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80c30a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c30d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c311:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80c314:	83 c0 10             	add    $0x10,%eax
  80c317:	89 04 24             	mov    %eax,(%esp)
  80c31a:	e8 6d d1 ff ff       	call   80948c <ip_addr_isbroadcast>
  80c31f:	84 c0                	test   %al,%al
  80c321:	0f 85 88 00 00 00    	jne    80c3af <udp_input+0x319>
  80c327:	8b 55 e8             	mov    -0x18(%ebp),%edx
  80c32a:	8b 5a 10             	mov    0x10(%edx),%ebx
  80c32d:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80c334:	e8 b7 e7 ff ff       	call   80aaf0 <ntohl>
  80c339:	89 c6                	mov    %eax,%esi
  80c33b:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c342:	e8 a9 e7 ff ff       	call   80aaf0 <ntohl>
  80c347:	89 f2                	mov    %esi,%edx
  80c349:	21 da                	and    %ebx,%edx
  80c34b:	39 c2                	cmp    %eax,%edx
  80c34d:	74 60                	je     80c3af <udp_input+0x319>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  80c34f:	8b 55 e8             	mov    -0x18(%ebp),%edx
  80c352:	0f b7 02             	movzwl (%edx),%eax
  80c355:	89 04 24             	mov    %eax,(%esp)
  80c358:	e8 48 e5 ff ff       	call   80a8a5 <ntohs>
  80c35d:	c1 e8 06             	shr    $0x6,%eax
  80c360:	83 e0 3c             	and    $0x3c,%eax
  80c363:	8d 40 08             	lea    0x8(%eax),%eax
  80c366:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c36a:	8b 45 08             	mov    0x8(%ebp),%eax
  80c36d:	89 04 24             	mov    %eax,(%esp)
  80c370:	e8 93 b3 ff ff       	call   807708 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  80c375:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80c378:	8b 55 08             	mov    0x8(%ebp),%edx
  80c37b:	39 42 04             	cmp    %eax,0x4(%edx)
  80c37e:	74 1c                	je     80c39c <udp_input+0x306>
  80c380:	c7 44 24 08 64 3b 81 	movl   $0x813b64,0x8(%esp)
  80c387:	00 
  80c388:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  80c38f:	00 
  80c390:	c7 04 24 50 3b 81 00 	movl   $0x813b50,(%esp)
  80c397:	e8 10 45 ff ff       	call   8008ac <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  80c39c:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80c3a3:	00 
  80c3a4:	8b 55 08             	mov    0x8(%ebp),%edx
  80c3a7:	89 14 24             	mov    %edx,(%esp)
  80c3aa:	e8 c0 55 00 00       	call   81196f <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  80c3af:	8b 45 08             	mov    0x8(%ebp),%eax
  80c3b2:	89 04 24             	mov    %eax,(%esp)
  80c3b5:	e8 b9 b6 ff ff       	call   807a73 <pbuf_free>
  80c3ba:	eb 39                	jmp    80c3f5 <udp_input+0x35f>
    }
  } else {
    pbuf_free(p);
  80c3bc:	8b 55 08             	mov    0x8(%ebp),%edx
  80c3bf:	89 14 24             	mov    %edx,(%esp)
  80c3c2:	e8 ac b6 ff ff       	call   807a73 <pbuf_free>
  80c3c7:	eb 2c                	jmp    80c3f5 <udp_input+0x35f>
  }
end:
  PERF_STOP("udp_input");
}
  80c3c9:	89 5d f0             	mov    %ebx,-0x10(%ebp)
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  80c3cc:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
  80c3d0:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  80c3d4:	0f 85 3a fe ff ff    	jne    80c214 <udp_input+0x17e>
  80c3da:	e9 06 fe ff ff       	jmp    80c1e5 <udp_input+0x14f>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  80c3df:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  80c3e2:	85 db                	test   %ebx,%ebx
  80c3e4:	0f 85 5a fe ff ff    	jne    80c244 <udp_input+0x1ae>
  80c3ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80c3f0:	e9 33 fe ff ff       	jmp    80c228 <udp_input+0x192>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  80c3f5:	83 c4 2c             	add    $0x2c,%esp
  80c3f8:	5b                   	pop    %ebx
  80c3f9:	5e                   	pop    %esi
  80c3fa:	5f                   	pop    %edi
  80c3fb:	5d                   	pop    %ebp
  80c3fc:	c3                   	ret    
  80c3fd:	00 00                	add    %al,(%eax)
	...

0080c400 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  80c400:	55                   	push   %ebp
  80c401:	89 e5                	mov    %esp,%ebp
  80c403:	57                   	push   %edi
  80c404:	56                   	push   %esi
  80c405:	53                   	push   %ebx
  80c406:	83 ec 1c             	sub    $0x1c,%esp
  80c409:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80c40c:	89 55 f0             	mov    %edx,-0x10(%ebp)
  80c40f:	89 ce                	mov    %ecx,%esi
  struct eth_hdr *ethhdr = p->payload;
  80c411:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c414:	b9 06 00 00 00       	mov    $0x6,%ecx
  80c419:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80c41d:	74 1c                	je     80c43b <etharp_send_ip+0x3b>
  80c41f:	c7 44 24 08 a8 3b 81 	movl   $0x813ba8,0x8(%esp)
  80c426:	00 
  80c427:	c7 44 24 04 b3 01 00 	movl   $0x1b3,0x4(%esp)
  80c42e:	00 
  80c42f:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80c436:	e8 71 44 ff ff       	call   8008ac <_panic>
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  80c43b:	83 e9 01             	sub    $0x1,%ecx
    ethhdr->dest.addr[k] = dst->addr[k];
  80c43e:	0f b6 c1             	movzbl %cl,%eax
  80c441:	8b 7d 08             	mov    0x8(%ebp),%edi
  80c444:	0f b6 14 07          	movzbl (%edi,%eax,1),%edx
  80c448:	88 14 03             	mov    %dl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  80c44b:	0f b6 14 06          	movzbl (%esi,%eax,1),%edx
  80c44f:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  80c453:	84 c9                	test   %cl,%cl
  80c455:	75 e4                	jne    80c43b <etharp_send_ip+0x3b>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  80c457:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80c45e:	e8 2c e4 ff ff       	call   80a88f <htons>
  80c463:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  80c467:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80c46a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c46e:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80c471:	89 14 24             	mov    %edx,(%esp)
  80c474:	ff 52 18             	call   *0x18(%edx)
  80c477:	0f be c0             	movsbl %al,%eax
}
  80c47a:	83 c4 1c             	add    $0x1c,%esp
  80c47d:	5b                   	pop    %ebx
  80c47e:	5e                   	pop    %esi
  80c47f:	5f                   	pop    %edi
  80c480:	5d                   	pop    %ebp
  80c481:	c3                   	ret    

0080c482 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80c482:	55                   	push   %ebp
  80c483:	89 e5                	mov    %esp,%ebp
  80c485:	57                   	push   %edi
  80c486:	56                   	push   %esi
  80c487:	53                   	push   %ebx
  80c488:	83 ec 0c             	sub    $0xc,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  80c48b:	8b 75 08             	mov    0x8(%ebp),%esi
  80c48e:	83 c6 25             	add    $0x25,%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  80c491:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c498:	00 
  80c499:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  80c4a0:	00 
  80c4a1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80c4a8:	e8 89 b8 ff ff       	call   807d36 <pbuf_alloc>
  80c4ad:	89 c7                	mov    %eax,%edi
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  80c4af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c4b4:	85 ff                	test   %edi,%edi
  80c4b6:	0f 84 0e 01 00 00    	je     80c5ca <etharp_request+0x148>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80c4bc:	66 83 7f 0a 29       	cmpw   $0x29,0xa(%edi)
  80c4c1:	77 1c                	ja     80c4df <etharp_request+0x5d>
  80c4c3:	c7 44 24 08 ec 3b 81 	movl   $0x813bec,0x8(%esp)
  80c4ca:	00 
  80c4cb:	c7 44 24 04 1c 04 00 	movl   $0x41c,0x4(%esp)
  80c4d2:	00 
  80c4d3:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80c4da:	e8 cd 43 ff ff       	call   8008ac <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  80c4df:	8b 5f 04             	mov    0x4(%edi),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  80c4e2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c4e9:	e8 a1 e3 ff ff       	call   80a88f <htons>
  80c4ee:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c4f2:	b9 06 00 00 00       	mov    $0x6,%ecx
  80c4f7:	8b 45 08             	mov    0x8(%ebp),%eax
  80c4fa:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80c4fe:	74 1c                	je     80c51c <etharp_request+0x9a>
  80c500:	c7 44 24 08 a8 3b 81 	movl   $0x813ba8,0x8(%esp)
  80c507:	00 
  80c508:	c7 44 24 04 23 04 00 	movl   $0x423,0x4(%esp)
  80c50f:	00 
  80c510:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80c517:	e8 90 43 ff ff       	call   8008ac <_panic>
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  80c51c:	83 e9 01             	sub    $0x1,%ecx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  80c51f:	0f b6 c1             	movzbl %cl,%eax
  80c522:	0f b6 14 06          	movzbl (%esi,%eax,1),%edx
  80c526:	88 54 18 16          	mov    %dl,0x16(%eax,%ebx,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80c52a:	0f b6 90 0d 3d 81 00 	movzbl 0x813d0d(%eax),%edx
  80c531:	88 54 18 20          	mov    %dl,0x20(%eax,%ebx,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  80c535:	0f b6 90 07 3d 81 00 	movzbl 0x813d07(%eax),%edx
  80c53c:	88 14 03             	mov    %dl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  80c53f:	0f b6 14 06          	movzbl (%esi,%eax,1),%edx
  80c543:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  80c547:	84 c9                	test   %cl,%cl
  80c549:	75 d1                	jne    80c51c <etharp_request+0x9a>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  80c54b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80c54e:	0f b7 51 04          	movzwl 0x4(%ecx),%edx
  80c552:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
  80c556:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  80c55a:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80c55e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c561:	0f b7 10             	movzwl (%eax),%edx
  80c564:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  80c568:	66 89 43 28          	mov    %ax,0x28(%ebx)
  80c56c:	66 89 53 26          	mov    %dx,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  80c570:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c577:	e8 13 e3 ff ff       	call   80a88f <htons>
  80c57c:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  80c580:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80c587:	e8 03 e3 ff ff       	call   80a88f <htons>
  80c58c:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80c590:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80c597:	e8 f3 e2 ff ff       	call   80a88f <htons>
  80c59c:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80c5a0:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80c5a7:	e8 e3 e2 ff ff       	call   80a88f <htons>
  80c5ac:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  80c5b0:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80c5b4:	8b 45 08             	mov    0x8(%ebp),%eax
  80c5b7:	89 04 24             	mov    %eax,(%esp)
  80c5ba:	ff 50 18             	call   *0x18(%eax)
  80c5bd:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  80c5bf:	89 3c 24             	mov    %edi,(%esp)
  80c5c2:	e8 ac b4 ff ff       	call   807a73 <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
  80c5c7:	0f be c3             	movsbl %bl,%eax
  80c5ca:	0f be c0             	movsbl %al,%eax
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80c5cd:	83 c4 0c             	add    $0xc,%esp
  80c5d0:	5b                   	pop    %ebx
  80c5d1:	5e                   	pop    %esi
  80c5d2:	5f                   	pop    %edi
  80c5d3:	5d                   	pop    %ebp
  80c5d4:	c3                   	ret    

0080c5d5 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  80c5d5:	55                   	push   %ebp
  80c5d6:	89 e5                	mov    %esp,%ebp
  80c5d8:	56                   	push   %esi
  80c5d9:	53                   	push   %ebx
  80c5da:	83 ec 10             	sub    $0x10,%esp
  80c5dd:	89 c6                	mov    %eax,%esi
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  80c5df:	85 c0                	test   %eax,%eax
  80c5e1:	75 1c                	jne    80c5ff <free_etharp_q+0x2a>
  80c5e3:	c7 44 24 08 5d 34 81 	movl   $0x81345d,0x8(%esp)
  80c5ea:	00 
  80c5eb:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  80c5f2:	00 
  80c5f3:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80c5fa:	e8 ad 42 ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80c5ff:	8b 40 04             	mov    0x4(%eax),%eax
  80c602:	85 c0                	test   %eax,%eax
  80c604:	75 63                	jne    80c669 <free_etharp_q+0x94>
  80c606:	c7 44 24 08 a9 3c 81 	movl   $0x813ca9,0x8(%esp)
  80c60d:	00 
  80c60e:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
  80c615:	00 
  80c616:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80c61d:	e8 8a 42 ff ff       	call   8008ac <_panic>
  while (q) {
    r = q;
    q = q->next;
  80c622:	8b 13                	mov    (%ebx),%edx
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  80c624:	8b 43 04             	mov    0x4(%ebx),%eax
  80c627:	85 c0                	test   %eax,%eax
  80c629:	75 1c                	jne    80c647 <free_etharp_q+0x72>
  80c62b:	c7 44 24 08 b6 3c 81 	movl   $0x813cb6,0x8(%esp)
  80c632:	00 
  80c633:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80c63a:	00 
  80c63b:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80c642:	e8 65 42 ff ff       	call   8008ac <_panic>
  80c647:	89 de                	mov    %ebx,%esi
  80c649:	89 d3                	mov    %edx,%ebx
    pbuf_free(r->p);
  80c64b:	89 04 24             	mov    %eax,(%esp)
  80c64e:	e8 20 b4 ff ff       	call   807a73 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  80c653:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c657:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80c65e:	e8 a4 ac ff ff       	call   807307 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  80c663:	85 db                	test   %ebx,%ebx
  80c665:	75 bb                	jne    80c622 <free_etharp_q+0x4d>
  80c667:	eb 09                	jmp    80c672 <free_etharp_q+0x9d>
    r = q;
    q = q->next;
  80c669:	8b 1e                	mov    (%esi),%ebx
  80c66b:	90                   	nop    
  80c66c:	8d 74 26 00          	lea    0x0(%esi),%esi
  80c670:	eb d9                	jmp    80c64b <free_etharp_q+0x76>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  80c672:	83 c4 10             	add    $0x10,%esp
  80c675:	5b                   	pop    %ebx
  80c676:	5e                   	pop    %esi
  80c677:	5d                   	pop    %ebp
  80c678:	c3                   	ret    

0080c679 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80c679:	55                   	push   %ebp
  80c67a:	89 e5                	mov    %esp,%ebp
  80c67c:	57                   	push   %edi
  80c67d:	56                   	push   %esi
  80c67e:	53                   	push   %ebx
  80c67f:	83 ec 1c             	sub    $0x1c,%esp
  80c682:	89 c7                	mov    %eax,%edi
  80c684:	88 55 ed             	mov    %dl,-0x13(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  80c687:	85 c0                	test   %eax,%eax
  80c689:	74 27                	je     80c6b2 <find_entry+0x39>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  80c68b:	0f b6 0d b8 7e b3 00 	movzbl 0xb37eb8,%ecx
  80c692:	0f b6 c1             	movzbl %cl,%eax
  80c695:	6b d8 1c             	imul   $0x1c,%eax,%ebx
  80c698:	83 bb b0 7d b3 00 02 	cmpl   $0x2,0xb37db0(%ebx)
  80c69f:	75 11                	jne    80c6b2 <find_entry+0x39>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  80c6a1:	8b 07                	mov    (%edi),%eax
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  80c6a3:	0f be c9             	movsbl %cl,%ecx
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  80c6a6:	3b 83 a4 7d b3 00    	cmp    0xb37da4(%ebx),%eax
  80c6ac:	0f 84 c5 01 00 00    	je     80c877 <find_entry+0x1fe>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  80c6b2:	c6 45 ee 0a          	movb   $0xa,-0x12(%ebp)
  80c6b6:	c6 45 ef 0a          	movb   $0xa,-0x11(%ebp)
  80c6ba:	c6 45 f0 0a          	movb   $0xa,-0x10(%ebp)
  80c6be:	c6 45 f1 00          	movb   $0x0,-0xf(%ebp)
  80c6c2:	c6 45 f2 00          	movb   $0x0,-0xe(%ebp)
  80c6c6:	c6 45 f3 0a          	movb   $0xa,-0xd(%ebp)
  80c6ca:	be 00 00 00 00       	mov    $0x0,%esi
  80c6cf:	b9 00 00 00 00       	mov    $0x0,%ecx
  80c6d4:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c6d9:	89 ca                	mov    %ecx,%edx
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80c6db:	80 7d f0 0a          	cmpb   $0xa,-0x10(%ebp)
  80c6df:	75 11                	jne    80c6f2 <find_entry+0x79>
  80c6e1:	83 bb b0 7d b3 00 00 	cmpl   $0x0,0xb37db0(%ebx)
  80c6e8:	75 08                	jne    80c6f2 <find_entry+0x79>
  80c6ea:	88 4d f0             	mov    %cl,-0x10(%ebp)
  80c6ed:	e9 8b 00 00 00       	jmp    80c77d <find_entry+0x104>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80c6f2:	8b 83 b0 7d b3 00    	mov    0xb37db0(%ebx),%eax
  80c6f8:	83 f8 01             	cmp    $0x1,%eax
  80c6fb:	75 4d                	jne    80c74a <find_entry+0xd1>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80c6fd:	85 ff                	test   %edi,%edi
  80c6ff:	74 18                	je     80c719 <find_entry+0xa0>
  80c701:	8b 07                	mov    (%edi),%eax
  80c703:	3b 83 a4 7d b3 00    	cmp    0xb37da4(%ebx),%eax
  80c709:	75 0e                	jne    80c719 <find_entry+0xa0>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80c70b:	88 15 b8 7e b3 00    	mov    %dl,0xb37eb8
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80c711:	0f be ca             	movsbl %dl,%ecx
  80c714:	e9 5e 01 00 00       	jmp    80c877 <find_entry+0x1fe>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  80c719:	83 bb a0 7d b3 00 00 	cmpl   $0x0,0xb37da0(%ebx)
  80c720:	74 14                	je     80c736 <find_entry+0xbd>
        if (arp_table[i].ctime >= age_queue) {
  80c722:	0f b6 83 b4 7d b3 00 	movzbl 0xb37db4(%ebx),%eax
  80c729:	89 f2                	mov    %esi,%edx
  80c72b:	38 c2                	cmp    %al,%dl
  80c72d:	77 4e                	ja     80c77d <find_entry+0x104>
  80c72f:	88 4d f3             	mov    %cl,-0xd(%ebp)
  80c732:	89 c6                	mov    %eax,%esi
  80c734:	eb 47                	jmp    80c77d <find_entry+0x104>
          age_queue = arp_table[i].ctime;
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  80c736:	0f b6 83 b4 7d b3 00 	movzbl 0xb37db4(%ebx),%eax
  80c73d:	38 45 f1             	cmp    %al,-0xf(%ebp)
  80c740:	77 3b                	ja     80c77d <find_entry+0x104>
  80c742:	88 4d ee             	mov    %cl,-0x12(%ebp)
  80c745:	88 45 f1             	mov    %al,-0xf(%ebp)
  80c748:	eb 33                	jmp    80c77d <find_entry+0x104>
          age_pending = arp_table[i].ctime;
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80c74a:	83 f8 02             	cmp    $0x2,%eax
  80c74d:	75 2e                	jne    80c77d <find_entry+0x104>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80c74f:	85 ff                	test   %edi,%edi
  80c751:	74 18                	je     80c76b <find_entry+0xf2>
  80c753:	8b 07                	mov    (%edi),%eax
  80c755:	3b 83 a4 7d b3 00    	cmp    0xb37da4(%ebx),%eax
  80c75b:	75 0e                	jne    80c76b <find_entry+0xf2>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80c75d:	88 15 b8 7e b3 00    	mov    %dl,0xb37eb8
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80c763:	0f be ca             	movsbl %dl,%ecx
  80c766:	e9 0c 01 00 00       	jmp    80c877 <find_entry+0x1fe>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  80c76b:	0f b6 83 b4 7d b3 00 	movzbl 0xb37db4(%ebx),%eax
  80c772:	38 45 f2             	cmp    %al,-0xe(%ebp)
  80c775:	77 06                	ja     80c77d <find_entry+0x104>
  80c777:	88 4d ef             	mov    %cl,-0x11(%ebp)
  80c77a:	88 45 f2             	mov    %al,-0xe(%ebp)
  80c77d:	83 c1 01             	add    $0x1,%ecx
  80c780:	83 c3 1c             	add    $0x1c,%ebx
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80c783:	83 f9 0a             	cmp    $0xa,%ecx
  80c786:	0f 85 4d ff ff ff    	jne    80c6d9 <find_entry+0x60>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80c78c:	80 7d f0 0a          	cmpb   $0xa,-0x10(%ebp)
  80c790:	75 0a                	jne    80c79c <find_entry+0x123>
  80c792:	f6 45 ed 01          	testb  $0x1,-0x13(%ebp)
  80c796:	0f 84 d6 00 00 00    	je     80c872 <find_entry+0x1f9>
  80c79c:	f6 45 ed 02          	testb  $0x2,-0x13(%ebp)
  80c7a0:	0f 85 cc 00 00 00    	jne    80c872 <find_entry+0x1f9>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  80c7a6:	0f b6 75 f0          	movzbl -0x10(%ebp),%esi
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  80c7aa:	80 7d f0 09          	cmpb   $0x9,-0x10(%ebp)
  80c7ae:	66 90                	xchg   %ax,%ax
  80c7b0:	7e 68                	jle    80c81a <find_entry+0x1a1>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  80c7b2:	80 7d ef 09          	cmpb   $0x9,-0x11(%ebp)
  80c7b6:	7f 31                	jg     80c7e9 <find_entry+0x170>
    /* recycle oldest stable*/
    i = old_stable;
  80c7b8:	0f b6 75 ef          	movzbl -0x11(%ebp),%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  80c7bc:	89 f2                	mov    %esi,%edx
  80c7be:	0f b6 c2             	movzbl %dl,%eax
  80c7c1:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80c7c4:	83 b8 a0 7d b3 00 00 	cmpl   $0x0,0xb37da0(%eax)
  80c7cb:	74 4d                	je     80c81a <find_entry+0x1a1>
  80c7cd:	c7 44 24 08 c3 3c 81 	movl   $0x813cc3,0x8(%esp)
  80c7d4:	00 
  80c7d5:	c7 44 24 04 75 01 00 	movl   $0x175,0x4(%esp)
  80c7dc:	00 
  80c7dd:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80c7e4:	e8 c3 40 ff ff       	call   8008ac <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
    /* recycle oldest pending */
    i = old_pending;
  80c7e9:	0f b6 75 ee          	movzbl -0x12(%ebp),%esi
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  80c7ed:	80 7d ee 09          	cmpb   $0x9,-0x12(%ebp)
  80c7f1:	7e 27                	jle    80c81a <find_entry+0x1a1>
    /* recycle oldest pending */
    i = old_pending;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  80c7f3:	80 7d f3 09          	cmpb   $0x9,-0xd(%ebp)
  80c7f7:	7f 79                	jg     80c872 <find_entry+0x1f9>
    /* recycle oldest pending */
    i = old_queue;
  80c7f9:	0f b6 75 f3          	movzbl -0xd(%ebp),%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  80c7fd:	89 f0                	mov    %esi,%eax
  80c7ff:	0f b6 d8             	movzbl %al,%ebx
  80c802:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  80c805:	8b 83 a0 7d b3 00    	mov    0xb37da0(%ebx),%eax
  80c80b:	e8 c5 fd ff ff       	call   80c5d5 <free_etharp_q>
    arp_table[i].q = NULL;
  80c810:	c7 83 a0 7d b3 00 00 	movl   $0x0,0xb37da0(%ebx)
  80c817:	00 00 00 
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  80c81a:	89 f2                	mov    %esi,%edx
  80c81c:	80 fa 09             	cmp    $0x9,%dl
  80c81f:	76 1c                	jbe    80c83d <find_entry+0x1c4>
  80c821:	c7 44 24 08 da 3c 81 	movl   $0x813cda,0x8(%esp)
  80c828:	00 
  80c829:	c7 44 24 04 8b 01 00 	movl   $0x18b,0x4(%esp)
  80c830:	00 
  80c831:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80c838:	e8 6f 40 ff ff       	call   8008ac <_panic>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  80c83d:	89 f0                	mov    %esi,%eax
  80c83f:	0f b6 c8             	movzbl %al,%ecx
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  80c842:	6b d1 1c             	imul   $0x1c,%ecx,%edx
  80c845:	c7 82 b0 7d b3 00 00 	movl   $0x0,0xb37db0(%edx)
  80c84c:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  80c84f:	85 ff                	test   %edi,%edi
  80c851:	74 08                	je     80c85b <find_entry+0x1e2>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  80c853:	8b 07                	mov    (%edi),%eax
  80c855:	89 82 a4 7d b3 00    	mov    %eax,0xb37da4(%edx)
  }
  arp_table[i].ctime = 0;
  80c85b:	6b c1 1c             	imul   $0x1c,%ecx,%eax
  80c85e:	c6 80 b4 7d b3 00 00 	movb   $0x0,0xb37db4(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  80c865:	89 f2                	mov    %esi,%edx
  80c867:	88 15 b8 7e b3 00    	mov    %dl,0xb37eb8
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  80c86d:	0f be ca             	movsbl %dl,%ecx
  80c870:	eb 05                	jmp    80c877 <find_entry+0x1fe>
  80c872:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
}
  80c877:	89 c8                	mov    %ecx,%eax
  80c879:	83 c4 1c             	add    $0x1c,%esp
  80c87c:	5b                   	pop    %ebx
  80c87d:	5e                   	pop    %esi
  80c87e:	5f                   	pop    %edi
  80c87f:	5d                   	pop    %ebp
  80c880:	c3                   	ret    

0080c881 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  80c881:	55                   	push   %ebp
  80c882:	89 e5                	mov    %esp,%ebp
  80c884:	83 ec 28             	sub    $0x28,%esp
  80c887:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80c88a:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80c88d:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80c890:	8b 7d 08             	mov    0x8(%ebp),%edi
  80c893:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80c896:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80c89a:	89 34 24             	mov    %esi,(%esp)
  80c89d:	e8 ea cb ff ff       	call   80948c <ip_addr_isbroadcast>
  80c8a2:	84 c0                	test   %al,%al
  80c8a4:	0f 85 d1 01 00 00    	jne    80ca7b <etharp_query+0x1fa>
  80c8aa:	8b 1e                	mov    (%esi),%ebx
  80c8ac:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80c8b3:	e8 38 e2 ff ff       	call   80aaf0 <ntohl>
  80c8b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
  80c8bb:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c8c2:	e8 29 e2 ff ff       	call   80aaf0 <ntohl>
  80c8c7:	8b 55 e8             	mov    -0x18(%ebp),%edx
  80c8ca:	21 da                	and    %ebx,%edx
  80c8cc:	39 c2                	cmp    %eax,%edx
  80c8ce:	0f 84 a7 01 00 00    	je     80ca7b <etharp_query+0x1fa>
  80c8d4:	85 f6                	test   %esi,%esi
  80c8d6:	0f 84 9f 01 00 00    	je     80ca7b <etharp_query+0x1fa>
  80c8dc:	83 3e 00             	cmpl   $0x0,(%esi)
  80c8df:	0f 84 96 01 00 00    	je     80ca7b <etharp_query+0x1fa>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  80c8e5:	ba 01 00 00 00       	mov    $0x1,%edx
  80c8ea:	89 f0                	mov    %esi,%eax
  80c8ec:	e8 88 fd ff ff       	call   80c679 <find_entry>
  80c8f1:	89 c2                	mov    %eax,%edx
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
  80c8f3:	0f be c0             	movsbl %al,%eax
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  80c8f6:	84 d2                	test   %dl,%dl
  80c8f8:	0f 88 94 01 00 00    	js     80ca92 <etharp_query+0x211>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80c8fe:	0f be d2             	movsbl %dl,%edx
  80c901:	89 55 ec             	mov    %edx,-0x14(%ebp)
  80c904:	6b c2 1c             	imul   $0x1c,%edx,%eax
  80c907:	8b 90 b0 7d b3 00    	mov    0xb37db0(%eax),%edx
  80c90d:	85 d2                	test   %edx,%edx
  80c90f:	75 0c                	jne    80c91d <etharp_query+0x9c>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80c911:	c7 80 b0 7d b3 00 01 	movl   $0x1,0xb37db0(%eax)
  80c918:	00 00 00 
  80c91b:	eb 33                	jmp    80c950 <etharp_query+0xcf>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80c91d:	8d 42 ff             	lea    -0x1(%edx),%eax
  80c920:	83 f8 01             	cmp    $0x1,%eax
  80c923:	76 1c                	jbe    80c941 <etharp_query+0xc0>
  80c925:	c7 44 24 08 20 3c 81 	movl   $0x813c20,0x8(%esp)
  80c92c:	00 
  80c92d:	c7 44 24 04 92 03 00 	movl   $0x392,0x4(%esp)
  80c934:	00 
  80c935:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80c93c:	e8 6b 3f ff ff       	call   8008ac <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  80c941:	83 fa 01             	cmp    $0x1,%edx
  80c944:	74 0a                	je     80c950 <etharp_query+0xcf>
  80c946:	c6 45 f3 ff          	movb   $0xff,-0xd(%ebp)
  80c94a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80c94e:	75 0f                	jne    80c95f <etharp_query+0xde>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80c950:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c954:	89 3c 24             	mov    %edi,(%esp)
  80c957:	e8 26 fb ff ff       	call   80c482 <etharp_request>
  80c95c:	88 45 f3             	mov    %al,-0xd(%ebp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80c95f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80c963:	0f 84 0c 01 00 00    	je     80ca75 <etharp_query+0x1f4>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80c969:	6b 45 ec 1c          	imul   $0x1c,-0x14(%ebp),%eax
  80c96d:	8b 90 b0 7d b3 00    	mov    0xb37db0(%eax),%edx
  80c973:	83 fa 02             	cmp    $0x2,%edx
  80c976:	75 1d                	jne    80c995 <etharp_query+0x114>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80c978:	8d 4f 25             	lea    0x25(%edi),%ecx
  80c97b:	05 a8 7d b3 00       	add    $0xb37da8,%eax
  80c980:	89 04 24             	mov    %eax,(%esp)
  80c983:	8b 55 10             	mov    0x10(%ebp),%edx
  80c986:	89 f8                	mov    %edi,%eax
  80c988:	e8 73 fa ff ff       	call   80c400 <etharp_send_ip>
  80c98d:	88 45 f3             	mov    %al,-0xd(%ebp)
  80c990:	e9 e0 00 00 00       	jmp    80ca75 <etharp_query+0x1f4>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80c995:	83 fa 01             	cmp    $0x1,%edx
  80c998:	0f 85 d7 00 00 00    	jne    80ca75 <etharp_query+0x1f4>
  80c99e:	8b 55 10             	mov    0x10(%ebp),%edx
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80c9a1:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80c9a5:	66 39 42 0a          	cmp    %ax,0xa(%edx)
  80c9a9:	75 21                	jne    80c9cc <etharp_query+0x14b>
  80c9ab:	83 3a 00             	cmpl   $0x0,(%edx)
  80c9ae:	74 1c                	je     80c9cc <etharp_query+0x14b>
  80c9b0:	c7 44 24 08 ed 3c 81 	movl   $0x813ced,0x8(%esp)
  80c9b7:	00 
  80c9b8:	c7 44 24 04 b1 03 00 	movl   $0x3b1,0x4(%esp)
  80c9bf:	00 
  80c9c0:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80c9c7:	e8 e0 3e ff ff       	call   8008ac <_panic>
        if(p->type != PBUF_ROM) {
  80c9cc:	80 7a 0c 01          	cmpb   $0x1,0xc(%edx)
  80c9d0:	75 10                	jne    80c9e2 <etharp_query+0x161>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80c9d2:	8b 12                	mov    (%edx),%edx
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  80c9d4:	85 d2                	test   %edx,%edx
  80c9d6:	0f 84 a6 00 00 00    	je     80ca82 <etharp_query+0x201>
  80c9dc:	8d 74 26 00          	lea    0x0(%esi),%esi
  80c9e0:	eb bf                	jmp    80c9a1 <etharp_query+0x120>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80c9e2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c9e9:	00 
  80c9ea:	0f b7 c0             	movzwl %ax,%eax
  80c9ed:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c9f1:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80c9f8:	e8 39 b3 ff ff       	call   807d36 <pbuf_alloc>
  80c9fd:	89 c3                	mov    %eax,%ebx
        if(p != NULL) {
  80c9ff:	85 c0                	test   %eax,%eax
  80ca01:	74 72                	je     80ca75 <etharp_query+0x1f4>
          if (pbuf_copy(p, q) != ERR_OK) {
  80ca03:	8b 45 10             	mov    0x10(%ebp),%eax
  80ca06:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ca0a:	89 1c 24             	mov    %ebx,(%esp)
  80ca0d:	e8 ba ae ff ff       	call   8078cc <pbuf_copy>
  80ca12:	84 c0                	test   %al,%al
  80ca14:	74 0c                	je     80ca22 <etharp_query+0x1a1>
            pbuf_free(p);
  80ca16:	89 1c 24             	mov    %ebx,(%esp)
  80ca19:	e8 55 b0 ff ff       	call   807a73 <pbuf_free>
  80ca1e:	66 90                	xchg   %ax,%ax
  80ca20:	eb 53                	jmp    80ca75 <etharp_query+0x1f4>
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  80ca22:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80ca29:	e8 1c a9 ff ff       	call   80734a <memp_malloc>
        if (new_entry != NULL) {
  80ca2e:	85 c0                	test   %eax,%eax
  80ca30:	74 3b                	je     80ca6d <etharp_query+0x1ec>
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  80ca32:	89 c1                	mov    %eax,%ecx
        if (new_entry != NULL) {
          new_entry->next = 0;
  80ca34:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80ca3a:	89 58 04             	mov    %ebx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  80ca3d:	6b 45 ec 1c          	imul   $0x1c,-0x14(%ebp),%eax
  80ca41:	8b 80 a0 7d b3 00    	mov    0xb37da0(%eax),%eax
  80ca47:	85 c0                	test   %eax,%eax
  80ca49:	74 12                	je     80ca5d <etharp_query+0x1dc>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  80ca4b:	8b 10                	mov    (%eax),%edx
  80ca4d:	85 d2                	test   %edx,%edx
  80ca4f:	74 04                	je     80ca55 <etharp_query+0x1d4>
  80ca51:	89 d0                	mov    %edx,%eax
  80ca53:	eb f6                	jmp    80ca4b <etharp_query+0x1ca>
              r = r->next;
            }
            r->next = new_entry;
  80ca55:	89 08                	mov    %ecx,(%eax)
  80ca57:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  80ca5b:	eb 18                	jmp    80ca75 <etharp_query+0x1f4>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  80ca5d:	6b 45 ec 1c          	imul   $0x1c,-0x14(%ebp),%eax
  80ca61:	89 88 a0 7d b3 00    	mov    %ecx,0xb37da0(%eax)
  80ca67:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  80ca6b:	eb 08                	jmp    80ca75 <etharp_query+0x1f4>
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  80ca6d:	89 1c 24             	mov    %ebx,(%esp)
  80ca70:	e8 fe af ff ff       	call   807a73 <pbuf_free>
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
  80ca75:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
  80ca79:	eb 17                	jmp    80ca92 <etharp_query+0x211>
  80ca7b:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80ca80:	eb 10                	jmp    80ca92 <etharp_query+0x211>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  80ca82:	8b 45 10             	mov    0x10(%ebp),%eax
  80ca85:	89 04 24             	mov    %eax,(%esp)
  80ca88:	e8 c5 ab ff ff       	call   807652 <pbuf_ref>
  80ca8d:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80ca90:	eb 90                	jmp    80ca22 <etharp_query+0x1a1>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  80ca92:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ca95:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ca98:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ca9b:	89 ec                	mov    %ebp,%esp
  80ca9d:	5d                   	pop    %ebp
  80ca9e:	c3                   	ret    

0080ca9f <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  80ca9f:	55                   	push   %ebp
  80caa0:	89 e5                	mov    %esp,%ebp
  80caa2:	83 ec 38             	sub    $0x38,%esp
  80caa5:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80caa8:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80caab:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80caae:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80cab1:	8b 75 10             	mov    0x10(%ebp),%esi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80cab4:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  80cabb:	00 
  80cabc:	8b 45 0c             	mov    0xc(%ebp),%eax
  80cabf:	89 04 24             	mov    %eax,(%esp)
  80cac2:	e8 41 ac ff ff       	call   807708 <pbuf_header>
  80cac7:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  80cacc:	84 c0                	test   %al,%al
  80cace:	0f 85 c9 00 00 00    	jne    80cb9d <etharp_output+0xfe>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80cad4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80cad8:	89 34 24             	mov    %esi,(%esp)
  80cadb:	e8 ac c9 ff ff       	call   80948c <ip_addr_isbroadcast>
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80cae0:	ba 07 3d 81 00       	mov    $0x813d07,%edx
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80cae5:	84 c0                	test   %al,%al
  80cae7:	0f 85 9d 00 00 00    	jne    80cb8a <etharp_output+0xeb>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80caed:	8b 06                	mov    (%esi),%eax
  80caef:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80caf2:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80caf9:	e8 f2 df ff ff       	call   80aaf0 <ntohl>
  80cafe:	89 c7                	mov    %eax,%edi
  80cb00:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80cb07:	e8 e4 df ff ff       	call   80aaf0 <ntohl>
  80cb0c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80cb0f:	21 fa                	and    %edi,%edx
  80cb11:	39 c2                	cmp    %eax,%edx
  80cb13:	75 41                	jne    80cb56 <etharp_output+0xb7>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80cb15:	c6 45 ee 01          	movb   $0x1,-0x12(%ebp)
    mcastaddr.addr[1] = 0x00;
  80cb19:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80cb1d:	c6 45 f0 5e          	movb   $0x5e,-0x10(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80cb21:	8b 06                	mov    (%esi),%eax
  80cb23:	89 04 24             	mov    %eax,(%esp)
  80cb26:	e8 c5 df ff ff       	call   80aaf0 <ntohl>
  80cb2b:	c1 e8 10             	shr    $0x10,%eax
  80cb2e:	83 e0 7f             	and    $0x7f,%eax
  80cb31:	88 45 f1             	mov    %al,-0xf(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80cb34:	8b 06                	mov    (%esi),%eax
  80cb36:	89 04 24             	mov    %eax,(%esp)
  80cb39:	e8 b2 df ff ff       	call   80aaf0 <ntohl>
  80cb3e:	c1 e8 08             	shr    $0x8,%eax
  80cb41:	88 45 f2             	mov    %al,-0xe(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80cb44:	8b 06                	mov    (%esi),%eax
  80cb46:	89 04 24             	mov    %eax,(%esp)
  80cb49:	e8 a2 df ff ff       	call   80aaf0 <ntohl>
  80cb4e:	88 45 f3             	mov    %al,-0xd(%ebp)
  80cb51:	8d 55 ee             	lea    -0x12(%ebp),%edx
  80cb54:	eb 34                	jmp    80cb8a <etharp_output+0xeb>
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80cb56:	8b 43 08             	mov    0x8(%ebx),%eax
  80cb59:	89 c2                	mov    %eax,%edx
  80cb5b:	23 16                	and    (%esi),%edx
  80cb5d:	23 43 04             	and    0x4(%ebx),%eax
  80cb60:	39 c2                	cmp    %eax,%edx
  80cb62:	74 0e                	je     80cb72 <etharp_output+0xd3>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  80cb64:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
  80cb69:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80cb6d:	74 2e                	je     80cb9d <etharp_output+0xfe>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  80cb6f:	8d 73 0c             	lea    0xc(%ebx),%esi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80cb72:	8b 45 0c             	mov    0xc(%ebp),%eax
  80cb75:	89 44 24 08          	mov    %eax,0x8(%esp)
  80cb79:	89 74 24 04          	mov    %esi,0x4(%esp)
  80cb7d:	89 1c 24             	mov    %ebx,(%esp)
  80cb80:	e8 fc fc ff ff       	call   80c881 <etharp_query>
  80cb85:	0f be d0             	movsbl %al,%edx
  80cb88:	eb 13                	jmp    80cb9d <etharp_output+0xfe>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80cb8a:	8d 4b 25             	lea    0x25(%ebx),%ecx
  80cb8d:	89 14 24             	mov    %edx,(%esp)
  80cb90:	8b 55 0c             	mov    0xc(%ebp),%edx
  80cb93:	89 d8                	mov    %ebx,%eax
  80cb95:	e8 66 f8 ff ff       	call   80c400 <etharp_send_ip>
  80cb9a:	0f be d0             	movsbl %al,%edx
}
  80cb9d:	89 d0                	mov    %edx,%eax
  80cb9f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80cba2:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80cba5:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80cba8:	89 ec                	mov    %ebp,%esp
  80cbaa:	5d                   	pop    %ebp
  80cbab:	c3                   	ret    

0080cbac <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  80cbac:	55                   	push   %ebp
  80cbad:	89 e5                	mov    %esp,%ebp
  80cbaf:	53                   	push   %ebx
  80cbb0:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  80cbb3:	ba 02 00 00 00       	mov    $0x2,%edx
  80cbb8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80cbbb:	e8 b9 fa ff ff       	call   80c679 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  80cbc0:	84 c0                	test   %al,%al
  80cbc2:	78 26                	js     80cbea <etharp_find_addr+0x3e>
  80cbc4:	0f be c8             	movsbl %al,%ecx
  80cbc7:	6b c1 1c             	imul   $0x1c,%ecx,%eax
  80cbca:	83 b8 b0 7d b3 00 02 	cmpl   $0x2,0xb37db0(%eax)
  80cbd1:	75 17                	jne    80cbea <etharp_find_addr+0x3e>
      *eth_ret = &arp_table[i].ethaddr;
  80cbd3:	05 a0 7d b3 00       	add    $0xb37da0,%eax
  80cbd8:	8d 50 08             	lea    0x8(%eax),%edx
  80cbdb:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80cbde:	89 13                	mov    %edx,(%ebx)
      *ip_ret = &arp_table[i].ipaddr;
  80cbe0:	83 c0 04             	add    $0x4,%eax
  80cbe3:	8b 55 14             	mov    0x14(%ebp),%edx
  80cbe6:	89 02                	mov    %eax,(%edx)
  80cbe8:	eb 05                	jmp    80cbef <etharp_find_addr+0x43>
      return i;
  80cbea:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  }
  return -1;
}
  80cbef:	89 c8                	mov    %ecx,%eax
  80cbf1:	83 c4 04             	add    $0x4,%esp
  80cbf4:	5b                   	pop    %ebx
  80cbf5:	5d                   	pop    %ebp
  80cbf6:	c3                   	ret    

0080cbf7 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80cbf7:	55                   	push   %ebp
  80cbf8:	89 e5                	mov    %esp,%ebp
  80cbfa:	83 ec 38             	sub    $0x38,%esp
  80cbfd:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80cc00:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80cc03:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80cc06:	89 c7                	mov    %eax,%edi
  80cc08:	89 d6                	mov    %edx,%esi
  80cc0a:	89 cb                	mov    %ecx,%ebx
  80cc0c:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
  80cc10:	88 45 eb             	mov    %al,-0x15(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80cc13:	80 7f 24 06          	cmpb   $0x6,0x24(%edi)
  80cc17:	74 1c                	je     80cc35 <update_arp_entry+0x3e>
  80cc19:	c7 44 24 08 48 3c 81 	movl   $0x813c48,0x8(%esp)
  80cc20:	00 
  80cc21:	c7 44 24 04 d9 01 00 	movl   $0x1d9,0x4(%esp)
  80cc28:	00 
  80cc29:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80cc30:	e8 77 3c ff ff       	call   8008ac <_panic>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80cc35:	85 d2                	test   %edx,%edx
  80cc37:	0f 84 12 01 00 00    	je     80cd4f <update_arp_entry+0x158>
  80cc3d:	83 3a 00             	cmpl   $0x0,(%edx)
  80cc40:	0f 84 09 01 00 00    	je     80cd4f <update_arp_entry+0x158>
  80cc46:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80cc4a:	89 14 24             	mov    %edx,(%esp)
  80cc4d:	e8 3a c8 ff ff       	call   80948c <ip_addr_isbroadcast>
  80cc52:	84 c0                	test   %al,%al
  80cc54:	0f 85 f5 00 00 00    	jne    80cd4f <update_arp_entry+0x158>
  80cc5a:	8b 0e                	mov    (%esi),%ecx
  80cc5c:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80cc5f:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80cc66:	e8 85 de ff ff       	call   80aaf0 <ntohl>
  80cc6b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80cc6e:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80cc75:	e8 76 de ff ff       	call   80aaf0 <ntohl>
  80cc7a:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80cc7d:	23 55 f0             	and    -0x10(%ebp),%edx
  80cc80:	39 c2                	cmp    %eax,%edx
  80cc82:	0f 84 c7 00 00 00    	je     80cd4f <update_arp_entry+0x158>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  80cc88:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
  80cc8c:	89 f0                	mov    %esi,%eax
  80cc8e:	e8 e6 f9 ff ff       	call   80c679 <find_entry>
  80cc93:	89 c2                	mov    %eax,%edx
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
    return (err_t)i;
  80cc95:	0f be c0             	movsbl %al,%eax
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  80cc98:	84 d2                	test   %dl,%dl
  80cc9a:	0f 88 bb 00 00 00    	js     80cd5b <update_arp_entry+0x164>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  80cca0:	0f be ca             	movsbl %dl,%ecx
  80cca3:	6b c1 1c             	imul   $0x1c,%ecx,%eax
  80cca6:	c7 80 b0 7d b3 00 02 	movl   $0x2,0xb37db0(%eax)
  80ccad:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  80ccb0:	89 b8 b8 7d b3 00    	mov    %edi,0xb37db8(%eax)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80ccb6:	0f b6 53 05          	movzbl 0x5(%ebx),%edx
  80ccba:	88 90 ad 7d b3 00    	mov    %dl,0xb37dad(%eax)
  80ccc0:	0f b6 53 04          	movzbl 0x4(%ebx),%edx
  80ccc4:	88 90 ac 7d b3 00    	mov    %dl,0xb37dac(%eax)
  80ccca:	0f b6 53 03          	movzbl 0x3(%ebx),%edx
  80ccce:	88 90 ab 7d b3 00    	mov    %dl,0xb37dab(%eax)
  80ccd4:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
  80ccd8:	88 90 aa 7d b3 00    	mov    %dl,0xb37daa(%eax)
  80ccde:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
  80cce2:	88 90 a9 7d b3 00    	mov    %dl,0xb37da9(%eax)
  80cce8:	0f b6 13             	movzbl (%ebx),%edx
  80cceb:	88 90 a8 7d b3 00    	mov    %dl,0xb37da8(%eax)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  80ccf1:	c6 80 b4 7d b3 00 00 	movb   $0x0,0xb37db4(%eax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80ccf8:	8b 90 a0 7d b3 00    	mov    0xb37da0(%eax),%edx
  80ccfe:	85 d2                	test   %edx,%edx
  80cd00:	74 54                	je     80cd56 <update_arp_entry+0x15f>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  80cd02:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80cd05:	8d 47 25             	lea    0x25(%edi),%eax
  80cd08:	89 45 e0             	mov    %eax,-0x20(%ebp)
  while (arp_table[i].q != NULL) {
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  80cd0b:	8b 02                	mov    (%edx),%eax
  80cd0d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80cd10:	89 81 a0 7d b3 00    	mov    %eax,0xb37da0(%ecx)
    /* get the packet pointer */
    p = q->p;
  80cd16:	8b 72 04             	mov    0x4(%edx),%esi
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  80cd19:	89 54 24 04          	mov    %edx,0x4(%esp)
  80cd1d:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80cd24:	e8 de a5 ff ff       	call   807307 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80cd29:	89 1c 24             	mov    %ebx,(%esp)
  80cd2c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80cd2f:	89 f2                	mov    %esi,%edx
  80cd31:	89 f8                	mov    %edi,%eax
  80cd33:	e8 c8 f6 ff ff       	call   80c400 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  80cd38:	89 34 24             	mov    %esi,(%esp)
  80cd3b:	e8 33 ad ff ff       	call   807a73 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80cd40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80cd43:	8b 90 a0 7d b3 00    	mov    0xb37da0(%eax),%edx
  80cd49:	85 d2                	test   %edx,%edx
  80cd4b:	74 09                	je     80cd56 <update_arp_entry+0x15f>
  80cd4d:	eb bc                	jmp    80cd0b <update_arp_entry+0x114>
  80cd4f:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80cd54:	eb 05                	jmp    80cd5b <update_arp_entry+0x164>
  80cd56:	b8 00 00 00 00       	mov    $0x0,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  80cd5b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80cd5e:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80cd61:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80cd64:	89 ec                	mov    %ebp,%esp
  80cd66:	5d                   	pop    %ebp
  80cd67:	c3                   	ret    

0080cd68 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  80cd68:	55                   	push   %ebp
  80cd69:	89 e5                	mov    %esp,%ebp
  80cd6b:	83 ec 18             	sub    $0x18,%esp
  80cd6e:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80cd71:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80cd74:	8b 75 08             	mov    0x8(%ebp),%esi
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80cd77:	85 f6                	test   %esi,%esi
  80cd79:	75 1c                	jne    80cd97 <etharp_ip_input+0x2f>
  80cd7b:	c7 44 24 08 bb 2e 81 	movl   $0x812ebb,0x8(%esp)
  80cd82:	00 
  80cd83:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  80cd8a:	00 
  80cd8b:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80cd92:	e8 15 3b ff ff       	call   8008ac <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  80cd97:	8b 45 0c             	mov    0xc(%ebp),%eax
  80cd9a:	8b 58 04             	mov    0x4(%eax),%ebx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80cd9d:	8b 46 08             	mov    0x8(%esi),%eax
  80cda0:	89 c2                	mov    %eax,%edx
  80cda2:	23 53 1c             	and    0x1c(%ebx),%edx
  80cda5:	23 46 04             	and    0x4(%esi),%eax
  80cda8:	39 c2                	cmp    %eax,%edx
  80cdaa:	75 14                	jne    80cdc0 <etharp_ip_input+0x58>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80cdac:	8d 4b 06             	lea    0x6(%ebx),%ecx
  80cdaf:	8d 53 1c             	lea    0x1c(%ebx),%edx
  80cdb2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80cdb9:	89 f0                	mov    %esi,%eax
  80cdbb:	e8 37 fe ff ff       	call   80cbf7 <update_arp_entry>
}
  80cdc0:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80cdc3:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80cdc6:	89 ec                	mov    %ebp,%esp
  80cdc8:	5d                   	pop    %ebp
  80cdc9:	c3                   	ret    

0080cdca <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  80cdca:	55                   	push   %ebp
  80cdcb:	89 e5                	mov    %esp,%ebp
  80cdcd:	53                   	push   %ebx
  80cdce:	83 ec 04             	sub    $0x4,%esp
  80cdd1:	bb 00 00 00 00       	mov    $0x0,%ebx
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80cdd6:	0f b6 93 b4 7d b3 00 	movzbl 0xb37db4(%ebx),%edx
  80cddd:	83 c2 01             	add    $0x1,%edx
  80cde0:	88 93 b4 7d b3 00    	mov    %dl,0xb37db4(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80cde6:	8b 83 b0 7d b3 00    	mov    0xb37db0(%ebx),%eax
  80cdec:	83 f8 02             	cmp    $0x2,%eax
  80cdef:	75 07                	jne    80cdf8 <etharp_tmr+0x2e>
  80cdf1:	80 fa ef             	cmp    $0xef,%dl
  80cdf4:	77 11                	ja     80ce07 <etharp_tmr+0x3d>
  80cdf6:	eb 32                	jmp    80ce2a <etharp_tmr+0x60>
  80cdf8:	83 f8 01             	cmp    $0x1,%eax
  80cdfb:	90                   	nop    
  80cdfc:	8d 74 26 00          	lea    0x0(%esi),%esi
  80ce00:	75 28                	jne    80ce2a <etharp_tmr+0x60>
  80ce02:	80 fa 01             	cmp    $0x1,%dl
  80ce05:	76 23                	jbe    80ce2a <etharp_tmr+0x60>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  80ce07:	8b 83 a0 7d b3 00    	mov    0xb37da0(%ebx),%eax
  80ce0d:	85 c0                	test   %eax,%eax
  80ce0f:	74 0f                	je     80ce20 <etharp_tmr+0x56>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  80ce11:	e8 bf f7 ff ff       	call   80c5d5 <free_etharp_q>
        arp_table[i].q = NULL;
  80ce16:	c7 83 a0 7d b3 00 00 	movl   $0x0,0xb37da0(%ebx)
  80ce1d:	00 00 00 
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  80ce20:	c7 83 b0 7d b3 00 00 	movl   $0x0,0xb37db0(%ebx)
  80ce27:	00 00 00 
  80ce2a:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80ce2d:	81 fb 18 01 00 00    	cmp    $0x118,%ebx
  80ce33:	75 a1                	jne    80cdd6 <etharp_tmr+0xc>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  80ce35:	83 c4 04             	add    $0x4,%esp
  80ce38:	5b                   	pop    %ebx
  80ce39:	5d                   	pop    %ebp
  80ce3a:	c3                   	ret    

0080ce3b <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  80ce3b:	55                   	push   %ebp
  80ce3c:	89 e5                	mov    %esp,%ebp
  80ce3e:	83 ec 28             	sub    $0x28,%esp
  80ce41:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ce44:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ce47:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80ce4a:	8b 7d 10             	mov    0x10(%ebp),%edi
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80ce4d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80ce51:	75 1c                	jne    80ce6f <etharp_arp_input+0x34>
  80ce53:	c7 44 24 08 bb 2e 81 	movl   $0x812ebb,0x8(%esp)
  80ce5a:	00 
  80ce5b:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80ce62:	00 
  80ce63:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80ce6a:	e8 3d 3a ff ff       	call   8008ac <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  80ce6f:	66 83 7f 0a 29       	cmpw   $0x29,0xa(%edi)
  80ce74:	77 0f                	ja     80ce85 <etharp_arp_input+0x4a>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80ce76:	89 3c 24             	mov    %edi,(%esp)
  80ce79:	e8 f5 ab ff ff       	call   807a73 <pbuf_free>
  80ce7e:	66 90                	xchg   %ax,%ax
  80ce80:	e9 b7 01 00 00       	jmp    80d03c <etharp_arp_input+0x201>
    return;
  }

  hdr = p->payload;
  80ce85:	8b 77 04             	mov    0x4(%edi),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80ce88:	0f b7 5e 0e          	movzwl 0xe(%esi),%ebx
  80ce8c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ce93:	e8 f7 d9 ff ff       	call   80a88f <htons>
  80ce98:	66 39 c3             	cmp    %ax,%bx
  80ce9b:	75 3f                	jne    80cedc <etharp_arp_input+0xa1>
  80ce9d:	0f b7 5e 12          	movzwl 0x12(%esi),%ebx
  80cea1:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80cea8:	e8 e2 d9 ff ff       	call   80a88f <htons>
  80cead:	66 39 c3             	cmp    %ax,%bx
  80ceb0:	75 2a                	jne    80cedc <etharp_arp_input+0xa1>
  80ceb2:	0f b7 5e 10          	movzwl 0x10(%esi),%ebx
  80ceb6:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80cebd:	e8 cd d9 ff ff       	call   80a88f <htons>
  80cec2:	66 39 c3             	cmp    %ax,%bx
  80cec5:	75 15                	jne    80cedc <etharp_arp_input+0xa1>
  80cec7:	0f b7 5e 0c          	movzwl 0xc(%esi),%ebx
  80cecb:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80ced2:	e8 b8 d9 ff ff       	call   80a88f <htons>
  80ced7:	66 39 c3             	cmp    %ax,%bx
  80ceda:	74 0d                	je     80cee9 <etharp_arp_input+0xae>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80cedc:	89 3c 24             	mov    %edi,(%esp)
  80cedf:	e8 8f ab ff ff       	call   807a73 <pbuf_free>
  80cee4:	e9 53 01 00 00       	jmp    80d03c <etharp_arp_input+0x201>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80cee9:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80cef0:	00 
  80cef1:	8d 46 1c             	lea    0x1c(%esi),%eax
  80cef4:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cef8:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80cefb:	89 04 24             	mov    %eax,(%esp)
  80cefe:	e8 65 43 ff ff       	call   801268 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80cf03:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80cf0a:	00 
  80cf0b:	8d 46 26             	lea    0x26(%esi),%eax
  80cf0e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cf12:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80cf15:	89 04 24             	mov    %eax,(%esp)
  80cf18:	e8 4b 43 ff ff       	call   801268 <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80cf1d:	8b 55 08             	mov    0x8(%ebp),%edx
  80cf20:	8b 42 04             	mov    0x4(%edx),%eax
  80cf23:	85 c0                	test   %eax,%eax
  80cf25:	74 1f                	je     80cf46 <etharp_arp_input+0x10b>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  80cf27:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  }

  /* ARP message directed to us? */
  if (for_us) {
  80cf2a:	0f 94 c3             	sete   %bl
  80cf2d:	75 1c                	jne    80cf4b <etharp_arp_input+0x110>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80cf2f:	8d 4e 16             	lea    0x16(%esi),%ecx
  80cf32:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80cf39:	8d 55 f0             	lea    -0x10(%ebp),%edx
  80cf3c:	8b 45 08             	mov    0x8(%ebp),%eax
  80cf3f:	e8 b3 fc ff ff       	call   80cbf7 <update_arp_entry>
  80cf44:	eb 1a                	jmp    80cf60 <etharp_arp_input+0x125>
  80cf46:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  80cf4b:	8d 4e 16             	lea    0x16(%esi),%ecx
  80cf4e:	8d 55 f0             	lea    -0x10(%ebp),%edx
  80cf51:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80cf58:	8b 45 08             	mov    0x8(%ebp),%eax
  80cf5b:	e8 97 fc ff ff       	call   80cbf7 <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  80cf60:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  80cf64:	89 04 24             	mov    %eax,(%esp)
  80cf67:	e8 23 d9 ff ff       	call   80a88f <htons>
  80cf6c:	66 83 f8 01          	cmp    $0x1,%ax
  80cf70:	74 13                	je     80cf85 <etharp_arp_input+0x14a>
  80cf72:	66 83 f8 02          	cmp    $0x2,%ax
  80cf76:	0f 85 b8 00 00 00    	jne    80d034 <etharp_arp_input+0x1f9>
  80cf7c:	8d 74 26 00          	lea    0x0(%esi),%esi
  80cf80:	e9 9d 00 00 00       	jmp    80d022 <etharp_arp_input+0x1e7>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  80cf85:	84 db                	test   %bl,%bl
  80cf87:	0f 84 a7 00 00 00    	je     80d034 <etharp_arp_input+0x1f9>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  80cf8d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80cf94:	e8 f6 d8 ff ff       	call   80a88f <htons>
  80cf99:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  80cf9d:	0f b7 56 1c          	movzwl 0x1c(%esi),%edx
  80cfa1:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80cfa5:	66 89 46 28          	mov    %ax,0x28(%esi)
  80cfa9:	66 89 56 26          	mov    %dx,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  80cfad:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80cfb0:	0f b7 51 04          	movzwl 0x4(%ecx),%edx
  80cfb4:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
  80cfb8:	66 89 46 1e          	mov    %ax,0x1e(%esi)
  80cfbc:	66 89 56 1c          	mov    %dx,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80cfc0:	b9 06 00 00 00       	mov    $0x6,%ecx
  80cfc5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80cfc8:	80 7b 24 06          	cmpb   $0x6,0x24(%ebx)
  80cfcc:	74 1c                	je     80cfea <etharp_arp_input+0x1af>
  80cfce:	c7 44 24 08 a8 3b 81 	movl   $0x813ba8,0x8(%esp)
  80cfd5:	00 
  80cfd6:	c7 44 24 04 c7 02 00 	movl   $0x2c7,0x4(%esp)
  80cfdd:	00 
  80cfde:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80cfe5:	e8 c2 38 ff ff       	call   8008ac <_panic>
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  80cfea:	83 e9 01             	sub    $0x1,%ecx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  80cfed:	0f b6 c1             	movzbl %cl,%eax
  80cff0:	0f b6 54 06 16       	movzbl 0x16(%esi,%eax,1),%edx
  80cff5:	88 54 06 20          	mov    %dl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  80cff9:	88 14 06             	mov    %dl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80cffc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80cfff:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
  80d003:	88 54 06 16          	mov    %dl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  80d007:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
  80d00b:	88 54 06 06          	mov    %dl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  80d00f:	84 c9                	test   %cl,%cl
  80d011:	75 d7                	jne    80cfea <etharp_arp_input+0x1af>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  80d013:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80d017:	8b 45 08             	mov    0x8(%ebp),%eax
  80d01a:	89 04 24             	mov    %eax,(%esp)
  80d01d:	ff 50 18             	call   *0x18(%eax)
  80d020:	eb 12                	jmp    80d034 <etharp_arp_input+0x1f9>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  80d022:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80d025:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d029:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d02c:	89 0c 24             	mov    %ecx,(%esp)
  80d02f:	e8 26 90 ff ff       	call   80605a <dhcp_arp_reply>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  80d034:	89 3c 24             	mov    %edi,(%esp)
  80d037:	e8 37 aa ff ff       	call   807a73 <pbuf_free>
}
  80d03c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80d03f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80d042:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80d045:	89 ec                	mov    %ebp,%esp
  80d047:	5d                   	pop    %ebp
  80d048:	c3                   	ret    

0080d049 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80d049:	55                   	push   %ebp
  80d04a:	89 e5                	mov    %esp,%ebp
  80d04c:	83 ec 18             	sub    $0x18,%esp
  80d04f:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80d052:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80d055:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80d058:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80d05b:	8b 43 04             	mov    0x4(%ebx),%eax
  80d05e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d062:	89 04 24             	mov    %eax,(%esp)
  80d065:	e8 25 d8 ff ff       	call   80a88f <htons>
  80d06a:	66 3d 00 08          	cmp    $0x800,%ax
  80d06e:	74 08                	je     80d078 <ethernet_input+0x2f>
  80d070:	66 3d 06 08          	cmp    $0x806,%ax
  80d074:	75 61                	jne    80d0d7 <ethernet_input+0x8e>
  80d076:	eb 4a                	jmp    80d0c2 <ethernet_input+0x79>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80d078:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80d07c:	89 34 24             	mov    %esi,(%esp)
  80d07f:	e8 e4 fc ff ff       	call   80cd68 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80d084:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80d08b:	ff 
  80d08c:	89 1c 24             	mov    %ebx,(%esp)
  80d08f:	e8 74 a6 ff ff       	call   807708 <pbuf_header>
  80d094:	84 c0                	test   %al,%al
  80d096:	74 1c                	je     80d0b4 <ethernet_input+0x6b>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80d098:	c7 44 24 08 70 3c 81 	movl   $0x813c70,0x8(%esp)
  80d09f:	00 
  80d0a0:	c7 44 24 04 7e 04 00 	movl   $0x47e,0x4(%esp)
  80d0a7:	00 
  80d0a8:	c7 04 24 91 3c 81 00 	movl   $0x813c91,(%esp)
  80d0af:	e8 f8 37 ff ff       	call   8008ac <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80d0b4:	89 74 24 04          	mov    %esi,0x4(%esp)
  80d0b8:	89 1c 24             	mov    %ebx,(%esp)
  80d0bb:	e8 ae c6 ff ff       	call   80976e <ip_input>
  80d0c0:	eb 1d                	jmp    80d0df <ethernet_input+0x96>
      }
      break;
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80d0c2:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80d0c6:	8d 46 25             	lea    0x25(%esi),%eax
  80d0c9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d0cd:	89 34 24             	mov    %esi,(%esp)
  80d0d0:	e8 66 fd ff ff       	call   80ce3b <etharp_arp_input>
  80d0d5:	eb 08                	jmp    80d0df <ethernet_input+0x96>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80d0d7:	89 1c 24             	mov    %ebx,(%esp)
  80d0da:	e8 94 a9 ff ff       	call   807a73 <pbuf_free>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80d0df:	b8 00 00 00 00       	mov    $0x0,%eax
  80d0e4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80d0e7:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80d0ea:	89 ec                	mov    %ebp,%esp
  80d0ec:	5d                   	pop    %ebp
  80d0ed:	c3                   	ret    
	...

0080d0f0 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80d0f0:	55                   	push   %ebp
  80d0f1:	89 e5                	mov    %esp,%ebp
  80d0f3:	53                   	push   %ebx
  80d0f4:	b9 c0 7e b3 00       	mov    $0xb37ec0,%ecx
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80d0f9:	c7 01 01 00 00 00    	movl   $0x1,(%ecx)
  80d0ff:	89 cb                	mov    %ecx,%ebx
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80d101:	8b 15 c0 92 b3 00    	mov    0xb392c0,%edx
  80d107:	89 51 0c             	mov    %edx,0xc(%ecx)
  80d10a:	85 d2                	test   %edx,%edx
  80d10c:	74 06                	je     80d114 <sys_init+0x24>
  80d10e:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d111:	89 42 10             	mov    %eax,0x10(%edx)
  80d114:	89 1d c0 92 b3 00    	mov    %ebx,0xb392c0
  80d11a:	c7 41 10 c0 92 b3 00 	movl   $0xb392c0,0x10(%ecx)
  80d121:	83 c1 14             	add    $0x14,%ecx

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80d124:	81 f9 c0 92 b3 00    	cmp    $0xb392c0,%ecx
  80d12a:	75 cd                	jne    80d0f9 <sys_init+0x9>
  80d12c:	b9 e0 92 b3 00       	mov    $0xb392e0,%ecx
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80d131:	c7 01 01 00 00 00    	movl   $0x1,(%ecx)
  80d137:	89 cb                	mov    %ecx,%ebx
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80d139:	8b 15 e0 e0 b3 00    	mov    0xb3e0e0,%edx
  80d13f:	89 91 94 00 00 00    	mov    %edx,0x94(%ecx)
  80d145:	85 d2                	test   %edx,%edx
  80d147:	74 0c                	je     80d155 <sys_init+0x65>
  80d149:	8d 81 94 00 00 00    	lea    0x94(%ecx),%eax
  80d14f:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
  80d155:	89 1d e0 e0 b3 00    	mov    %ebx,0xb3e0e0
  80d15b:	c7 81 98 00 00 00 e0 	movl   $0xb3e0e0,0x98(%ecx)
  80d162:	e0 b3 00 
  80d165:	81 c1 9c 00 00 00    	add    $0x9c,%ecx
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  80d16b:	81 f9 e0 e0 b3 00    	cmp    $0xb3e0e0,%ecx
  80d171:	75 be                	jne    80d131 <sys_init+0x41>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  80d173:	5b                   	pop    %ebx
  80d174:	5d                   	pop    %ebp
  80d175:	c3                   	ret    

0080d176 <lwip_core_lock>:
    return &t->tmo;
}

void
lwip_core_lock(void)
{
  80d176:	55                   	push   %ebp
  80d177:	89 e5                	mov    %esp,%ebp
}
  80d179:	5d                   	pop    %ebp
  80d17a:	c3                   	ret    

0080d17b <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80d17b:	55                   	push   %ebp
  80d17c:	89 e5                	mov    %esp,%ebp
}
  80d17e:	5d                   	pop    %ebp
  80d17f:	c3                   	ret    

0080d180 <sys_sem_free>:
    return se - &sems[0];
}

void
sys_sem_free(sys_sem_t sem)
{
  80d180:	55                   	push   %ebp
  80d181:	89 e5                	mov    %esp,%ebp
  80d183:	83 ec 18             	sub    $0x18,%esp
  80d186:	8b 55 08             	mov    0x8(%ebp),%edx
    assert(!sems[sem].freed);
  80d189:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d18c:	83 3c 85 c0 7e b3 00 	cmpl   $0x0,0xb37ec0(,%eax,4)
  80d193:	00 
  80d194:	74 24                	je     80d1ba <sys_sem_free+0x3a>
  80d196:	c7 44 24 0c 13 3d 81 	movl   $0x813d13,0xc(%esp)
  80d19d:	00 
  80d19e:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  80d1a5:	00 
  80d1a6:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80d1ad:	00 
  80d1ae:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d1b5:	e8 f2 36 ff ff       	call   8008ac <_panic>
    sems[sem].freed = 1;
  80d1ba:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d1bd:	c1 e0 02             	shl    $0x2,%eax
  80d1c0:	c7 80 c0 7e b3 00 01 	movl   $0x1,0xb37ec0(%eax)
  80d1c7:	00 00 00 
    sems[sem].gen++;
  80d1ca:	83 80 c4 7e b3 00 01 	addl   $0x1,0xb37ec4(%eax)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80d1d1:	8d 88 c0 7e b3 00    	lea    0xb37ec0(%eax),%ecx
  80d1d7:	8b 15 c0 92 b3 00    	mov    0xb392c0,%edx
  80d1dd:	89 51 0c             	mov    %edx,0xc(%ecx)
  80d1e0:	85 d2                	test   %edx,%edx
  80d1e2:	74 06                	je     80d1ea <sys_sem_free+0x6a>
  80d1e4:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d1e7:	89 42 10             	mov    %eax,0x10(%edx)
  80d1ea:	89 0d c0 92 b3 00    	mov    %ecx,0xb392c0
  80d1f0:	c7 41 10 c0 92 b3 00 	movl   $0xb392c0,0x10(%ecx)
}
  80d1f7:	c9                   	leave  
  80d1f8:	c3                   	ret    

0080d1f9 <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  80d1f9:	55                   	push   %ebp
  80d1fa:	89 e5                	mov    %esp,%ebp
  80d1fc:	56                   	push   %esi
  80d1fd:	53                   	push   %ebx
  80d1fe:	83 ec 10             	sub    $0x10,%esp
  80d201:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80d204:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80d20a:	83 b8 e0 92 b3 00 00 	cmpl   $0x0,0xb392e0(%eax)
  80d211:	74 24                	je     80d237 <sys_mbox_free+0x3e>
  80d213:	c7 44 24 0c 41 3d 81 	movl   $0x813d41,0xc(%esp)
  80d21a:	00 
  80d21b:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  80d222:	00 
  80d223:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  80d22a:	00 
  80d22b:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d232:	e8 75 36 ff ff       	call   8008ac <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  80d237:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80d23d:	8b 83 6c 93 b3 00    	mov    0xb3936c(%ebx),%eax
  80d243:	89 04 24             	mov    %eax,(%esp)
  80d246:	e8 35 ff ff ff       	call   80d180 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80d24b:	8b 83 70 93 b3 00    	mov    0xb39370(%ebx),%eax
  80d251:	89 04 24             	mov    %eax,(%esp)
  80d254:	e8 27 ff ff ff       	call   80d180 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80d259:	8d 8b e0 92 b3 00    	lea    0xb392e0(%ebx),%ecx
  80d25f:	8b 15 e0 e0 b3 00    	mov    0xb3e0e0,%edx
  80d265:	89 91 94 00 00 00    	mov    %edx,0x94(%ecx)
  80d26b:	85 d2                	test   %edx,%edx
  80d26d:	74 0c                	je     80d27b <sys_mbox_free+0x82>
  80d26f:	8d 81 94 00 00 00    	lea    0x94(%ecx),%eax
  80d275:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
  80d27b:	89 0d e0 e0 b3 00    	mov    %ecx,0xb3e0e0
  80d281:	c7 81 98 00 00 00 e0 	movl   $0xb3e0e0,0x98(%ecx)
  80d288:	e0 b3 00 
    mboxes[mbox].freed = 1;
  80d28b:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80d291:	c7 80 e0 92 b3 00 01 	movl   $0x1,0xb392e0(%eax)
  80d298:	00 00 00 
}
  80d29b:	83 c4 10             	add    $0x10,%esp
  80d29e:	5b                   	pop    %ebx
  80d29f:	5e                   	pop    %esi
  80d2a0:	5d                   	pop    %ebp
  80d2a1:	c3                   	ret    

0080d2a2 <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80d2a2:	55                   	push   %ebp
  80d2a3:	89 e5                	mov    %esp,%ebp
  80d2a5:	57                   	push   %edi
  80d2a6:	56                   	push   %esi
  80d2a7:	53                   	push   %ebx
  80d2a8:	83 ec 1c             	sub    $0x1c,%esp
    thread_id_t tid = thread_id();
  80d2ab:	e8 c3 07 00 00       	call   80da73 <thread_id>
  80d2b0:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d2b2:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80d2b7:	f7 e2                	mul    %edx
  80d2b9:	c1 ea 08             	shr    $0x8,%edx
  80d2bc:	89 d0                	mov    %edx,%eax
  80d2be:	c1 e0 08             	shl    $0x8,%eax
  80d2c1:	01 d0                	add    %edx,%eax
  80d2c3:	89 f2                	mov    %esi,%edx
  80d2c5:	29 c2                	sub    %eax,%edx
  80d2c7:	89 d0                	mov    %edx,%eax
  80d2c9:	c1 e0 02             	shl    $0x2,%eax
  80d2cc:	8d b8 00 e1 b3 00    	lea    0xb3e100(%eax),%edi
  80d2d2:	8b 98 00 e1 b3 00    	mov    0xb3e100(%eax),%ebx
  80d2d8:	85 db                	test   %ebx,%ebx
  80d2da:	74 18                	je     80d2f4 <sys_arch_timeouts+0x52>
	if (t->tid == tid)
  80d2dc:	3b 33                	cmp    (%ebx),%esi
  80d2de:	75 0d                	jne    80d2ed <sys_arch_timeouts+0x4b>
  80d2e0:	e9 a8 00 00 00       	jmp    80d38d <sys_arch_timeouts+0xeb>
  80d2e5:	3b 33                	cmp    (%ebx),%esi
  80d2e7:	0f 84 a0 00 00 00    	je     80d38d <sys_arch_timeouts+0xeb>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d2ed:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80d2f0:	85 db                	test   %ebx,%ebx
  80d2f2:	75 f1                	jne    80d2e5 <sys_arch_timeouts+0x43>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80d2f4:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  80d2fb:	e8 b4 5a ff ff       	call   802db4 <malloc>
  80d300:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80d302:	85 c0                	test   %eax,%eax
  80d304:	75 1c                	jne    80d322 <sys_arch_timeouts+0x80>
	panic("sys_arch_timeouts: cannot malloc");
  80d306:	c7 44 24 08 a4 3d 81 	movl   $0x813da4,0x8(%esp)
  80d30d:	00 
  80d30e:	c7 44 24 04 2c 01 00 	movl   $0x12c,0x4(%esp)
  80d315:	00 
  80d316:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d31d:	e8 8a 35 ff ff       	call   8008ac <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80d322:	c7 04 24 98 d3 80 00 	movl   $0x80d398,(%esp)
  80d329:	e8 9e 07 00 00       	call   80dacc <thread_onhalt>
    if (r < 0)
  80d32e:	85 c0                	test   %eax,%eax
  80d330:	79 28                	jns    80d35a <sys_arch_timeouts+0xb8>
	panic("thread_onhalt failed: %s", e2s(r));
  80d332:	89 04 24             	mov    %eax,(%esp)
  80d335:	e8 fe 0a 00 00       	call   80de38 <e2s>
  80d33a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d33e:	c7 44 24 08 55 3d 81 	movl   $0x813d55,0x8(%esp)
  80d345:	00 
  80d346:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80d34d:	00 
  80d34e:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d355:	e8 52 35 ff ff       	call   8008ac <_panic>

    t->tid = tid;
  80d35a:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80d35c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80d363:	00 
  80d364:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80d36b:	00 
  80d36c:	8d 43 04             	lea    0x4(%ebx),%eax
  80d36f:	89 04 24             	mov    %eax,(%esp)
  80d372:	e8 17 3e ff ff       	call   80118e <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80d377:	8b 07                	mov    (%edi),%eax
  80d379:	89 43 08             	mov    %eax,0x8(%ebx)
  80d37c:	85 c0                	test   %eax,%eax
  80d37e:	74 08                	je     80d388 <sys_arch_timeouts+0xe6>
  80d380:	8b 17                	mov    (%edi),%edx
  80d382:	8d 43 08             	lea    0x8(%ebx),%eax
  80d385:	89 42 0c             	mov    %eax,0xc(%edx)
  80d388:	89 1f                	mov    %ebx,(%edi)
  80d38a:	89 7b 0c             	mov    %edi,0xc(%ebx)

out:
  80d38d:	8d 43 04             	lea    0x4(%ebx),%eax
    return &t->tmo;
}
  80d390:	83 c4 1c             	add    $0x1c,%esp
  80d393:	5b                   	pop    %ebx
  80d394:	5e                   	pop    %esi
  80d395:	5f                   	pop    %edi
  80d396:	5d                   	pop    %ebp
  80d397:	c3                   	ret    

0080d398 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  80d398:	55                   	push   %ebp
  80d399:	89 e5                	mov    %esp,%ebp
  80d39b:	53                   	push   %ebx
  80d39c:	83 ec 04             	sub    $0x4,%esp
  80d39f:	8b 5d 08             	mov    0x8(%ebp),%ebx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d3a2:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80d3a7:	89 d8                	mov    %ebx,%eax
  80d3a9:	f7 e2                	mul    %edx
  80d3ab:	c1 ea 08             	shr    $0x8,%edx
  80d3ae:	89 d0                	mov    %edx,%eax
  80d3b0:	c1 e0 08             	shl    $0x8,%eax
  80d3b3:	01 d0                	add    %edx,%eax
  80d3b5:	89 da                	mov    %ebx,%edx
  80d3b7:	29 c2                	sub    %eax,%edx
  80d3b9:	8b 0c 95 00 e1 b3 00 	mov    0xb3e100(,%edx,4),%ecx
  80d3c0:	85 c9                	test   %ecx,%ecx
  80d3c2:	74 34                	je     80d3f8 <timeout_cleanup+0x60>
	if (t->tid == tid) {
  80d3c4:	39 19                	cmp    %ebx,(%ecx)
  80d3c6:	75 29                	jne    80d3f1 <timeout_cleanup+0x59>
  80d3c8:	eb 08                	jmp    80d3d2 <timeout_cleanup+0x3a>
  80d3ca:	39 19                	cmp    %ebx,(%ecx)
  80d3cc:	8d 74 26 00          	lea    0x0(%esi),%esi
  80d3d0:	75 1f                	jne    80d3f1 <timeout_cleanup+0x59>
	    LIST_REMOVE(t, link);
  80d3d2:	8b 51 08             	mov    0x8(%ecx),%edx
  80d3d5:	85 d2                	test   %edx,%edx
  80d3d7:	74 06                	je     80d3df <timeout_cleanup+0x47>
  80d3d9:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d3dc:	89 42 0c             	mov    %eax,0xc(%edx)
  80d3df:	8b 51 0c             	mov    0xc(%ecx),%edx
  80d3e2:	8b 41 08             	mov    0x8(%ecx),%eax
  80d3e5:	89 02                	mov    %eax,(%edx)
	    free(t);
  80d3e7:	89 0c 24             	mov    %ecx,(%esp)
  80d3ea:	e8 f1 58 ff ff       	call   802ce0 <free>
  80d3ef:	eb 07                	jmp    80d3f8 <timeout_cleanup+0x60>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d3f1:	8b 49 08             	mov    0x8(%ecx),%ecx
  80d3f4:	85 c9                	test   %ecx,%ecx
  80d3f6:	75 d2                	jne    80d3ca <timeout_cleanup+0x32>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80d3f8:	83 c4 04             	add    $0x4,%esp
  80d3fb:	5b                   	pop    %ebx
  80d3fc:	5d                   	pop    %ebp
  80d3fd:	8d 76 00             	lea    0x0(%esi),%esi
  80d400:	c3                   	ret    

0080d401 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80d401:	55                   	push   %ebp
  80d402:	89 e5                	mov    %esp,%ebp
  80d404:	53                   	push   %ebx
  80d405:	83 ec 04             	sub    $0x4,%esp
  80d408:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  80d40b:	8b 43 04             	mov    0x4(%ebx),%eax
  80d40e:	89 04 24             	mov    %eax,(%esp)
  80d411:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  80d413:	89 1c 24             	mov    %ebx,(%esp)
  80d416:	e8 c5 58 ff ff       	call   802ce0 <free>
}
  80d41b:	83 c4 04             	add    $0x4,%esp
  80d41e:	5b                   	pop    %ebx
  80d41f:	5d                   	pop    %ebp
  80d420:	c3                   	ret    

0080d421 <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80d421:	55                   	push   %ebp
  80d422:	89 e5                	mov    %esp,%ebp
  80d424:	83 ec 28             	sub    $0x28,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80d427:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80d42e:	e8 81 59 ff ff       	call   802db4 <malloc>
    if (lt == 0)
  80d433:	85 c0                	test   %eax,%eax
  80d435:	75 1c                	jne    80d453 <sys_thread_new+0x32>
	panic("sys_thread_new: cannot allocate thread struct");
  80d437:	c7 44 24 08 c8 3d 81 	movl   $0x813dc8,0x8(%esp)
  80d43e:	00 
  80d43f:	c7 44 24 04 fd 00 00 	movl   $0xfd,0x4(%esp)
  80d446:	00 
  80d447:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d44e:	e8 59 34 ff ff       	call   8008ac <_panic>

    if (stacksize > PGSIZE)
  80d453:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80d45a:	7e 23                	jle    80d47f <sys_thread_new+0x5e>
	panic("large stack %d", stacksize);
  80d45c:	8b 45 14             	mov    0x14(%ebp),%eax
  80d45f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d463:	c7 44 24 08 6e 3d 81 	movl   $0x813d6e,0x8(%esp)
  80d46a:	00 
  80d46b:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  80d472:	00 
  80d473:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d47a:	e8 2d 34 ff ff       	call   8008ac <_panic>

    lt->func = thread;
  80d47f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80d482:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80d484:	8b 55 10             	mov    0x10(%ebp),%edx
  80d487:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80d48a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d48e:	c7 44 24 08 01 d4 80 	movl   $0x80d401,0x8(%esp)
  80d495:	00 
  80d496:	8b 45 08             	mov    0x8(%ebp),%eax
  80d499:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d49d:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80d4a0:	89 04 24             	mov    %eax,(%esp)
  80d4a3:	e8 8c 07 00 00       	call   80dc34 <thread_create>

    if (r < 0)
  80d4a8:	85 c0                	test   %eax,%eax
  80d4aa:	79 28                	jns    80d4d4 <sys_thread_new+0xb3>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80d4ac:	89 04 24             	mov    %eax,(%esp)
  80d4af:	e8 84 09 00 00       	call   80de38 <e2s>
  80d4b4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d4b8:	c7 44 24 08 f8 3d 81 	movl   $0x813df8,0x8(%esp)
  80d4bf:	00 
  80d4c0:	c7 44 24 04 09 01 00 	movl   $0x109,0x4(%esp)
  80d4c7:	00 
  80d4c8:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d4cf:	e8 d8 33 ff ff       	call   8008ac <_panic>
  80d4d4:	8b 45 fc             	mov    -0x4(%ebp),%eax

    return tid;
}
  80d4d7:	c9                   	leave  
  80d4d8:	c3                   	ret    

0080d4d9 <sys_arch_sem_wait>:
    }
}

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80d4d9:	55                   	push   %ebp
  80d4da:	89 e5                	mov    %esp,%ebp
  80d4dc:	57                   	push   %edi
  80d4dd:	56                   	push   %esi
  80d4de:	53                   	push   %ebx
  80d4df:	83 ec 1c             	sub    $0x1c,%esp
    assert(!sems[sem].freed);
  80d4e2:	8b 55 08             	mov    0x8(%ebp),%edx
  80d4e5:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d4e8:	83 3c 85 c0 7e b3 00 	cmpl   $0x0,0xb37ec0(,%eax,4)
  80d4ef:	00 
  80d4f0:	74 24                	je     80d516 <sys_arch_sem_wait+0x3d>
  80d4f2:	c7 44 24 0c 13 3d 81 	movl   $0x813d13,0xc(%esp)
  80d4f9:	00 
  80d4fa:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  80d501:	00 
  80d502:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
  80d509:	00 
  80d50a:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d511:	e8 96 33 ff ff       	call   8008ac <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80d516:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d519:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80d51c:	8b 04 85 c4 7e b3 00 	mov    0xb37ec4(,%eax,4),%eax
  80d523:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (tm_msec == 0 || waited < tm_msec) {
  80d526:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80d52a:	0f 94 45 ee          	sete   -0x12(%ebp)
  80d52e:	0f 95 45 ef          	setne  -0x11(%ebp)
	if (sems[sem].counter > 0) {
  80d532:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80d535:	0f b7 04 85 c8 7e b3 	movzwl 0xb37ec8(,%eax,4),%eax
  80d53c:	00 
  80d53d:	bf 00 00 00 00       	mov    $0x0,%edi
  80d542:	66 85 c0             	test   %ax,%ax
  80d545:	75 17                	jne    80d55e <sys_arch_sem_wait+0x85>
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80d547:	83 7d 0c fe          	cmpl   $0xfffffffe,0xc(%ebp)
  80d54b:	75 27                	jne    80d574 <sys_arch_sem_wait+0x9b>
  80d54d:	e9 b5 00 00 00       	jmp    80d607 <sys_arch_sem_wait+0x12e>
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80d552:	0f b7 83 c8 7e b3 00 	movzwl 0xb37ec8(%ebx),%eax
  80d559:	66 85 c0             	test   %ax,%ax
  80d55c:	74 31                	je     80d58f <sys_arch_sem_wait+0xb6>
	    sems[sem].counter--;
  80d55e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d561:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  80d564:	83 e8 01             	sub    $0x1,%eax
  80d567:	66 89 04 95 c8 7e b3 	mov    %ax,0xb37ec8(,%edx,4)
  80d56e:	00 
  80d56f:	e9 98 00 00 00       	jmp    80d60c <sys_arch_sem_wait+0x133>
	    return waited;
  80d574:	bf 00 00 00 00       	mov    $0x0,%edi
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
  80d579:	8b 55 08             	mov    0x8(%ebp),%edx
  80d57c:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d57f:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80d586:	8d 8b c8 7e b3 00    	lea    0xb37ec8(%ebx),%ecx
  80d58c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80d58f:	e8 e7 3e ff ff       	call   80147b <sys_time_msec>
  80d594:	89 c6                	mov    %eax,%esi
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80d596:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80d59b:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
  80d59f:	74 0a                	je     80d5ab <sys_arch_sem_wait+0xd2>
  80d5a1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80d5a4:	8d 04 10             	lea    (%eax,%edx,1),%eax
  80d5a7:	89 c2                	mov    %eax,%edx
  80d5a9:	29 fa                	sub    %edi,%edx
	    sems[sem].waiters = 1;
  80d5ab:	66 c7 83 ca 7e b3 00 	movw   $0x1,0xb37eca(%ebx)
  80d5b2:	01 00 
	    uint32_t cur_v = sems[sem].v;
  80d5b4:	8b 83 c8 7e b3 00    	mov    0xb37ec8(%ebx),%eax
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80d5ba:	89 54 24 08          	mov    %edx,0x8(%esp)
  80d5be:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d5c2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  80d5c5:	89 0c 24             	mov    %ecx,(%esp)
  80d5c8:	e8 b1 07 00 00       	call   80dd7e <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80d5cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80d5d0:	39 83 c4 7e b3 00    	cmp    %eax,0xb37ec4(%ebx)
  80d5d6:	74 13                	je     80d5eb <sys_arch_sem_wait+0x112>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80d5d8:	c7 04 24 24 3e 81 00 	movl   $0x813e24,(%esp)
  80d5df:	e8 95 33 ff ff       	call   800979 <cprintf>
  80d5e4:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80d5e9:	eb 21                	jmp    80d60c <sys_arch_sem_wait+0x133>
		return SYS_ARCH_TIMEOUT;
	    }
	    uint32_t b = sys_time_msec();
  80d5eb:	e8 8b 3e ff ff       	call   80147b <sys_time_msec>
	    waited += (b - a);
  80d5f0:	29 f0                	sub    %esi,%eax
  80d5f2:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80d5f4:	39 7d 0c             	cmp    %edi,0xc(%ebp)
  80d5f7:	0f 87 55 ff ff ff    	ja     80d552 <sys_arch_sem_wait+0x79>
  80d5fd:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
  80d601:	0f 85 4b ff ff ff    	jne    80d552 <sys_arch_sem_wait+0x79>
  80d607:	bf ff ff ff ff       	mov    $0xffffffff,%edi
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80d60c:	89 f8                	mov    %edi,%eax
  80d60e:	83 c4 1c             	add    $0x1c,%esp
  80d611:	5b                   	pop    %ebx
  80d612:	5e                   	pop    %esi
  80d613:	5f                   	pop    %edi
  80d614:	5d                   	pop    %ebp
  80d615:	c3                   	ret    

0080d616 <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  80d616:	55                   	push   %ebp
  80d617:	89 e5                	mov    %esp,%ebp
  80d619:	53                   	push   %ebx
  80d61a:	83 ec 14             	sub    $0x14,%esp
  80d61d:	0f b6 5d 08          	movzbl 0x8(%ebp),%ebx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80d621:	8b 0d c0 92 b3 00    	mov    0xb392c0,%ecx
    if (!se) {
  80d627:	85 c9                	test   %ecx,%ecx
  80d629:	75 13                	jne    80d63e <sys_sem_new+0x28>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80d62b:	c7 04 24 50 3e 81 00 	movl   $0x813e50,(%esp)
  80d632:	e8 42 33 ff ff       	call   800979 <cprintf>
  80d637:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80d63c:	eb 5f                	jmp    80d69d <sys_sem_new+0x87>
	return SYS_SEM_NULL;
    }
    LIST_REMOVE(se, link);
  80d63e:	8b 51 0c             	mov    0xc(%ecx),%edx
  80d641:	85 d2                	test   %edx,%edx
  80d643:	74 06                	je     80d64b <sys_sem_new+0x35>
  80d645:	8b 41 10             	mov    0x10(%ecx),%eax
  80d648:	89 42 10             	mov    %eax,0x10(%edx)
  80d64b:	8b 51 10             	mov    0x10(%ecx),%edx
  80d64e:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d651:	89 02                	mov    %eax,(%edx)
    assert(se->freed);
  80d653:	83 39 00             	cmpl   $0x0,(%ecx)
  80d656:	75 24                	jne    80d67c <sys_sem_new+0x66>
  80d658:	c7 44 24 0c 7d 3d 81 	movl   $0x813d7d,0xc(%esp)
  80d65f:	00 
  80d660:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  80d667:	00 
  80d668:	c7 44 24 04 8d 00 00 	movl   $0x8d,0x4(%esp)
  80d66f:	00 
  80d670:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d677:	e8 30 32 ff ff       	call   8008ac <_panic>
    se->freed = 0;
  80d67c:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)

    se->counter = count;
  80d682:	0f b6 c3             	movzbl %bl,%eax
  80d685:	66 89 41 08          	mov    %ax,0x8(%ecx)
    se->gen++;
  80d689:	83 41 04 01          	addl   $0x1,0x4(%ecx)
    return se - &sems[0];
  80d68d:	89 c8                	mov    %ecx,%eax
  80d68f:	2d c0 7e b3 00       	sub    $0xb37ec0,%eax
  80d694:	c1 f8 02             	sar    $0x2,%eax
  80d697:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  80d69d:	83 c4 14             	add    $0x14,%esp
  80d6a0:	5b                   	pop    %ebx
  80d6a1:	5d                   	pop    %ebp
  80d6a2:	c3                   	ret    

0080d6a3 <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  80d6a3:	55                   	push   %ebp
  80d6a4:	89 e5                	mov    %esp,%ebp
  80d6a6:	56                   	push   %esi
  80d6a7:	53                   	push   %ebx
  80d6a8:	83 ec 10             	sub    $0x10,%esp
    assert(size < MBOXSLOTS);
  80d6ab:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80d6af:	7e 24                	jle    80d6d5 <sys_mbox_new+0x32>
  80d6b1:	c7 44 24 0c 87 3d 81 	movl   $0x813d87,0xc(%esp)
  80d6b8:	00 
  80d6b9:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  80d6c0:	00 
  80d6c1:	c7 44 24 04 45 00 00 	movl   $0x45,0x4(%esp)
  80d6c8:	00 
  80d6c9:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d6d0:	e8 d7 31 ff ff       	call   8008ac <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80d6d5:	8b 1d e0 e0 b3 00    	mov    0xb3e0e0,%ebx
    if (!mbe) {
  80d6db:	85 db                	test   %ebx,%ebx
  80d6dd:	75 16                	jne    80d6f5 <sys_mbox_new+0x52>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80d6df:	c7 04 24 78 3e 81 00 	movl   $0x813e78,(%esp)
  80d6e6:	e8 8e 32 ff ff       	call   800979 <cprintf>
  80d6eb:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80d6f0:	e9 bc 00 00 00       	jmp    80d7b1 <sys_mbox_new+0x10e>
	return SYS_MBOX_NULL;
    }
    LIST_REMOVE(mbe, link);
  80d6f5:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80d6fb:	85 d2                	test   %edx,%edx
  80d6fd:	74 0c                	je     80d70b <sys_mbox_new+0x68>
  80d6ff:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d705:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
  80d70b:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80d711:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80d717:	89 02                	mov    %eax,(%edx)
    assert(mbe->freed);
  80d719:	83 3b 00             	cmpl   $0x0,(%ebx)
  80d71c:	75 24                	jne    80d742 <sys_mbox_new+0x9f>
  80d71e:	c7 44 24 0c 98 3d 81 	movl   $0x813d98,0xc(%esp)
  80d725:	00 
  80d726:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  80d72d:	00 
  80d72e:	c7 44 24 04 4c 00 00 	movl   $0x4c,0x4(%esp)
  80d735:	00 
  80d736:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d73d:	e8 6a 31 ff ff       	call   8008ac <_panic>
    mbe->freed = 0;
  80d742:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80d748:	89 d8                	mov    %ebx,%eax
  80d74a:	2d e0 92 b3 00       	sub    $0xb392e0,%eax
  80d74f:	c1 f8 02             	sar    $0x2,%eax
  80d752:	69 f0 97 6f f9 96    	imul   $0x96f96f97,%eax,%esi
    mbe->head = -1;
  80d758:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80d75f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80d766:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80d76d:	e8 a4 fe ff ff       	call   80d616 <sys_sem_new>
  80d772:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80d778:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80d77f:	e8 92 fe ff ff       	call   80d616 <sys_sem_new>
  80d784:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80d78a:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80d791:	74 05                	je     80d798 <sys_mbox_new+0xf5>
  80d793:	83 f8 ff             	cmp    $0xffffffff,%eax
  80d796:	75 19                	jne    80d7b1 <sys_mbox_new+0x10e>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  80d798:	89 34 24             	mov    %esi,(%esp)
  80d79b:	e8 59 fa ff ff       	call   80d1f9 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80d7a0:	c7 04 24 a0 3e 81 00 	movl   $0x813ea0,(%esp)
  80d7a7:	e8 cd 31 ff ff       	call   800979 <cprintf>
  80d7ac:	be ff ff ff ff       	mov    $0xffffffff,%esi
	return SYS_MBOX_NULL;
    }
    return i;
}
  80d7b1:	89 f0                	mov    %esi,%eax
  80d7b3:	83 c4 10             	add    $0x10,%esp
  80d7b6:	5b                   	pop    %ebx
  80d7b7:	5e                   	pop    %esi
  80d7b8:	5d                   	pop    %ebp
  80d7b9:	c3                   	ret    

0080d7ba <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  80d7ba:	55                   	push   %ebp
  80d7bb:	89 e5                	mov    %esp,%ebp
  80d7bd:	83 ec 18             	sub    $0x18,%esp
  80d7c0:	8b 55 08             	mov    0x8(%ebp),%edx
    assert(!sems[sem].freed);
  80d7c3:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d7c6:	83 3c 85 c0 7e b3 00 	cmpl   $0x0,0xb37ec0(,%eax,4)
  80d7cd:	00 
  80d7ce:	74 24                	je     80d7f4 <sys_sem_signal+0x3a>
  80d7d0:	c7 44 24 0c 13 3d 81 	movl   $0x813d13,0xc(%esp)
  80d7d7:	00 
  80d7d8:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  80d7df:	00 
  80d7e0:	c7 44 24 04 a1 00 00 	movl   $0xa1,0x4(%esp)
  80d7e7:	00 
  80d7e8:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d7ef:	e8 b8 30 ff ff       	call   8008ac <_panic>
    sems[sem].counter++;
  80d7f4:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d7f7:	c1 e0 02             	shl    $0x2,%eax
  80d7fa:	66 83 80 c8 7e b3 00 	addw   $0x1,0xb37ec8(%eax)
  80d801:	01 
    if (sems[sem].waiters) {
  80d802:	66 83 b8 ca 7e b3 00 	cmpw   $0x0,0xb37eca(%eax)
  80d809:	00 
  80d80a:	74 16                	je     80d822 <sys_sem_signal+0x68>
	sems[sem].waiters = 0;
  80d80c:	66 c7 80 ca 7e b3 00 	movw   $0x0,0xb37eca(%eax)
  80d813:	00 00 
	thread_wakeup(&sems[sem].v);
  80d815:	05 c8 7e b3 00       	add    $0xb37ec8,%eax
  80d81a:	89 04 24             	mov    %eax,(%esp)
  80d81d:	e8 5d 02 00 00       	call   80da7f <thread_wakeup>
    }
}
  80d822:	c9                   	leave  
  80d823:	c3                   	ret    

0080d824 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80d824:	55                   	push   %ebp
  80d825:	89 e5                	mov    %esp,%ebp
  80d827:	83 ec 28             	sub    $0x28,%esp
  80d82a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80d82d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80d830:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80d833:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80d836:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80d83c:	83 b8 e0 92 b3 00 00 	cmpl   $0x0,0xb392e0(%eax)
  80d843:	74 24                	je     80d869 <sys_arch_mbox_fetch+0x45>
  80d845:	c7 44 24 0c 41 3d 81 	movl   $0x813d41,0xc(%esp)
  80d84c:	00 
  80d84d:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  80d854:	00 
  80d855:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80d85c:	00 
  80d85d:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d864:	e8 43 30 ff ff       	call   8008ac <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80d869:	8b 45 10             	mov    0x10(%ebp),%eax
  80d86c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d870:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80d876:	8b 83 6c 93 b3 00    	mov    0xb3936c(%ebx),%eax
  80d87c:	89 04 24             	mov    %eax,(%esp)
  80d87f:	e8 55 fc ff ff       	call   80d4d9 <sys_arch_sem_wait>
  80d884:	89 c7                	mov    %eax,%edi
    if (waited == SYS_ARCH_TIMEOUT)
  80d886:	83 f8 ff             	cmp    $0xffffffff,%eax
  80d889:	0f 84 82 00 00 00    	je     80d911 <sys_arch_mbox_fetch+0xed>
	return waited;

    int slot = mboxes[mbox].head;
  80d88f:	8b 93 e4 92 b3 00    	mov    0xb392e4(%ebx),%edx
    if (slot == -1)
  80d895:	83 fa ff             	cmp    $0xffffffff,%edx
  80d898:	75 1c                	jne    80d8b6 <sys_arch_mbox_fetch+0x92>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80d89a:	c7 44 24 08 cc 3e 81 	movl   $0x813ecc,0x8(%esp)
  80d8a1:	00 
  80d8a2:	c7 44 24 04 d6 00 00 	movl   $0xd6,0x4(%esp)
  80d8a9:	00 
  80d8aa:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d8b1:	e8 f6 2f ff ff       	call   8008ac <_panic>
    if (msg)
  80d8b6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80d8ba:	74 11                	je     80d8cd <sys_arch_mbox_fetch+0xa9>
	*msg = mboxes[mbox].msg[slot];
  80d8bc:	6b c6 27             	imul   $0x27,%esi,%eax
  80d8bf:	01 d0                	add    %edx,%eax
  80d8c1:	8b 04 85 ec 92 b3 00 	mov    0xb392ec(,%eax,4),%eax
  80d8c8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80d8cb:	89 01                	mov    %eax,(%ecx)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80d8cd:	8d 42 01             	lea    0x1(%edx),%eax
  80d8d0:	89 c2                	mov    %eax,%edx
  80d8d2:	c1 fa 1f             	sar    $0x1f,%edx
  80d8d5:	c1 ea 1b             	shr    $0x1b,%edx
  80d8d8:	01 d0                	add    %edx,%eax
  80d8da:	83 e0 1f             	and    $0x1f,%eax
  80d8dd:	29 d0                	sub    %edx,%eax
  80d8df:	69 d6 9c 00 00 00    	imul   $0x9c,%esi,%edx
  80d8e5:	89 82 e4 92 b3 00    	mov    %eax,0xb392e4(%edx)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80d8eb:	3b 82 e8 92 b3 00    	cmp    0xb392e8(%edx),%eax
  80d8f1:	75 0a                	jne    80d8fd <sys_arch_mbox_fetch+0xd9>
	mboxes[mbox].head = -1;
  80d8f3:	c7 82 e4 92 b3 00 ff 	movl   $0xffffffff,0xb392e4(%edx)
  80d8fa:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80d8fd:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80d903:	8b 80 70 93 b3 00    	mov    0xb39370(%eax),%eax
  80d909:	89 04 24             	mov    %eax,(%esp)
  80d90c:	e8 a9 fe ff ff       	call   80d7ba <sys_sem_signal>
    return waited;
}
  80d911:	89 f8                	mov    %edi,%eax
  80d913:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80d916:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80d919:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80d91c:	89 ec                	mov    %ebp,%esp
  80d91e:	5d                   	pop    %ebp
  80d91f:	c3                   	ret    

0080d920 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80d920:	55                   	push   %ebp
  80d921:	89 e5                	mov    %esp,%ebp
  80d923:	83 ec 18             	sub    $0x18,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80d926:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
  80d92d:	ff 
  80d92e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d931:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d935:	8b 45 08             	mov    0x8(%ebp),%eax
  80d938:	89 04 24             	mov    %eax,(%esp)
  80d93b:	e8 e4 fe ff ff       	call   80d824 <sys_arch_mbox_fetch>
}
  80d940:	c9                   	leave  
  80d941:	c3                   	ret    

0080d942 <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80d942:	55                   	push   %ebp
  80d943:	89 e5                	mov    %esp,%ebp
  80d945:	56                   	push   %esi
  80d946:	53                   	push   %ebx
  80d947:	83 ec 10             	sub    $0x10,%esp
  80d94a:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80d94d:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80d953:	83 b8 e0 92 b3 00 00 	cmpl   $0x0,0xb392e0(%eax)
  80d95a:	74 24                	je     80d980 <sys_mbox_trypost+0x3e>
  80d95c:	c7 44 24 0c 41 3d 81 	movl   $0x813d41,0xc(%esp)
  80d963:	00 
  80d964:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  80d96b:	00 
  80d96c:	c7 44 24 04 72 00 00 	movl   $0x72,0x4(%esp)
  80d973:	00 
  80d974:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80d97b:	e8 2c 2f ff ff       	call   8008ac <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80d980:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80d987:	00 
  80d988:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80d98e:	8b 83 70 93 b3 00    	mov    0xb39370(%ebx),%eax
  80d994:	89 04 24             	mov    %eax,(%esp)
  80d997:	e8 3d fb ff ff       	call   80d4d9 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80d99c:	8b 8b e8 92 b3 00    	mov    0xb392e8(%ebx),%ecx
  80d9a2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80d9a7:	3b 8b e4 92 b3 00    	cmp    0xb392e4(%ebx),%ecx
  80d9ad:	74 55                	je     80da04 <sys_mbox_trypost+0xc2>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80d9af:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80d9b5:	8d 41 01             	lea    0x1(%ecx),%eax
  80d9b8:	89 c2                	mov    %eax,%edx
  80d9ba:	c1 fa 1f             	sar    $0x1f,%edx
  80d9bd:	c1 ea 1b             	shr    $0x1b,%edx
  80d9c0:	01 d0                	add    %edx,%eax
  80d9c2:	83 e0 1f             	and    $0x1f,%eax
  80d9c5:	29 d0                	sub    %edx,%eax
  80d9c7:	89 83 e8 92 b3 00    	mov    %eax,0xb392e8(%ebx)
    mboxes[mbox].msg[slot] = msg;
  80d9cd:	6b c6 27             	imul   $0x27,%esi,%eax
  80d9d0:	01 c8                	add    %ecx,%eax
  80d9d2:	8b 55 0c             	mov    0xc(%ebp),%edx
  80d9d5:	89 14 85 ec 92 b3 00 	mov    %edx,0xb392ec(,%eax,4)

    if (mboxes[mbox].head == -1)
  80d9dc:	83 bb e4 92 b3 00 ff 	cmpl   $0xffffffff,0xb392e4(%ebx)
  80d9e3:	75 06                	jne    80d9eb <sys_mbox_trypost+0xa9>
	mboxes[mbox].head = slot;
  80d9e5:	89 8b e4 92 b3 00    	mov    %ecx,0xb392e4(%ebx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80d9eb:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80d9f1:	8b 80 6c 93 b3 00    	mov    0xb3936c(%eax),%eax
  80d9f7:	89 04 24             	mov    %eax,(%esp)
  80d9fa:	e8 bb fd ff ff       	call   80d7ba <sys_sem_signal>
  80d9ff:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80da04:	83 c4 10             	add    $0x10,%esp
  80da07:	5b                   	pop    %ebx
  80da08:	5e                   	pop    %esi
  80da09:	5d                   	pop    %ebp
  80da0a:	c3                   	ret    

0080da0b <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80da0b:	55                   	push   %ebp
  80da0c:	89 e5                	mov    %esp,%ebp
  80da0e:	83 ec 18             	sub    $0x18,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80da11:	8b 45 0c             	mov    0xc(%ebp),%eax
  80da14:	89 44 24 04          	mov    %eax,0x4(%esp)
  80da18:	8b 45 08             	mov    0x8(%ebp),%eax
  80da1b:	89 04 24             	mov    %eax,(%esp)
  80da1e:	e8 1f ff ff ff       	call   80d942 <sys_mbox_trypost>
  80da23:	84 c0                	test   %al,%al
  80da25:	74 24                	je     80da4b <sys_mbox_post+0x40>
  80da27:	c7 44 24 0c f4 3e 81 	movl   $0x813ef4,0xc(%esp)
  80da2e:	00 
  80da2f:	c7 44 24 08 38 28 81 	movl   $0x812838,0x8(%esp)
  80da36:	00 
  80da37:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
  80da3e:	00 
  80da3f:	c7 04 24 24 3d 81 00 	movl   $0x813d24,(%esp)
  80da46:	e8 61 2e ff ff       	call   8008ac <_panic>
}
  80da4b:	c9                   	leave  
  80da4c:	c3                   	ret    
  80da4d:	00 00                	add    %al,(%eax)
	...

0080da50 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80da50:	55                   	push   %ebp
  80da51:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80da53:	c7 05 0c e5 b3 00 00 	movl   $0x0,0xb3e50c
  80da5a:	00 00 00 
    tq->tq_last = 0;
  80da5d:	c7 05 10 e5 b3 00 00 	movl   $0x0,0xb3e510
  80da64:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80da67:	c7 05 04 e5 b3 00 00 	movl   $0x0,0xb3e504
  80da6e:	00 00 00 
}
  80da71:	5d                   	pop    %ebp
  80da72:	c3                   	ret    

0080da73 <thread_id>:

uint32_t
thread_id(void) {
  80da73:	55                   	push   %ebp
  80da74:	89 e5                	mov    %esp,%ebp
  80da76:	a1 08 e5 b3 00       	mov    0xb3e508,%eax
  80da7b:	8b 00                	mov    (%eax),%eax
    return cur_tc->tc_tid;
}
  80da7d:	5d                   	pop    %ebp
  80da7e:	c3                   	ret    

0080da7f <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80da7f:	55                   	push   %ebp
  80da80:	89 e5                	mov    %esp,%ebp
  80da82:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80da85:	a1 0c e5 b3 00       	mov    0xb3e50c,%eax
    while (tc) {
  80da8a:	85 c0                	test   %eax,%eax
  80da8c:	74 10                	je     80da9e <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
  80da8e:	39 50 48             	cmp    %edx,0x48(%eax)
  80da91:	75 04                	jne    80da97 <thread_wakeup+0x18>
	    tc->tc_wakeup = 1;
  80da93:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80da97:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80da9a:	85 c0                	test   %eax,%eax
  80da9c:	75 f0                	jne    80da8e <thread_wakeup+0xf>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80da9e:	5d                   	pop    %ebp
  80da9f:	90                   	nop    
  80daa0:	c3                   	ret    

0080daa1 <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80daa1:	55                   	push   %ebp
  80daa2:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80daa4:	8b 15 0c e5 b3 00    	mov    0xb3e50c,%edx
    int n = 0;
    while (tc) {
  80daaa:	b9 00 00 00 00       	mov    $0x0,%ecx
  80daaf:	85 d2                	test   %edx,%edx
  80dab1:	74 15                	je     80dac8 <thread_wakeups_pending+0x27>
  80dab3:	b9 00 00 00 00       	mov    $0x0,%ecx
	if (tc->tc_wakeup)
  80dab8:	0f b6 42 4c          	movzbl 0x4c(%edx),%eax
	    ++n;
  80dabc:	3c 01                	cmp    $0x1,%al
  80dabe:	83 d9 ff             	sbb    $0xffffffff,%ecx
	tc = tc->tc_queue_link;
  80dac1:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80dac4:	85 d2                	test   %edx,%edx
  80dac6:	75 f0                	jne    80dab8 <thread_wakeups_pending+0x17>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80dac8:	89 c8                	mov    %ecx,%eax
  80daca:	5d                   	pop    %ebp
  80dacb:	c3                   	ret    

0080dacc <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80dacc:	55                   	push   %ebp
  80dacd:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80dacf:	8b 15 08 e5 b3 00    	mov    0xb3e508,%edx
  80dad5:	8b 42 60             	mov    0x60(%edx),%eax
  80dad8:	b9 fc ff ff ff       	mov    $0xfffffffc,%ecx
  80dadd:	83 f8 03             	cmp    $0x3,%eax
  80dae0:	7f 12                	jg     80daf4 <thread_onhalt+0x28>
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80dae2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80dae5:	89 4c 82 50          	mov    %ecx,0x50(%edx,%eax,4)
  80dae9:	83 c0 01             	add    $0x1,%eax
  80daec:	89 42 60             	mov    %eax,0x60(%edx)
  80daef:	b9 00 00 00 00       	mov    $0x0,%ecx
    return 0;
}
  80daf4:	89 c8                	mov    %ecx,%eax
  80daf6:	5d                   	pop    %ebp
  80daf7:	c3                   	ret    

0080daf8 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80daf8:	55                   	push   %ebp
  80daf9:	89 e5                	mov    %esp,%ebp
  80dafb:	53                   	push   %ebx
  80dafc:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80daff:	8b 1d 0c e5 b3 00    	mov    0xb3e50c,%ebx
  80db05:	85 db                	test   %ebx,%ebx
  80db07:	74 6c                	je     80db75 <thread_yield+0x7d>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80db09:	8b 43 64             	mov    0x64(%ebx),%eax
  80db0c:	a3 0c e5 b3 00       	mov    %eax,0xb3e50c
    tc->tc_queue_link = 0;
  80db11:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80db18:	a1 08 e5 b3 00       	mov    0xb3e508,%eax
  80db1d:	85 c0                	test   %eax,%eax
  80db1f:	74 41                	je     80db62 <thread_yield+0x6a>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80db21:	83 c0 30             	add    $0x30,%eax
  80db24:	89 04 24             	mov    %eax,(%esp)
  80db27:	e8 c4 02 00 00       	call   80ddf0 <jos_setjmp>
  80db2c:	85 c0                	test   %eax,%eax
  80db2e:	75 45                	jne    80db75 <thread_yield+0x7d>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80db30:	8b 15 08 e5 b3 00    	mov    0xb3e508,%edx
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80db36:	c7 42 64 00 00 00 00 	movl   $0x0,0x64(%edx)
    if (!tq->tq_first) {
  80db3d:	83 3d 0c e5 b3 00 00 	cmpl   $0x0,0xb3e50c
  80db44:	75 0e                	jne    80db54 <thread_yield+0x5c>
	tq->tq_first = tc;
  80db46:	89 15 0c e5 b3 00    	mov    %edx,0xb3e50c
	tq->tq_last = tc;
  80db4c:	89 15 10 e5 b3 00    	mov    %edx,0xb3e510
  80db52:	eb 0e                	jmp    80db62 <thread_yield+0x6a>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80db54:	a1 10 e5 b3 00       	mov    0xb3e510,%eax
  80db59:	89 50 64             	mov    %edx,0x64(%eax)
	tq->tq_last = tc;
  80db5c:	89 15 10 e5 b3 00    	mov    %edx,0xb3e510
    }

    cur_tc = next_tc;
  80db62:	89 1d 08 e5 b3 00    	mov    %ebx,0xb3e508
    jos_longjmp(&cur_tc->tc_jb, 1);
  80db68:	8d 43 30             	lea    0x30(%ebx),%eax
  80db6b:	ba 01 00 00 00       	mov    $0x1,%edx
  80db70:	e8 ab 02 00 00       	call   80de20 <jos_longjmp>
}
  80db75:	83 c4 04             	add    $0x4,%esp
  80db78:	5b                   	pop    %ebx
  80db79:	5d                   	pop    %ebp
  80db7a:	c3                   	ret    

0080db7b <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80db7b:	55                   	push   %ebp
  80db7c:	89 e5                	mov    %esp,%ebp
  80db7e:	56                   	push   %esi
  80db7f:	53                   	push   %ebx
  80db80:	83 ec 10             	sub    $0x10,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80db83:	8b 1d 14 e5 b3 00    	mov    0xb3e514,%ebx
  80db89:	85 db                	test   %ebx,%ebx
  80db8b:	74 3e                	je     80dbcb <thread_halt+0x50>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80db8d:	8b 43 64             	mov    0x64(%ebx),%eax
  80db90:	a3 14 e5 b3 00       	mov    %eax,0xb3e514
    tc->tc_queue_link = 0;
  80db95:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80db9c:	83 7b 60 00          	cmpl   $0x0,0x60(%ebx)
  80dba0:	7e 16                	jle    80dbb8 <thread_halt+0x3d>
  80dba2:	be 00 00 00 00       	mov    $0x0,%esi
	tc->tc_onhalt[i](tc->tc_tid);
  80dba7:	8b 03                	mov    (%ebx),%eax
  80dba9:	89 04 24             	mov    %eax,(%esp)
  80dbac:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80dbb0:	83 c6 01             	add    $0x1,%esi
  80dbb3:	39 73 60             	cmp    %esi,0x60(%ebx)
  80dbb6:	7f ef                	jg     80dba7 <thread_halt+0x2c>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80dbb8:	8b 43 04             	mov    0x4(%ebx),%eax
  80dbbb:	89 04 24             	mov    %eax,(%esp)
  80dbbe:	e8 1d 51 ff ff       	call   802ce0 <free>
    free(tc);
  80dbc3:	89 1c 24             	mov    %ebx,(%esp)
  80dbc6:	e8 15 51 ff ff       	call   802ce0 <free>
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80dbcb:	8b 15 08 e5 b3 00    	mov    0xb3e508,%edx
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80dbd1:	c7 42 64 00 00 00 00 	movl   $0x0,0x64(%edx)
    if (!tq->tq_first) {
  80dbd8:	83 3d 14 e5 b3 00 00 	cmpl   $0x0,0xb3e514
  80dbdf:	75 0e                	jne    80dbef <thread_halt+0x74>
	tq->tq_first = tc;
  80dbe1:	89 15 14 e5 b3 00    	mov    %edx,0xb3e514
	tq->tq_last = tc;
  80dbe7:	89 15 18 e5 b3 00    	mov    %edx,0xb3e518
  80dbed:	eb 0e                	jmp    80dbfd <thread_halt+0x82>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80dbef:	a1 18 e5 b3 00       	mov    0xb3e518,%eax
  80dbf4:	89 50 64             	mov    %edx,0x64(%eax)
	tq->tq_last = tc;
  80dbf7:	89 15 18 e5 b3 00    	mov    %edx,0xb3e518
    cur_tc = NULL;
  80dbfd:	c7 05 08 e5 b3 00 00 	movl   $0x0,0xb3e508
  80dc04:	00 00 00 
    thread_yield();
  80dc07:	e8 ec fe ff ff       	call   80daf8 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80dc0c:	e8 7f 2c ff ff       	call   800890 <exit>
}
  80dc11:	83 c4 10             	add    $0x10,%esp
  80dc14:	5b                   	pop    %ebx
  80dc15:	5e                   	pop    %esi
  80dc16:	5d                   	pop    %ebp
  80dc17:	c3                   	ret    

0080dc18 <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80dc18:	55                   	push   %ebp
  80dc19:	89 e5                	mov    %esp,%ebp
  80dc1b:	83 ec 08             	sub    $0x8,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80dc1e:	8b 15 08 e5 b3 00    	mov    0xb3e508,%edx
  80dc24:	8b 42 2c             	mov    0x2c(%edx),%eax
  80dc27:	89 04 24             	mov    %eax,(%esp)
  80dc2a:	ff 52 28             	call   *0x28(%edx)
    thread_halt();
  80dc2d:	e8 49 ff ff ff       	call   80db7b <thread_halt>
}
  80dc32:	c9                   	leave  
  80dc33:	c3                   	ret    

0080dc34 <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80dc34:	55                   	push   %ebp
  80dc35:	89 e5                	mov    %esp,%ebp
  80dc37:	57                   	push   %edi
  80dc38:	56                   	push   %esi
  80dc39:	53                   	push   %ebx
  80dc3a:	83 ec 0c             	sub    $0xc,%esp
  80dc3d:	8b 7d 08             	mov    0x8(%ebp),%edi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80dc40:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp)
  80dc47:	e8 68 51 ff ff       	call   802db4 <malloc>
    if (!tc)
  80dc4c:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
  80dc51:	85 c0                	test   %eax,%eax
  80dc53:	0f 84 1b 01 00 00    	je     80dd74 <thread_create+0x140>
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80dc59:	89 c6                	mov    %eax,%esi
    if (!tc)
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80dc5b:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
  80dc62:	00 
  80dc63:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80dc6a:	00 
  80dc6b:	89 04 24             	mov    %eax,(%esp)
  80dc6e:	e8 1b 35 ff ff       	call   80118e <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80dc73:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  80dc7a:	00 
  80dc7b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80dc7e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dc82:	8d 46 08             	lea    0x8(%esi),%eax
  80dc85:	89 04 24             	mov    %eax,(%esp)
  80dc88:	e8 74 33 ff ff       	call   801001 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80dc8d:	c6 46 27 00          	movb   $0x0,0x27(%esi)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80dc91:	8b 15 04 e5 b3 00    	mov    0xb3e504,%edx
  80dc97:	8d 42 01             	lea    0x1(%edx),%eax
  80dc9a:	a3 04 e5 b3 00       	mov    %eax,0xb3e504
    if (max_tid == (uint32_t)~0)
  80dc9f:	83 f8 ff             	cmp    $0xffffffff,%eax
  80dca2:	75 1c                	jne    80dcc0 <thread_create+0x8c>
	panic("alloc_tid: no more thread ids");
  80dca4:	c7 44 24 08 1a 3f 81 	movl   $0x813f1a,0x8(%esp)
  80dcab:	00 
  80dcac:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80dcb3:	00 
  80dcb4:	c7 04 24 38 3f 81 00 	movl   $0x813f38,(%esp)
  80dcbb:	e8 ec 2b ff ff       	call   8008ac <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80dcc0:	89 16                	mov    %edx,(%esi)

    tc->tc_stack_bottom = malloc(stack_size);
  80dcc2:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80dcc9:	e8 e6 50 ff ff       	call   802db4 <malloc>
  80dcce:	89 46 04             	mov    %eax,0x4(%esi)
    if (!tc->tc_stack_bottom) {
  80dcd1:	85 c0                	test   %eax,%eax
  80dcd3:	75 12                	jne    80dce7 <thread_create+0xb3>
	free(tc);
  80dcd5:	89 34 24             	mov    %esi,(%esp)
  80dcd8:	e8 03 50 ff ff       	call   802ce0 <free>
  80dcdd:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
  80dce2:	e9 8d 00 00 00       	jmp    80dd74 <thread_create+0x140>
	return -E_NO_MEM;
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80dce7:	8d 98 fc 0f 00 00    	lea    0xffc(%eax),%ebx
    memset(stacktop, 0, 4);
  80dced:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80dcf4:	00 
  80dcf5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80dcfc:	00 
  80dcfd:	89 1c 24             	mov    %ebx,(%esp)
  80dd00:	e8 89 34 ff ff       	call   80118e <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80dd05:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  80dd0c:	00 
  80dd0d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80dd14:	00 
  80dd15:	8d 46 30             	lea    0x30(%esi),%eax
  80dd18:	89 04 24             	mov    %eax,(%esp)
  80dd1b:	e8 6e 34 ff ff       	call   80118e <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80dd20:	89 5e 34             	mov    %ebx,0x34(%esi)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80dd23:	c7 46 30 18 dc 80 00 	movl   $0x80dc18,0x30(%esi)
    tc->tc_entry = entry;
  80dd2a:	8b 45 10             	mov    0x10(%ebp),%eax
  80dd2d:	89 46 28             	mov    %eax,0x28(%esi)
    tc->tc_arg = arg;
  80dd30:	8b 45 14             	mov    0x14(%ebp),%eax
  80dd33:	89 46 2c             	mov    %eax,0x2c(%esi)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80dd36:	c7 46 64 00 00 00 00 	movl   $0x0,0x64(%esi)
    if (!tq->tq_first) {
  80dd3d:	83 3d 0c e5 b3 00 00 	cmpl   $0x0,0xb3e50c
  80dd44:	75 0e                	jne    80dd54 <thread_create+0x120>
	tq->tq_first = tc;
  80dd46:	89 35 0c e5 b3 00    	mov    %esi,0xb3e50c
	tq->tq_last = tc;
  80dd4c:	89 35 10 e5 b3 00    	mov    %esi,0xb3e510
  80dd52:	eb 0e                	jmp    80dd62 <thread_create+0x12e>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80dd54:	a1 10 e5 b3 00       	mov    0xb3e510,%eax
  80dd59:	89 70 64             	mov    %esi,0x64(%eax)
	tq->tq_last = tc;
  80dd5c:	89 35 10 e5 b3 00    	mov    %esi,0xb3e510

    threadq_push(&thread_queue, tc);

    if (tid)
  80dd62:	ba 00 00 00 00       	mov    $0x0,%edx
  80dd67:	85 ff                	test   %edi,%edi
  80dd69:	74 09                	je     80dd74 <thread_create+0x140>
	*tid = tc->tc_tid;
  80dd6b:	8b 06                	mov    (%esi),%eax
  80dd6d:	89 07                	mov    %eax,(%edi)
  80dd6f:	ba 00 00 00 00       	mov    $0x0,%edx
    return 0;
}
  80dd74:	89 d0                	mov    %edx,%eax
  80dd76:	83 c4 0c             	add    $0xc,%esp
  80dd79:	5b                   	pop    %ebx
  80dd7a:	5e                   	pop    %esi
  80dd7b:	5f                   	pop    %edi
  80dd7c:	5d                   	pop    %ebp
  80dd7d:	c3                   	ret    

0080dd7e <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80dd7e:	55                   	push   %ebp
  80dd7f:	89 e5                	mov    %esp,%ebp
  80dd81:	57                   	push   %edi
  80dd82:	56                   	push   %esi
  80dd83:	53                   	push   %ebx
  80dd84:	83 ec 0c             	sub    $0xc,%esp
  80dd87:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dd8a:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80dd8d:	e8 e9 36 ff ff       	call   80147b <sys_time_msec>
  80dd92:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80dd94:	a1 08 e5 b3 00       	mov    0xb3e508,%eax
  80dd99:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80dd9c:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)

    while (p < msec) {
  80dda0:	39 fe                	cmp    %edi,%esi
  80dda2:	72 06                	jb     80ddaa <thread_wait+0x2c>
  80dda4:	eb 2e                	jmp    80ddd4 <thread_wait+0x56>
	if (p < s)
  80dda6:	39 c6                	cmp    %eax,%esi
  80dda8:	77 2a                	ja     80ddd4 <thread_wait+0x56>
	    break;
	if (addr && *addr != val)
  80ddaa:	85 db                	test   %ebx,%ebx
  80ddac:	8d 74 26 00          	lea    0x0(%esi),%esi
  80ddb0:	74 07                	je     80ddb9 <thread_wait+0x3b>
  80ddb2:	8b 03                	mov    (%ebx),%eax
  80ddb4:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80ddb7:	75 1b                	jne    80ddd4 <thread_wait+0x56>
	    break;
	if (cur_tc->tc_wakeup)
  80ddb9:	a1 08 e5 b3 00       	mov    0xb3e508,%eax
  80ddbe:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80ddc2:	84 c0                	test   %al,%al
  80ddc4:	75 0e                	jne    80ddd4 <thread_wait+0x56>
	    break;

	thread_yield();
  80ddc6:	e8 2d fd ff ff       	call   80daf8 <thread_yield>
	p = sys_time_msec();
  80ddcb:	e8 ab 36 ff ff       	call   80147b <sys_time_msec>
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80ddd0:	39 c7                	cmp    %eax,%edi
  80ddd2:	77 d2                	ja     80dda6 <thread_wait+0x28>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80ddd4:	a1 08 e5 b3 00       	mov    0xb3e508,%eax
  80ddd9:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80dde0:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80dde4:	83 c4 0c             	add    $0xc,%esp
  80dde7:	5b                   	pop    %ebx
  80dde8:	5e                   	pop    %esi
  80dde9:	5f                   	pop    %edi
  80ddea:	5d                   	pop    %ebp
  80ddeb:	c3                   	ret    
  80ddec:	00 00                	add    %al,(%eax)
	...

0080ddf0 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80ddf0:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80ddf4:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80ddf7:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80ddf9:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80ddfd:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80de00:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80de03:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80de06:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80de09:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80de0c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80de11:	c3                   	ret    
  80de12:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  80de19:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0080de20 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80de20:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80de22:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80de25:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80de28:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80de2b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80de2e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80de31:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80de33:	ff e1                	jmp    *%ecx
  80de35:	00 00                	add    %al,(%eax)
	...

0080de38 <e2s>:
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
  80de38:	55                   	push   %ebp
  80de39:	89 e5                	mov    %esp,%ebp
  80de3b:	8b 45 08             	mov    0x8(%ebp),%eax
  80de3e:	8b 04 85 60 80 81 00 	mov    0x818060(,%eax,4),%eax
	return sys_errlist[err];
}
  80de45:	5d                   	pop    %ebp
  80de46:	c3                   	ret    

0080de47 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80de47:	55                   	push   %ebp
  80de48:	89 e5                	mov    %esp,%ebp
  80de4a:	83 ec 18             	sub    $0x18,%esp
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80de4d:	a1 60 e5 b3 00       	mov    0xb3e560,%eax
  80de52:	89 04 24             	mov    %eax,(%esp)
  80de55:	e8 de ff ff ff       	call   80de38 <e2s>
  80de5a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80de5e:	8b 45 08             	mov    0x8(%ebp),%eax
  80de61:	89 44 24 04          	mov    %eax,0x4(%esp)
  80de65:	c7 04 24 53 3f 81 00 	movl   $0x813f53,(%esp)
  80de6c:	e8 08 2b ff ff       	call   800979 <cprintf>
}
  80de71:	c9                   	leave  
  80de72:	c3                   	ret    
	...

0080de80 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80de80:	55                   	push   %ebp
  80de81:	89 e5                	mov    %esp,%ebp
  80de83:	83 ec 28             	sub    $0x28,%esp
  80de86:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80de89:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80de8c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80de8f:	8b 75 08             	mov    0x8(%ebp),%esi
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80de92:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80de99:	e8 42 8e ff ff       	call   806ce0 <mem_malloc>
  80de9e:	89 c7                	mov    %eax,%edi

    if (jif == NULL) {
  80dea0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80dea5:	85 ff                	test   %edi,%edi
  80dea7:	0f 84 8a 00 00 00    	je     80df37 <jif_init+0xb7>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80dead:	8b 5e 1c             	mov    0x1c(%esi),%ebx

    netif->state = jif;
  80deb0:	89 7e 1c             	mov    %edi,0x1c(%esi)
    netif->output = jif_output;
  80deb3:	c7 46 14 5d e0 80 00 	movl   $0x80e05d,0x14(%esi)
    netif->linkoutput = low_level_output;
  80deba:	c7 46 18 44 df 80 00 	movl   $0x80df44,0x18(%esi)
    memcpy(&netif->name[0], "en", 2);
  80dec1:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80dec8:	00 
  80dec9:	c7 44 24 04 6b 28 81 	movl   $0x81286b,0x4(%esp)
  80ded0:	00 
  80ded1:	8d 46 2f             	lea    0x2f(%esi),%eax
  80ded4:	89 04 24             	mov    %eax,(%esp)
  80ded7:	e8 8c 33 ff ff       	call   801268 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80dedc:	8d 46 25             	lea    0x25(%esi),%eax
  80dedf:	89 07                	mov    %eax,(%edi)
    jif->envid = *output_envid; 
  80dee1:	8b 03                	mov    (%ebx),%eax
  80dee3:	89 47 04             	mov    %eax,0x4(%edi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80dee6:	c6 46 24 06          	movb   $0x6,0x24(%esi)
    netif->mtu = 1500;
  80deea:	66 c7 46 2c dc 05    	movw   $0x5dc,0x2c(%esi)
    netif->flags = NETIF_FLAG_BROADCAST;
  80def0:	c6 46 2e 02          	movb   $0x2,0x2e(%esi)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  80def4:	c6 46 25 52          	movb   $0x52,0x25(%esi)
    netif->hwaddr[1] = 0x54;
  80def8:	c6 46 26 54          	movb   $0x54,0x26(%esi)
    netif->hwaddr[2] = 0x00;
  80defc:	c6 46 27 00          	movb   $0x0,0x27(%esi)
    netif->hwaddr[3] = 0x12;
  80df00:	c6 46 28 12          	movb   $0x12,0x28(%esi)
    netif->hwaddr[4] = 0x34;
  80df04:	c6 46 29 34          	movb   $0x34,0x29(%esi)
    netif->hwaddr[5] = 0x56;
  80df08:	c6 46 2a 56          	movb   $0x56,0x2a(%esi)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80df0c:	c7 04 24 0c 21 81 00 	movl   $0x81210c,(%esp)
  80df13:	e8 b6 cb ff ff       	call   80aace <inet_addr>
  80df18:	89 45 f0             	mov    %eax,-0x10(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80df1b:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80df1e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80df25:	00 
  80df26:	89 44 24 04          	mov    %eax,0x4(%esp)
  80df2a:	89 34 24             	mov    %esi,(%esp)
  80df2d:	e8 4f e9 ff ff       	call   80c881 <etharp_query>
  80df32:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80df37:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80df3a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80df3d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80df40:	89 ec                	mov    %ebp,%esp
  80df42:	5d                   	pop    %ebp
  80df43:	c3                   	ret    

0080df44 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80df44:	55                   	push   %ebp
  80df45:	89 e5                	mov    %esp,%ebp
  80df47:	57                   	push   %edi
  80df48:	56                   	push   %esi
  80df49:	53                   	push   %ebx
  80df4a:	83 ec 1c             	sub    $0x1c,%esp
  80df4d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80df50:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80df57:	00 
  80df58:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80df5f:	10 
  80df60:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80df67:	e8 ae 37 ff ff       	call   80171a <sys_page_alloc>
    if (r < 0)
  80df6c:	85 c0                	test   %eax,%eax
  80df6e:	79 1c                	jns    80df8c <low_level_output+0x48>
	panic("jif: could not allocate page of memory");
  80df70:	c7 44 24 08 4c 44 81 	movl   $0x81444c,0x8(%esp)
  80df77:	00 
  80df78:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80df7f:	00 
  80df80:	c7 04 24 35 44 81 00 	movl   $0x814435,(%esp)
  80df87:	e8 20 29 ff ff       	call   8008ac <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80df8c:	8b 45 08             	mov    0x8(%ebp),%eax
  80df8f:	8b 78 1c             	mov    0x1c(%eax),%edi

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80df92:	be 00 00 00 00       	mov    $0x0,%esi
  80df97:	85 db                	test   %ebx,%ebx
  80df99:	74 78                	je     80e013 <low_level_output+0xcf>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80df9b:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80df9f:	0f b7 ca             	movzwl %dx,%ecx
  80dfa2:	be 00 00 00 00       	mov    $0x0,%esi
  80dfa7:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80dfad:	7f 13                	jg     80dfc2 <low_level_output+0x7e>
  80dfaf:	eb 35                	jmp    80dfe6 <low_level_output+0xa2>
  80dfb1:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80dfb5:	0f b7 ca             	movzwl %dx,%ecx
  80dfb8:	8d 04 0e             	lea    (%esi,%ecx,1),%eax
  80dfbb:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  80dfc0:	7e 29                	jle    80dfeb <low_level_output+0xa7>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80dfc2:	89 74 24 10          	mov    %esi,0x10(%esp)
  80dfc6:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  80dfca:	c7 44 24 08 74 44 81 	movl   $0x814474,0x8(%esp)
  80dfd1:	00 
  80dfd2:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  80dfd9:	00 
  80dfda:	c7 04 24 35 44 81 00 	movl   $0x814435,(%esp)
  80dfe1:	e8 c6 28 ff ff       	call   8008ac <_panic>
  80dfe6:	be 00 00 00 00       	mov    $0x0,%esi
	memcpy(&txbuf[txsize], q->payload, q->len);
  80dfeb:	0f b7 c2             	movzwl %dx,%eax
  80dfee:	89 44 24 08          	mov    %eax,0x8(%esp)
  80dff2:	8b 43 04             	mov    0x4(%ebx),%eax
  80dff5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dff9:	8d 86 04 00 00 10    	lea    0x10000004(%esi),%eax
  80dfff:	89 04 24             	mov    %eax,(%esp)
  80e002:	e8 61 32 ff ff       	call   801268 <memcpy>
	txsize += q->len;
  80e007:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e00b:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80e00d:	8b 1b                	mov    (%ebx),%ebx
  80e00f:	85 db                	test   %ebx,%ebx
  80e011:	75 9e                	jne    80dfb1 <low_level_output+0x6d>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80e013:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80e019:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80e020:	00 
  80e021:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
  80e028:	10 
  80e029:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  80e030:	00 
  80e031:	8b 47 04             	mov    0x4(%edi),%eax
  80e034:	89 04 24             	mov    %eax,(%esp)
  80e037:	e8 54 3d ff ff       	call   801d90 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80e03c:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80e043:	10 
  80e044:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e04b:	e8 0e 36 ff ff       	call   80165e <sys_page_unmap>

    return ERR_OK;
}
  80e050:	b8 00 00 00 00       	mov    $0x0,%eax
  80e055:	83 c4 1c             	add    $0x1c,%esp
  80e058:	5b                   	pop    %ebx
  80e059:	5e                   	pop    %esi
  80e05a:	5f                   	pop    %edi
  80e05b:	5d                   	pop    %ebp
  80e05c:	c3                   	ret    

0080e05d <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80e05d:	55                   	push   %ebp
  80e05e:	89 e5                	mov    %esp,%ebp
  80e060:	83 ec 18             	sub    $0x18,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80e063:	8b 45 10             	mov    0x10(%ebp),%eax
  80e066:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e06a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e06d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e071:	8b 45 08             	mov    0x8(%ebp),%eax
  80e074:	89 04 24             	mov    %eax,(%esp)
  80e077:	e8 23 ea ff ff       	call   80ca9f <etharp_output>
  80e07c:	0f be c0             	movsbl %al,%eax
}
  80e07f:	c9                   	leave  
  80e080:	c3                   	ret    

0080e081 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80e081:	55                   	push   %ebp
  80e082:	89 e5                	mov    %esp,%ebp
  80e084:	57                   	push   %edi
  80e085:	56                   	push   %esi
  80e086:	53                   	push   %ebx
  80e087:	83 ec 1c             	sub    $0x1c,%esp
  80e08a:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80e08d:	8b 45 08             	mov    0x8(%ebp),%eax
  80e090:	8b 40 1c             	mov    0x1c(%eax),%eax
  80e093:	89 45 e8             	mov    %eax,-0x18(%ebp)
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
    s16_t len = pkt->jp_len;
  80e096:	0f b7 1e             	movzwl (%esi),%ebx

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80e099:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  80e0a0:	00 
  80e0a1:	0f b7 c3             	movzwl %bx,%eax
  80e0a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e0a8:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80e0af:	e8 82 9c ff ff       	call   807d36 <pbuf_alloc>
  80e0b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (p == 0)
  80e0b7:	85 c0                	test   %eax,%eax
  80e0b9:	0f 84 c5 00 00 00    	je     80e184 <jif_input+0x103>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80e0bf:	83 c6 04             	add    $0x4,%esi
  80e0c2:	89 75 f0             	mov    %esi,-0x10(%ebp)
  80e0c5:	89 c6                	mov    %eax,%esi
  80e0c7:	bf 00 00 00 00       	mov    $0x0,%edi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80e0cc:	0f bf db             	movswl %bx,%ebx
  80e0cf:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80e0d2:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80e0d6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80e0d9:	29 fb                	sub    %edi,%ebx
  80e0db:	39 c3                	cmp    %eax,%ebx
  80e0dd:	7e 02                	jle    80e0e1 <jif_input+0x60>
  80e0df:	89 c3                	mov    %eax,%ebx
	if (bytes > (len - copied))
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80e0e1:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80e0e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80e0e8:	01 f8                	add    %edi,%eax
  80e0ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e0ee:	8b 46 04             	mov    0x4(%esi),%eax
  80e0f1:	89 04 24             	mov    %eax,(%esp)
  80e0f4:	e8 6f 31 ff ff       	call   801268 <memcpy>
	copied += bytes;
  80e0f9:	01 df                	add    %ebx,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80e0fb:	8b 36                	mov    (%esi),%esi
  80e0fd:	85 f6                	test   %esi,%esi
  80e0ff:	74 63                	je     80e164 <jif_input+0xe3>
  80e101:	eb cf                	jmp    80e0d2 <jif_input+0x51>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80e103:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80e106:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e10a:	8b 45 08             	mov    0x8(%ebp),%eax
  80e10d:	89 04 24             	mov    %eax,(%esp)
  80e110:	e8 53 ec ff ff       	call   80cd68 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80e115:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80e11c:	ff 
  80e11d:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80e120:	89 14 24             	mov    %edx,(%esp)
  80e123:	e8 e0 95 ff ff       	call   807708 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80e128:	8b 45 08             	mov    0x8(%ebp),%eax
  80e12b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e12f:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80e132:	89 14 24             	mov    %edx,(%esp)
  80e135:	ff 50 10             	call   *0x10(%eax)
  80e138:	eb 4a                	jmp    80e184 <jif_input+0x103>
	break;
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80e13a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80e13d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e141:	8b 55 e8             	mov    -0x18(%ebp),%edx
  80e144:	8b 02                	mov    (%edx),%eax
  80e146:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e14a:	8b 45 08             	mov    0x8(%ebp),%eax
  80e14d:	89 04 24             	mov    %eax,(%esp)
  80e150:	e8 e6 ec ff ff       	call   80ce3b <etharp_arp_input>
  80e155:	eb 2d                	jmp    80e184 <jif_input+0x103>
	break;

    default:
	pbuf_free(p);
  80e157:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80e15a:	89 14 24             	mov    %edx,(%esp)
  80e15d:	e8 11 99 ff ff       	call   807a73 <pbuf_free>
  80e162:	eb 20                	jmp    80e184 <jif_input+0x103>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80e164:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80e167:	8b 42 04             	mov    0x4(%edx),%eax
  80e16a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80e16e:	89 04 24             	mov    %eax,(%esp)
  80e171:	e8 19 c7 ff ff       	call   80a88f <htons>
  80e176:	66 3d 00 08          	cmp    $0x800,%ax
  80e17a:	74 87                	je     80e103 <jif_input+0x82>
  80e17c:	66 3d 06 08          	cmp    $0x806,%ax
  80e180:	75 d5                	jne    80e157 <jif_input+0xd6>
  80e182:	eb b6                	jmp    80e13a <jif_input+0xb9>
	break;

    default:
	pbuf_free(p);
    }
}
  80e184:	83 c4 1c             	add    $0x1c,%esp
  80e187:	5b                   	pop    %ebx
  80e188:	5e                   	pop    %esi
  80e189:	5f                   	pop    %edi
  80e18a:	5d                   	pop    %ebp
  80e18b:	c3                   	ret    
  80e18c:	00 00                	add    %al,(%eax)
	...

0080e190 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80e190:	55                   	push   %ebp
  80e191:	89 e5                	mov    %esp,%ebp
  80e193:	83 ec 18             	sub    $0x18,%esp
  80e196:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80e199:	85 c0                	test   %eax,%eax
  80e19b:	75 1c                	jne    80e1b9 <netconn_type+0x29>
  80e19d:	c7 44 24 08 9d 44 81 	movl   $0x81449d,0x8(%esp)
  80e1a4:	00 
  80e1a5:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  80e1ac:	00 
  80e1ad:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e1b4:	e8 f3 26 ff ff       	call   8008ac <_panic>
  80e1b9:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80e1bb:	c9                   	leave  
  80e1bc:	c3                   	ret    

0080e1bd <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80e1bd:	55                   	push   %ebp
  80e1be:	89 e5                	mov    %esp,%ebp
  80e1c0:	53                   	push   %ebx
  80e1c1:	83 ec 34             	sub    $0x34,%esp
  80e1c4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e1c7:	85 db                	test   %ebx,%ebx
  80e1c9:	75 1c                	jne    80e1e7 <netconn_close+0x2a>
  80e1cb:	c7 44 24 08 cf 44 81 	movl   $0x8144cf,0x8(%esp)
  80e1d2:	00 
  80e1d3:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
  80e1da:	00 
  80e1db:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e1e2:	e8 c5 26 ff ff       	call   8008ac <_panic>

  msg.function = do_close;
  80e1e7:	c7 45 e8 d5 eb 80 00 	movl   $0x80ebd5,-0x18(%ebp)
  msg.msg.conn = conn;
  80e1ee:	89 5d ec             	mov    %ebx,-0x14(%ebp)
  tcpip_apimsg(&msg);
  80e1f1:	8d 45 e8             	lea    -0x18(%ebp),%eax
  80e1f4:	89 04 24             	mov    %eax,(%esp)
  80e1f7:	e8 95 6b ff ff       	call   804d91 <tcpip_apimsg>
  80e1fc:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
  return conn->err;
}
  80e200:	83 c4 34             	add    $0x34,%esp
  80e203:	5b                   	pop    %ebx
  80e204:	5d                   	pop    %ebp
  80e205:	c3                   	ret    

0080e206 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80e206:	55                   	push   %ebp
  80e207:	89 e5                	mov    %esp,%ebp
  80e209:	53                   	push   %ebx
  80e20a:	83 ec 34             	sub    $0x34,%esp
  80e20d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e210:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e214:	85 db                	test   %ebx,%ebx
  80e216:	75 1c                	jne    80e234 <netconn_write+0x2e>
  80e218:	c7 44 24 08 eb 44 81 	movl   $0x8144eb,0x8(%esp)
  80e21f:	00 
  80e220:	c7 44 24 04 d3 01 00 	movl   $0x1d3,0x4(%esp)
  80e227:	00 
  80e228:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e22f:	e8 78 26 ff ff       	call   8008ac <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80e234:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e237:	74 1c                	je     80e255 <netconn_write+0x4f>
  80e239:	c7 44 24 08 38 46 81 	movl   $0x814638,0x8(%esp)
  80e240:	00 
  80e241:	c7 44 24 04 d4 01 00 	movl   $0x1d4,0x4(%esp)
  80e248:	00 
  80e249:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e250:	e8 57 26 ff ff       	call   8008ac <_panic>

  msg.function = do_write;
  80e255:	c7 45 e8 79 ee 80 00 	movl   $0x80ee79,-0x18(%ebp)
  msg.msg.conn = conn;
  80e25c:	89 5d ec             	mov    %ebx,-0x14(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80e25f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e262:	89 55 f0             	mov    %edx,-0x10(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80e265:	88 45 f8             	mov    %al,-0x8(%ebp)
  msg.msg.msg.w.len = size;
  80e268:	8b 45 10             	mov    0x10(%ebp),%eax
  80e26b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80e26e:	8d 45 e8             	lea    -0x18(%ebp),%eax
  80e271:	89 04 24             	mov    %eax,(%esp)
  80e274:	e8 18 6b ff ff       	call   804d91 <tcpip_apimsg>
  80e279:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
  return conn->err;
}
  80e27d:	83 c4 34             	add    $0x34,%esp
  80e280:	5b                   	pop    %ebx
  80e281:	5d                   	pop    %ebp
  80e282:	c3                   	ret    

0080e283 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80e283:	55                   	push   %ebp
  80e284:	89 e5                	mov    %esp,%ebp
  80e286:	53                   	push   %ebx
  80e287:	83 ec 34             	sub    $0x34,%esp
  80e28a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e28d:	85 db                	test   %ebx,%ebx
  80e28f:	75 1c                	jne    80e2ad <netconn_send+0x2a>
  80e291:	c7 44 24 08 07 45 81 	movl   $0x814507,0x8(%esp)
  80e298:	00 
  80e299:	c7 44 24 04 b9 01 00 	movl   $0x1b9,0x4(%esp)
  80e2a0:	00 
  80e2a1:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e2a8:	e8 ff 25 ff ff       	call   8008ac <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80e2ad:	c7 45 e8 02 f0 80 00 	movl   $0x80f002,-0x18(%ebp)
  msg.msg.conn = conn;
  80e2b4:	89 5d ec             	mov    %ebx,-0x14(%ebp)
  msg.msg.msg.b = buf;
  80e2b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e2ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80e2bd:	8d 45 e8             	lea    -0x18(%ebp),%eax
  80e2c0:	89 04 24             	mov    %eax,(%esp)
  80e2c3:	e8 c9 6a ff ff       	call   804d91 <tcpip_apimsg>
  80e2c8:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
  return conn->err;
}
  80e2cc:	83 c4 34             	add    $0x34,%esp
  80e2cf:	5b                   	pop    %ebx
  80e2d0:	5d                   	pop    %ebp
  80e2d1:	c3                   	ret    

0080e2d2 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80e2d2:	55                   	push   %ebp
  80e2d3:	89 e5                	mov    %esp,%ebp
  80e2d5:	83 ec 08             	sub    $0x8,%esp
  80e2d8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e2db:	0f b7 4d 14          	movzwl 0x14(%ebp),%ecx
  if (buf != NULL) {
  80e2df:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80e2e4:	85 d2                	test   %edx,%edx
  80e2e6:	74 1c                	je     80e304 <netconn_sendto+0x32>
    buf->addr = addr;
  80e2e8:	8b 45 10             	mov    0x10(%ebp),%eax
  80e2eb:	89 42 08             	mov    %eax,0x8(%edx)
    buf->port = port;
  80e2ee:	66 89 4a 0c          	mov    %cx,0xc(%edx)
    return netconn_send(conn, buf);
  80e2f2:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e2f6:	8b 45 08             	mov    0x8(%ebp),%eax
  80e2f9:	89 04 24             	mov    %eax,(%esp)
  80e2fc:	e8 82 ff ff ff       	call   80e283 <netconn_send>
  80e301:	0f be c0             	movsbl %al,%eax
  }
  return ERR_VAL;
}
  80e304:	c9                   	leave  
  80e305:	c3                   	ret    

0080e306 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80e306:	55                   	push   %ebp
  80e307:	89 e5                	mov    %esp,%ebp
  80e309:	53                   	push   %ebx
  80e30a:	83 ec 34             	sub    $0x34,%esp
  80e30d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80e310:	85 db                	test   %ebx,%ebx
  80e312:	75 1c                	jne    80e330 <netconn_listen_with_backlog+0x2a>
  80e314:	c7 44 24 08 22 45 81 	movl   $0x814522,0x8(%esp)
  80e31b:	00 
  80e31c:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80e323:	00 
  80e324:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e32b:	e8 7c 25 ff ff       	call   8008ac <_panic>

  msg.function = do_listen;
  80e330:	c7 45 e8 c9 f0 80 00 	movl   $0x80f0c9,-0x18(%ebp)
  msg.msg.conn = conn;
  80e337:	89 5d ec             	mov    %ebx,-0x14(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80e33a:	8d 45 e8             	lea    -0x18(%ebp),%eax
  80e33d:	89 04 24             	mov    %eax,(%esp)
  80e340:	e8 4c 6a ff ff       	call   804d91 <tcpip_apimsg>
  80e345:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
  return conn->err;
}
  80e349:	83 c4 34             	add    $0x34,%esp
  80e34c:	5b                   	pop    %ebx
  80e34d:	5d                   	pop    %ebp
  80e34e:	c3                   	ret    

0080e34f <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80e34f:	55                   	push   %ebp
  80e350:	89 e5                	mov    %esp,%ebp
  80e352:	53                   	push   %ebx
  80e353:	83 ec 34             	sub    $0x34,%esp
  80e356:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80e359:	85 db                	test   %ebx,%ebx
  80e35b:	75 1c                	jne    80e379 <netconn_disconnect+0x2a>
  80e35d:	c7 44 24 08 5c 46 81 	movl   $0x81465c,0x8(%esp)
  80e364:	00 
  80e365:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
  80e36c:	00 
  80e36d:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e374:	e8 33 25 ff ff       	call   8008ac <_panic>

  msg.function = do_disconnect;
  80e379:	c7 45 e8 89 f2 80 00 	movl   $0x80f289,-0x18(%ebp)
  msg.msg.conn = conn;
  80e380:	89 5d ec             	mov    %ebx,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80e383:	8d 45 e8             	lea    -0x18(%ebp),%eax
  80e386:	89 04 24             	mov    %eax,(%esp)
  80e389:	e8 03 6a ff ff       	call   804d91 <tcpip_apimsg>
  80e38e:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
  return conn->err;
}
  80e392:	83 c4 34             	add    $0x34,%esp
  80e395:	5b                   	pop    %ebx
  80e396:	5d                   	pop    %ebp
  80e397:	c3                   	ret    

0080e398 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80e398:	55                   	push   %ebp
  80e399:	89 e5                	mov    %esp,%ebp
  80e39b:	53                   	push   %ebx
  80e39c:	83 ec 34             	sub    $0x34,%esp
  80e39f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e3a2:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80e3a6:	85 db                	test   %ebx,%ebx
  80e3a8:	75 1c                	jne    80e3c6 <netconn_connect+0x2e>
  80e3aa:	c7 44 24 08 3f 45 81 	movl   $0x81453f,0x8(%esp)
  80e3b1:	00 
  80e3b2:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
  80e3b9:	00 
  80e3ba:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e3c1:	e8 e6 24 ff ff       	call   8008ac <_panic>

  msg.function = do_connect;
  80e3c6:	c7 45 e8 bf f2 80 00 	movl   $0x80f2bf,-0x18(%ebp)
  msg.msg.conn = conn;
  80e3cd:	89 5d ec             	mov    %ebx,-0x14(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80e3d0:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e3d3:	89 55 f0             	mov    %edx,-0x10(%ebp)
  msg.msg.msg.bc.port = port;
  80e3d6:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80e3da:	8d 45 e8             	lea    -0x18(%ebp),%eax
  80e3dd:	89 04 24             	mov    %eax,(%esp)
  80e3e0:	e8 ac 69 ff ff       	call   804d91 <tcpip_apimsg>
  80e3e5:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
  return conn->err;
}
  80e3e9:	83 c4 34             	add    $0x34,%esp
  80e3ec:	5b                   	pop    %ebx
  80e3ed:	5d                   	pop    %ebp
  80e3ee:	c3                   	ret    

0080e3ef <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80e3ef:	55                   	push   %ebp
  80e3f0:	89 e5                	mov    %esp,%ebp
  80e3f2:	53                   	push   %ebx
  80e3f3:	83 ec 34             	sub    $0x34,%esp
  80e3f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e3f9:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80e3fd:	85 db                	test   %ebx,%ebx
  80e3ff:	75 1c                	jne    80e41d <netconn_bind+0x2e>
  80e401:	c7 44 24 08 5d 45 81 	movl   $0x81455d,0x8(%esp)
  80e408:	00 
  80e409:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80e410:	00 
  80e411:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e418:	e8 8f 24 ff ff       	call   8008ac <_panic>

  msg.function = do_bind;
  80e41d:	c7 45 e8 91 f3 80 00 	movl   $0x80f391,-0x18(%ebp)
  msg.msg.conn = conn;
  80e424:	89 5d ec             	mov    %ebx,-0x14(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80e427:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e42a:	89 55 f0             	mov    %edx,-0x10(%ebp)
  msg.msg.msg.bc.port = port;
  80e42d:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80e431:	8d 45 e8             	lea    -0x18(%ebp),%eax
  80e434:	89 04 24             	mov    %eax,(%esp)
  80e437:	e8 55 69 ff ff       	call   804d91 <tcpip_apimsg>
  80e43c:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
  return conn->err;
}
  80e440:	83 c4 34             	add    $0x34,%esp
  80e443:	5b                   	pop    %ebx
  80e444:	5d                   	pop    %ebp
  80e445:	c3                   	ret    

0080e446 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80e446:	55                   	push   %ebp
  80e447:	89 e5                	mov    %esp,%ebp
  80e449:	53                   	push   %ebx
  80e44a:	83 ec 34             	sub    $0x34,%esp
  80e44d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e450:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e453:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80e456:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80e45a:	85 db                	test   %ebx,%ebx
  80e45c:	75 1c                	jne    80e47a <netconn_getaddr+0x34>
  80e45e:	c7 44 24 08 78 45 81 	movl   $0x814578,0x8(%esp)
  80e465:	00 
  80e466:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80e46d:	00 
  80e46e:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e475:	e8 32 24 ff ff       	call   8008ac <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80e47a:	85 d2                	test   %edx,%edx
  80e47c:	75 1c                	jne    80e49a <netconn_getaddr+0x54>
  80e47e:	c7 44 24 08 96 45 81 	movl   $0x814596,0x8(%esp)
  80e485:	00 
  80e486:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80e48d:	00 
  80e48e:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e495:	e8 12 24 ff ff       	call   8008ac <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80e49a:	85 c9                	test   %ecx,%ecx
  80e49c:	75 1c                	jne    80e4ba <netconn_getaddr+0x74>
  80e49e:	c7 44 24 08 b4 45 81 	movl   $0x8145b4,0x8(%esp)
  80e4a5:	00 
  80e4a6:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  80e4ad:	00 
  80e4ae:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e4b5:	e8 f2 23 ff ff       	call   8008ac <_panic>

  msg.function = do_getaddr;
  80e4ba:	c7 45 e8 60 e8 80 00 	movl   $0x80e860,-0x18(%ebp)
  msg.msg.conn = conn;
  80e4c1:	89 5d ec             	mov    %ebx,-0x14(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80e4c4:	89 55 f0             	mov    %edx,-0x10(%ebp)
  msg.msg.msg.ad.port = port;
  80e4c7:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  msg.msg.msg.ad.local = local;
  80e4ca:	88 45 f8             	mov    %al,-0x8(%ebp)
  TCPIP_APIMSG(&msg);
  80e4cd:	8d 45 e8             	lea    -0x18(%ebp),%eax
  80e4d0:	89 04 24             	mov    %eax,(%esp)
  80e4d3:	e8 b9 68 ff ff       	call   804d91 <tcpip_apimsg>
  80e4d8:	0f be 43 0c          	movsbl 0xc(%ebx),%eax

  return conn->err;
}
  80e4dc:	83 c4 34             	add    $0x34,%esp
  80e4df:	5b                   	pop    %ebx
  80e4e0:	5d                   	pop    %ebp
  80e4e1:	c3                   	ret    

0080e4e2 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80e4e2:	55                   	push   %ebp
  80e4e3:	89 e5                	mov    %esp,%ebp
  80e4e5:	53                   	push   %ebx
  80e4e6:	83 ec 24             	sub    $0x24,%esp
  80e4e9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80e4ec:	85 db                	test   %ebx,%ebx
  80e4ee:	75 1c                	jne    80e50c <netconn_accept+0x2a>
  80e4f0:	c7 44 24 08 d2 45 81 	movl   $0x8145d2,0x8(%esp)
  80e4f7:	00 
  80e4f8:	c7 44 24 04 10 01 00 	movl   $0x110,0x4(%esp)
  80e4ff:	00 
  80e500:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e507:	e8 a0 23 ff ff       	call   8008ac <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80e50c:	8b 53 18             	mov    0x18(%ebx),%edx
  80e50f:	83 fa ff             	cmp    $0xffffffff,%edx
  80e512:	75 1c                	jne    80e530 <netconn_accept+0x4e>
  80e514:	c7 44 24 08 80 46 81 	movl   $0x814680,0x8(%esp)
  80e51b:	00 
  80e51c:	c7 44 24 04 11 01 00 	movl   $0x111,0x4(%esp)
  80e523:	00 
  80e524:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e52b:	e8 7c 23 ff ff       	call   8008ac <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80e530:	8d 45 f8             	lea    -0x8(%ebp),%eax
  80e533:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e53a:	00 
  80e53b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e53f:	89 14 24             	mov    %edx,(%esp)
  80e542:	e8 dd f2 ff ff       	call   80d824 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80e547:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80e54a:	85 c0                	test   %eax,%eax
  80e54c:	74 15                	je     80e563 <netconn_accept+0x81>
  80e54e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e555:	00 
  80e556:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80e55d:	00 
  80e55e:	89 1c 24             	mov    %ebx,(%esp)
  80e561:	ff d0                	call   *%eax
  80e563:	8b 45 f8             	mov    -0x8(%ebp),%eax
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80e566:	83 c4 24             	add    $0x24,%esp
  80e569:	5b                   	pop    %ebx
  80e56a:	5d                   	pop    %ebp
  80e56b:	c3                   	ret    

0080e56c <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80e56c:	55                   	push   %ebp
  80e56d:	89 e5                	mov    %esp,%ebp
  80e56f:	53                   	push   %ebx
  80e570:	83 ec 34             	sub    $0x34,%esp
  80e573:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80e576:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80e57d:	85 db                	test   %ebx,%ebx
  80e57f:	75 1c                	jne    80e59d <netconn_recv+0x31>
  80e581:	c7 44 24 08 ef 45 81 	movl   $0x8145ef,0x8(%esp)
  80e588:	00 
  80e589:	c7 44 24 04 3a 01 00 	movl   $0x13a,0x4(%esp)
  80e590:	00 
  80e591:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e598:	e8 0f 23 ff ff       	call   8008ac <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80e59d:	8b 53 14             	mov    0x14(%ebx),%edx
  80e5a0:	83 fa ff             	cmp    $0xffffffff,%edx
  80e5a3:	75 0e                	jne    80e5b3 <netconn_recv+0x47>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80e5a5:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80e5a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80e5ae:	e9 5f 01 00 00       	jmp    80e712 <netconn_recv+0x1a6>
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
  80e5b3:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80e5b7:	0f 8c 50 01 00 00    	jl     80e70d <netconn_recv+0x1a1>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80e5bd:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e5c0:	0f 85 fc 00 00 00    	jne    80e6c2 <netconn_recv+0x156>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80e5c6:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80e5ca:	75 0e                	jne    80e5da <netconn_recv+0x6e>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80e5cc:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80e5d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80e5d5:	e9 38 01 00 00       	jmp    80e712 <netconn_recv+0x1a6>
      return NULL;
    }

    buf = memp_malloc(MEMP_NETBUF);
  80e5da:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80e5e1:	e8 64 8d ff ff       	call   80734a <memp_malloc>
  80e5e6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    if (buf == NULL) {
  80e5e9:	85 c0                	test   %eax,%eax
  80e5eb:	75 09                	jne    80e5f6 <netconn_recv+0x8a>
      conn->err = ERR_MEM;
  80e5ed:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
  80e5f1:	e9 1c 01 00 00       	jmp    80e712 <netconn_recv+0x1a6>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80e5f6:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80e5f9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e600:	00 
  80e601:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e605:	8b 43 14             	mov    0x14(%ebx),%eax
  80e608:	89 04 24             	mov    %eax,(%esp)
  80e60b:	e8 14 f2 ff ff       	call   80d824 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80e610:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80e613:	b8 00 00 00 00       	mov    $0x0,%eax
  80e618:	85 d2                	test   %edx,%edx
  80e61a:	74 08                	je     80e624 <netconn_recv+0xb8>
      len = p->tot_len;
  80e61c:	0f b7 42 08          	movzwl 0x8(%edx),%eax
      SYS_ARCH_DEC(conn->recv_avail, len);
  80e620:	66 29 43 20          	sub    %ax,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80e624:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80e627:	85 d2                	test   %edx,%edx
  80e629:	74 14                	je     80e63f <netconn_recv+0xd3>
  80e62b:	0f b7 c0             	movzwl %ax,%eax
  80e62e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e632:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80e639:	00 
  80e63a:	89 1c 24             	mov    %ebx,(%esp)
  80e63d:	ff d2                	call   *%edx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80e63f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80e642:	85 d2                	test   %edx,%edx
  80e644:	75 2b                	jne    80e671 <netconn_recv+0x105>
      memp_free(MEMP_NETBUF, buf);
  80e646:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e649:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e64d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80e654:	e8 ae 8c ff ff       	call   807307 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80e659:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80e65d:	0f 85 aa 00 00 00    	jne    80e70d <netconn_recv+0x1a1>
        conn->err = ERR_CLSD;
  80e663:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80e667:	b8 00 00 00 00       	mov    $0x0,%eax
  80e66c:	e9 a1 00 00 00       	jmp    80e712 <netconn_recv+0x1a6>
      }
      return NULL;
    }

    buf->p = p;
  80e671:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e674:	89 10                	mov    %edx,(%eax)
    buf->ptr = p;
  80e676:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80e679:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e67c:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80e67f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e682:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80e688:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e68b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80e692:	c7 45 e8 c1 ef 80 00 	movl   $0x80efc1,-0x18(%ebp)
    msg.msg.conn = conn;
  80e699:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    if (buf != NULL) {
  80e69c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e69f:	85 c0                	test   %eax,%eax
  80e6a1:	74 0c                	je     80e6af <netconn_recv+0x143>
      msg.msg.msg.r.len = buf->p->tot_len;
  80e6a3:	8b 00                	mov    (%eax),%eax
  80e6a5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e6a9:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  80e6ad:	eb 06                	jmp    80e6b5 <netconn_recv+0x149>
    } else {
      msg.msg.msg.r.len = 1;
  80e6af:	66 c7 45 f0 01 00    	movw   $0x1,-0x10(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80e6b5:	8d 45 e8             	lea    -0x18(%ebp),%eax
  80e6b8:	89 04 24             	mov    %eax,(%esp)
  80e6bb:	e8 d1 66 ff ff       	call   804d91 <tcpip_apimsg>
  80e6c0:	eb 46                	jmp    80e708 <netconn_recv+0x19c>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80e6c2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e6c5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e6cc:	00 
  80e6cd:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e6d1:	89 14 24             	mov    %edx,(%esp)
  80e6d4:	e8 4b f1 ff ff       	call   80d824 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80e6d9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80e6dc:	85 d2                	test   %edx,%edx
  80e6de:	74 28                	je     80e708 <netconn_recv+0x19c>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80e6e0:	8b 02                	mov    (%edx),%eax
  80e6e2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e6e6:	66 29 43 20          	sub    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80e6ea:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80e6ed:	85 c9                	test   %ecx,%ecx
  80e6ef:	74 17                	je     80e708 <netconn_recv+0x19c>
  80e6f1:	8b 02                	mov    (%edx),%eax
  80e6f3:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e6f7:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e6fb:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80e702:	00 
  80e703:	89 1c 24             	mov    %ebx,(%esp)
  80e706:	ff d1                	call   *%ecx
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80e708:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e70b:	eb 05                	jmp    80e712 <netconn_recv+0x1a6>
  80e70d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e712:	83 c4 34             	add    $0x34,%esp
  80e715:	5b                   	pop    %ebx
  80e716:	5d                   	pop    %ebp
  80e717:	c3                   	ret    

0080e718 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80e718:	55                   	push   %ebp
  80e719:	89 e5                	mov    %esp,%ebp
  80e71b:	53                   	push   %ebx
  80e71c:	83 ec 24             	sub    $0x24,%esp
  80e71f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80e722:	85 db                	test   %ebx,%ebx
  80e724:	74 24                	je     80e74a <netconn_delete+0x32>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80e726:	c7 45 e8 34 f4 80 00 	movl   $0x80f434,-0x18(%ebp)
  msg.msg.conn = conn;
  80e72d:	89 5d ec             	mov    %ebx,-0x14(%ebp)
  tcpip_apimsg(&msg);
  80e730:	8d 45 e8             	lea    -0x18(%ebp),%eax
  80e733:	89 04 24             	mov    %eax,(%esp)
  80e736:	e8 56 66 ff ff       	call   804d91 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80e73b:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80e742:	89 1c 24             	mov    %ebx,(%esp)
  80e745:	e8 a5 0d 00 00       	call   80f4ef <netconn_free>

  return ERR_OK;
}
  80e74a:	b8 00 00 00 00       	mov    $0x0,%eax
  80e74f:	83 c4 24             	add    $0x24,%esp
  80e752:	5b                   	pop    %ebx
  80e753:	5d                   	pop    %ebp
  80e754:	c3                   	ret    

0080e755 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80e755:	55                   	push   %ebp
  80e756:	89 e5                	mov    %esp,%ebp
  80e758:	56                   	push   %esi
  80e759:	53                   	push   %ebx
  80e75a:	83 ec 30             	sub    $0x30,%esp
  80e75d:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80e760:	8b 45 10             	mov    0x10(%ebp),%eax
  80e763:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e767:	8b 45 08             	mov    0x8(%ebp),%eax
  80e76a:	89 04 24             	mov    %eax,(%esp)
  80e76d:	e8 71 0f 00 00       	call   80f6e3 <netconn_alloc>
  80e772:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80e774:	85 c0                	test   %eax,%eax
  80e776:	0f 84 d6 00 00 00    	je     80e852 <netconn_new_with_proto_and_callback+0xfd>
    msg.function = do_newconn;
  80e77c:	c7 45 e4 5c f8 80 00 	movl   $0x80f85c,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80e783:	89 f0                	mov    %esi,%eax
  80e785:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80e788:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80e78b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e78e:	89 04 24             	mov    %eax,(%esp)
  80e791:	e8 fb 65 ff ff       	call   804d91 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80e796:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80e79a:	0f 84 b2 00 00 00    	je     80e852 <netconn_new_with_proto_and_callback+0xfd>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80e7a0:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80e7a4:	74 1c                	je     80e7c2 <netconn_new_with_proto_and_callback+0x6d>
  80e7a6:	c7 44 24 08 a4 46 81 	movl   $0x8146a4,0x8(%esp)
  80e7ad:	00 
  80e7ae:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80e7b5:	00 
  80e7b6:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e7bd:	e8 ea 20 ff ff       	call   8008ac <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80e7c2:	8b 43 10             	mov    0x10(%ebx),%eax
  80e7c5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e7c8:	75 1c                	jne    80e7e6 <netconn_new_with_proto_and_callback+0x91>
  80e7ca:	c7 44 24 08 0a 46 81 	movl   $0x81460a,0x8(%esp)
  80e7d1:	00 
  80e7d2:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  80e7d9:	00 
  80e7da:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e7e1:	e8 c6 20 ff ff       	call   8008ac <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80e7e6:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80e7ea:	75 1c                	jne    80e808 <netconn_new_with_proto_and_callback+0xb3>
  80e7ec:	c7 44 24 08 23 46 81 	movl   $0x814623,0x8(%esp)
  80e7f3:	00 
  80e7f4:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80e7fb:	00 
  80e7fc:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e803:	e8 a4 20 ff ff       	call   8008ac <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80e808:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80e80c:	74 1c                	je     80e82a <netconn_new_with_proto_and_callback+0xd5>
  80e80e:	c7 44 24 08 c8 46 81 	movl   $0x8146c8,0x8(%esp)
  80e815:	00 
  80e816:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80e81d:	00 
  80e81e:	c7 04 24 b8 44 81 00 	movl   $0x8144b8,(%esp)
  80e825:	e8 82 20 ff ff       	call   8008ac <_panic>
      sys_sem_free(conn->op_completed);
  80e82a:	89 04 24             	mov    %eax,(%esp)
  80e82d:	e8 4e e9 ff ff       	call   80d180 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80e832:	8b 43 14             	mov    0x14(%ebx),%eax
  80e835:	89 04 24             	mov    %eax,(%esp)
  80e838:	e8 bc e9 ff ff       	call   80d1f9 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80e83d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e841:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80e848:	e8 ba 8a ff ff       	call   807307 <memp_free>
  80e84d:	bb 00 00 00 00       	mov    $0x0,%ebx
      return NULL;
    }
  }
  return conn;
}
  80e852:	89 d8                	mov    %ebx,%eax
  80e854:	83 c4 30             	add    $0x30,%esp
  80e857:	5b                   	pop    %ebx
  80e858:	5e                   	pop    %esi
  80e859:	5d                   	pop    %ebp
  80e85a:	c3                   	ret    
  80e85b:	00 00                	add    %al,(%eax)
  80e85d:	00 00                	add    %al,(%eax)
	...

0080e860 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80e860:	55                   	push   %ebp
  80e861:	89 e5                	mov    %esp,%ebp
  80e863:	53                   	push   %ebx
  80e864:	83 ec 04             	sub    $0x4,%esp
  80e867:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if (msg->conn->pcb.ip != NULL) {
  80e86a:	8b 11                	mov    (%ecx),%edx
  80e86c:	8b 42 08             	mov    0x8(%edx),%eax
  80e86f:	85 c0                	test   %eax,%eax
  80e871:	0f 84 9e 00 00 00    	je     80e915 <do_getaddr+0xb5>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80e877:	8b 51 04             	mov    0x4(%ecx),%edx
  80e87a:	80 79 0c 00          	cmpb   $0x0,0xc(%ecx)
  80e87e:	74 06                	je     80e886 <do_getaddr+0x26>
  80e880:	8b 00                	mov    (%eax),%eax
  80e882:	89 02                	mov    %eax,(%edx)
  80e884:	eb 05                	jmp    80e88b <do_getaddr+0x2b>
  80e886:	8b 40 04             	mov    0x4(%eax),%eax
  80e889:	89 02                	mov    %eax,(%edx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80e88b:	8b 11                	mov    (%ecx),%edx
  80e88d:	8b 02                	mov    (%edx),%eax
  80e88f:	25 f0 00 00 00       	and    $0xf0,%eax
  80e894:	83 f8 20             	cmp    $0x20,%eax
  80e897:	74 2e                	je     80e8c7 <do_getaddr+0x67>
  80e899:	83 f8 40             	cmp    $0x40,%eax
  80e89c:	74 07                	je     80e8a5 <do_getaddr+0x45>
  80e89e:	83 f8 10             	cmp    $0x10,%eax
  80e8a1:	75 76                	jne    80e919 <do_getaddr+0xb9>
  80e8a3:	eb 52                	jmp    80e8f7 <do_getaddr+0x97>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80e8a5:	80 79 0c 00          	cmpb   $0x0,0xc(%ecx)
  80e8a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  80e8b0:	74 0f                	je     80e8c1 <do_getaddr+0x61>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80e8b2:	8b 41 08             	mov    0x8(%ecx),%eax
  80e8b5:	8b 52 08             	mov    0x8(%edx),%edx
  80e8b8:	0f b6 52 10          	movzbl 0x10(%edx),%edx
  80e8bc:	66 89 10             	mov    %dx,(%eax)
  80e8bf:	eb 58                	jmp    80e919 <do_getaddr+0xb9>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80e8c1:	c6 42 0c f8          	movb   $0xf8,0xc(%edx)
  80e8c5:	eb 52                	jmp    80e919 <do_getaddr+0xb9>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80e8c7:	80 79 0c 00          	cmpb   $0x0,0xc(%ecx)
  80e8cb:	74 0f                	je     80e8dc <do_getaddr+0x7c>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80e8cd:	8b 41 08             	mov    0x8(%ecx),%eax
  80e8d0:	8b 52 08             	mov    0x8(%edx),%edx
  80e8d3:	0f b7 52 12          	movzwl 0x12(%edx),%edx
  80e8d7:	66 89 10             	mov    %dx,(%eax)
  80e8da:	eb 3d                	jmp    80e919 <do_getaddr+0xb9>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80e8dc:	8b 42 08             	mov    0x8(%edx),%eax
  80e8df:	f6 40 10 04          	testb  $0x4,0x10(%eax)
  80e8e3:	75 06                	jne    80e8eb <do_getaddr+0x8b>
          msg->conn->err = ERR_CONN;
  80e8e5:	c6 42 0c f8          	movb   $0xf8,0xc(%edx)
  80e8e9:	eb 2e                	jmp    80e919 <do_getaddr+0xb9>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80e8eb:	8b 51 08             	mov    0x8(%ecx),%edx
  80e8ee:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  80e8f2:	66 89 02             	mov    %ax,(%edx)
  80e8f5:	eb 22                	jmp    80e919 <do_getaddr+0xb9>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80e8f7:	8b 59 08             	mov    0x8(%ecx),%ebx
  80e8fa:	80 79 0c 00          	cmpb   $0x0,0xc(%ecx)
  80e8fe:	74 09                	je     80e909 <do_getaddr+0xa9>
  80e900:	8b 42 08             	mov    0x8(%edx),%eax
  80e903:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  80e907:	eb 07                	jmp    80e910 <do_getaddr+0xb0>
  80e909:	8b 42 08             	mov    0x8(%edx),%eax
  80e90c:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
  80e910:	66 89 03             	mov    %ax,(%ebx)
  80e913:	eb 04                	jmp    80e919 <do_getaddr+0xb9>
      break;
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80e915:	c6 42 0c f8          	movb   $0xf8,0xc(%edx)
  }
  TCPIP_APIMSG_ACK(msg);
  80e919:	8b 01                	mov    (%ecx),%eax
  80e91b:	8b 40 10             	mov    0x10(%eax),%eax
  80e91e:	89 04 24             	mov    %eax,(%esp)
  80e921:	e8 94 ee ff ff       	call   80d7ba <sys_sem_signal>
}
  80e926:	83 c4 04             	add    $0x4,%esp
  80e929:	5b                   	pop    %ebx
  80e92a:	5d                   	pop    %ebp
  80e92b:	c3                   	ret    

0080e92c <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80e92c:	55                   	push   %ebp
  80e92d:	89 e5                	mov    %esp,%ebp
  80e92f:	53                   	push   %ebx
  80e930:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80e933:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80e936:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e93a:	89 1c 24             	mov    %ebx,(%esp)
  80e93d:	e8 b7 9a ff ff       	call   8083f9 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80e942:	c7 44 24 04 bb f1 80 	movl   $0x80f1bb,0x4(%esp)
  80e949:	00 
  80e94a:	89 1c 24             	mov    %ebx,(%esp)
  80e94d:	e8 b5 9a ff ff       	call   808407 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80e952:	c7 44 24 04 c6 ee 80 	movl   $0x80eec6,0x4(%esp)
  80e959:	00 
  80e95a:	89 1c 24             	mov    %ebx,(%esp)
  80e95d:	e8 b6 9a ff ff       	call   808418 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80e962:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80e969:	00 
  80e96a:	c7 44 24 04 6f ef 80 	movl   $0x80ef6f,0x4(%esp)
  80e971:	00 
  80e972:	89 1c 24             	mov    %ebx,(%esp)
  80e975:	e8 ce 9a ff ff       	call   808448 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80e97a:	c7 44 24 04 0e ec 80 	movl   $0x80ec0e,0x4(%esp)
  80e981:	00 
  80e982:	89 1c 24             	mov    %ebx,(%esp)
  80e985:	e8 9f 9a ff ff       	call   808429 <tcp_err>
}
  80e98a:	83 c4 14             	add    $0x14,%esp
  80e98d:	5b                   	pop    %ebx
  80e98e:	5d                   	pop    %ebp
  80e98f:	c3                   	ret    

0080e990 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80e990:	55                   	push   %ebp
  80e991:	89 e5                	mov    %esp,%ebp
  80e993:	53                   	push   %ebx
  80e994:	83 ec 04             	sub    $0x4,%esp
  80e997:	8b 55 08             	mov    0x8(%ebp),%edx
  80e99a:	0f b6 4d 10          	movzbl 0x10(%ebp),%ecx

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80e99e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80e9a3:	85 d2                	test   %edx,%edx
  80e9a5:	74 2c                	je     80e9d3 <do_connected+0x43>
{
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  80e9a7:	89 d3                	mov    %edx,%ebx

  if (conn == NULL) {
    return ERR_VAL;
  }

  conn->err = err;
  80e9a9:	88 4a 0c             	mov    %cl,0xc(%edx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80e9ac:	83 3a 10             	cmpl   $0x10,(%edx)
  80e9af:	75 0b                	jne    80e9bc <do_connected+0x2c>
  80e9b1:	84 c9                	test   %cl,%cl
  80e9b3:	75 07                	jne    80e9bc <do_connected+0x2c>
    setup_tcp(conn);
  80e9b5:	89 d0                	mov    %edx,%eax
  80e9b7:	e8 70 ff ff ff       	call   80e92c <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80e9bc:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80e9c3:	8b 43 10             	mov    0x10(%ebx),%eax
  80e9c6:	89 04 24             	mov    %eax,(%esp)
  80e9c9:	e8 ec ed ff ff       	call   80d7ba <sys_sem_signal>
  80e9ce:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  80e9d3:	83 c4 04             	add    $0x4,%esp
  80e9d6:	5b                   	pop    %ebx
  80e9d7:	5d                   	pop    %ebp
  80e9d8:	c3                   	ret    

0080e9d9 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80e9d9:	55                   	push   %ebp
  80e9da:	89 e5                	mov    %esp,%ebp
  80e9dc:	53                   	push   %ebx
  80e9dd:	83 ec 14             	sub    $0x14,%esp
  80e9e0:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80e9e2:	85 c0                	test   %eax,%eax
  80e9e4:	75 1c                	jne    80ea02 <do_close_internal+0x29>
  80e9e6:	c7 44 24 08 15 45 81 	movl   $0x814515,0x8(%esp)
  80e9ed:	00 
  80e9ee:	c7 44 24 04 53 02 00 	movl   $0x253,0x4(%esp)
  80e9f5:	00 
  80e9f6:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80e9fd:	e8 aa 1e ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80ea02:	83 38 10             	cmpl   $0x10,(%eax)
  80ea05:	74 1c                	je     80ea23 <do_close_internal+0x4a>
  80ea07:	c7 44 24 08 00 47 81 	movl   $0x814700,0x8(%esp)
  80ea0e:	00 
  80ea0f:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
  80ea16:	00 
  80ea17:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80ea1e:	e8 89 1e ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80ea23:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80ea27:	74 1c                	je     80ea45 <do_close_internal+0x6c>
  80ea29:	c7 44 24 08 cc 47 81 	movl   $0x8147cc,0x8(%esp)
  80ea30:	00 
  80ea31:	c7 44 24 04 55 02 00 	movl   $0x255,0x4(%esp)
  80ea38:	00 
  80ea39:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80ea40:	e8 67 1e ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80ea45:	8b 40 08             	mov    0x8(%eax),%eax
  80ea48:	85 c0                	test   %eax,%eax
  80ea4a:	75 1c                	jne    80ea68 <do_close_internal+0x8f>
  80ea4c:	c7 44 24 08 1e 47 81 	movl   $0x81471e,0x8(%esp)
  80ea53:	00 
  80ea54:	c7 44 24 04 56 02 00 	movl   $0x256,0x4(%esp)
  80ea5b:	00 
  80ea5c:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80ea63:	e8 44 1e ff ff       	call   8008ac <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80ea68:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ea6f:	00 
  80ea70:	89 04 24             	mov    %eax,(%esp)
  80ea73:	e8 81 99 ff ff       	call   8083f9 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80ea78:	8b 43 08             	mov    0x8(%ebx),%eax
  80ea7b:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80ea7f:	75 12                	jne    80ea93 <do_close_internal+0xba>
    tcp_accept(conn->pcb.tcp, NULL);
  80ea81:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ea88:	00 
  80ea89:	89 04 24             	mov    %eax,(%esp)
  80ea8c:	e8 a9 99 ff ff       	call   80843a <tcp_accept>
  80ea91:	eb 64                	jmp    80eaf7 <do_close_internal+0x11e>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80ea93:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ea9a:	00 
  80ea9b:	89 04 24             	mov    %eax,(%esp)
  80ea9e:	e8 64 99 ff ff       	call   808407 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80eaa3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eaaa:	00 
  80eaab:	8b 43 08             	mov    0x8(%ebx),%eax
  80eaae:	89 04 24             	mov    %eax,(%esp)
  80eab1:	e8 84 99 ff ff       	call   80843a <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80eab6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eabd:	00 
  80eabe:	8b 43 08             	mov    0x8(%ebx),%eax
  80eac1:	89 04 24             	mov    %eax,(%esp)
  80eac4:	e8 4f 99 ff ff       	call   808418 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80eac9:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ead0:	00 
  80ead1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ead8:	00 
  80ead9:	8b 43 08             	mov    0x8(%ebx),%eax
  80eadc:	89 04 24             	mov    %eax,(%esp)
  80eadf:	e8 64 99 ff ff       	call   808448 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80eae4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eaeb:	00 
  80eaec:	8b 43 08             	mov    0x8(%ebx),%eax
  80eaef:	89 04 24             	mov    %eax,(%esp)
  80eaf2:	e8 32 99 ff ff       	call   808429 <tcp_err>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80eaf7:	8b 43 08             	mov    0x8(%ebx),%eax
  80eafa:	89 04 24             	mov    %eax,(%esp)
  80eafd:	e8 fd a7 ff ff       	call   8092ff <tcp_close>
  if (err == ERR_OK) {
  80eb02:	84 c0                	test   %al,%al
  80eb04:	75 57                	jne    80eb5d <do_close_internal+0x184>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80eb06:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80eb0d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80eb14:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80eb18:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80eb1b:	85 c0                	test   %eax,%eax
  80eb1d:	74 31                	je     80eb50 <do_close_internal+0x177>
  80eb1f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80eb26:	00 
  80eb27:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eb2e:	00 
  80eb2f:	89 1c 24             	mov    %ebx,(%esp)
  80eb32:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80eb34:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80eb37:	85 c0                	test   %eax,%eax
  80eb39:	74 15                	je     80eb50 <do_close_internal+0x177>
  80eb3b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80eb42:	00 
  80eb43:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80eb4a:	00 
  80eb4b:	89 1c 24             	mov    %ebx,(%esp)
  80eb4e:	ff d0                	call   *%eax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80eb50:	8b 43 10             	mov    0x10(%ebx),%eax
  80eb53:	89 04 24             	mov    %eax,(%esp)
  80eb56:	e8 5f ec ff ff       	call   80d7ba <sys_sem_signal>
  80eb5b:	eb 72                	jmp    80ebcf <do_close_internal+0x1f6>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80eb5d:	8b 43 08             	mov    0x8(%ebx),%eax
  80eb60:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80eb64:	75 1c                	jne    80eb82 <do_close_internal+0x1a9>
  80eb66:	c7 44 24 08 f0 47 81 	movl   $0x8147f0,0x8(%esp)
  80eb6d:	00 
  80eb6e:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80eb75:	00 
  80eb76:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80eb7d:	e8 2a 1d ff ff       	call   8008ac <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80eb82:	c7 44 24 04 c6 ee 80 	movl   $0x80eec6,0x4(%esp)
  80eb89:	00 
  80eb8a:	89 04 24             	mov    %eax,(%esp)
  80eb8d:	e8 86 98 ff ff       	call   808418 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80eb92:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80eb99:	00 
  80eb9a:	c7 44 24 04 6f ef 80 	movl   $0x80ef6f,0x4(%esp)
  80eba1:	00 
  80eba2:	8b 43 08             	mov    0x8(%ebx),%eax
  80eba5:	89 04 24             	mov    %eax,(%esp)
  80eba8:	e8 9b 98 ff ff       	call   808448 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80ebad:	c7 44 24 04 0e ec 80 	movl   $0x80ec0e,0x4(%esp)
  80ebb4:	00 
  80ebb5:	8b 43 08             	mov    0x8(%ebx),%eax
  80ebb8:	89 04 24             	mov    %eax,(%esp)
  80ebbb:	e8 69 98 ff ff       	call   808429 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80ebc0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ebc4:	8b 43 08             	mov    0x8(%ebx),%eax
  80ebc7:	89 04 24             	mov    %eax,(%esp)
  80ebca:	e8 2a 98 ff ff       	call   8083f9 <tcp_arg>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80ebcf:	83 c4 14             	add    $0x14,%esp
  80ebd2:	5b                   	pop    %ebx
  80ebd3:	5d                   	pop    %ebp
  80ebd4:	c3                   	ret    

0080ebd5 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80ebd5:	55                   	push   %ebp
  80ebd6:	89 e5                	mov    %esp,%ebp
  80ebd8:	83 ec 08             	sub    $0x8,%esp
  80ebdb:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80ebde:	8b 10                	mov    (%eax),%edx
  80ebe0:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  80ebe4:	74 15                	je     80ebfb <do_close+0x26>
  80ebe6:	83 3a 10             	cmpl   $0x10,(%edx)
  80ebe9:	75 10                	jne    80ebfb <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80ebeb:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80ebf2:	8b 00                	mov    (%eax),%eax
  80ebf4:	e8 e0 fd ff ff       	call   80e9d9 <do_close_internal>
  80ebf9:	eb 11                	jmp    80ec0c <do_close+0x37>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80ebfb:	c6 42 0c f7          	movb   $0xf7,0xc(%edx)
    TCPIP_APIMSG_ACK(msg);
  80ebff:	8b 00                	mov    (%eax),%eax
  80ec01:	8b 40 10             	mov    0x10(%eax),%eax
  80ec04:	89 04 24             	mov    %eax,(%esp)
  80ec07:	e8 ae eb ff ff       	call   80d7ba <sys_sem_signal>
  }
}
  80ec0c:	c9                   	leave  
  80ec0d:	c3                   	ret    

0080ec0e <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80ec0e:	55                   	push   %ebp
  80ec0f:	89 e5                	mov    %esp,%ebp
  80ec11:	53                   	push   %ebx
  80ec12:	83 ec 14             	sub    $0x14,%esp
  80ec15:	8b 55 08             	mov    0x8(%ebp),%edx
  80ec18:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80ec1c:	85 d2                	test   %edx,%edx
  80ec1e:	75 1c                	jne    80ec3c <err_tcp+0x2e>
  80ec20:	c7 44 24 08 31 47 81 	movl   $0x814731,0x8(%esp)
  80ec27:	00 
  80ec28:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
  80ec2f:	00 
  80ec30:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80ec37:	e8 70 1c ff ff       	call   8008ac <_panic>
static void
err_tcp(void *arg, err_t err)
{
  struct netconn *conn;

  conn = arg;
  80ec3c:	89 d3                	mov    %edx,%ebx
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  conn->pcb.tcp = NULL;
  80ec3e:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)

  conn->err = err;
  80ec45:	88 42 0c             	mov    %al,0xc(%edx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80ec48:	83 7a 14 ff          	cmpl   $0xffffffff,0x14(%edx)
  80ec4c:	74 2f                	je     80ec7d <err_tcp+0x6f>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80ec4e:	8b 42 2c             	mov    0x2c(%edx),%eax
  80ec51:	85 c0                	test   %eax,%eax
  80ec53:	74 15                	je     80ec6a <err_tcp+0x5c>
  80ec55:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ec5c:	00 
  80ec5d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ec64:	00 
  80ec65:	89 14 24             	mov    %edx,(%esp)
  80ec68:	ff d0                	call   *%eax
    sys_mbox_post(conn->recvmbox, NULL);
  80ec6a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ec71:	00 
  80ec72:	8b 43 14             	mov    0x14(%ebx),%eax
  80ec75:	89 04 24             	mov    %eax,(%esp)
  80ec78:	e8 8e ed ff ff       	call   80da0b <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80ec7d:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  80ec81:	74 18                	je     80ec9b <err_tcp+0x8d>
  80ec83:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80ec87:	75 12                	jne    80ec9b <err_tcp+0x8d>
    conn->state = NETCONN_NONE;
  80ec89:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80ec90:	8b 43 10             	mov    0x10(%ebx),%eax
  80ec93:	89 04 24             	mov    %eax,(%esp)
  80ec96:	e8 1f eb ff ff       	call   80d7ba <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80ec9b:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80ec9f:	74 2f                	je     80ecd0 <err_tcp+0xc2>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80eca1:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80eca4:	85 c0                	test   %eax,%eax
  80eca6:	74 15                	je     80ecbd <err_tcp+0xaf>
  80eca8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ecaf:	00 
  80ecb0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ecb7:	00 
  80ecb8:	89 1c 24             	mov    %ebx,(%esp)
  80ecbb:	ff d0                	call   *%eax
    sys_mbox_post(conn->acceptmbox, NULL);
  80ecbd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ecc4:	00 
  80ecc5:	8b 43 18             	mov    0x18(%ebx),%eax
  80ecc8:	89 04 24             	mov    %eax,(%esp)
  80eccb:	e8 3b ed ff ff       	call   80da0b <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80ecd0:	8b 43 04             	mov    0x4(%ebx),%eax
  80ecd3:	83 f8 01             	cmp    $0x1,%eax
  80ecd6:	74 05                	je     80ecdd <err_tcp+0xcf>
  80ecd8:	83 f8 04             	cmp    $0x4,%eax
  80ecdb:	75 12                	jne    80ecef <err_tcp+0xe1>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80ecdd:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80ece4:	8b 43 10             	mov    0x10(%ebx),%eax
  80ece7:	89 04 24             	mov    %eax,(%esp)
  80ecea:	e8 cb ea ff ff       	call   80d7ba <sys_sem_signal>
  }
}
  80ecef:	83 c4 14             	add    $0x14,%esp
  80ecf2:	5b                   	pop    %ebx
  80ecf3:	5d                   	pop    %ebp
  80ecf4:	c3                   	ret    

0080ecf5 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80ecf5:	55                   	push   %ebp
  80ecf6:	89 e5                	mov    %esp,%ebp
  80ecf8:	57                   	push   %edi
  80ecf9:	56                   	push   %esi
  80ecfa:	53                   	push   %ebx
  80ecfb:	83 ec 2c             	sub    $0x2c,%esp
  80ecfe:	89 c3                	mov    %eax,%ebx
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80ed00:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80ed04:	74 1c                	je     80ed22 <do_writemore+0x2d>
  80ed06:	c7 44 24 08 3e 47 81 	movl   $0x81473e,0x8(%esp)
  80ed0d:	00 
  80ed0e:	c7 44 24 04 b8 03 00 	movl   $0x3b8,0x4(%esp)
  80ed15:	00 
  80ed16:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80ed1d:	e8 8a 1b ff ff       	call   8008ac <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80ed22:	8b 70 24             	mov    0x24(%eax),%esi
  80ed25:	8b 46 04             	mov    0x4(%esi),%eax
  80ed28:	89 45 e8             	mov    %eax,-0x18(%ebp)
  80ed2b:	8b 7b 28             	mov    0x28(%ebx),%edi
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80ed2e:	8b 46 08             	mov    0x8(%esi),%eax
  80ed31:	89 c2                	mov    %eax,%edx
  80ed33:	29 fa                	sub    %edi,%edx
  80ed35:	66 29 f8             	sub    %di,%ax
  80ed38:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  80ed3c:	81 fa 00 00 01 00    	cmp    $0x10000,%edx
  80ed42:	0f 9c c2             	setl   %dl
  80ed45:	0f b6 d2             	movzbl %dl,%edx
  80ed48:	83 ea 01             	sub    $0x1,%edx
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80ed4b:	8b 4b 08             	mov    0x8(%ebx),%ecx
  80ed4e:	89 4d ec             	mov    %ecx,-0x14(%ebp)
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80ed51:	0f b7 49 6e          	movzwl 0x6e(%ecx),%ecx
  80ed55:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80ed59:	09 d0                	or     %edx,%eax
  80ed5b:	66 39 c8             	cmp    %cx,%ax
  80ed5e:	76 02                	jbe    80ed62 <do_writemore+0x6d>
  80ed60:	89 c8                	mov    %ecx,%eax
  80ed62:	0f b7 c0             	movzwl %ax,%eax
  80ed65:	89 45 f0             	mov    %eax,-0x10(%ebp)
  80ed68:	0f b6 46 0c          	movzbl 0xc(%esi),%eax
  80ed6c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ed70:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80ed73:	89 54 24 08          	mov    %edx,0x8(%esp)
  80ed77:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80ed7a:	01 f8                	add    %edi,%eax
  80ed7c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ed80:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  80ed83:	89 0c 24             	mov    %ecx,(%esp)
  80ed86:	e8 f5 cd ff ff       	call   80bb80 <tcp_write>
  80ed8b:	89 c1                	mov    %eax,%ecx
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80ed8d:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80ed90:	03 53 28             	add    0x28(%ebx),%edx
  80ed93:	8b 43 24             	mov    0x24(%ebx),%eax
  80ed96:	3b 50 08             	cmp    0x8(%eax),%edx
  80ed99:	7e 1c                	jle    80edb7 <do_writemore+0xc2>
  80ed9b:	c7 44 24 08 5b 47 81 	movl   $0x81475b,0x8(%esp)
  80eda2:	00 
  80eda3:	c7 44 24 04 cd 03 00 	movl   $0x3cd,0x4(%esp)
  80edaa:	00 
  80edab:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80edb2:	e8 f5 1a ff ff       	call   8008ac <_panic>
  if (err == ERR_OK) {
  80edb7:	84 c9                	test   %cl,%cl
  80edb9:	75 75                	jne    80ee30 <do_writemore+0x13b>
    conn->write_offset += len;
  80edbb:	89 53 28             	mov    %edx,0x28(%ebx)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80edbe:	8b 43 24             	mov    0x24(%ebx),%eax
  80edc1:	be 00 00 00 00       	mov    $0x0,%esi
  80edc6:	3b 50 08             	cmp    0x8(%eax),%edx
  80edc9:	75 13                	jne    80edde <do_writemore+0xe9>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80edcb:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80edd2:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  80edd9:	be 01 00 00 00       	mov    $0x1,%esi
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80edde:	8b 43 08             	mov    0x8(%ebx),%eax
  80ede1:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80ede5:	74 12                	je     80edf9 <do_writemore+0x104>
  80ede7:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80edeb:	75 0c                	jne    80edf9 <do_writemore+0x104>
  80eded:	8b 50 74             	mov    0x74(%eax),%edx
  80edf0:	85 d2                	test   %edx,%edx
  80edf2:	74 72                	je     80ee66 <do_writemore+0x171>
  80edf4:	83 3a 00             	cmpl   $0x0,(%edx)
  80edf7:	74 6d                	je     80ee66 <do_writemore+0x171>
  80edf9:	89 04 24             	mov    %eax,(%esp)
  80edfc:	e8 38 c1 ff ff       	call   80af39 <tcp_output>
    conn->err = err;
  80ee01:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80ee04:	84 c0                	test   %al,%al
  80ee06:	75 44                	jne    80ee4c <do_writemore+0x157>
  80ee08:	8b 43 08             	mov    0x8(%ebx),%eax
  80ee0b:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80ee11:	77 39                	ja     80ee4c <do_writemore+0x157>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80ee13:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ee16:	85 c0                	test   %eax,%eax
  80ee18:	74 32                	je     80ee4c <do_writemore+0x157>
  80ee1a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80ee1d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80ee21:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80ee28:	00 
  80ee29:	89 1c 24             	mov    %ebx,(%esp)
  80ee2c:	ff d0                	call   *%eax
  80ee2e:	eb 1c                	jmp    80ee4c <do_writemore+0x157>
    }
  } else if (err == ERR_MEM) {
  80ee30:	80 f9 ff             	cmp    $0xff,%cl
  80ee33:	75 12                	jne    80ee47 <do_writemore+0x152>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80ee35:	8b 43 08             	mov    0x8(%ebx),%eax
  80ee38:	89 04 24             	mov    %eax,(%esp)
  80ee3b:	90                   	nop    
  80ee3c:	8d 74 26 00          	lea    0x0(%esi),%esi
  80ee40:	e8 f4 c0 ff ff       	call   80af39 <tcp_output>
  80ee45:	eb 25                	jmp    80ee6c <do_writemore+0x177>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80ee47:	88 4b 0c             	mov    %cl,0xc(%ebx)
  80ee4a:	eb 06                	jmp    80ee52 <do_writemore+0x15d>
    write_finished = 1;
  }

  if (write_finished) {
  80ee4c:	89 f1                	mov    %esi,%ecx
  80ee4e:	84 c9                	test   %cl,%cl
  80ee50:	74 1a                	je     80ee6c <do_writemore+0x177>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80ee52:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80ee59:	8b 43 10             	mov    0x10(%ebx),%eax
  80ee5c:	89 04 24             	mov    %eax,(%esp)
  80ee5f:	e8 56 e9 ff ff       	call   80d7ba <sys_sem_signal>
  80ee64:	eb 06                	jmp    80ee6c <do_writemore+0x177>
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80ee66:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80ee6a:	eb 9c                	jmp    80ee08 <do_writemore+0x113>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80ee6c:	b8 00 00 00 00       	mov    $0x0,%eax
  80ee71:	83 c4 2c             	add    $0x2c,%esp
  80ee74:	5b                   	pop    %ebx
  80ee75:	5e                   	pop    %esi
  80ee76:	5f                   	pop    %edi
  80ee77:	5d                   	pop    %ebp
  80ee78:	c3                   	ret    

0080ee79 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80ee79:	55                   	push   %ebp
  80ee7a:	89 e5                	mov    %esp,%ebp
  80ee7c:	83 ec 08             	sub    $0x8,%esp
  80ee7f:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80ee82:	8b 02                	mov    (%edx),%eax
  80ee84:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80ee88:	7c 2d                	jl     80eeb7 <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80ee8a:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80ee8e:	74 23                	je     80eeb3 <do_write+0x3a>
  80ee90:	83 38 10             	cmpl   $0x10,(%eax)
  80ee93:	75 1e                	jne    80eeb3 <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80ee95:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80ee9c:	8b 02                	mov    (%edx),%eax
  80ee9e:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80eea1:	8b 02                	mov    (%edx),%eax
  80eea3:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80eeaa:	8b 02                	mov    (%edx),%eax
  80eeac:	e8 44 fe ff ff       	call   80ecf5 <do_writemore>
  80eeb1:	eb 11                	jmp    80eec4 <do_write+0x4b>
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80eeb3:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80eeb7:	8b 02                	mov    (%edx),%eax
  80eeb9:	8b 40 10             	mov    0x10(%eax),%eax
  80eebc:	89 04 24             	mov    %eax,(%esp)
  80eebf:	e8 f6 e8 ff ff       	call   80d7ba <sys_sem_signal>
}
  80eec4:	c9                   	leave  
  80eec5:	c3                   	ret    

0080eec6 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80eec6:	55                   	push   %ebp
  80eec7:	89 e5                	mov    %esp,%ebp
  80eec9:	56                   	push   %esi
  80eeca:	53                   	push   %ebx
  80eecb:	83 ec 10             	sub    $0x10,%esp
  80eece:	8b 45 08             	mov    0x8(%ebp),%eax
  80eed1:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80eed5:	85 c0                	test   %eax,%eax
  80eed7:	75 1c                	jne    80eef5 <sent_tcp+0x2f>
  80eed9:	c7 44 24 08 31 47 81 	movl   $0x814731,0x8(%esp)
  80eee0:	00 
  80eee1:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  80eee8:	00 
  80eee9:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80eef0:	e8 b7 19 ff ff       	call   8008ac <_panic>
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  struct netconn *conn = arg;
  80eef5:	89 c3                	mov    %eax,%ebx

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
  80eef7:	8b 40 04             	mov    0x4(%eax),%eax
  80eefa:	83 f8 01             	cmp    $0x1,%eax
  80eefd:	75 2b                	jne    80ef2a <sent_tcp+0x64>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80eeff:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80ef03:	75 1c                	jne    80ef21 <sent_tcp+0x5b>
  80ef05:	c7 44 24 08 79 47 81 	movl   $0x814779,0x8(%esp)
  80ef0c:	00 
  80ef0d:	c7 44 24 04 06 01 00 	movl   $0x106,0x4(%esp)
  80ef14:	00 
  80ef15:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80ef1c:	e8 8b 19 ff ff       	call   8008ac <_panic>
    do_writemore(conn);
  80ef21:	89 d8                	mov    %ebx,%eax
  80ef23:	e8 cd fd ff ff       	call   80ecf5 <do_writemore>
  80ef28:	eb 0f                	jmp    80ef39 <sent_tcp+0x73>
  } else if (conn->state == NETCONN_CLOSE) {
  80ef2a:	83 f8 04             	cmp    $0x4,%eax
  80ef2d:	8d 76 00             	lea    0x0(%esi),%esi
  80ef30:	75 07                	jne    80ef39 <sent_tcp+0x73>
    do_close_internal(conn);
  80ef32:	89 d8                	mov    %ebx,%eax
  80ef34:	e8 a0 fa ff ff       	call   80e9d9 <do_close_internal>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80ef39:	8b 43 08             	mov    0x8(%ebx),%eax
  80ef3c:	85 c0                	test   %eax,%eax
  80ef3e:	74 23                	je     80ef63 <sent_tcp+0x9d>
  80ef40:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80ef46:	76 1b                	jbe    80ef63 <sent_tcp+0x9d>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80ef48:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80ef4b:	85 d2                	test   %edx,%edx
  80ef4d:	74 14                	je     80ef63 <sent_tcp+0x9d>
  80ef4f:	0f b7 c6             	movzwl %si,%eax
  80ef52:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ef56:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80ef5d:	00 
  80ef5e:	89 1c 24             	mov    %ebx,(%esp)
  80ef61:	ff d2                	call   *%edx
    }
  }
  
  return ERR_OK;
}
  80ef63:	b8 00 00 00 00       	mov    $0x0,%eax
  80ef68:	83 c4 10             	add    $0x10,%esp
  80ef6b:	5b                   	pop    %ebx
  80ef6c:	5e                   	pop    %esi
  80ef6d:	5d                   	pop    %ebp
  80ef6e:	c3                   	ret    

0080ef6f <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80ef6f:	55                   	push   %ebp
  80ef70:	89 e5                	mov    %esp,%ebp
  80ef72:	83 ec 18             	sub    $0x18,%esp
  80ef75:	8b 45 08             	mov    0x8(%ebp),%eax
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80ef78:	85 c0                	test   %eax,%eax
  80ef7a:	75 1c                	jne    80ef98 <poll_tcp+0x29>
  80ef7c:	c7 44 24 08 31 47 81 	movl   $0x814731,0x8(%esp)
  80ef83:	00 
  80ef84:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  80ef8b:	00 
  80ef8c:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80ef93:	e8 14 19 ff ff       	call   8008ac <_panic>

  if (conn->state == NETCONN_WRITE) {
  80ef98:	8b 50 04             	mov    0x4(%eax),%edx
  80ef9b:	83 fa 01             	cmp    $0x1,%edx
  80ef9e:	75 07                	jne    80efa7 <poll_tcp+0x38>
    do_writemore(conn);
  80efa0:	e8 50 fd ff ff       	call   80ecf5 <do_writemore>
  80efa5:	eb 10                	jmp    80efb7 <poll_tcp+0x48>
  } else if (conn->state == NETCONN_CLOSE) {
  80efa7:	83 fa 04             	cmp    $0x4,%edx
  80efaa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80efb0:	75 05                	jne    80efb7 <poll_tcp+0x48>
    do_close_internal(conn);
  80efb2:	e8 22 fa ff ff       	call   80e9d9 <do_close_internal>
  }

  return ERR_OK;
}
  80efb7:	b8 00 00 00 00       	mov    $0x0,%eax
  80efbc:	c9                   	leave  
  80efbd:	8d 76 00             	lea    0x0(%esi),%esi
  80efc0:	c3                   	ret    

0080efc1 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80efc1:	55                   	push   %ebp
  80efc2:	89 e5                	mov    %esp,%ebp
  80efc4:	53                   	push   %ebx
  80efc5:	83 ec 14             	sub    $0x14,%esp
  80efc8:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80efcb:	8b 03                	mov    (%ebx),%eax
  80efcd:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80efd1:	7c 1c                	jl     80efef <do_recv+0x2e>
    if (msg->conn->pcb.tcp != NULL) {
  80efd3:	8b 50 08             	mov    0x8(%eax),%edx
  80efd6:	85 d2                	test   %edx,%edx
  80efd8:	74 15                	je     80efef <do_recv+0x2e>
      if (msg->conn->type == NETCONN_TCP) {
  80efda:	83 38 10             	cmpl   $0x10,(%eax)
  80efdd:	75 10                	jne    80efef <do_recv+0x2e>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80efdf:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80efe3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80efe7:	89 14 24             	mov    %edx,(%esp)
  80efea:	e8 bb 94 ff ff       	call   8084aa <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80efef:	8b 03                	mov    (%ebx),%eax
  80eff1:	8b 40 10             	mov    0x10(%eax),%eax
  80eff4:	89 04 24             	mov    %eax,(%esp)
  80eff7:	e8 be e7 ff ff       	call   80d7ba <sys_sem_signal>
}
  80effc:	83 c4 14             	add    $0x14,%esp
  80efff:	5b                   	pop    %ebx
  80f000:	5d                   	pop    %ebp
  80f001:	c3                   	ret    

0080f002 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80f002:	55                   	push   %ebp
  80f003:	89 e5                	mov    %esp,%ebp
  80f005:	83 ec 18             	sub    $0x18,%esp
  80f008:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f00b:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f00e:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f011:	8b 1e                	mov    (%esi),%ebx
  80f013:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80f017:	0f 8c 95 00 00 00    	jl     80f0b2 <do_send+0xb0>
    if (msg->conn->pcb.tcp != NULL) {
  80f01d:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80f021:	0f 84 8b 00 00 00    	je     80f0b2 <do_send+0xb0>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f027:	8b 03                	mov    (%ebx),%eax
  80f029:	25 f0 00 00 00       	and    $0xf0,%eax
  80f02e:	83 f8 20             	cmp    $0x20,%eax
  80f031:	74 3f                	je     80f072 <do_send+0x70>
  80f033:	83 f8 40             	cmp    $0x40,%eax
  80f036:	75 7a                	jne    80f0b2 <do_send+0xb0>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80f038:	8b 46 04             	mov    0x4(%esi),%eax
  80f03b:	8b 50 08             	mov    0x8(%eax),%edx
  80f03e:	85 d2                	test   %edx,%edx
  80f040:	75 16                	jne    80f058 <do_send+0x56>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80f042:	8b 00                	mov    (%eax),%eax
  80f044:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f048:	8b 43 08             	mov    0x8(%ebx),%eax
  80f04b:	89 04 24             	mov    %eax,(%esp)
  80f04e:	e8 2f 27 00 00       	call   811782 <raw_send>
  80f053:	88 43 0c             	mov    %al,0xc(%ebx)
  80f056:	eb 5a                	jmp    80f0b2 <do_send+0xb0>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80f058:	89 54 24 08          	mov    %edx,0x8(%esp)
  80f05c:	8b 00                	mov    (%eax),%eax
  80f05e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f062:	8b 43 08             	mov    0x8(%ebx),%eax
  80f065:	89 04 24             	mov    %eax,(%esp)
  80f068:	e8 0a 26 00 00       	call   811677 <raw_sendto>
  80f06d:	88 43 0c             	mov    %al,0xc(%ebx)
  80f070:	eb 40                	jmp    80f0b2 <do_send+0xb0>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80f072:	8b 56 04             	mov    0x4(%esi),%edx
  80f075:	8b 4a 08             	mov    0x8(%edx),%ecx
  80f078:	85 c9                	test   %ecx,%ecx
  80f07a:	75 16                	jne    80f092 <do_send+0x90>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80f07c:	8b 02                	mov    (%edx),%eax
  80f07e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f082:	8b 43 08             	mov    0x8(%ebx),%eax
  80f085:	89 04 24             	mov    %eax,(%esp)
  80f088:	e8 dd cf ff ff       	call   80c06a <udp_send>
  80f08d:	88 43 0c             	mov    %al,0xc(%ebx)
  80f090:	eb 20                	jmp    80f0b2 <do_send+0xb0>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80f092:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80f096:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f09a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f09e:	8b 02                	mov    (%edx),%eax
  80f0a0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f0a4:	8b 43 08             	mov    0x8(%ebx),%eax
  80f0a7:	89 04 24             	mov    %eax,(%esp)
  80f0aa:	e8 67 cf ff ff       	call   80c016 <udp_sendto>
  80f0af:	88 43 0c             	mov    %al,0xc(%ebx)
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f0b2:	8b 06                	mov    (%esi),%eax
  80f0b4:	8b 40 10             	mov    0x10(%eax),%eax
  80f0b7:	89 04 24             	mov    %eax,(%esp)
  80f0ba:	e8 fb e6 ff ff       	call   80d7ba <sys_sem_signal>
}
  80f0bf:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f0c2:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f0c5:	89 ec                	mov    %ebp,%esp
  80f0c7:	5d                   	pop    %ebp
  80f0c8:	c3                   	ret    

0080f0c9 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80f0c9:	55                   	push   %ebp
  80f0ca:	89 e5                	mov    %esp,%ebp
  80f0cc:	83 ec 18             	sub    $0x18,%esp
  80f0cf:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f0d2:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f0d5:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f0d8:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f0db:	8b 03                	mov    (%ebx),%eax
  80f0dd:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80f0e1:	0f 8c ba 00 00 00    	jl     80f1a1 <do_listen+0xd8>
    if (msg->conn->pcb.tcp != NULL) {
  80f0e7:	8b 50 08             	mov    0x8(%eax),%edx
  80f0ea:	85 d2                	test   %edx,%edx
  80f0ec:	0f 84 af 00 00 00    	je     80f1a1 <do_listen+0xd8>
      if (msg->conn->type == NETCONN_TCP) {
  80f0f2:	83 38 10             	cmpl   $0x10,(%eax)
  80f0f5:	0f 85 a6 00 00 00    	jne    80f1a1 <do_listen+0xd8>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80f0fb:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80f0ff:	90                   	nop    
  80f100:	0f 85 97 00 00 00    	jne    80f19d <do_listen+0xd4>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80f106:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80f10d:	00 
  80f10e:	89 14 24             	mov    %edx,(%esp)
  80f111:	e8 de 96 ff ff       	call   8087f4 <tcp_listen_with_backlog>
  80f116:	89 c7                	mov    %eax,%edi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80f118:	85 c0                	test   %eax,%eax
  80f11a:	75 08                	jne    80f124 <do_listen+0x5b>
            msg->conn->err = ERR_MEM;
  80f11c:	8b 03                	mov    (%ebx),%eax
  80f11e:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80f122:	eb 7d                	jmp    80f1a1 <do_listen+0xd8>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80f124:	8b 03                	mov    (%ebx),%eax
  80f126:	8b 40 14             	mov    0x14(%eax),%eax
  80f129:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f12c:	74 11                	je     80f13f <do_listen+0x76>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80f12e:	89 04 24             	mov    %eax,(%esp)
  80f131:	e8 c3 e0 ff ff       	call   80d1f9 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80f136:	8b 03                	mov    (%ebx),%eax
  80f138:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80f13f:	8b 33                	mov    (%ebx),%esi
  80f141:	83 7e 18 ff          	cmpl   $0xffffffff,0x18(%esi)
  80f145:	75 1a                	jne    80f161 <do_listen+0x98>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80f147:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f14e:	e8 50 e5 ff ff       	call   80d6a3 <sys_mbox_new>
  80f153:	89 46 18             	mov    %eax,0x18(%esi)
  80f156:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f159:	75 06                	jne    80f161 <do_listen+0x98>
                msg->conn->err = ERR_MEM;
  80f15b:	8b 03                	mov    (%ebx),%eax
  80f15d:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80f161:	8b 03                	mov    (%ebx),%eax
  80f163:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80f167:	75 38                	jne    80f1a1 <do_listen+0xd8>
              msg->conn->state = NETCONN_LISTEN;
  80f169:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80f170:	8b 03                	mov    (%ebx),%eax
  80f172:	89 78 08             	mov    %edi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80f175:	8b 03                	mov    (%ebx),%eax
  80f177:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f17b:	8b 40 08             	mov    0x8(%eax),%eax
  80f17e:	89 04 24             	mov    %eax,(%esp)
  80f181:	e8 73 92 ff ff       	call   8083f9 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80f186:	c7 44 24 04 9f f7 80 	movl   $0x80f79f,0x4(%esp)
  80f18d:	00 
  80f18e:	8b 03                	mov    (%ebx),%eax
  80f190:	8b 40 08             	mov    0x8(%eax),%eax
  80f193:	89 04 24             	mov    %eax,(%esp)
  80f196:	e8 9f 92 ff ff       	call   80843a <tcp_accept>
  80f19b:	eb 04                	jmp    80f1a1 <do_listen+0xd8>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80f19d:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80f1a1:	8b 03                	mov    (%ebx),%eax
  80f1a3:	8b 40 10             	mov    0x10(%eax),%eax
  80f1a6:	89 04 24             	mov    %eax,(%esp)
  80f1a9:	e8 0c e6 ff ff       	call   80d7ba <sys_sem_signal>
}
  80f1ae:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f1b1:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f1b4:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f1b7:	89 ec                	mov    %ebp,%esp
  80f1b9:	5d                   	pop    %ebp
  80f1ba:	c3                   	ret    

0080f1bb <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80f1bb:	55                   	push   %ebp
  80f1bc:	89 e5                	mov    %esp,%ebp
  80f1be:	56                   	push   %esi
  80f1bf:	53                   	push   %ebx
  80f1c0:	83 ec 10             	sub    $0x10,%esp
  80f1c3:	8b 55 08             	mov    0x8(%ebp),%edx
  80f1c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f1c9:	8b 75 10             	mov    0x10(%ebp),%esi
  80f1cc:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80f1d0:	85 c0                	test   %eax,%eax
  80f1d2:	75 1c                	jne    80f1f0 <recv_tcp+0x35>
  80f1d4:	c7 44 24 08 14 48 81 	movl   $0x814814,0x8(%esp)
  80f1db:	00 
  80f1dc:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
  80f1e3:	00 
  80f1e4:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80f1eb:	e8 bc 16 ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80f1f0:	85 d2                	test   %edx,%edx
  80f1f2:	75 1c                	jne    80f210 <recv_tcp+0x55>
  80f1f4:	c7 44 24 08 38 48 81 	movl   $0x814838,0x8(%esp)
  80f1fb:	00 
  80f1fc:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80f203:	00 
  80f204:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80f20b:	e8 9c 16 ff ff       	call   8008ac <_panic>
  conn = arg;
  80f210:	89 d3                	mov    %edx,%ebx
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80f212:	39 42 08             	cmp    %eax,0x8(%edx)
  80f215:	74 1c                	je     80f233 <recv_tcp+0x78>
  80f217:	c7 44 24 08 8f 47 81 	movl   $0x81478f,0x8(%esp)
  80f21e:	00 
  80f21f:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
  80f226:	00 
  80f227:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80f22e:	e8 79 16 ff ff       	call   8008ac <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80f233:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80f238:	83 7a 14 ff          	cmpl   $0xffffffff,0x14(%edx)
  80f23c:	74 44                	je     80f282 <recv_tcp+0xc7>
    return ERR_VAL;
  }

  conn->err = err;
  80f23e:	88 4a 0c             	mov    %cl,0xc(%edx)
  if (p != NULL) {
  80f241:	b8 00 00 00 00       	mov    $0x0,%eax
  80f246:	85 f6                	test   %esi,%esi
  80f248:	74 08                	je     80f252 <recv_tcp+0x97>
    len = p->tot_len;
  80f24a:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80f24e:	66 01 42 20          	add    %ax,0x20(%edx)
  } else {
    len = 0;
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80f252:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80f255:	85 d2                	test   %edx,%edx
  80f257:	74 14                	je     80f26d <recv_tcp+0xb2>
  80f259:	0f b7 c0             	movzwl %ax,%eax
  80f25c:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f260:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f267:	00 
  80f268:	89 1c 24             	mov    %ebx,(%esp)
  80f26b:	ff d2                	call   *%edx
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80f26d:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f271:	8b 43 14             	mov    0x14(%ebx),%eax
  80f274:	89 04 24             	mov    %eax,(%esp)
  80f277:	e8 c6 e6 ff ff       	call   80d942 <sys_mbox_trypost>
  80f27c:	3c 01                	cmp    $0x1,%al
  80f27e:	19 c0                	sbb    %eax,%eax
  80f280:	f7 d0                	not    %eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80f282:	83 c4 10             	add    $0x10,%esp
  80f285:	5b                   	pop    %ebx
  80f286:	5e                   	pop    %esi
  80f287:	5d                   	pop    %ebp
  80f288:	c3                   	ret    

0080f289 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80f289:	55                   	push   %ebp
  80f28a:	89 e5                	mov    %esp,%ebp
  80f28c:	53                   	push   %ebx
  80f28d:	83 ec 04             	sub    $0x4,%esp
  80f290:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80f293:	8b 13                	mov    (%ebx),%edx
  80f295:	8b 02                	mov    (%edx),%eax
  80f297:	25 f0 00 00 00       	and    $0xf0,%eax
  80f29c:	83 f8 20             	cmp    $0x20,%eax
  80f29f:	75 0b                	jne    80f2ac <do_disconnect+0x23>
    udp_disconnect(msg->conn->pcb.udp);
  80f2a1:	8b 42 08             	mov    0x8(%edx),%eax
  80f2a4:	89 04 24             	mov    %eax,(%esp)
  80f2a7:	e8 a4 c9 ff ff       	call   80bc50 <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80f2ac:	8b 03                	mov    (%ebx),%eax
  80f2ae:	8b 40 10             	mov    0x10(%eax),%eax
  80f2b1:	89 04 24             	mov    %eax,(%esp)
  80f2b4:	e8 01 e5 ff ff       	call   80d7ba <sys_sem_signal>
}
  80f2b9:	83 c4 04             	add    $0x4,%esp
  80f2bc:	5b                   	pop    %ebx
  80f2bd:	5d                   	pop    %ebp
  80f2be:	c3                   	ret    

0080f2bf <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80f2bf:	55                   	push   %ebp
  80f2c0:	89 e5                	mov    %esp,%ebp
  80f2c2:	83 ec 18             	sub    $0x18,%esp
  80f2c5:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f2c8:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f2cb:	8b 75 08             	mov    0x8(%ebp),%esi
  if (msg->conn->pcb.tcp == NULL) {
  80f2ce:	8b 1e                	mov    (%esi),%ebx
  80f2d0:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80f2d4:	75 10                	jne    80f2e6 <do_connect+0x27>
    sys_sem_signal(msg->conn->op_completed);
  80f2d6:	8b 43 10             	mov    0x10(%ebx),%eax
  80f2d9:	89 04 24             	mov    %eax,(%esp)
  80f2dc:	e8 d9 e4 ff ff       	call   80d7ba <sys_sem_signal>
  80f2e1:	e9 a1 00 00 00       	jmp    80f387 <do_connect+0xc8>
    return;
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f2e6:	8b 03                	mov    (%ebx),%eax
  80f2e8:	25 f0 00 00 00       	and    $0xf0,%eax
  80f2ed:	83 f8 20             	cmp    $0x20,%eax
  80f2f0:	74 34                	je     80f326 <do_connect+0x67>
  80f2f2:	83 f8 40             	cmp    $0x40,%eax
  80f2f5:	74 0b                	je     80f302 <do_connect+0x43>
  80f2f7:	83 f8 10             	cmp    $0x10,%eax
  80f2fa:	0f 85 87 00 00 00    	jne    80f387 <do_connect+0xc8>
  80f300:	eb 50                	jmp    80f352 <do_connect+0x93>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80f302:	8b 46 04             	mov    0x4(%esi),%eax
  80f305:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f309:	8b 43 08             	mov    0x8(%ebx),%eax
  80f30c:	89 04 24             	mov    %eax,(%esp)
  80f30f:	e8 89 22 00 00       	call   81159d <raw_connect>
  80f314:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80f317:	8b 06                	mov    (%esi),%eax
  80f319:	8b 40 10             	mov    0x10(%eax),%eax
  80f31c:	89 04 24             	mov    %eax,(%esp)
  80f31f:	e8 96 e4 ff ff       	call   80d7ba <sys_sem_signal>
  80f324:	eb 61                	jmp    80f387 <do_connect+0xc8>
    break;
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f326:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f32a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f32e:	8b 46 04             	mov    0x4(%esi),%eax
  80f331:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f335:	8b 43 08             	mov    0x8(%ebx),%eax
  80f338:	89 04 24             	mov    %eax,(%esp)
  80f33b:	e8 a2 ca ff ff       	call   80bde2 <udp_connect>
  80f340:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80f343:	8b 06                	mov    (%esi),%eax
  80f345:	8b 40 10             	mov    0x10(%eax),%eax
  80f348:	89 04 24             	mov    %eax,(%esp)
  80f34b:	e8 6a e4 ff ff       	call   80d7ba <sys_sem_signal>
  80f350:	eb 35                	jmp    80f387 <do_connect+0xc8>
    break;
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80f352:	c7 43 04 03 00 00 00 	movl   $0x3,0x4(%ebx)
    setup_tcp(msg->conn);
  80f359:	8b 06                	mov    (%esi),%eax
  80f35b:	e8 cc f5 ff ff       	call   80e92c <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80f360:	8b 1e                	mov    (%esi),%ebx
  80f362:	c7 44 24 0c 90 e9 80 	movl   $0x80e990,0xc(%esp)
  80f369:	00 
  80f36a:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f36e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f372:	8b 46 04             	mov    0x4(%esi),%eax
  80f375:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f379:	8b 43 08             	mov    0x8(%ebx),%eax
  80f37c:	89 04 24             	mov    %eax,(%esp)
  80f37f:	e8 b9 96 ff ff       	call   808a3d <tcp_connect>
  80f384:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80f387:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f38a:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f38d:	89 ec                	mov    %ebp,%esp
  80f38f:	5d                   	pop    %ebp
  80f390:	c3                   	ret    

0080f391 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80f391:	55                   	push   %ebp
  80f392:	89 e5                	mov    %esp,%ebp
  80f394:	83 ec 18             	sub    $0x18,%esp
  80f397:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f39a:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f39d:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f3a0:	8b 1e                	mov    (%esi),%ebx
  80f3a2:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80f3a6:	7c 75                	jl     80f41d <do_bind+0x8c>
    if (msg->conn->pcb.tcp != NULL) {
  80f3a8:	8b 53 08             	mov    0x8(%ebx),%edx
  80f3ab:	85 d2                	test   %edx,%edx
  80f3ad:	74 6a                	je     80f419 <do_bind+0x88>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f3af:	8b 03                	mov    (%ebx),%eax
  80f3b1:	25 f0 00 00 00       	and    $0xf0,%eax
  80f3b6:	83 f8 20             	cmp    $0x20,%eax
  80f3b9:	74 23                	je     80f3de <do_bind+0x4d>
  80f3bb:	83 f8 40             	cmp    $0x40,%eax
  80f3be:	74 07                	je     80f3c7 <do_bind+0x36>
  80f3c0:	83 f8 10             	cmp    $0x10,%eax
  80f3c3:	75 58                	jne    80f41d <do_bind+0x8c>
  80f3c5:	eb 36                	jmp    80f3fd <do_bind+0x6c>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80f3c7:	8b 46 04             	mov    0x4(%esi),%eax
  80f3ca:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f3ce:	8b 43 08             	mov    0x8(%ebx),%eax
  80f3d1:	89 04 24             	mov    %eax,(%esp)
  80f3d4:	e8 a7 21 00 00       	call   811580 <raw_bind>
  80f3d9:	88 43 0c             	mov    %al,0xc(%ebx)
  80f3dc:	eb 3f                	jmp    80f41d <do_bind+0x8c>
        break;
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f3de:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f3e2:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f3e6:	8b 46 04             	mov    0x4(%esi),%eax
  80f3e9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f3ed:	8b 43 08             	mov    0x8(%ebx),%eax
  80f3f0:	89 04 24             	mov    %eax,(%esp)
  80f3f3:	e8 10 c9 ff ff       	call   80bd08 <udp_bind>
  80f3f8:	88 43 0c             	mov    %al,0xc(%ebx)
  80f3fb:	eb 20                	jmp    80f41d <do_bind+0x8c>
        break;
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f3fd:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f401:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f405:	8b 46 04             	mov    0x4(%esi),%eax
  80f408:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f40c:	89 14 24             	mov    %edx,(%esp)
  80f40f:	e8 e2 94 ff ff       	call   8088f6 <tcp_bind>
  80f414:	88 43 0c             	mov    %al,0xc(%ebx)
  80f417:	eb 04                	jmp    80f41d <do_bind+0x8c>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80f419:	c6 43 0c f7          	movb   $0xf7,0xc(%ebx)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f41d:	8b 06                	mov    (%esi),%eax
  80f41f:	8b 40 10             	mov    0x10(%eax),%eax
  80f422:	89 04 24             	mov    %eax,(%esp)
  80f425:	e8 90 e3 ff ff       	call   80d7ba <sys_sem_signal>
}
  80f42a:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f42d:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f430:	89 ec                	mov    %ebp,%esp
  80f432:	5d                   	pop    %ebp
  80f433:	c3                   	ret    

0080f434 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80f434:	55                   	push   %ebp
  80f435:	89 e5                	mov    %esp,%ebp
  80f437:	53                   	push   %ebx
  80f438:	83 ec 14             	sub    $0x14,%esp
  80f43b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80f43e:	8b 13                	mov    (%ebx),%edx
  80f440:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  80f444:	74 55                	je     80f49b <do_delconn+0x67>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f446:	8b 02                	mov    (%edx),%eax
  80f448:	25 f0 00 00 00       	and    $0xf0,%eax
  80f44d:	83 f8 20             	cmp    $0x20,%eax
  80f450:	74 20                	je     80f472 <do_delconn+0x3e>
  80f452:	83 f8 40             	cmp    $0x40,%eax
  80f455:	74 0b                	je     80f462 <do_delconn+0x2e>
  80f457:	83 f8 10             	cmp    $0x10,%eax
  80f45a:	75 3f                	jne    80f49b <do_delconn+0x67>
  80f45c:	8d 74 26 00          	lea    0x0(%esi),%esi
  80f460:	eb 29                	jmp    80f48b <do_delconn+0x57>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80f462:	8b 42 08             	mov    0x8(%edx),%eax
  80f465:	89 04 24             	mov    %eax,(%esp)
  80f468:	e8 be 21 00 00       	call   81162b <raw_remove>
  80f46d:	8d 76 00             	lea    0x0(%esi),%esi
  80f470:	eb 29                	jmp    80f49b <do_delconn+0x67>
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80f472:	8b 42 08             	mov    0x8(%edx),%eax
  80f475:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
      udp_remove(msg->conn->pcb.udp);
  80f47c:	8b 03                	mov    (%ebx),%eax
  80f47e:	8b 40 08             	mov    0x8(%eax),%eax
  80f481:	89 04 24             	mov    %eax,(%esp)
  80f484:	e8 33 c8 ff ff       	call   80bcbc <udp_remove>
  80f489:	eb 10                	jmp    80f49b <do_delconn+0x67>
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80f48b:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80f492:	8b 03                	mov    (%ebx),%eax
  80f494:	e8 40 f5 ff ff       	call   80e9d9 <do_close_internal>
  80f499:	eb 4e                	jmp    80f4e9 <do_delconn+0xb5>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80f49b:	8b 03                	mov    (%ebx),%eax
  80f49d:	8b 50 2c             	mov    0x2c(%eax),%edx
  80f4a0:	85 d2                	test   %edx,%edx
  80f4a2:	74 33                	je     80f4d7 <do_delconn+0xa3>
  80f4a4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f4ab:	00 
  80f4ac:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f4b3:	00 
  80f4b4:	89 04 24             	mov    %eax,(%esp)
  80f4b7:	ff d2                	call   *%edx
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80f4b9:	8b 13                	mov    (%ebx),%edx
  80f4bb:	8b 42 2c             	mov    0x2c(%edx),%eax
  80f4be:	85 c0                	test   %eax,%eax
  80f4c0:	74 15                	je     80f4d7 <do_delconn+0xa3>
  80f4c2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f4c9:	00 
  80f4ca:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80f4d1:	00 
  80f4d2:	89 14 24             	mov    %edx,(%esp)
  80f4d5:	ff d0                	call   *%eax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80f4d7:	8b 03                	mov    (%ebx),%eax
  80f4d9:	8b 40 10             	mov    0x10(%eax),%eax
  80f4dc:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f4df:	74 08                	je     80f4e9 <do_delconn+0xb5>
    sys_sem_signal(msg->conn->op_completed);
  80f4e1:	89 04 24             	mov    %eax,(%esp)
  80f4e4:	e8 d1 e2 ff ff       	call   80d7ba <sys_sem_signal>
  }
}
  80f4e9:	83 c4 14             	add    $0x14,%esp
  80f4ec:	5b                   	pop    %ebx
  80f4ed:	5d                   	pop    %ebp
  80f4ee:	c3                   	ret    

0080f4ef <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80f4ef:	55                   	push   %ebp
  80f4f0:	89 e5                	mov    %esp,%ebp
  80f4f2:	56                   	push   %esi
  80f4f3:	53                   	push   %ebx
  80f4f4:	83 ec 20             	sub    $0x20,%esp
  80f4f7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80f4fa:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80f4fe:	74 1c                	je     80f51c <netconn_free+0x2d>
  80f500:	c7 44 24 08 58 48 81 	movl   $0x814858,0x8(%esp)
  80f507:	00 
  80f508:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
  80f50f:	00 
  80f510:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80f517:	e8 90 13 ff ff       	call   8008ac <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80f51c:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80f51f:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f523:	75 23                	jne    80f548 <netconn_free+0x59>
  80f525:	eb 47                	jmp    80f56e <netconn_free+0x7f>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80f527:	83 3b 10             	cmpl   $0x10,(%ebx)
  80f52a:	75 11                	jne    80f53d <netconn_free+0x4e>
        if(mem != NULL) {
  80f52c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f52f:	85 c0                	test   %eax,%eax
  80f531:	74 15                	je     80f548 <netconn_free+0x59>
          pbuf_free((struct pbuf *)mem);
  80f533:	89 04 24             	mov    %eax,(%esp)
  80f536:	e8 38 85 ff ff       	call   807a73 <pbuf_free>
  80f53b:	eb 0b                	jmp    80f548 <netconn_free+0x59>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80f53d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f540:	89 04 24             	mov    %eax,(%esp)
  80f543:	e8 7b 5c ff ff       	call   8051c3 <netbuf_delete>
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80f548:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f54c:	8b 43 14             	mov    0x14(%ebx),%eax
  80f54f:	89 04 24             	mov    %eax,(%esp)
  80f552:	e8 c9 e3 ff ff       	call   80d920 <sys_arch_mbox_tryfetch>
  80f557:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f55a:	75 cb                	jne    80f527 <netconn_free+0x38>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80f55c:	8b 43 14             	mov    0x14(%ebx),%eax
  80f55f:	89 04 24             	mov    %eax,(%esp)
  80f562:	e8 92 dc ff ff       	call   80d1f9 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80f567:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80f56e:	8d 75 f4             	lea    -0xc(%ebp),%esi
    sys_mbox_free(conn->recvmbox);
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80f571:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80f575:	75 0d                	jne    80f584 <netconn_free+0x95>
  80f577:	eb 31                	jmp    80f5aa <netconn_free+0xbb>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80f579:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f57c:	89 04 24             	mov    %eax,(%esp)
  80f57f:	e8 94 f1 ff ff       	call   80e718 <netconn_delete>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80f584:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f588:	8b 43 18             	mov    0x18(%ebx),%eax
  80f58b:	89 04 24             	mov    %eax,(%esp)
  80f58e:	e8 8d e3 ff ff       	call   80d920 <sys_arch_mbox_tryfetch>
  80f593:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f596:	75 e1                	jne    80f579 <netconn_free+0x8a>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80f598:	8b 43 18             	mov    0x18(%ebx),%eax
  80f59b:	89 04 24             	mov    %eax,(%esp)
  80f59e:	e8 56 dc ff ff       	call   80d1f9 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80f5a3:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  }

  sys_sem_free(conn->op_completed);
  80f5aa:	8b 43 10             	mov    0x10(%ebx),%eax
  80f5ad:	89 04 24             	mov    %eax,(%esp)
  80f5b0:	e8 cb db ff ff       	call   80d180 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80f5b5:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80f5bc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f5c0:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f5c7:	e8 3b 7d ff ff       	call   807307 <memp_free>
}
  80f5cc:	83 c4 20             	add    $0x20,%esp
  80f5cf:	5b                   	pop    %ebx
  80f5d0:	5e                   	pop    %esi
  80f5d1:	5d                   	pop    %ebp
  80f5d2:	c3                   	ret    

0080f5d3 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80f5d3:	55                   	push   %ebp
  80f5d4:	89 e5                	mov    %esp,%ebp
  80f5d6:	83 ec 28             	sub    $0x28,%esp
  80f5d9:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f5dc:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f5df:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f5e2:	8b 55 08             	mov    0x8(%ebp),%edx
  80f5e5:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f5e8:	8b 7d 10             	mov    0x10(%ebp),%edi
  80f5eb:	0f b7 4d 18          	movzwl 0x18(%ebp),%ecx
  80f5ef:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80f5f3:	85 c0                	test   %eax,%eax
  80f5f5:	75 1c                	jne    80f613 <recv_udp+0x40>
  80f5f7:	c7 44 24 08 88 48 81 	movl   $0x814888,0x8(%esp)
  80f5fe:	00 
  80f5ff:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80f606:	00 
  80f607:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80f60e:	e8 99 12 ff ff       	call   8008ac <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80f613:	85 d2                	test   %edx,%edx
  80f615:	75 1c                	jne    80f633 <recv_udp+0x60>
  80f617:	c7 44 24 08 ac 48 81 	movl   $0x8148ac,0x8(%esp)
  80f61e:	00 
  80f61f:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  80f626:	00 
  80f627:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80f62e:	e8 79 12 ff ff       	call   8008ac <_panic>
  conn = arg;
  80f633:	89 d3                	mov    %edx,%ebx
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80f635:	39 42 08             	cmp    %eax,0x8(%edx)
  80f638:	74 1c                	je     80f656 <recv_udp+0x83>
  80f63a:	c7 44 24 08 ad 47 81 	movl   $0x8147ad,0x8(%esp)
  80f641:	00 
  80f642:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  80f649:	00 
  80f64a:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80f651:	e8 56 12 ff ff       	call   8008ac <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80f656:	83 7a 14 ff          	cmpl   $0xffffffff,0x14(%edx)
  80f65a:	75 0a                	jne    80f666 <recv_udp+0x93>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80f65c:	89 3c 24             	mov    %edi,(%esp)
  80f65f:	e8 0f 84 ff ff       	call   807a73 <pbuf_free>
  80f664:	eb 70                	jmp    80f6d6 <recv_udp+0x103>
    return;
  }

  buf = memp_malloc(MEMP_NETBUF);
  80f666:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80f66d:	e8 d8 7c ff ff       	call   80734a <memp_malloc>
  if (buf == NULL) {
  80f672:	85 c0                	test   %eax,%eax
  80f674:	75 0c                	jne    80f682 <recv_udp+0xaf>
    pbuf_free(p);
  80f676:	89 3c 24             	mov    %edi,(%esp)
  80f679:	e8 f5 83 ff ff       	call   807a73 <pbuf_free>
  80f67e:	66 90                	xchg   %ax,%ax
  80f680:	eb 54                	jmp    80f6d6 <recv_udp+0x103>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
    return;
  }

  buf = memp_malloc(MEMP_NETBUF);
  80f682:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
    pbuf_free(p);
    return;
  } else {
    buf->p = p;
  80f684:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80f686:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80f689:	8b 45 14             	mov    0x14(%ebp),%eax
  80f68c:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80f68f:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  80f693:	66 89 4e 0c          	mov    %cx,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80f697:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80f69b:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80f69f:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80f6a2:	85 d2                	test   %edx,%edx
  80f6a4:	74 15                	je     80f6bb <recv_udp+0xe8>
  80f6a6:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80f6aa:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f6ae:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f6b5:	00 
  80f6b6:	89 1c 24             	mov    %ebx,(%esp)
  80f6b9:	ff d2                	call   *%edx
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80f6bb:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f6bf:	8b 43 14             	mov    0x14(%ebx),%eax
  80f6c2:	89 04 24             	mov    %eax,(%esp)
  80f6c5:	e8 78 e2 ff ff       	call   80d942 <sys_mbox_trypost>
  80f6ca:	84 c0                	test   %al,%al
  80f6cc:	74 08                	je     80f6d6 <recv_udp+0x103>
    netbuf_delete(buf);
  80f6ce:	89 34 24             	mov    %esi,(%esp)
  80f6d1:	e8 ed 5a ff ff       	call   8051c3 <netbuf_delete>
    return;
  }
}
  80f6d6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f6d9:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f6dc:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f6df:	89 ec                	mov    %ebp,%esp
  80f6e1:	5d                   	pop    %ebp
  80f6e2:	c3                   	ret    

0080f6e3 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80f6e3:	55                   	push   %ebp
  80f6e4:	89 e5                	mov    %esp,%ebp
  80f6e6:	53                   	push   %ebx
  80f6e7:	83 ec 14             	sub    $0x14,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80f6ea:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f6f1:	e8 54 7c ff ff       	call   80734a <memp_malloc>
  if (conn == NULL) {
  80f6f6:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f6fb:	85 c0                	test   %eax,%eax
  80f6fd:	0f 84 94 00 00 00    	je     80f797 <netconn_alloc+0xb4>
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80f703:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
    return NULL;
  }

  conn->err = ERR_OK;
  80f705:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80f709:	8b 45 08             	mov    0x8(%ebp),%eax
  80f70c:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80f70e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80f715:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f71c:	e8 f5 de ff ff       	call   80d616 <sys_sem_new>
  80f721:	89 43 10             	mov    %eax,0x10(%ebx)
  80f724:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f727:	75 17                	jne    80f740 <netconn_alloc+0x5d>
    memp_free(MEMP_NETCONN, conn);
  80f729:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f72d:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f734:	e8 ce 7b ff ff       	call   807307 <memp_free>
  80f739:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f73e:	eb 57                	jmp    80f797 <netconn_alloc+0xb4>
    return NULL;
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80f740:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f747:	e8 57 df ff ff       	call   80d6a3 <sys_mbox_new>
  80f74c:	89 43 14             	mov    %eax,0x14(%ebx)
  80f74f:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f752:	75 22                	jne    80f776 <netconn_alloc+0x93>
    sys_sem_free(conn->op_completed);
  80f754:	8b 43 10             	mov    0x10(%ebx),%eax
  80f757:	89 04 24             	mov    %eax,(%esp)
  80f75a:	e8 21 da ff ff       	call   80d180 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80f75f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f763:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f76a:	e8 98 7b ff ff       	call   807307 <memp_free>
  80f76f:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f774:	eb 21                	jmp    80f797 <netconn_alloc+0xb4>
    return NULL;
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80f776:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80f77d:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80f784:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80f78b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f78e:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80f791:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80f797:	89 d8                	mov    %ebx,%eax
  80f799:	83 c4 14             	add    $0x14,%esp
  80f79c:	5b                   	pop    %ebx
  80f79d:	5d                   	pop    %ebp
  80f79e:	c3                   	ret    

0080f79f <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80f79f:	55                   	push   %ebp
  80f7a0:	89 e5                	mov    %esp,%ebp
  80f7a2:	83 ec 18             	sub    $0x18,%esp
  80f7a5:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f7a8:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f7ab:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f7ae:	0f b6 7d 10          	movzbl 0x10(%ebp),%edi
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  80f7b2:	8b 75 08             	mov    0x8(%ebp),%esi

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80f7b5:	83 7e 18 ff          	cmpl   $0xffffffff,0x18(%esi)
  80f7b9:	75 1c                	jne    80f7d7 <accept_function+0x38>
  80f7bb:	c7 44 24 08 cc 48 81 	movl   $0x8148cc,0x8(%esp)
  80f7c2:	00 
  80f7c3:	c7 44 24 04 65 01 00 	movl   $0x165,0x4(%esp)
  80f7ca:	00 
  80f7cb:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80f7d2:	e8 d5 10 ff ff       	call   8008ac <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80f7d7:	8b 46 2c             	mov    0x2c(%esi),%eax
  80f7da:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f7de:	8b 06                	mov    (%esi),%eax
  80f7e0:	89 04 24             	mov    %eax,(%esp)
  80f7e3:	e8 fb fe ff ff       	call   80f6e3 <netconn_alloc>
  80f7e8:	89 c3                	mov    %eax,%ebx
  if (newconn == NULL) {
  80f7ea:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80f7ef:	85 c0                	test   %eax,%eax
  80f7f1:	74 5a                	je     80f84d <accept_function+0xae>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80f7f3:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f7f6:	89 43 08             	mov    %eax,0x8(%ebx)
  setup_tcp(newconn);
  80f7f9:	89 d8                	mov    %ebx,%eax
  80f7fb:	e8 2c f1 ff ff       	call   80e92c <setup_tcp>
  newconn->err = err;
  80f800:	89 f8                	mov    %edi,%eax
  80f802:	88 43 0c             	mov    %al,0xc(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80f805:	8b 46 2c             	mov    0x2c(%esi),%eax
  80f808:	85 c0                	test   %eax,%eax
  80f80a:	74 15                	je     80f821 <accept_function+0x82>
  80f80c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f813:	00 
  80f814:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f81b:	00 
  80f81c:	89 34 24             	mov    %esi,(%esp)
  80f81f:	ff d0                	call   *%eax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80f821:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f825:	8b 46 18             	mov    0x18(%esi),%eax
  80f828:	89 04 24             	mov    %eax,(%esp)
  80f82b:	e8 12 e1 ff ff       	call   80d942 <sys_mbox_trypost>
  80f830:	ba 00 00 00 00       	mov    $0x0,%edx
  80f835:	84 c0                	test   %al,%al
  80f837:	74 14                	je     80f84d <accept_function+0xae>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80f839:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    netconn_free(newconn);
  80f840:	89 1c 24             	mov    %ebx,(%esp)
  80f843:	e8 a7 fc ff ff       	call   80f4ef <netconn_free>
  80f848:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    return ERR_MEM;
  }
  return ERR_OK;
}
  80f84d:	89 d0                	mov    %edx,%eax
  80f84f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f852:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f855:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f858:	89 ec                	mov    %ebp,%esp
  80f85a:	5d                   	pop    %ebp
  80f85b:	c3                   	ret    

0080f85c <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80f85c:	55                   	push   %ebp
  80f85d:	89 e5                	mov    %esp,%ebp
  80f85f:	83 ec 18             	sub    $0x18,%esp
  80f862:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f865:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f868:	8b 75 08             	mov    0x8(%ebp),%esi
   if(msg->conn->pcb.tcp == NULL) {
  80f86b:	8b 06                	mov    (%esi),%eax
  80f86d:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80f871:	0f 85 df 00 00 00    	jne    80f956 <do_newconn+0xfa>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80f877:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80f87b:	8b 1e                	mov    (%esi),%ebx
  80f87d:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80f881:	74 1c                	je     80f89f <do_newconn+0x43>
  80f883:	c7 44 24 08 f8 48 81 	movl   $0x8148f8,0x8(%esp)
  80f88a:	00 
  80f88b:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80f892:	00 
  80f893:	c7 04 24 e9 46 81 00 	movl   $0x8146e9,(%esp)
  80f89a:	e8 0d 10 ff ff       	call   8008ac <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80f89f:	8b 03                	mov    (%ebx),%eax
  80f8a1:	25 f0 00 00 00       	and    $0xf0,%eax
  80f8a6:	83 f8 20             	cmp    $0x20,%eax
  80f8a9:	74 4b                	je     80f8f6 <do_newconn+0x9a>
  80f8ab:	83 f8 40             	cmp    $0x40,%eax
  80f8ae:	74 12                	je     80f8c2 <do_newconn+0x66>
  80f8b0:	83 f8 10             	cmp    $0x10,%eax
  80f8b3:	0f 85 99 00 00 00    	jne    80f952 <do_newconn+0xf6>
  80f8b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  80f8c0:	eb 6f                	jmp    80f931 <do_newconn+0xd5>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80f8c2:	0f b6 46 04          	movzbl 0x4(%esi),%eax
  80f8c6:	89 04 24             	mov    %eax,(%esp)
  80f8c9:	e8 01 1d 00 00       	call   8115cf <raw_new>
  80f8ce:	89 43 08             	mov    %eax,0x8(%ebx)
     if(msg->conn->pcb.raw == NULL) {
  80f8d1:	8b 06                	mov    (%esi),%eax
  80f8d3:	8b 50 08             	mov    0x8(%eax),%edx
  80f8d6:	85 d2                	test   %edx,%edx
  80f8d8:	75 06                	jne    80f8e0 <do_newconn+0x84>
       msg->conn->err = ERR_MEM;
  80f8da:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80f8de:	eb 76                	jmp    80f956 <do_newconn+0xfa>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80f8e0:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f8e4:	c7 44 24 04 6d f9 80 	movl   $0x80f96d,0x4(%esp)
  80f8eb:	00 
  80f8ec:	89 14 24             	mov    %edx,(%esp)
  80f8ef:	e8 c7 1c 00 00       	call   8115bb <raw_recv>
  80f8f4:	eb 60                	jmp    80f956 <do_newconn+0xfa>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80f8f6:	e8 84 c3 ff ff       	call   80bc7f <udp_new>
  80f8fb:	89 43 08             	mov    %eax,0x8(%ebx)
     if(msg->conn->pcb.udp == NULL) {
  80f8fe:	8b 06                	mov    (%esi),%eax
  80f900:	8b 50 08             	mov    0x8(%eax),%edx
  80f903:	85 d2                	test   %edx,%edx
  80f905:	75 06                	jne    80f90d <do_newconn+0xb1>
       msg->conn->err = ERR_MEM;
  80f907:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80f90b:	eb 49                	jmp    80f956 <do_newconn+0xfa>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80f90d:	83 38 22             	cmpl   $0x22,(%eax)
  80f910:	75 04                	jne    80f916 <do_newconn+0xba>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80f912:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80f916:	8b 06                	mov    (%esi),%eax
  80f918:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f91c:	c7 44 24 04 d3 f5 80 	movl   $0x80f5d3,0x4(%esp)
  80f923:	00 
  80f924:	8b 40 08             	mov    0x8(%eax),%eax
  80f927:	89 04 24             	mov    %eax,(%esp)
  80f92a:	e8 3c c3 ff ff       	call   80bc6b <udp_recv>
  80f92f:	eb 25                	jmp    80f956 <do_newconn+0xfa>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80f931:	e8 23 95 ff ff       	call   808e59 <tcp_new>
  80f936:	89 43 08             	mov    %eax,0x8(%ebx)
     if(msg->conn->pcb.tcp == NULL) {
  80f939:	8b 06                	mov    (%esi),%eax
  80f93b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80f93f:	90                   	nop    
  80f940:	75 06                	jne    80f948 <do_newconn+0xec>
       msg->conn->err = ERR_MEM;
  80f942:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80f946:	eb 0e                	jmp    80f956 <do_newconn+0xfa>
       break;
     }
     setup_tcp(msg->conn);
  80f948:	e8 df ef ff ff       	call   80e92c <setup_tcp>
  80f94d:	8d 76 00             	lea    0x0(%esi),%esi
  80f950:	eb 04                	jmp    80f956 <do_newconn+0xfa>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80f952:	c6 43 0c f7          	movb   $0xf7,0xc(%ebx)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80f956:	8b 06                	mov    (%esi),%eax
  80f958:	8b 40 10             	mov    0x10(%eax),%eax
  80f95b:	89 04 24             	mov    %eax,(%esp)
  80f95e:	e8 57 de ff ff       	call   80d7ba <sys_sem_signal>
}
  80f963:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f966:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f969:	89 ec                	mov    %ebp,%esp
  80f96b:	5d                   	pop    %ebp
  80f96c:	c3                   	ret    

0080f96d <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80f96d:	55                   	push   %ebp
  80f96e:	89 e5                	mov    %esp,%ebp
  80f970:	83 ec 18             	sub    $0x18,%esp
  80f973:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f976:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f979:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f97c:	8b 45 08             	mov    0x8(%ebp),%eax
  80f97f:	8b 7d 10             	mov    0x10(%ebp),%edi
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80f982:	85 c0                	test   %eax,%eax
  80f984:	0f 84 cc 00 00 00    	je     80fa56 <recv_raw+0xe9>
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  80f98a:	89 c6                	mov    %eax,%esi
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80f98c:	83 78 14 ff          	cmpl   $0xffffffff,0x14(%eax)
  80f990:	0f 84 c0 00 00 00    	je     80fa56 <recv_raw+0xe9>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80f996:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f99d:	00 
  80f99e:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80f9a2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f9a6:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80f9ad:	e8 84 83 ff ff       	call   807d36 <pbuf_alloc>
  80f9b2:	89 c3                	mov    %eax,%ebx
    if(q != NULL) {
  80f9b4:	85 c0                	test   %eax,%eax
  80f9b6:	0f 84 9a 00 00 00    	je     80fa56 <recv_raw+0xe9>
      if (pbuf_copy(q, p) != ERR_OK) {
  80f9bc:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f9c0:	89 04 24             	mov    %eax,(%esp)
  80f9c3:	e8 04 7f ff ff       	call   8078cc <pbuf_copy>
  80f9c8:	84 c0                	test   %al,%al
  80f9ca:	74 76                	je     80fa42 <recv_raw+0xd5>
        pbuf_free(q);
  80f9cc:	89 1c 24             	mov    %ebx,(%esp)
  80f9cf:	e8 9f 80 ff ff       	call   807a73 <pbuf_free>
  80f9d4:	e9 7d 00 00 00       	jmp    80fa56 <recv_raw+0xe9>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80f9d9:	89 1c 24             	mov    %ebx,(%esp)
  80f9dc:	e8 92 80 ff ff       	call   807a73 <pbuf_free>
  80f9e1:	eb 73                	jmp    80fa56 <recv_raw+0xe9>
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80f9e3:	89 d7                	mov    %edx,%edi
      if (buf == NULL) {
        pbuf_free(q);
        return 0;
      }

      buf->p = q;
  80f9e5:	89 1a                	mov    %ebx,(%edx)
      buf->ptr = q;
  80f9e7:	89 5a 04             	mov    %ebx,0x4(%edx)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80f9ea:	8b 43 04             	mov    0x4(%ebx),%eax
  80f9ed:	83 c0 0c             	add    $0xc,%eax
  80f9f0:	89 42 08             	mov    %eax,0x8(%edx)
      buf->port = pcb->protocol;
  80f9f3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f9f6:	0f b6 41 10          	movzbl 0x10(%ecx),%eax
  80f9fa:	66 89 42 0c          	mov    %ax,0xc(%edx)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80f9fe:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80fa02:	66 01 46 20          	add    %ax,0x20(%esi)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80fa06:	8b 56 2c             	mov    0x2c(%esi),%edx
  80fa09:	85 d2                	test   %edx,%edx
  80fa0b:	74 15                	je     80fa22 <recv_raw+0xb5>
  80fa0d:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80fa11:	89 44 24 08          	mov    %eax,0x8(%esp)
  80fa15:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80fa1c:	00 
  80fa1d:	89 34 24             	mov    %esi,(%esp)
  80fa20:	ff d2                	call   *%edx
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80fa22:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80fa26:	8b 46 14             	mov    0x14(%esi),%eax
  80fa29:	89 04 24             	mov    %eax,(%esp)
  80fa2c:	e8 11 df ff ff       	call   80d942 <sys_mbox_trypost>
  80fa31:	84 c0                	test   %al,%al
  80fa33:	74 21                	je     80fa56 <recv_raw+0xe9>
        netbuf_delete(buf);
  80fa35:	89 3c 24             	mov    %edi,(%esp)
  80fa38:	e8 86 57 ff ff       	call   8051c3 <netbuf_delete>
  80fa3d:	8d 76 00             	lea    0x0(%esi),%esi
  80fa40:	eb 14                	jmp    80fa56 <recv_raw+0xe9>
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80fa42:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80fa49:	e8 fc 78 ff ff       	call   80734a <memp_malloc>
  80fa4e:	89 c2                	mov    %eax,%edx
      if (buf == NULL) {
  80fa50:	85 c0                	test   %eax,%eax
  80fa52:	75 8f                	jne    80f9e3 <recv_raw+0x76>
  80fa54:	eb 83                	jmp    80f9d9 <recv_raw+0x6c>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80fa56:	b8 00 00 00 00       	mov    $0x0,%eax
  80fa5b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fa5e:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fa61:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fa64:	89 ec                	mov    %ebp,%esp
  80fa66:	5d                   	pop    %ebp
  80fa67:	c3                   	ret    
	...

0080fa70 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80fa70:	55                   	push   %ebp
  80fa71:	89 e5                	mov    %esp,%ebp
  80fa73:	57                   	push   %edi
  80fa74:	56                   	push   %esi
  80fa75:	53                   	push   %ebx
  80fa76:	83 ec 0c             	sub    $0xc,%esp
  80fa79:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80fa7b:	a1 30 e5 b3 00       	mov    0xb3e530,%eax
  80fa80:	8d 70 14             	lea    0x14(%eax),%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80fa83:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fa87:	89 04 24             	mov    %eax,(%esp)
  80fa8a:	e8 16 ae ff ff       	call   80a8a5 <ntohs>
  80fa8f:	66 c1 e8 0c          	shr    $0xc,%ax
  80fa93:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fa98:	66 83 f8 05          	cmp    $0x5,%ax
  80fa9c:	77 52                	ja     80faf0 <tcp_parseopt+0x80>
  80fa9e:	eb 76                	jmp    80fb16 <tcp_parseopt+0xa6>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80faa0:	0f b6 d3             	movzbl %bl,%edx
  80faa3:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
      if (opt == 0x00) {
  80faa7:	84 c0                	test   %al,%al
  80faa9:	74 6b                	je     80fb16 <tcp_parseopt+0xa6>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80faab:	3c 01                	cmp    $0x1,%al
  80faad:	8d 76 00             	lea    0x0(%esi),%esi
  80fab0:	75 05                	jne    80fab7 <tcp_parseopt+0x47>
        ++c;
  80fab2:	83 c3 01             	add    $0x1,%ebx
  80fab5:	eb 39                	jmp    80faf0 <tcp_parseopt+0x80>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80fab7:	3c 02                	cmp    $0x2,%al
  80fab9:	75 2a                	jne    80fae5 <tcp_parseopt+0x75>
  80fabb:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80fabe:	80 79 01 04          	cmpb   $0x4,0x1(%ecx)
  80fac2:	75 21                	jne    80fae5 <tcp_parseopt+0x75>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80fac4:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  80fac8:	c1 e0 08             	shl    $0x8,%eax
  80facb:	0f b6 51 03          	movzbl 0x3(%ecx),%edx
  80facf:	09 c2                	or     %eax,%edx
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80fad1:	8d 42 ff             	lea    -0x1(%edx),%eax
  80fad4:	66 3d b3 05          	cmp    $0x5b3,%ax
  80fad8:	76 05                	jbe    80fadf <tcp_parseopt+0x6f>
  80fada:	ba b4 05 00 00       	mov    $0x5b4,%edx
  80fadf:	66 89 57 34          	mov    %dx,0x34(%edi)
  80fae3:	eb 31                	jmp    80fb16 <tcp_parseopt+0xa6>

        /* And we are done processing options. */
        break;
      } else {
        if (opts[c + 1] == 0) {
  80fae5:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80faea:	84 c0                	test   %al,%al
  80faec:	74 28                	je     80fb16 <tcp_parseopt+0xa6>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80faee:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80faf0:	a1 30 e5 b3 00       	mov    0xb3e530,%eax
  80faf5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80faf9:	89 04 24             	mov    %eax,(%esp)
  80fafc:	e8 a4 ad ff ff       	call   80a8a5 <ntohs>
  80fb01:	0f b6 d3             	movzbl %bl,%edx
  80fb04:	66 c1 e8 0c          	shr    $0xc,%ax
  80fb08:	0f b7 c0             	movzwl %ax,%eax
  80fb0b:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80fb12:	39 c2                	cmp    %eax,%edx
  80fb14:	7c 8a                	jl     80faa0 <tcp_parseopt+0x30>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80fb16:	83 c4 0c             	add    $0xc,%esp
  80fb19:	5b                   	pop    %ebx
  80fb1a:	5e                   	pop    %esi
  80fb1b:	5f                   	pop    %edi
  80fb1c:	5d                   	pop    %ebp
  80fb1d:	c3                   	ret    

0080fb1e <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80fb1e:	55                   	push   %ebp
  80fb1f:	89 e5                	mov    %esp,%ebp
  80fb21:	57                   	push   %edi
  80fb22:	56                   	push   %esi
  80fb23:	53                   	push   %ebx
  80fb24:	83 ec 2c             	sub    $0x2c,%esp
  80fb27:	89 c7                	mov    %eax,%edi
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80fb29:	f6 05 40 e5 b3 00 10 	testb  $0x10,0xb3e540
  80fb30:	0f 84 65 04 00 00    	je     80ff9b <tcp_receive+0x47d>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80fb36:	0f b7 58 5c          	movzwl 0x5c(%eax),%ebx
  80fb3a:	8b 48 60             	mov    0x60(%eax),%ecx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80fb3d:	8b 15 38 e5 b3 00    	mov    0xb3e538,%edx
  80fb43:	39 d1                	cmp    %edx,%ecx
  80fb45:	78 24                	js     80fb6b <tcp_receive+0x4d>
  80fb47:	39 d1                	cmp    %edx,%ecx
  80fb49:	75 0a                	jne    80fb55 <tcp_receive+0x37>
  80fb4b:	a1 3c e5 b3 00       	mov    0xb3e53c,%eax
  80fb50:	39 47 64             	cmp    %eax,0x64(%edi)
  80fb53:	78 16                	js     80fb6b <tcp_receive+0x4d>
  80fb55:	8b 47 64             	mov    0x64(%edi),%eax
  80fb58:	3b 05 3c e5 b3 00    	cmp    0xb3e53c,%eax
  80fb5e:	75 3a                	jne    80fb9a <tcp_receive+0x7c>
  80fb60:	a1 30 e5 b3 00       	mov    0xb3e530,%eax
  80fb65:	66 3b 58 0e          	cmp    0xe(%eax),%bx
  80fb69:	73 2f                	jae    80fb9a <tcp_receive+0x7c>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
  80fb6b:	a1 30 e5 b3 00       	mov    0xb3e530,%eax
  80fb70:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  80fb74:	66 89 47 5c          	mov    %ax,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80fb78:	89 57 60             	mov    %edx,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80fb7b:	a1 3c e5 b3 00       	mov    0xb3e53c,%eax
  80fb80:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80fb83:	66 83 7f 5c 00       	cmpw   $0x0,0x5c(%edi)
  80fb88:	74 10                	je     80fb9a <tcp_receive+0x7c>
  80fb8a:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80fb91:	74 07                	je     80fb9a <tcp_receive+0x7c>
          pcb->persist_backoff = 0;
  80fb93:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80fb9a:	8b 47 48             	mov    0x48(%edi),%eax
  80fb9d:	8b 15 3c e5 b3 00    	mov    0xb3e53c,%edx
  80fba3:	39 d0                	cmp    %edx,%eax
  80fba5:	0f 85 aa 00 00 00    	jne    80fc55 <tcp_receive+0x137>
      pcb->acked = 0;
  80fbab:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80fbb1:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80fbb5:	03 57 60             	add    0x60(%edi),%edx
  80fbb8:	0f b7 c3             	movzwl %bx,%eax
  80fbbb:	01 c8                	add    %ecx,%eax
  80fbbd:	39 c2                	cmp    %eax,%edx
  80fbbf:	0f 85 01 03 00 00    	jne    80fec6 <tcp_receive+0x3a8>
        ++pcb->dupacks;
  80fbc5:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80fbc9:	83 c0 01             	add    $0x1,%eax
  80fbcc:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80fbcf:	3c 02                	cmp    $0x2,%al
  80fbd1:	0f 86 ef 02 00 00    	jbe    80fec6 <tcp_receive+0x3a8>
  80fbd7:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80fbdb:	0f 84 e5 02 00 00    	je     80fec6 <tcp_receive+0x3a8>
          if (!(pcb->flags & TF_INFR)) {
  80fbe1:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80fbe5:	75 52                	jne    80fc39 <tcp_receive+0x11b>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80fbe7:	89 3c 24             	mov    %edi,(%esp)
  80fbea:	e8 04 b8 ff ff       	call   80b3f3 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80fbef:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80fbf3:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80fbf7:	66 39 c2             	cmp    %ax,%dx
  80fbfa:	76 09                	jbe    80fc05 <tcp_receive+0xe7>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80fbfc:	66 d1 e8             	shr    %ax
  80fbff:	66 89 47 50          	mov    %ax,0x50(%edi)
  80fc03:	eb 09                	jmp    80fc0e <tcp_receive+0xf0>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80fc05:	89 d0                	mov    %edx,%eax
  80fc07:	66 d1 e8             	shr    %ax
  80fc0a:	66 89 47 50          	mov    %ax,0x50(%edi)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80fc0e:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80fc12:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80fc15:	0f b7 47 50          	movzwl 0x50(%edi),%eax
  80fc19:	39 d0                	cmp    %edx,%eax
  80fc1b:	7d 04                	jge    80fc21 <tcp_receive+0x103>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80fc1d:	66 89 57 50          	mov    %dx,0x50(%edi)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80fc21:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80fc25:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80fc28:	66 03 47 50          	add    0x50(%edi),%ax
  80fc2c:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80fc30:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80fc34:	e9 8d 02 00 00       	jmp    80fec6 <tcp_receive+0x3a8>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80fc39:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  80fc3d:	89 c2                	mov    %eax,%edx
  80fc3f:	66 03 57 34          	add    0x34(%edi),%dx
  80fc43:	66 39 d0             	cmp    %dx,%ax
  80fc46:	0f 83 7a 02 00 00    	jae    80fec6 <tcp_receive+0x3a8>
              pcb->cwnd += pcb->mss;
  80fc4c:	66 89 57 4e          	mov    %dx,0x4e(%edi)
  80fc50:	e9 71 02 00 00       	jmp    80fec6 <tcp_receive+0x3a8>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80fc55:	89 d1                	mov    %edx,%ecx
  80fc57:	29 c1                	sub    %eax,%ecx
  80fc59:	89 c8                	mov    %ecx,%eax
  80fc5b:	83 e8 01             	sub    $0x1,%eax
  80fc5e:	0f 88 b1 01 00 00    	js     80fe15 <tcp_receive+0x2f7>
  80fc64:	89 d0                	mov    %edx,%eax
  80fc66:	2b 47 58             	sub    0x58(%edi),%eax
  80fc69:	85 c0                	test   %eax,%eax
  80fc6b:	0f 8f a4 01 00 00    	jg     80fe15 <tcp_receive+0x2f7>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80fc71:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80fc75:	a8 04                	test   $0x4,%al
  80fc77:	74 0e                	je     80fc87 <tcp_receive+0x169>
        pcb->flags &= ~TF_INFR;
  80fc79:	83 e0 fb             	and    $0xfffffffb,%eax
  80fc7c:	88 47 20             	mov    %al,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80fc7f:	0f b7 47 50          	movzwl 0x50(%edi),%eax
  80fc83:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80fc87:	c6 47 46 00          	movb   $0x0,0x46(%edi)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80fc8b:	0f b7 47 40          	movzwl 0x40(%edi),%eax
  80fc8f:	66 c1 f8 03          	sar    $0x3,%ax
  80fc93:	66 03 47 42          	add    0x42(%edi),%ax
  80fc97:	66 89 47 44          	mov    %ax,0x44(%edi)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80fc9b:	89 d0                	mov    %edx,%eax
  80fc9d:	66 2b 47 48          	sub    0x48(%edi),%ax
  80fca1:	66 89 47 6c          	mov    %ax,0x6c(%edi)

      pcb->snd_buf += pcb->acked;
  80fca5:	66 01 47 6e          	add    %ax,0x6e(%edi)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80fca9:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80fcad:	89 57 48             	mov    %edx,0x48(%edi)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80fcb0:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80fcb4:	0f 86 d5 00 00 00    	jbe    80fd8f <tcp_receive+0x271>
        if (pcb->cwnd < pcb->ssthresh) {
  80fcba:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80fcbe:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80fcc2:	73 18                	jae    80fcdc <tcp_receive+0x1be>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80fcc4:	89 c8                	mov    %ecx,%eax
  80fcc6:	66 03 47 34          	add    0x34(%edi),%ax
  80fcca:	66 39 c1             	cmp    %ax,%cx
  80fccd:	0f 83 bc 00 00 00    	jae    80fd8f <tcp_receive+0x271>
            pcb->cwnd += pcb->mss;
  80fcd3:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80fcd7:	e9 b3 00 00 00       	jmp    80fd8f <tcp_receive+0x271>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80fcdc:	0f b7 57 34          	movzwl 0x34(%edi),%edx
  80fce0:	0f af d2             	imul   %edx,%edx
  80fce3:	0f b7 c1             	movzwl %cx,%eax
  80fce6:	89 c3                	mov    %eax,%ebx
  80fce8:	89 d0                	mov    %edx,%eax
  80fcea:	c1 fa 1f             	sar    $0x1f,%edx
  80fced:	f7 fb                	idiv   %ebx
  80fcef:	8d 04 01             	lea    (%ecx,%eax,1),%eax
          if (new_cwnd > pcb->cwnd) {
  80fcf2:	66 39 c1             	cmp    %ax,%cx
  80fcf5:	0f 83 94 00 00 00    	jae    80fd8f <tcp_receive+0x271>
            pcb->cwnd = new_cwnd;
  80fcfb:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80fcff:	e9 8b 00 00 00       	jmp    80fd8f <tcp_receive+0x271>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80fd04:	8b 77 78             	mov    0x78(%edi),%esi
        pcb->unacked = pcb->unacked->next;
  80fd07:	8b 06                	mov    (%esi),%eax
  80fd09:	89 47 78             	mov    %eax,0x78(%edi)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80fd0c:	0f b7 5f 70          	movzwl 0x70(%edi),%ebx
  80fd10:	8b 46 04             	mov    0x4(%esi),%eax
  80fd13:	89 04 24             	mov    %eax,(%esp)
  80fd16:	e8 15 79 ff ff       	call   807630 <pbuf_clen>
  80fd1b:	0f b6 c0             	movzbl %al,%eax
  80fd1e:	66 39 c3             	cmp    %ax,%bx
  80fd21:	73 1c                	jae    80fd3f <tcp_receive+0x221>
  80fd23:	c7 44 24 08 18 49 81 	movl   $0x814918,0x8(%esp)
  80fd2a:	00 
  80fd2b:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
  80fd32:	00 
  80fd33:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  80fd3a:	e8 6d 0b ff ff       	call   8008ac <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80fd3f:	0f b7 5f 70          	movzwl 0x70(%edi),%ebx
  80fd43:	8b 46 04             	mov    0x4(%esi),%eax
  80fd46:	89 04 24             	mov    %eax,(%esp)
  80fd49:	e8 e2 78 ff ff       	call   807630 <pbuf_clen>
  80fd4e:	0f b6 c0             	movzbl %al,%eax
  80fd51:	66 29 c3             	sub    %ax,%bx
  80fd54:	66 89 5f 70          	mov    %bx,0x70(%edi)
        tcp_seg_free(next);
  80fd58:	89 34 24             	mov    %esi,(%esp)
  80fd5b:	e8 9e 88 ff ff       	call   8085fe <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80fd60:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80fd65:	74 28                	je     80fd8f <tcp_receive+0x271>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80fd67:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80fd6b:	75 22                	jne    80fd8f <tcp_receive+0x271>
  80fd6d:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80fd71:	75 1c                	jne    80fd8f <tcp_receive+0x271>
  80fd73:	c7 44 24 08 40 49 81 	movl   $0x814940,0x8(%esp)
  80fd7a:	00 
  80fd7b:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
  80fd82:	00 
  80fd83:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  80fd8a:	e8 1d 0b ff ff       	call   8008ac <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80fd8f:	8b 47 78             	mov    0x78(%edi),%eax
  80fd92:	85 c0                	test   %eax,%eax
  80fd94:	74 68                	je     80fdfe <tcp_receive+0x2e0>
  80fd96:	8b 40 10             	mov    0x10(%eax),%eax
  80fd99:	8b 40 04             	mov    0x4(%eax),%eax
  80fd9c:	89 04 24             	mov    %eax,(%esp)
  80fd9f:	e8 4c ad ff ff       	call   80aaf0 <ntohl>
  80fda4:	89 c6                	mov    %eax,%esi
  80fda6:	8b 47 78             	mov    0x78(%edi),%eax
  80fda9:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80fdad:	8b 40 10             	mov    0x10(%eax),%eax
  80fdb0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fdb4:	89 04 24             	mov    %eax,(%esp)
  80fdb7:	e8 e9 aa ff ff       	call   80a8a5 <ntohs>
  80fdbc:	a8 01                	test   $0x1,%al
  80fdbe:	75 1b                	jne    80fddb <tcp_receive+0x2bd>
  80fdc0:	8b 47 78             	mov    0x78(%edi),%eax
  80fdc3:	8b 40 10             	mov    0x10(%eax),%eax
  80fdc6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fdca:	89 04 24             	mov    %eax,(%esp)
  80fdcd:	e8 d3 aa ff ff       	call   80a8a5 <ntohs>
  80fdd2:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fdd7:	a8 02                	test   $0x2,%al
  80fdd9:	74 05                	je     80fde0 <tcp_receive+0x2c2>
  80fddb:	b9 01 00 00 00       	mov    $0x1,%ecx
  80fde0:	89 f2                	mov    %esi,%edx
  80fde2:	2b 15 3c e5 b3 00    	sub    0xb3e53c,%edx
  80fde8:	0f b7 c3             	movzwl %bx,%eax
  80fdeb:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  80fdee:	01 c2                	add    %eax,%edx
  80fdf0:	85 d2                	test   %edx,%edx
  80fdf2:	0f 8e 0c ff ff ff    	jle    80fd04 <tcp_receive+0x1e6>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80fdf8:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80fdfc:	75 08                	jne    80fe06 <tcp_receive+0x2e8>
        pcb->rtime = -1;
  80fdfe:	66 c7 47 32 ff ff    	movw   $0xffff,0x32(%edi)
  80fe04:	eb 06                	jmp    80fe0c <tcp_receive+0x2ee>
      else
        pcb->rtime = 0;
  80fe06:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

      pcb->polltmr = 0;
  80fe0c:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80fe10:	e9 b1 00 00 00       	jmp    80fec6 <tcp_receive+0x3a8>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80fe15:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80fe1b:	e9 a6 00 00 00       	jmp    80fec6 <tcp_receive+0x3a8>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80fe20:	8b 77 74             	mov    0x74(%edi),%esi
      pcb->unsent = pcb->unsent->next;
  80fe23:	8b 06                	mov    (%esi),%eax
  80fe25:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80fe28:	0f b7 5f 70          	movzwl 0x70(%edi),%ebx
  80fe2c:	8b 46 04             	mov    0x4(%esi),%eax
  80fe2f:	89 04 24             	mov    %eax,(%esp)
  80fe32:	e8 f9 77 ff ff       	call   807630 <pbuf_clen>
  80fe37:	0f b6 c0             	movzbl %al,%eax
  80fe3a:	66 39 c3             	cmp    %ax,%bx
  80fe3d:	73 1c                	jae    80fe5b <tcp_receive+0x33d>
  80fe3f:	c7 44 24 08 18 49 81 	movl   $0x814918,0x8(%esp)
  80fe46:	00 
  80fe47:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
  80fe4e:	00 
  80fe4f:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  80fe56:	e8 51 0a ff ff       	call   8008ac <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80fe5b:	0f b7 5f 70          	movzwl 0x70(%edi),%ebx
  80fe5f:	8b 46 04             	mov    0x4(%esi),%eax
  80fe62:	89 04 24             	mov    %eax,(%esp)
  80fe65:	e8 c6 77 ff ff       	call   807630 <pbuf_clen>
  80fe6a:	0f b6 c0             	movzbl %al,%eax
  80fe6d:	66 29 c3             	sub    %ax,%bx
  80fe70:	66 89 5f 70          	mov    %bx,0x70(%edi)
      tcp_seg_free(next);
  80fe74:	89 34 24             	mov    %esi,(%esp)
  80fe77:	e8 82 87 ff ff       	call   8085fe <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80fe7c:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80fe81:	74 2b                	je     80feae <tcp_receive+0x390>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80fe83:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80fe87:	75 25                	jne    80feae <tcp_receive+0x390>
  80fe89:	8b 47 74             	mov    0x74(%edi),%eax
  80fe8c:	85 c0                	test   %eax,%eax
  80fe8e:	66 90                	xchg   %ax,%ax
  80fe90:	75 23                	jne    80feb5 <tcp_receive+0x397>
  80fe92:	c7 44 24 08 40 49 81 	movl   $0x814940,0x8(%esp)
  80fe99:	00 
  80fe9a:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
  80fea1:	00 
  80fea2:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  80fea9:	e8 fe 09 ff ff       	call   8008ac <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80feae:	8b 47 74             	mov    0x74(%edi),%eax
  80feb1:	85 c0                	test   %eax,%eax
  80feb3:	74 11                	je     80fec6 <tcp_receive+0x3a8>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80feb5:	8b 40 10             	mov    0x10(%eax),%eax
  80feb8:	8b 40 04             	mov    0x4(%eax),%eax
  80febb:	89 04 24             	mov    %eax,(%esp)
  80febe:	e8 f9 a9 ff ff       	call   80a8bc <htonl>
  80fec3:	89 47 54             	mov    %eax,0x54(%edi)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80fec6:	8b 47 74             	mov    0x74(%edi),%eax
  80fec9:	85 c0                	test   %eax,%eax
  80fecb:	74 72                	je     80ff3f <tcp_receive+0x421>
  80fecd:	8b 35 3c e5 b3 00    	mov    0xb3e53c,%esi
  80fed3:	89 75 f0             	mov    %esi,-0x10(%ebp)
  80fed6:	8b 40 10             	mov    0x10(%eax),%eax
  80fed9:	8b 40 04             	mov    0x4(%eax),%eax
  80fedc:	89 04 24             	mov    %eax,(%esp)
  80fedf:	e8 0c ac ff ff       	call   80aaf0 <ntohl>
  80fee4:	89 c6                	mov    %eax,%esi
  80fee6:	8b 47 74             	mov    0x74(%edi),%eax
  80fee9:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80feed:	8b 40 10             	mov    0x10(%eax),%eax
  80fef0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fef4:	89 04 24             	mov    %eax,(%esp)
  80fef7:	e8 a9 a9 ff ff       	call   80a8a5 <ntohs>
  80fefc:	a8 01                	test   $0x1,%al
  80fefe:	75 1b                	jne    80ff1b <tcp_receive+0x3fd>
  80ff00:	8b 47 74             	mov    0x74(%edi),%eax
  80ff03:	8b 40 10             	mov    0x10(%eax),%eax
  80ff06:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ff0a:	89 04 24             	mov    %eax,(%esp)
  80ff0d:	e8 93 a9 ff ff       	call   80a8a5 <ntohs>
  80ff12:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ff17:	a8 02                	test   $0x2,%al
  80ff19:	74 05                	je     80ff20 <tcp_receive+0x402>
  80ff1b:	b9 01 00 00 00       	mov    $0x1,%ecx
  80ff20:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80ff23:	29 f2                	sub    %esi,%edx
  80ff25:	0f b7 c3             	movzwl %bx,%eax
  80ff28:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  80ff2b:	39 c2                	cmp    %eax,%edx
  80ff2d:	78 10                	js     80ff3f <tcp_receive+0x421>
  80ff2f:	a1 3c e5 b3 00       	mov    0xb3e53c,%eax
  80ff34:	2b 47 58             	sub    0x58(%edi),%eax
  80ff37:	85 c0                	test   %eax,%eax
  80ff39:	0f 8e e1 fe ff ff    	jle    80fe20 <tcp_receive+0x302>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80ff3f:	8b 57 38             	mov    0x38(%edi),%edx
  80ff42:	85 d2                	test   %edx,%edx
  80ff44:	74 55                	je     80ff9b <tcp_receive+0x47d>
  80ff46:	a1 3c e5 b3 00       	mov    0xb3e53c,%eax
  80ff4b:	39 47 3c             	cmp    %eax,0x3c(%edi)
  80ff4e:	79 4b                	jns    80ff9b <tcp_receive+0x47d>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80ff50:	0f b7 5f 40          	movzwl 0x40(%edi),%ebx
  80ff54:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  80ff59:	66 29 d0             	sub    %dx,%ax
  80ff5c:	89 da                	mov    %ebx,%edx
  80ff5e:	66 c1 fa 03          	sar    $0x3,%dx
  80ff62:	66 29 d0             	sub    %dx,%ax
      pcb->sa += m;
  80ff65:	8d 1c 18             	lea    (%eax,%ebx,1),%ebx
  80ff68:	66 89 5f 40          	mov    %bx,0x40(%edi)
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
  80ff6c:	0f b7 57 42          	movzwl 0x42(%edi),%edx
      pcb->sv += m;
  80ff70:	89 d1                	mov    %edx,%ecx
  80ff72:	66 c1 f9 02          	sar    $0x2,%cx
  80ff76:	66 29 ca             	sub    %cx,%dx
  80ff79:	89 c1                	mov    %eax,%ecx
  80ff7b:	66 c1 f9 0f          	sar    $0xf,%cx
  80ff7f:	31 c8                	xor    %ecx,%eax
  80ff81:	66 29 c8             	sub    %cx,%ax
  80ff84:	01 c2                	add    %eax,%edx
  80ff86:	66 89 57 42          	mov    %dx,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80ff8a:	66 c1 fb 03          	sar    $0x3,%bx
  80ff8e:	01 da                	add    %ebx,%edx
  80ff90:	66 89 57 44          	mov    %dx,0x44(%edi)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80ff94:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80ff9b:	0f b7 15 42 e5 b3 00 	movzwl 0xb3e542,%edx
  80ffa2:	66 85 d2             	test   %dx,%dx
  80ffa5:	0f 84 87 07 00 00    	je     810732 <tcp_receive+0xc14>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80ffab:	8b 4f 24             	mov    0x24(%edi),%ecx
  80ffae:	8b 1d 38 e5 b3 00    	mov    0xb3e538,%ebx
  80ffb4:	89 ce                	mov    %ecx,%esi
  80ffb6:	29 de                	sub    %ebx,%esi
  80ffb8:	89 f0                	mov    %esi,%eax
  80ffba:	83 e8 01             	sub    $0x1,%eax
  80ffbd:	0f 88 36 01 00 00    	js     8100f9 <tcp_receive+0x5db>
  80ffc3:	8d 41 01             	lea    0x1(%ecx),%eax
  80ffc6:	29 d8                	sub    %ebx,%eax
  80ffc8:	0f b7 d2             	movzwl %dx,%edx
  80ffcb:	29 d0                	sub    %edx,%eax
  80ffcd:	85 c0                	test   %eax,%eax
  80ffcf:	0f 8f 24 01 00 00    	jg     8100f9 <tcp_receive+0x5db>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
  80ffd5:	8b 1d 20 e5 b3 00    	mov    0xb3e520,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80ffdb:	85 db                	test   %ebx,%ebx
  80ffdd:	75 1c                	jne    80fffb <tcp_receive+0x4dd>
  80ffdf:	c7 44 24 08 9b 4a 81 	movl   $0x814a9b,0x8(%esp)
  80ffe6:	00 
  80ffe7:	c7 44 24 04 e5 03 00 	movl   $0x3e5,0x4(%esp)
  80ffee:	00 
  80ffef:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  80fff6:	e8 b1 08 ff ff       	call   8008ac <_panic>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80fffb:	89 f1                	mov    %esi,%ecx
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80fffd:	81 fe fe 7f 00 00    	cmp    $0x7ffe,%esi
  810003:	7e 1c                	jle    810021 <tcp_receive+0x503>
  810005:	c7 44 24 08 ab 4a 81 	movl   $0x814aab,0x8(%esp)
  81000c:	00 
  81000d:	c7 44 24 04 e6 03 00 	movl   $0x3e6,0x4(%esp)
  810014:	00 
  810015:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  81001c:	e8 8b 08 ff ff       	call   8008ac <_panic>
      if (inseg.p->len < off) {
  810021:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  810025:	39 d6                	cmp    %edx,%esi
  810027:	7e 73                	jle    81009c <tcp_receive+0x57e>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  810029:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  81002d:	0f b7 c6             	movzwl %si,%eax
  810030:	39 c1                	cmp    %eax,%ecx
  810032:	7e 1c                	jle    810050 <tcp_receive+0x532>
  810034:	c7 44 24 08 ba 4a 81 	movl   $0x814aba,0x8(%esp)
  81003b:	00 
  81003c:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  810043:	00 
  810044:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  81004b:	e8 5c 08 ff ff       	call   8008ac <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  810050:	89 f0                	mov    %esi,%eax
  810052:	66 29 c8             	sub    %cx,%ax
        while (p->len < off) {
          off -= p->len;
  810055:	29 d1                	sub    %edx,%ecx
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  810057:	66 89 43 08          	mov    %ax,0x8(%ebx)
          p->len = 0;
  81005b:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  810061:	8b 1b                	mov    (%ebx),%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  810063:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  810067:	39 ca                	cmp    %ecx,%edx
  810069:	7c ea                	jl     810055 <tcp_receive+0x537>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  81006b:	89 c8                	mov    %ecx,%eax
  81006d:	f7 d8                	neg    %eax
  81006f:	98                   	cwtl   
  810070:	89 44 24 04          	mov    %eax,0x4(%esp)
  810074:	89 1c 24             	mov    %ebx,(%esp)
  810077:	e8 8c 76 ff ff       	call   807708 <pbuf_header>
  81007c:	84 c0                	test   %al,%al
  81007e:	74 4d                	je     8100cd <tcp_receive+0x5af>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  810080:	c7 44 24 08 ca 4a 81 	movl   $0x814aca,0x8(%esp)
  810087:	00 
  810088:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp)
  81008f:	00 
  810090:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  810097:	e8 10 08 ff ff       	call   8008ac <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  81009c:	89 f0                	mov    %esi,%eax
  81009e:	f7 d8                	neg    %eax
  8100a0:	98                   	cwtl   
  8100a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8100a5:	89 1c 24             	mov    %ebx,(%esp)
  8100a8:	e8 5b 76 ff ff       	call   807708 <pbuf_header>
  8100ad:	84 c0                	test   %al,%al
  8100af:	74 1c                	je     8100cd <tcp_receive+0x5af>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  8100b1:	c7 44 24 08 ca 4a 81 	movl   $0x814aca,0x8(%esp)
  8100b8:	00 
  8100b9:	c7 44 24 04 fa 03 00 	movl   $0x3fa,0x4(%esp)
  8100c0:	00 
  8100c1:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  8100c8:	e8 df 07 ff ff       	call   8008ac <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  8100cd:	8b 43 04             	mov    0x4(%ebx),%eax
  8100d0:	a3 24 e5 b3 00       	mov    %eax,0xb3e524
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  8100d5:	8b 47 24             	mov    0x24(%edi),%eax
  8100d8:	66 2b 05 38 e5 b3 00 	sub    0xb3e538,%ax
  8100df:	66 29 05 28 e5 b3 00 	sub    %ax,0xb3e528
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  8100e6:	8b 57 24             	mov    0x24(%edi),%edx
  8100e9:	89 15 38 e5 b3 00    	mov    %edx,0xb3e538
  8100ef:	a1 2c e5 b3 00       	mov    0xb3e52c,%eax
  8100f4:	89 50 04             	mov    %edx,0x4(%eax)
  8100f7:	eb 10                	jmp    810109 <tcp_receive+0x5eb>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  8100f9:	39 cb                	cmp    %ecx,%ebx
  8100fb:	79 1d                	jns    81011a <tcp_receive+0x5fc>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  8100fd:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  810101:	89 3c 24             	mov    %edi,(%esp)
  810104:	e8 30 ae ff ff       	call   80af39 <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  810109:	8b 1d 38 e5 b3 00    	mov    0xb3e538,%ebx
  81010f:	8b 4f 24             	mov    0x24(%edi),%ecx
  810112:	39 cb                	cmp    %ecx,%ebx
  810114:	0f 88 05 06 00 00    	js     81071f <tcp_receive+0xc01>
  81011a:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  81011e:	89 da                	mov    %ebx,%edx
  810120:	29 c2                	sub    %eax,%edx
  810122:	8d 42 01             	lea    0x1(%edx),%eax
  810125:	29 c8                	sub    %ecx,%eax
  810127:	85 c0                	test   %eax,%eax
  810129:	0f 8f f0 05 00 00    	jg     81071f <tcp_receive+0xc01>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81012f:	39 cb                	cmp    %ecx,%ebx
  810131:	0f 85 94 03 00 00    	jne    8104cb <tcp_receive+0x9ad>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  810137:	8b 57 7c             	mov    0x7c(%edi),%edx
  81013a:	85 d2                	test   %edx,%edx
  81013c:	0f 84 8a 00 00 00    	je     8101cc <tcp_receive+0x6ae>
  810142:	8b 42 10             	mov    0x10(%edx),%eax
  810145:	8b 48 04             	mov    0x4(%eax),%ecx
  810148:	0f b7 05 28 e5 b3 00 	movzwl 0xb3e528,%eax
  81014f:	89 ce                	mov    %ecx,%esi
  810151:	29 c6                	sub    %eax,%esi
  810153:	89 f0                	mov    %esi,%eax
  810155:	29 d8                	sub    %ebx,%eax
  810157:	85 c0                	test   %eax,%eax
  810159:	7f 71                	jg     8101cc <tcp_receive+0x6ae>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  81015b:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  810160:	74 21                	je     810183 <tcp_receive+0x665>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  810162:	89 c8                	mov    %ecx,%eax
  810164:	66 29 d8             	sub    %bx,%ax
  810167:	66 a3 28 e5 b3 00    	mov    %ax,0xb3e528
            pbuf_realloc(inseg.p, inseg.len);
  81016d:	0f b7 c0             	movzwl %ax,%eax
  810170:	89 44 24 04          	mov    %eax,0x4(%esp)
  810174:	a1 20 e5 b3 00       	mov    0xb3e520,%eax
  810179:	89 04 24             	mov    %eax,(%esp)
  81017c:	e8 81 7a ff ff       	call   807c02 <pbuf_realloc>
  810181:	eb 49                	jmp    8101cc <tcp_receive+0x6ae>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  810183:	a1 2c e5 b3 00       	mov    0xb3e52c,%eax
  810188:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81018c:	89 04 24             	mov    %eax,(%esp)
  81018f:	e8 11 a7 ff ff       	call   80a8a5 <ntohs>
  810194:	89 c3                	mov    %eax,%ebx
  810196:	8b 47 7c             	mov    0x7c(%edi),%eax
  810199:	8b 40 10             	mov    0x10(%eax),%eax
  81019c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8101a0:	89 04 24             	mov    %eax,(%esp)
  8101a3:	e8 fd a6 ff ff       	call   80a8a5 <ntohs>
  8101a8:	89 da                	mov    %ebx,%edx
  8101aa:	83 e2 03             	and    $0x3,%edx
  8101ad:	83 e0 03             	and    $0x3,%eax
  8101b0:	39 c2                	cmp    %eax,%edx
  8101b2:	75 18                	jne    8101cc <tcp_receive+0x6ae>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  8101b4:	8b 57 7c             	mov    0x7c(%edi),%edx
              pcb->ooseq = pcb->ooseq->next;
  8101b7:	8b 02                	mov    (%edx),%eax
  8101b9:	89 47 7c             	mov    %eax,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  8101bc:	89 54 24 04          	mov    %edx,0x4(%esp)
  8101c0:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  8101c7:	e8 3b 71 ff ff       	call   807307 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  8101cc:	0f b7 1d 28 e5 b3 00 	movzwl 0xb3e528,%ebx
  8101d3:	a1 2c e5 b3 00       	mov    0xb3e52c,%eax
  8101d8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8101dc:	89 04 24             	mov    %eax,(%esp)
  8101df:	e8 c1 a6 ff ff       	call   80a8a5 <ntohs>
  8101e4:	a8 01                	test   $0x1,%al
  8101e6:	75 1a                	jne    810202 <tcp_receive+0x6e4>
  8101e8:	a1 2c e5 b3 00       	mov    0xb3e52c,%eax
  8101ed:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8101f1:	89 04 24             	mov    %eax,(%esp)
  8101f4:	e8 ac a6 ff ff       	call   80a8a5 <ntohs>
  8101f9:	ba 00 00 00 00       	mov    $0x0,%edx
  8101fe:	a8 02                	test   $0x2,%al
  810200:	74 05                	je     810207 <tcp_receive+0x6e9>
  810202:	ba 01 00 00 00       	mov    $0x1,%edx
  810207:	8d 14 13             	lea    (%ebx,%edx,1),%edx
  81020a:	66 89 15 42 e5 b3 00 	mov    %dx,0xb3e542

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  810211:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  810215:	74 06                	je     81021d <tcp_receive+0x6ff>
          pcb->rcv_nxt += tcplen;
  810217:	0f b7 c2             	movzwl %dx,%eax
  81021a:	01 47 24             	add    %eax,0x24(%edi)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  81021d:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  810221:	66 39 c2             	cmp    %ax,%dx
  810224:	76 08                	jbe    81022e <tcp_receive+0x710>
          pcb->rcv_wnd = 0;
  810226:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  81022c:	eb 07                	jmp    810235 <tcp_receive+0x717>
        } else {
          pcb->rcv_wnd -= tcplen;
  81022e:	66 29 d0             	sub    %dx,%ax
  810231:	66 89 47 28          	mov    %ax,0x28(%edi)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  810235:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  810239:	66 39 c2             	cmp    %ax,%dx
  81023c:	76 08                	jbe    810246 <tcp_receive+0x728>
          pcb->rcv_ann_wnd = 0;
  81023e:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  810244:	eb 07                	jmp    81024d <tcp_receive+0x72f>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  810246:	66 29 d0             	sub    %dx,%ax
  810249:	66 89 47 2a          	mov    %ax,0x2a(%edi)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  81024d:	a1 20 e5 b3 00       	mov    0xb3e520,%eax
  810252:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  810257:	74 0f                	je     810268 <tcp_receive+0x74a>
          recv_data = inseg.p;
  810259:	a3 48 e5 b3 00       	mov    %eax,0xb3e548
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  81025e:	c7 05 20 e5 b3 00 00 	movl   $0x0,0xb3e520
  810265:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  810268:	a1 2c e5 b3 00       	mov    0xb3e52c,%eax
  81026d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810271:	89 04 24             	mov    %eax,(%esp)
  810274:	e8 2c a6 ff ff       	call   80a8a5 <ntohs>
  810279:	a8 01                	test   $0x1,%al
  81027b:	74 07                	je     810284 <tcp_receive+0x766>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  81027d:	c6 05 44 e5 b3 00 20 	movb   $0x20,0xb3e544
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  810284:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  810287:	85 db                	test   %ebx,%ebx
  810289:	0f 84 09 02 00 00    	je     810498 <tcp_receive+0x97a>
  81028f:	8b 53 10             	mov    0x10(%ebx),%edx
  810292:	8b 42 04             	mov    0x4(%edx),%eax
  810295:	8b 77 24             	mov    0x24(%edi),%esi
  810298:	39 f0                	cmp    %esi,%eax
  81029a:	0f 85 f8 01 00 00    	jne    810498 <tcp_receive+0x97a>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  8102a0:	a3 38 e5 b3 00       	mov    %eax,0xb3e538

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  8102a5:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8102a9:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  8102ad:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  8102b1:	89 04 24             	mov    %eax,(%esp)
  8102b4:	e8 ec a5 ff ff       	call   80a8a5 <ntohs>
  8102b9:	a8 01                	test   $0x1,%al
  8102bb:	75 18                	jne    8102d5 <tcp_receive+0x7b7>
  8102bd:	8b 43 10             	mov    0x10(%ebx),%eax
  8102c0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8102c4:	89 04 24             	mov    %eax,(%esp)
  8102c7:	e8 d9 a5 ff ff       	call   80a8a5 <ntohs>
  8102cc:	ba 00 00 00 00       	mov    $0x0,%edx
  8102d1:	a8 02                	test   $0x2,%al
  8102d3:	74 05                	je     8102da <tcp_receive+0x7bc>
  8102d5:	ba 01 00 00 00       	mov    $0x1,%edx
  8102da:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8102de:	8d 04 02             	lea    (%edx,%eax,1),%eax
  8102e1:	01 f0                	add    %esi,%eax
  8102e3:	89 47 24             	mov    %eax,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  8102e6:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  8102ea:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
  8102ee:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8102f2:	8b 43 10             	mov    0x10(%ebx),%eax
  8102f5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8102f9:	89 04 24             	mov    %eax,(%esp)
  8102fc:	e8 a4 a5 ff ff       	call   80a8a5 <ntohs>
  810301:	a8 01                	test   $0x1,%al
  810303:	75 18                	jne    81031d <tcp_receive+0x7ff>
  810305:	8b 43 10             	mov    0x10(%ebx),%eax
  810308:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81030c:	89 04 24             	mov    %eax,(%esp)
  81030f:	e8 91 a5 ff ff       	call   80a8a5 <ntohs>
  810314:	b9 00 00 00 00       	mov    $0x0,%ecx
  810319:	a8 02                	test   $0x2,%al
  81031b:	74 05                	je     810322 <tcp_receive+0x804>
  81031d:	b9 01 00 00 00       	mov    $0x1,%ecx
  810322:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
  810326:	0f b7 c6             	movzwl %si,%eax
  810329:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  81032c:	39 c2                	cmp    %eax,%edx
  81032e:	7d 08                	jge    810338 <tcp_receive+0x81a>
            pcb->rcv_wnd = 0;
  810330:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  810336:	eb 4a                	jmp    810382 <tcp_receive+0x864>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  810338:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
  81033c:	66 89 4d ea          	mov    %cx,-0x16(%ebp)
  810340:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  810344:	8b 43 10             	mov    0x10(%ebx),%eax
  810347:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81034b:	89 04 24             	mov    %eax,(%esp)
  81034e:	e8 52 a5 ff ff       	call   80a8a5 <ntohs>
  810353:	a8 01                	test   $0x1,%al
  810355:	75 18                	jne    81036f <tcp_receive+0x851>
  810357:	8b 43 10             	mov    0x10(%ebx),%eax
  81035a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81035e:	89 04 24             	mov    %eax,(%esp)
  810361:	e8 3f a5 ff ff       	call   80a8a5 <ntohs>
  810366:	ba 00 00 00 00       	mov    $0x0,%edx
  81036b:	a8 02                	test   $0x2,%al
  81036d:	74 05                	je     810374 <tcp_receive+0x856>
  81036f:	ba 01 00 00 00       	mov    $0x1,%edx
  810374:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
  810378:	66 29 f0             	sub    %si,%ax
  81037b:	66 29 d0             	sub    %dx,%ax
  81037e:	66 89 47 28          	mov    %ax,0x28(%edi)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  810382:	0f b7 77 2a          	movzwl 0x2a(%edi),%esi
  810386:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  81038a:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  81038e:	8b 43 10             	mov    0x10(%ebx),%eax
  810391:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810395:	89 04 24             	mov    %eax,(%esp)
  810398:	e8 08 a5 ff ff       	call   80a8a5 <ntohs>
  81039d:	a8 01                	test   $0x1,%al
  81039f:	75 18                	jne    8103b9 <tcp_receive+0x89b>
  8103a1:	8b 43 10             	mov    0x10(%ebx),%eax
  8103a4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8103a8:	89 04 24             	mov    %eax,(%esp)
  8103ab:	e8 f5 a4 ff ff       	call   80a8a5 <ntohs>
  8103b0:	b9 00 00 00 00       	mov    $0x0,%ecx
  8103b5:	a8 02                	test   $0x2,%al
  8103b7:	74 05                	je     8103be <tcp_receive+0x8a0>
  8103b9:	b9 01 00 00 00       	mov    $0x1,%ecx
  8103be:	0f b7 d6             	movzwl %si,%edx
  8103c1:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
  8103c5:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  8103c8:	39 c2                	cmp    %eax,%edx
  8103ca:	7d 08                	jge    8103d4 <tcp_receive+0x8b6>
            pcb->rcv_ann_wnd = 0;
  8103cc:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  8103d2:	eb 4a                	jmp    81041e <tcp_receive+0x900>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  8103d4:	0f b7 57 2a          	movzwl 0x2a(%edi),%edx
  8103d8:	66 89 55 ee          	mov    %dx,-0x12(%ebp)
  8103dc:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8103e0:	8b 43 10             	mov    0x10(%ebx),%eax
  8103e3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8103e7:	89 04 24             	mov    %eax,(%esp)
  8103ea:	e8 b6 a4 ff ff       	call   80a8a5 <ntohs>
  8103ef:	a8 01                	test   $0x1,%al
  8103f1:	75 18                	jne    81040b <tcp_receive+0x8ed>
  8103f3:	8b 43 10             	mov    0x10(%ebx),%eax
  8103f6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8103fa:	89 04 24             	mov    %eax,(%esp)
  8103fd:	e8 a3 a4 ff ff       	call   80a8a5 <ntohs>
  810402:	ba 00 00 00 00       	mov    $0x0,%edx
  810407:	a8 02                	test   $0x2,%al
  810409:	74 05                	je     810410 <tcp_receive+0x8f2>
  81040b:	ba 01 00 00 00       	mov    $0x1,%edx
  810410:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
  810414:	66 29 f0             	sub    %si,%ax
  810417:	66 29 d0             	sub    %dx,%ax
  81041a:	66 89 47 2a          	mov    %ax,0x2a(%edi)
          }

          if (cseg->p->tot_len > 0) {
  81041e:	8b 43 04             	mov    0x4(%ebx),%eax
  810421:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  810426:	74 24                	je     81044c <tcp_receive+0x92e>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  810428:	8b 15 48 e5 b3 00    	mov    0xb3e548,%edx
  81042e:	85 d2                	test   %edx,%edx
  810430:	74 0e                	je     810440 <tcp_receive+0x922>
              pbuf_cat(recv_data, cseg->p);
  810432:	89 44 24 04          	mov    %eax,0x4(%esp)
  810436:	89 14 24             	mov    %edx,(%esp)
  810439:	e8 25 72 ff ff       	call   807663 <pbuf_cat>
  81043e:	eb 05                	jmp    810445 <tcp_receive+0x927>
            } else {
              recv_data = cseg->p;
  810440:	a3 48 e5 b3 00       	mov    %eax,0xb3e548
            }
            cseg->p = NULL;
  810445:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  81044c:	8b 43 10             	mov    0x10(%ebx),%eax
  81044f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810453:	89 04 24             	mov    %eax,(%esp)
  810456:	e8 4a a4 ff ff       	call   80a8a5 <ntohs>
  81045b:	a8 01                	test   $0x1,%al
  81045d:	74 14                	je     810473 <tcp_receive+0x955>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  81045f:	c6 05 44 e5 b3 00 20 	movb   $0x20,0xb3e544
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  810466:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  81046a:	75 07                	jne    810473 <tcp_receive+0x955>
              pcb->state = CLOSE_WAIT;
  81046c:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
            } 
          }


          pcb->ooseq = cseg->next;
  810473:	8b 03                	mov    (%ebx),%eax
  810475:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  810478:	89 1c 24             	mov    %ebx,(%esp)
  81047b:	e8 7e 81 ff ff       	call   8085fe <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  810480:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  810483:	85 db                	test   %ebx,%ebx
  810485:	74 11                	je     810498 <tcp_receive+0x97a>
  810487:	8b 53 10             	mov    0x10(%ebx),%edx
  81048a:	8b 42 04             	mov    0x4(%edx),%eax
  81048d:	8b 77 24             	mov    0x24(%edi),%esi
  810490:	39 f0                	cmp    %esi,%eax
  810492:	0f 84 08 fe ff ff    	je     8102a0 <tcp_receive+0x782>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  810498:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  81049c:	a8 01                	test   $0x1,%al
  81049e:	74 1b                	je     8104bb <tcp_receive+0x99d>
  8104a0:	83 e0 fe             	and    $0xfffffffe,%eax
  8104a3:	83 c8 02             	or     $0x2,%eax
  8104a6:	88 47 20             	mov    %al,0x20(%edi)
  8104a9:	89 3c 24             	mov    %edi,(%esp)
  8104ac:	e8 88 aa ff ff       	call   80af39 <tcp_output>
  8104b1:	b8 01 00 00 00       	mov    $0x1,%eax
  8104b6:	e9 aa 02 00 00       	jmp    810765 <tcp_receive+0xc47>
  8104bb:	83 c8 01             	or     $0x1,%eax
  8104be:	88 47 20             	mov    %al,0x20(%edi)
  8104c1:	b8 01 00 00 00       	mov    $0x1,%eax
  8104c6:	e9 9a 02 00 00       	jmp    810765 <tcp_receive+0xc47>

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  8104cb:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  8104cf:	89 3c 24             	mov    %edi,(%esp)
  8104d2:	e8 62 aa ff ff       	call   80af39 <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  8104d7:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  8104da:	85 db                	test   %ebx,%ebx
  8104dc:	75 19                	jne    8104f7 <tcp_receive+0x9d9>
          pcb->ooseq = tcp_seg_copy(&inseg);
  8104de:	c7 04 24 1c e5 b3 00 	movl   $0xb3e51c,(%esp)
  8104e5:	e8 cc 80 ff ff       	call   8085b6 <tcp_seg_copy>
  8104ea:	89 47 7c             	mov    %eax,0x7c(%edi)
  8104ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8104f2:	e9 6e 02 00 00       	jmp    810765 <tcp_receive+0xc47>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  8104f7:	8b 0d 38 e5 b3 00    	mov    0xb3e538,%ecx
  8104fd:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  810500:	be 00 00 00 00       	mov    $0x0,%esi
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  810505:	83 c1 01             	add    $0x1,%ecx
  810508:	89 4d dc             	mov    %ecx,-0x24(%ebp)
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  81050b:	8b 43 10             	mov    0x10(%ebx),%eax
  81050e:	8b 50 04             	mov    0x4(%eax),%edx
  810511:	3b 55 d8             	cmp    -0x28(%ebp),%edx
  810514:	0f 85 93 00 00 00    	jne    8105ad <tcp_receive+0xa8f>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  81051a:	0f b7 05 28 e5 b3 00 	movzwl 0xb3e528,%eax
  810521:	66 3b 43 0c          	cmp    0xc(%ebx),%ax
  810525:	0f 86 35 02 00 00    	jbe    810760 <tcp_receive+0xc42>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  81052b:	c7 04 24 1c e5 b3 00 	movl   $0xb3e51c,(%esp)
  810532:	e8 7f 80 ff ff       	call   8085b6 <tcp_seg_copy>
  810537:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  81053a:	85 c0                	test   %eax,%eax
  81053c:	0f 84 1e 02 00 00    	je     810760 <tcp_receive+0xc42>
                  cseg->next = next->next;
  810542:	8b 03                	mov    (%ebx),%eax
  810544:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  810547:	89 02                	mov    %eax,(%edx)
                  if (prev != NULL) {
  810549:	85 f6                	test   %esi,%esi
  81054b:	74 04                	je     810551 <tcp_receive+0xa33>
                    prev->next = cseg;
  81054d:	89 16                	mov    %edx,(%esi)
  81054f:	eb 06                	jmp    810557 <tcp_receive+0xa39>
                  } else {
                    pcb->ooseq = cseg;
  810551:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  810554:	89 4f 7c             	mov    %ecx,0x7c(%edi)
                  }
                  tcp_seg_free(next);
  810557:	89 1c 24             	mov    %ebx,(%esp)
  81055a:	e8 9f 80 ff ff       	call   8085fe <tcp_seg_free>
                  if (cseg->next != NULL) {
  81055f:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  810562:	8b 03                	mov    (%ebx),%eax
  810564:	85 c0                	test   %eax,%eax
  810566:	0f 84 f4 01 00 00    	je     810760 <tcp_receive+0xc42>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  81056c:	8b 0d 38 e5 b3 00    	mov    0xb3e538,%ecx
  810572:	8b 40 10             	mov    0x10(%eax),%eax
  810575:	8b 50 04             	mov    0x4(%eax),%edx
  810578:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  81057c:	29 d0                	sub    %edx,%eax
  81057e:	01 c8                	add    %ecx,%eax
  810580:	85 c0                	test   %eax,%eax
  810582:	0f 8e d8 01 00 00    	jle    810760 <tcp_receive+0xc42>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  810588:	89 d0                	mov    %edx,%eax
  81058a:	66 29 c8             	sub    %cx,%ax
  81058d:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                      pbuf_realloc(cseg->p, cseg->len);
  810591:	0f b7 c0             	movzwl %ax,%eax
  810594:	89 44 24 04          	mov    %eax,0x4(%esp)
  810598:	8b 43 04             	mov    0x4(%ebx),%eax
  81059b:	89 04 24             	mov    %eax,(%esp)
  81059e:	e8 5f 76 ff ff       	call   807c02 <pbuf_realloc>
  8105a3:	b8 00 00 00 00       	mov    $0x0,%eax
  8105a8:	e9 b8 01 00 00       	jmp    810765 <tcp_receive+0xc47>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  8105ad:	85 f6                	test   %esi,%esi
  8105af:	75 5c                	jne    81060d <tcp_receive+0xaef>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  8105b1:	39 55 d8             	cmp    %edx,-0x28(%ebp)
  8105b4:	0f 89 fd 00 00 00    	jns    8106b7 <tcp_receive+0xb99>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  8105ba:	0f b7 05 28 e5 b3 00 	movzwl 0xb3e528,%eax
  8105c1:	03 45 d8             	add    -0x28(%ebp),%eax
  8105c4:	29 d0                	sub    %edx,%eax
  8105c6:	85 c0                	test   %eax,%eax
  8105c8:	7e 20                	jle    8105ea <tcp_receive+0xacc>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  8105ca:	89 d0                	mov    %edx,%eax
  8105cc:	66 2b 45 d8          	sub    -0x28(%ebp),%ax
  8105d0:	66 a3 28 e5 b3 00    	mov    %ax,0xb3e528
                    pbuf_realloc(inseg.p, inseg.len);
  8105d6:	0f b7 c0             	movzwl %ax,%eax
  8105d9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8105dd:	a1 20 e5 b3 00       	mov    0xb3e520,%eax
  8105e2:	89 04 24             	mov    %eax,(%esp)
  8105e5:	e8 18 76 ff ff       	call   807c02 <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
  8105ea:	c7 04 24 1c e5 b3 00 	movl   $0xb3e51c,(%esp)
  8105f1:	e8 c0 7f ff ff       	call   8085b6 <tcp_seg_copy>
                  if (cseg != NULL) {
  8105f6:	85 c0                	test   %eax,%eax
  8105f8:	0f 84 62 01 00 00    	je     810760 <tcp_receive+0xc42>
                    cseg->next = next;
  8105fe:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  810600:	89 47 7c             	mov    %eax,0x7c(%edi)
  810603:	b8 00 00 00 00       	mov    $0x0,%eax
  810608:	e9 58 01 00 00       	jmp    810765 <tcp_receive+0xc47>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  81060d:	8b 46 10             	mov    0x10(%esi),%eax
  810610:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  810613:	2b 48 04             	sub    0x4(%eax),%ecx
  810616:	89 c8                	mov    %ecx,%eax
  810618:	83 e8 01             	sub    $0x1,%eax
  81061b:	0f 88 96 00 00 00    	js     8106b7 <tcp_receive+0xb99>
  810621:	8b 45 dc             	mov    -0x24(%ebp),%eax
  810624:	29 d0                	sub    %edx,%eax
  810626:	85 c0                	test   %eax,%eax
  810628:	0f 8f 89 00 00 00    	jg     8106b7 <tcp_receive+0xb99>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81062e:	0f b7 05 28 e5 b3 00 	movzwl 0xb3e528,%eax
  810635:	03 45 d8             	add    -0x28(%ebp),%eax
  810638:	29 d0                	sub    %edx,%eax
  81063a:	85 c0                	test   %eax,%eax
  81063c:	7e 20                	jle    81065e <tcp_receive+0xb40>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81063e:	89 d0                	mov    %edx,%eax
  810640:	66 2b 45 d8          	sub    -0x28(%ebp),%ax
  810644:	66 a3 28 e5 b3 00    	mov    %ax,0xb3e528
                  pbuf_realloc(inseg.p, inseg.len);
  81064a:	0f b7 c0             	movzwl %ax,%eax
  81064d:	89 44 24 04          	mov    %eax,0x4(%esp)
  810651:	a1 20 e5 b3 00       	mov    0xb3e520,%eax
  810656:	89 04 24             	mov    %eax,(%esp)
  810659:	e8 a4 75 ff ff       	call   807c02 <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
  81065e:	c7 04 24 1c e5 b3 00 	movl   $0xb3e51c,(%esp)
  810665:	e8 4c 7f ff ff       	call   8085b6 <tcp_seg_copy>
                if (cseg != NULL) {
  81066a:	85 c0                	test   %eax,%eax
  81066c:	0f 84 ee 00 00 00    	je     810760 <tcp_receive+0xc42>
                  cseg->next = next;
  810672:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  810674:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  810676:	8b 46 10             	mov    0x10(%esi),%eax
  810679:	8b 48 04             	mov    0x4(%eax),%ecx
  81067c:	8b 15 38 e5 b3 00    	mov    0xb3e538,%edx
  810682:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  810686:	29 d0                	sub    %edx,%eax
  810688:	01 c8                	add    %ecx,%eax
  81068a:	85 c0                	test   %eax,%eax
  81068c:	0f 8e ce 00 00 00    	jle    810760 <tcp_receive+0xc42>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  810692:	89 d0                	mov    %edx,%eax
  810694:	66 29 c8             	sub    %cx,%ax
  810697:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  81069b:	0f b7 c0             	movzwl %ax,%eax
  81069e:	89 44 24 04          	mov    %eax,0x4(%esp)
  8106a2:	8b 46 04             	mov    0x4(%esi),%eax
  8106a5:	89 04 24             	mov    %eax,(%esp)
  8106a8:	e8 55 75 ff ff       	call   807c02 <pbuf_realloc>
  8106ad:	b8 00 00 00 00       	mov    $0x0,%eax
  8106b2:	e9 ae 00 00 00       	jmp    810765 <tcp_receive+0xc47>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  8106b7:	8b 03                	mov    (%ebx),%eax
  8106b9:	89 de                	mov    %ebx,%esi
  8106bb:	85 c0                	test   %eax,%eax
  8106bd:	74 07                	je     8106c6 <tcp_receive+0xba8>
  8106bf:	89 c3                	mov    %eax,%ebx
  8106c1:	e9 45 fe ff ff       	jmp    81050b <tcp_receive+0x9ed>
  8106c6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8106c9:	29 d0                	sub    %edx,%eax
  8106cb:	85 c0                	test   %eax,%eax
  8106cd:	0f 8e 8d 00 00 00    	jle    810760 <tcp_receive+0xc42>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  8106d3:	c7 04 24 1c e5 b3 00 	movl   $0xb3e51c,(%esp)
  8106da:	e8 d7 7e ff ff       	call   8085b6 <tcp_seg_copy>
  8106df:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  8106e1:	85 c0                	test   %eax,%eax
  8106e3:	74 7b                	je     810760 <tcp_receive+0xc42>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  8106e5:	8b 43 10             	mov    0x10(%ebx),%eax
  8106e8:	8b 48 04             	mov    0x4(%eax),%ecx
  8106eb:	8b 15 38 e5 b3 00    	mov    0xb3e538,%edx
  8106f1:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8106f5:	29 d0                	sub    %edx,%eax
  8106f7:	01 c8                	add    %ecx,%eax
  8106f9:	85 c0                	test   %eax,%eax
  8106fb:	7e 63                	jle    810760 <tcp_receive+0xc42>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  8106fd:	89 d0                	mov    %edx,%eax
  8106ff:	66 29 c8             	sub    %cx,%ax
  810702:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  810706:	0f b7 c0             	movzwl %ax,%eax
  810709:	89 44 24 04          	mov    %eax,0x4(%esp)
  81070d:	8b 43 04             	mov    0x4(%ebx),%eax
  810710:	89 04 24             	mov    %eax,(%esp)
  810713:	e8 ea 74 ff ff       	call   807c02 <pbuf_realloc>
  810718:	b8 00 00 00 00       	mov    $0x0,%eax
  81071d:	eb 46                	jmp    810765 <tcp_receive+0xc47>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  81071f:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  810723:	89 3c 24             	mov    %edi,(%esp)
  810726:	e8 0e a8 ff ff       	call   80af39 <tcp_output>
  81072b:	b8 00 00 00 00       	mov    $0x0,%eax
  810730:	eb 33                	jmp    810765 <tcp_receive+0xc47>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  810732:	a1 38 e5 b3 00       	mov    0xb3e538,%eax
  810737:	8b 57 24             	mov    0x24(%edi),%edx
  81073a:	39 d0                	cmp    %edx,%eax
  81073c:	78 0f                	js     81074d <tcp_receive+0xc2f>
  81073e:	83 c0 01             	add    $0x1,%eax
  810741:	29 d0                	sub    %edx,%eax
  810743:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  810747:	29 d0                	sub    %edx,%eax
  810749:	85 c0                	test   %eax,%eax
  81074b:	7e 13                	jle    810760 <tcp_receive+0xc42>
      tcp_ack_now(pcb);
  81074d:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  810751:	89 3c 24             	mov    %edi,(%esp)
  810754:	e8 e0 a7 ff ff       	call   80af39 <tcp_output>
  810759:	b8 00 00 00 00       	mov    $0x0,%eax
  81075e:	eb 05                	jmp    810765 <tcp_receive+0xc47>
  810760:	b8 00 00 00 00       	mov    $0x0,%eax
  810765:	0f b6 c0             	movzbl %al,%eax
    }
  }
  return accepted_inseq;
}
  810768:	83 c4 2c             	add    $0x2c,%esp
  81076b:	5b                   	pop    %ebx
  81076c:	5e                   	pop    %esi
  81076d:	5f                   	pop    %edi
  81076e:	5d                   	pop    %ebp
  81076f:	c3                   	ret    

00810770 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  810770:	55                   	push   %ebp
  810771:	89 e5                	mov    %esp,%ebp
  810773:	57                   	push   %edi
  810774:	56                   	push   %esi
  810775:	53                   	push   %ebx
  810776:	83 ec 5c             	sub    $0x5c,%esp
  810779:	8b 7d 08             	mov    0x8(%ebp),%edi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  81077c:	8b 5f 04             	mov    0x4(%edi),%ebx
  81077f:	89 1d 34 e5 b3 00    	mov    %ebx,0xb3e534
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  810785:	0f b7 03             	movzwl (%ebx),%eax
  810788:	89 04 24             	mov    %eax,(%esp)
  81078b:	e8 15 a1 ff ff       	call   80a8a5 <ntohs>
  810790:	c1 e8 06             	shr    $0x6,%eax
  810793:	83 e0 3c             	and    $0x3c,%eax
  810796:	01 c3                	add    %eax,%ebx
  810798:	89 1d 30 e5 b3 00    	mov    %ebx,0xb3e530
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  81079e:	a1 34 e5 b3 00       	mov    0xb3e534,%eax
  8107a3:	0f b7 00             	movzwl (%eax),%eax
  8107a6:	89 04 24             	mov    %eax,(%esp)
  8107a9:	e8 f7 a0 ff ff       	call   80a8a5 <ntohs>
  8107ae:	c1 e8 06             	shr    $0x6,%eax
  8107b1:	83 e0 3c             	and    $0x3c,%eax
  8107b4:	f7 d8                	neg    %eax
  8107b6:	98                   	cwtl   
  8107b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8107bb:	89 3c 24             	mov    %edi,(%esp)
  8107be:	e8 45 6f ff ff       	call   807708 <pbuf_header>
  8107c3:	84 c0                	test   %al,%al
  8107c5:	75 07                	jne    8107ce <tcp_input+0x5e>
  8107c7:	66 83 7f 08 13       	cmpw   $0x13,0x8(%edi)
  8107cc:	77 0d                	ja     8107db <tcp_input+0x6b>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  8107ce:	89 3c 24             	mov    %edi,(%esp)
  8107d1:	e8 9d 72 ff ff       	call   807a73 <pbuf_free>
  8107d6:	e9 98 0d 00 00       	jmp    811573 <tcp_input+0xe03>
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  8107db:	8b 45 0c             	mov    0xc(%ebp),%eax
  8107de:	89 44 24 04          	mov    %eax,0x4(%esp)
  8107e2:	a1 34 e5 b3 00       	mov    0xb3e534,%eax
  8107e7:	83 c0 10             	add    $0x10,%eax
  8107ea:	89 04 24             	mov    %eax,(%esp)
  8107ed:	e8 9a 8c ff ff       	call   80948c <ip_addr_isbroadcast>
  8107f2:	84 c0                	test   %al,%al
  8107f4:	75 2a                	jne    810820 <tcp_input+0xb0>
  8107f6:	a1 34 e5 b3 00       	mov    0xb3e534,%eax
  8107fb:	8b 58 10             	mov    0x10(%eax),%ebx
  8107fe:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  810805:	e8 e6 a2 ff ff       	call   80aaf0 <ntohl>
  81080a:	89 c6                	mov    %eax,%esi
  81080c:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  810813:	e8 d8 a2 ff ff       	call   80aaf0 <ntohl>
  810818:	89 f2                	mov    %esi,%edx
  81081a:	21 da                	and    %ebx,%edx
  81081c:	39 c2                	cmp    %eax,%edx
  81081e:	75 0d                	jne    81082d <tcp_input+0xbd>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810820:	89 3c 24             	mov    %edi,(%esp)
  810823:	e8 4b 72 ff ff       	call   807a73 <pbuf_free>
  810828:	e9 46 0d 00 00       	jmp    811573 <tcp_input+0xe03>
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81082d:	8b 15 34 e5 b3 00    	mov    0xb3e534,%edx
  810833:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  810837:	89 44 24 10          	mov    %eax,0x10(%esp)
  81083b:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  810842:	00 
  810843:	8d 42 10             	lea    0x10(%edx),%eax
  810846:	89 44 24 08          	mov    %eax,0x8(%esp)
  81084a:	83 c2 0c             	add    $0xc,%edx
  81084d:	89 54 24 04          	mov    %edx,0x4(%esp)
  810851:	89 3c 24             	mov    %edi,(%esp)
  810854:	e8 37 9d ff ff       	call   80a590 <inet_chksum_pseudo>
  810859:	66 85 c0             	test   %ax,%ax
  81085c:	74 0d                	je     81086b <tcp_input+0xfb>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81085e:	89 3c 24             	mov    %edi,(%esp)
  810861:	e8 0d 72 ff ff       	call   807a73 <pbuf_free>
  810866:	e9 08 0d 00 00       	jmp    811573 <tcp_input+0xe03>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  81086b:	a1 30 e5 b3 00       	mov    0xb3e530,%eax
  810870:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810874:	89 04 24             	mov    %eax,(%esp)
  810877:	e8 29 a0 ff ff       	call   80a8a5 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  81087c:	66 c1 e8 0c          	shr    $0xc,%ax
  810880:	0f b6 c0             	movzbl %al,%eax
  810883:	c1 e0 02             	shl    $0x2,%eax
  810886:	f7 d8                	neg    %eax
  810888:	89 44 24 04          	mov    %eax,0x4(%esp)
  81088c:	89 3c 24             	mov    %edi,(%esp)
  81088f:	e8 74 6e ff ff       	call   807708 <pbuf_header>
  810894:	84 c0                	test   %al,%al
  810896:	74 0d                	je     8108a5 <tcp_input+0x135>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810898:	89 3c 24             	mov    %edi,(%esp)
  81089b:	e8 d3 71 ff ff       	call   807a73 <pbuf_free>
  8108a0:	e9 ce 0c 00 00       	jmp    811573 <tcp_input+0xe03>
    return;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  8108a5:	8b 1d 30 e5 b3 00    	mov    0xb3e530,%ebx
  8108ab:	0f b7 03             	movzwl (%ebx),%eax
  8108ae:	89 04 24             	mov    %eax,(%esp)
  8108b1:	e8 ef 9f ff ff       	call   80a8a5 <ntohs>
  8108b6:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  8108b9:	8b 1d 30 e5 b3 00    	mov    0xb3e530,%ebx
  8108bf:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  8108c3:	89 04 24             	mov    %eax,(%esp)
  8108c6:	e8 da 9f ff ff       	call   80a8a5 <ntohs>
  8108cb:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  8108cf:	8b 1d 30 e5 b3 00    	mov    0xb3e530,%ebx
  8108d5:	8b 43 04             	mov    0x4(%ebx),%eax
  8108d8:	89 04 24             	mov    %eax,(%esp)
  8108db:	e8 10 a2 ff ff       	call   80aaf0 <ntohl>
  8108e0:	89 43 04             	mov    %eax,0x4(%ebx)
  8108e3:	a3 38 e5 b3 00       	mov    %eax,0xb3e538
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  8108e8:	8b 1d 30 e5 b3 00    	mov    0xb3e530,%ebx
  8108ee:	8b 43 08             	mov    0x8(%ebx),%eax
  8108f1:	89 04 24             	mov    %eax,(%esp)
  8108f4:	e8 f7 a1 ff ff       	call   80aaf0 <ntohl>
  8108f9:	89 43 08             	mov    %eax,0x8(%ebx)
  8108fc:	a3 3c e5 b3 00       	mov    %eax,0xb3e53c
  tcphdr->wnd = ntohs(tcphdr->wnd);
  810901:	8b 1d 30 e5 b3 00    	mov    0xb3e530,%ebx
  810907:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  81090b:	89 04 24             	mov    %eax,(%esp)
  81090e:	e8 92 9f ff ff       	call   80a8a5 <ntohs>
  810913:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  810917:	a1 30 e5 b3 00       	mov    0xb3e530,%eax
  81091c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810920:	89 04 24             	mov    %eax,(%esp)
  810923:	e8 7d 9f ff ff       	call   80a8a5 <ntohs>
  810928:	83 e0 3f             	and    $0x3f,%eax
  81092b:	88 45 b8             	mov    %al,-0x48(%ebp)
  81092e:	a2 40 e5 b3 00       	mov    %al,0xb3e540
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  810933:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  810937:	b8 01 00 00 00       	mov    $0x1,%eax
  81093c:	f6 45 b8 01          	testb  $0x1,-0x48(%ebp)
  810940:	75 09                	jne    81094b <tcp_input+0x1db>
  810942:	0f b6 45 b8          	movzbl -0x48(%ebp),%eax
  810946:	d1 e8                	shr    %eax
  810948:	83 e0 01             	and    $0x1,%eax
  81094b:	01 c2                	add    %eax,%edx
  81094d:	66 89 55 ce          	mov    %dx,-0x32(%ebp)
  810951:	66 89 15 42 e5 b3 00 	mov    %dx,0xb3e542
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810958:	8b 35 c8 e5 b3 00    	mov    0xb3e5c8,%esi
  81095e:	85 f6                	test   %esi,%esi
  810960:	0f 84 2e 01 00 00    	je     810a94 <tcp_input+0x324>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  810966:	8b 46 10             	mov    0x10(%esi),%eax
  810969:	85 c0                	test   %eax,%eax
  81096b:	74 15                	je     810982 <tcp_input+0x212>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81096d:	83 f8 0a             	cmp    $0xa,%eax
  810970:	74 31                	je     8109a3 <tcp_input+0x233>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  810972:	83 f8 01             	cmp    $0x1,%eax
  810975:	75 6f                	jne    8109e6 <tcp_input+0x276>
  810977:	eb 51                	jmp    8109ca <tcp_input+0x25a>
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  810979:	8b 42 10             	mov    0x10(%edx),%eax
  81097c:	85 c0                	test   %eax,%eax
  81097e:	66 90                	xchg   %ax,%ax
  810980:	75 1c                	jne    81099e <tcp_input+0x22e>
  810982:	c7 44 24 08 60 49 81 	movl   $0x814960,0x8(%esp)
  810989:	00 
  81098a:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  810991:	00 
  810992:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  810999:	e8 0e ff fe ff       	call   8008ac <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81099e:	83 f8 0a             	cmp    $0xa,%eax
  8109a1:	75 1c                	jne    8109bf <tcp_input+0x24f>
  8109a3:	c7 44 24 08 88 49 81 	movl   $0x814988,0x8(%esp)
  8109aa:	00 
  8109ab:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
  8109b2:	00 
  8109b3:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  8109ba:	e8 ed fe fe ff       	call   8008ac <_panic>
  8109bf:	89 f1                	mov    %esi,%ecx
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  8109c1:	83 f8 01             	cmp    $0x1,%eax
  8109c4:	74 04                	je     8109ca <tcp_input+0x25a>
  8109c6:	89 d6                	mov    %edx,%esi
  8109c8:	eb 35                	jmp    8109ff <tcp_input+0x28f>
  8109ca:	c7 44 24 08 b4 49 81 	movl   $0x8149b4,0x8(%esp)
  8109d1:	00 
  8109d2:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  8109d9:	00 
  8109da:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  8109e1:	e8 c6 fe fe ff       	call   8008ac <_panic>
    if (pcb->remote_port == tcphdr->src &&
  8109e6:	8b 15 30 e5 b3 00    	mov    0xb3e530,%edx
  8109ec:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  8109ef:	0f b7 1a             	movzwl (%edx),%ebx
  8109f2:	a1 34 e5 b3 00       	mov    0xb3e534,%eax
  8109f7:	89 45 d0             	mov    %eax,-0x30(%ebp)
  8109fa:	b9 00 00 00 00       	mov    $0x0,%ecx
  8109ff:	66 39 5e 1e          	cmp    %bx,0x1e(%esi)
  810a03:	0f 85 80 00 00 00    	jne    810a89 <tcp_input+0x319>
  810a09:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  810a0d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  810a10:	66 3b 42 02          	cmp    0x2(%edx),%ax
  810a14:	75 73                	jne    810a89 <tcp_input+0x319>
  810a16:	8b 46 04             	mov    0x4(%esi),%eax
  810a19:	8b 55 d0             	mov    -0x30(%ebp),%edx
  810a1c:	3b 42 0c             	cmp    0xc(%edx),%eax
  810a1f:	75 68                	jne    810a89 <tcp_input+0x319>
  810a21:	8b 06                	mov    (%esi),%eax
  810a23:	3b 42 10             	cmp    0x10(%edx),%eax
  810a26:	75 61                	jne    810a89 <tcp_input+0x319>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  810a28:	8b 46 0c             	mov    0xc(%esi),%eax
  810a2b:	39 f0                	cmp    %esi,%eax
  810a2d:	75 1c                	jne    810a4b <tcp_input+0x2db>
  810a2f:	c7 44 24 08 dc 49 81 	movl   $0x8149dc,0x8(%esp)
  810a36:	00 
  810a37:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  810a3e:	00 
  810a3f:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  810a46:	e8 61 fe fe ff       	call   8008ac <_panic>
      if (prev != NULL) {
  810a4b:	85 c9                	test   %ecx,%ecx
  810a4d:	0f 84 d1 0a 00 00    	je     811524 <tcp_input+0xdb4>
        prev->next = pcb->next;
  810a53:	89 41 0c             	mov    %eax,0xc(%ecx)
        pcb->next = tcp_active_pcbs;
  810a56:	a1 c8 e5 b3 00       	mov    0xb3e5c8,%eax
  810a5b:	89 46 0c             	mov    %eax,0xc(%esi)
        tcp_active_pcbs = pcb;
  810a5e:	89 35 c8 e5 b3 00    	mov    %esi,0xb3e5c8
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  810a64:	39 76 0c             	cmp    %esi,0xc(%esi)
  810a67:	0f 85 b2 02 00 00    	jne    810d1f <tcp_input+0x5af>
  810a6d:	c7 44 24 08 08 4a 81 	movl   $0x814a08,0x8(%esp)
  810a74:	00 
  810a75:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
  810a7c:	00 
  810a7d:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  810a84:	e8 23 fe fe ff       	call   8008ac <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810a89:	8b 56 0c             	mov    0xc(%esi),%edx
  810a8c:	85 d2                	test   %edx,%edx
  810a8e:	0f 85 e5 fe ff ff    	jne    810979 <tcp_input+0x209>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810a94:	8b 1d dc e5 b3 00    	mov    0xb3e5dc,%ebx
  810a9a:	85 db                	test   %ebx,%ebx
  810a9c:	0f 84 a5 00 00 00    	je     810b47 <tcp_input+0x3d7>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  810aa2:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  810aa6:	74 26                	je     810ace <tcp_input+0x35e>
  810aa8:	eb 08                	jmp    810ab2 <tcp_input+0x342>
  810aaa:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  810aae:	66 90                	xchg   %ax,%ax
  810ab0:	74 2b                	je     810add <tcp_input+0x36d>
  810ab2:	c7 44 24 08 34 4a 81 	movl   $0x814a34,0x8(%esp)
  810ab9:	00 
  810aba:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
  810ac1:	00 
  810ac2:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  810ac9:	e8 de fd fe ff       	call   8008ac <_panic>
      if (pcb->remote_port == tcphdr->src &&
  810ace:	8b 0d 30 e5 b3 00    	mov    0xb3e530,%ecx
  810ad4:	0f b7 11             	movzwl (%ecx),%edx
  810ad7:	8b 35 34 e5 b3 00    	mov    0xb3e534,%esi
  810add:	66 39 53 1e          	cmp    %dx,0x1e(%ebx)
  810ae1:	75 59                	jne    810b3c <tcp_input+0x3cc>
  810ae3:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  810ae7:	66 3b 41 02          	cmp    0x2(%ecx),%ax
  810aeb:	75 4f                	jne    810b3c <tcp_input+0x3cc>
  810aed:	8b 43 04             	mov    0x4(%ebx),%eax
  810af0:	3b 46 0c             	cmp    0xc(%esi),%eax
  810af3:	75 47                	jne    810b3c <tcp_input+0x3cc>
  810af5:	8b 03                	mov    (%ebx),%eax
  810af7:	3b 46 10             	cmp    0x10(%esi),%eax
  810afa:	75 40                	jne    810b3c <tcp_input+0x3cc>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  810afc:	0f b7 45 ce          	movzwl -0x32(%ebp),%eax
  810b00:	89 c2                	mov    %eax,%edx
  810b02:	03 15 38 e5 b3 00    	add    0xb3e538,%edx
  810b08:	89 d0                	mov    %edx,%eax
  810b0a:	2b 43 24             	sub    0x24(%ebx),%eax
  810b0d:	85 c0                	test   %eax,%eax
  810b0f:	7e 03                	jle    810b14 <tcp_input+0x3a4>
    pcb->rcv_nxt = seqno + tcplen;
  810b11:	89 53 24             	mov    %edx,0x24(%ebx)
  }
  if (tcplen > 0) {
  810b14:	66 83 7d ce 00       	cmpw   $0x0,-0x32(%ebp)
  810b19:	74 0c                	je     810b27 <tcp_input+0x3b7>
    tcp_ack_now(pcb);
  810b1b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810b1f:	89 1c 24             	mov    %ebx,(%esp)
  810b22:	e8 12 a4 ff ff       	call   80af39 <tcp_output>
  }
  return tcp_output(pcb);
  810b27:	89 1c 24             	mov    %ebx,(%esp)
  810b2a:	e8 0a a4 ff ff       	call   80af39 <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  810b2f:	89 3c 24             	mov    %edi,(%esp)
  810b32:	e8 3c 6f ff ff       	call   807a73 <pbuf_free>
  810b37:	e9 37 0a 00 00       	jmp    811573 <tcp_input+0xe03>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810b3c:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  810b3f:	85 db                	test   %ebx,%ebx
  810b41:	0f 85 63 ff ff ff    	jne    810aaa <tcp_input+0x33a>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  810b47:	8b 1d d0 e5 b3 00    	mov    0xb3e5d0,%ebx
  810b4d:	85 db                	test   %ebx,%ebx
  810b4f:	0f 84 69 09 00 00    	je     8114be <tcp_input+0xd4e>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  810b55:	8b 35 34 e5 b3 00    	mov    0xb3e534,%esi
  810b5b:	8b 0d 30 e5 b3 00    	mov    0xb3e530,%ecx
  810b61:	ba 00 00 00 00       	mov    $0x0,%edx
  810b66:	85 db                	test   %ebx,%ebx
  810b68:	74 0f                	je     810b79 <tcp_input+0x409>
  810b6a:	8b 03                	mov    (%ebx),%eax
  810b6c:	85 c0                	test   %eax,%eax
  810b6e:	74 09                	je     810b79 <tcp_input+0x409>
  810b70:	3b 46 10             	cmp    0x10(%esi),%eax
  810b73:	0f 85 92 01 00 00    	jne    810d0b <tcp_input+0x59b>
  810b79:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  810b7d:	66 3b 41 02          	cmp    0x2(%ecx),%ax
  810b81:	0f 85 84 01 00 00    	jne    810d0b <tcp_input+0x59b>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  810b87:	85 d2                	test   %edx,%edx
  810b89:	74 14                	je     810b9f <tcp_input+0x42f>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  810b8b:	8b 43 0c             	mov    0xc(%ebx),%eax
  810b8e:	89 42 0c             	mov    %eax,0xc(%edx)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  810b91:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  810b96:	89 43 0c             	mov    %eax,0xc(%ebx)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  810b99:	89 1d d0 e5 b3 00    	mov    %ebx,0xb3e5d0
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  810b9f:	0f b6 45 b8          	movzbl -0x48(%ebp),%eax
  810ba3:	a8 10                	test   $0x10,%al
  810ba5:	74 40                	je     810be7 <tcp_input+0x477>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  810ba7:	0f b7 01             	movzwl (%ecx),%eax
  810baa:	89 44 24 14          	mov    %eax,0x14(%esp)
  810bae:	0f b7 41 02          	movzwl 0x2(%ecx),%eax
  810bb2:	89 44 24 10          	mov    %eax,0x10(%esp)
  810bb6:	8d 46 0c             	lea    0xc(%esi),%eax
  810bb9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810bbd:	8d 46 10             	lea    0x10(%esi),%eax
  810bc0:	89 44 24 08          	mov    %eax,0x8(%esp)
  810bc4:	0f b7 45 ce          	movzwl -0x32(%ebp),%eax
  810bc8:	03 05 38 e5 b3 00    	add    0xb3e538,%eax
  810bce:	89 44 24 04          	mov    %eax,0x4(%esp)
  810bd2:	a1 3c e5 b3 00       	mov    0xb3e53c,%eax
  810bd7:	83 c0 01             	add    $0x1,%eax
  810bda:	89 04 24             	mov    %eax,(%esp)
  810bdd:	e8 fa a1 ff ff       	call   80addc <tcp_rst>
  810be2:	e9 17 01 00 00       	jmp    810cfe <tcp_input+0x58e>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  810be7:	a8 02                	test   $0x2,%al
  810be9:	0f 84 0f 01 00 00    	je     810cfe <tcp_input+0x58e>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  810bef:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  810bf3:	89 04 24             	mov    %eax,(%esp)
  810bf6:	e8 d4 80 ff ff       	call   808ccf <tcp_alloc>
  810bfb:	89 c6                	mov    %eax,%esi
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  810bfd:	85 c0                	test   %eax,%eax
  810bff:	0f 84 f9 00 00 00    	je     810cfe <tcp_input+0x58e>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  810c05:	8b 15 34 e5 b3 00    	mov    0xb3e534,%edx
  810c0b:	b8 00 00 00 00       	mov    $0x0,%eax
  810c10:	83 fa f0             	cmp    $0xfffffff0,%edx
  810c13:	74 03                	je     810c18 <tcp_input+0x4a8>
  810c15:	8b 42 10             	mov    0x10(%edx),%eax
  810c18:	89 06                	mov    %eax,(%esi)
    npcb->local_port = pcb->local_port;
  810c1a:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  810c1e:	66 89 46 1c          	mov    %ax,0x1c(%esi)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  810c22:	b8 00 00 00 00       	mov    $0x0,%eax
  810c27:	83 fa f4             	cmp    $0xfffffff4,%edx
  810c2a:	74 03                	je     810c2f <tcp_input+0x4bf>
  810c2c:	8b 42 0c             	mov    0xc(%edx),%eax
  810c2f:	89 46 04             	mov    %eax,0x4(%esi)
    npcb->remote_port = tcphdr->src;
  810c32:	8b 0d 30 e5 b3 00    	mov    0xb3e530,%ecx
  810c38:	0f b7 01             	movzwl (%ecx),%eax
  810c3b:	66 89 46 1e          	mov    %ax,0x1e(%esi)
    npcb->state = SYN_RCVD;
  810c3f:	c7 46 10 03 00 00 00 	movl   $0x3,0x10(%esi)
    npcb->rcv_nxt = seqno + 1;
  810c46:	8b 15 38 e5 b3 00    	mov    0xb3e538,%edx
  810c4c:	8d 42 01             	lea    0x1(%edx),%eax
  810c4f:	89 46 24             	mov    %eax,0x24(%esi)
    npcb->snd_wnd = tcphdr->wnd;
  810c52:	0f b7 41 0e          	movzwl 0xe(%ecx),%eax
  810c56:	66 89 46 5c          	mov    %ax,0x5c(%esi)
    npcb->ssthresh = npcb->snd_wnd;
  810c5a:	66 89 46 50          	mov    %ax,0x50(%esi)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  810c5e:	83 ea 01             	sub    $0x1,%edx
  810c61:	89 56 60             	mov    %edx,0x60(%esi)
    npcb->callback_arg = pcb->callback_arg;
  810c64:	8b 43 18             	mov    0x18(%ebx),%eax
  810c67:	89 46 18             	mov    %eax,0x18(%esi)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  810c6a:	8b 43 20             	mov    0x20(%ebx),%eax
  810c6d:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  810c73:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  810c77:	66 25 99 01          	and    $0x199,%ax
  810c7b:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  810c7f:	a1 c8 e5 b3 00       	mov    0xb3e5c8,%eax
  810c84:	89 46 0c             	mov    %eax,0xc(%esi)
  810c87:	89 35 c8 e5 b3 00    	mov    %esi,0xb3e5c8
  810c8d:	e8 9b 3e ff ff       	call   804b2d <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  810c92:	89 f0                	mov    %esi,%eax
  810c94:	e8 d7 ed ff ff       	call   80fa70 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  810c99:	8d 46 04             	lea    0x4(%esi),%eax
  810c9c:	89 44 24 04          	mov    %eax,0x4(%esp)
  810ca0:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  810ca4:	89 04 24             	mov    %eax,(%esp)
  810ca7:	e8 c8 77 ff ff       	call   808474 <tcp_eff_send_mss>
  810cac:	66 89 46 34          	mov    %ax,0x34(%esi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  810cb0:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  810cb7:	e8 00 9c ff ff       	call   80a8bc <htonl>
  810cbc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  810cbf:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  810cc2:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  810cc9:	00 
  810cca:	89 44 24 14          	mov    %eax,0x14(%esp)
  810cce:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  810cd5:	00 
  810cd6:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  810cdd:	00 
  810cde:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810ce5:	00 
  810ce6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810ced:	00 
  810cee:	89 34 24             	mov    %esi,(%esp)
  810cf1:	e8 9f a7 ff ff       	call   80b495 <tcp_enqueue>
    return tcp_output(npcb);
  810cf6:	89 34 24             	mov    %esi,(%esp)
  810cf9:	e8 3b a2 ff ff       	call   80af39 <tcp_output>
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  810cfe:	89 3c 24             	mov    %edi,(%esp)
  810d01:	e8 6d 6d ff ff       	call   807a73 <pbuf_free>
  810d06:	e9 68 08 00 00       	jmp    811573 <tcp_input+0xe03>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  810d0b:	8b 43 0c             	mov    0xc(%ebx),%eax
  810d0e:	85 c0                	test   %eax,%eax
  810d10:	0f 84 a8 07 00 00    	je     8114be <tcp_input+0xd4e>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
        return;
      }
      prev = (struct tcp_pcb *)lpcb;
  810d16:	89 da                	mov    %ebx,%edx
  810d18:	89 c3                	mov    %eax,%ebx
  810d1a:	e9 47 fe ff ff       	jmp    810b66 <tcp_input+0x3f6>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  810d1f:	85 f6                	test   %esi,%esi
  810d21:	0f 84 97 07 00 00    	je     8114be <tcp_input+0xd4e>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  810d27:	c7 05 1c e5 b3 00 00 	movl   $0x0,0xb3e51c
  810d2e:	00 00 00 
    inseg.len = p->tot_len;
  810d31:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  810d35:	66 a3 28 e5 b3 00    	mov    %ax,0xb3e528
    inseg.dataptr = p->payload;
  810d3b:	8b 47 04             	mov    0x4(%edi),%eax
  810d3e:	a3 24 e5 b3 00       	mov    %eax,0xb3e524
    inseg.p = p;
  810d43:	89 3d 20 e5 b3 00    	mov    %edi,0xb3e520
    inseg.tcphdr = tcphdr;
  810d49:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  810d4c:	a3 2c e5 b3 00       	mov    %eax,0xb3e52c

    recv_data = NULL;
  810d51:	c7 05 48 e5 b3 00 00 	movl   $0x0,0xb3e548
  810d58:	00 00 00 
    recv_flags = 0;
  810d5b:	c6 05 44 e5 b3 00 00 	movb   $0x0,0xb3e544

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  810d62:	8b 86 80 00 00 00    	mov    0x80(%esi),%eax
  810d68:	85 c0                	test   %eax,%eax
  810d6a:	74 49                	je     810db5 <tcp_input+0x645>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  810d6c:	8b 96 88 00 00 00    	mov    0x88(%esi),%edx
  810d72:	85 d2                	test   %edx,%edx
  810d74:	74 1e                	je     810d94 <tcp_input+0x624>
  810d76:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  810d7d:	00 
  810d7e:	89 44 24 08          	mov    %eax,0x8(%esp)
  810d82:	89 74 24 04          	mov    %esi,0x4(%esp)
  810d86:	8b 46 18             	mov    0x18(%esi),%eax
  810d89:	89 04 24             	mov    %eax,(%esp)
  810d8c:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  810d8e:	84 c0                	test   %al,%al
  810d90:	74 0a                	je     810d9c <tcp_input+0x62c>
  810d92:	eb 14                	jmp    810da8 <tcp_input+0x638>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  810d94:	89 04 24             	mov    %eax,(%esp)
  810d97:	e8 d7 6c ff ff       	call   807a73 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  810d9c:	c7 86 80 00 00 00 00 	movl   $0x0,0x80(%esi)
  810da3:	00 00 00 
  810da6:	eb 0d                	jmp    810db5 <tcp_input+0x645>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  810da8:	89 3c 24             	mov    %edi,(%esp)
  810dab:	e8 c3 6c ff ff       	call   807a73 <pbuf_free>
  810db0:	e9 be 07 00 00       	jmp    811573 <tcp_input+0xe03>
        return;
      }
    }

    tcp_input_pcb = pcb;
  810db5:	89 35 e4 e5 b3 00    	mov    %esi,0xb3e5e4
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  810dbb:	0f b6 15 40 e5 b3 00 	movzbl 0xb3e540,%edx
  810dc2:	f6 c2 04             	test   $0x4,%dl
  810dc5:	74 68                	je     810e2f <tcp_input+0x6bf>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  810dc7:	8b 4e 10             	mov    0x10(%esi),%ecx
  810dca:	83 f9 02             	cmp    $0x2,%ecx
  810dcd:	75 11                	jne    810de0 <tcp_input+0x670>
      if (ackno == pcb->snd_nxt) {
  810dcf:	8b 46 54             	mov    0x54(%esi),%eax
  810dd2:	3b 05 3c e5 b3 00    	cmp    0xb3e53c,%eax
  810dd8:	0f 85 67 07 00 00    	jne    811545 <tcp_input+0xdd5>
  810dde:	eb 3f                	jmp    810e1f <tcp_input+0x6af>
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  810de0:	a1 38 e5 b3 00       	mov    0xb3e538,%eax
  810de5:	89 c2                	mov    %eax,%edx
  810de7:	2b 56 24             	sub    0x24(%esi),%edx
  810dea:	0f 88 55 07 00 00    	js     811545 <tcp_input+0xdd5>
  810df0:	0f b7 46 28          	movzwl 0x28(%esi),%eax
  810df4:	29 c2                	sub    %eax,%edx
  810df6:	85 d2                	test   %edx,%edx
  810df8:	0f 8f 47 07 00 00    	jg     811545 <tcp_input+0xdd5>
  810dfe:	e9 32 07 00 00       	jmp    811535 <tcp_input+0xdc5>
      }
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  810e03:	c7 44 24 08 64 4a 81 	movl   $0x814a64,0x8(%esp)
  810e0a:	00 
  810e0b:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
  810e12:	00 
  810e13:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  810e1a:	e8 8d fa fe ff       	call   8008ac <_panic>
      recv_flags = TF_RESET;
  810e1f:	c6 05 44 e5 b3 00 08 	movb   $0x8,0xb3e544
      pcb->flags &= ~TF_ACK_DELAY;
  810e26:	80 66 20 fe          	andb   $0xfe,0x20(%esi)
  810e2a:	e9 16 07 00 00       	jmp    811545 <tcp_input+0xdd5>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  810e2f:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  810e34:	89 46 2c             	mov    %eax,0x2c(%esi)
  pcb->keep_cnt_sent = 0;
  810e37:	c6 86 a5 00 00 00 00 	movb   $0x0,0xa5(%esi)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  810e3e:	83 7e 10 09          	cmpl   $0x9,0x10(%esi)
  810e42:	0f 87 0d 05 00 00    	ja     811355 <tcp_input+0xbe5>
  810e48:	8b 46 10             	mov    0x10(%esi),%eax
  810e4b:	ff 24 85 08 4b 81 00 	jmp    *0x814b08(,%eax,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  810e52:	89 d0                	mov    %edx,%eax
  810e54:	83 e0 12             	and    $0x12,%eax
  810e57:	83 f8 12             	cmp    $0x12,%eax
  810e5a:	0f 85 10 01 00 00    	jne    810f70 <tcp_input+0x800>
  810e60:	8b 46 78             	mov    0x78(%esi),%eax
  810e63:	8b 40 10             	mov    0x10(%eax),%eax
  810e66:	8b 40 04             	mov    0x4(%eax),%eax
  810e69:	89 04 24             	mov    %eax,(%esp)
  810e6c:	e8 7f 9c ff ff       	call   80aaf0 <ntohl>
  810e71:	8d 48 01             	lea    0x1(%eax),%ecx
  810e74:	3b 0d 3c e5 b3 00    	cmp    0xb3e53c,%ecx
  810e7a:	0f 85 f0 00 00 00    	jne    810f70 <tcp_input+0x800>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
  810e80:	66 83 46 6e 01       	addw   $0x1,0x6e(%esi)
      pcb->rcv_nxt = seqno + 1;
  810e85:	8b 15 38 e5 b3 00    	mov    0xb3e538,%edx
  810e8b:	8d 42 01             	lea    0x1(%edx),%eax
  810e8e:	89 46 24             	mov    %eax,0x24(%esi)
      pcb->lastack = ackno;
  810e91:	89 4e 48             	mov    %ecx,0x48(%esi)
      pcb->snd_wnd = tcphdr->wnd;
  810e94:	a1 30 e5 b3 00       	mov    0xb3e530,%eax
  810e99:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  810e9d:	66 89 46 5c          	mov    %ax,0x5c(%esi)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  810ea1:	83 ea 01             	sub    $0x1,%edx
  810ea4:	89 56 60             	mov    %edx,0x60(%esi)
      pcb->state = ESTABLISHED;
  810ea7:	c7 46 10 04 00 00 00 	movl   $0x4,0x10(%esi)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  810eae:	89 f0                	mov    %esi,%eax
  810eb0:	e8 bb eb ff ff       	call   80fa70 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  810eb5:	0f b7 56 34          	movzwl 0x34(%esi),%edx
  810eb9:	8d 46 04             	lea    0x4(%esi),%eax
  810ebc:	89 44 24 04          	mov    %eax,0x4(%esp)
  810ec0:	89 14 24             	mov    %edx,(%esp)
  810ec3:	e8 ac 75 ff ff       	call   808474 <tcp_eff_send_mss>
  810ec8:	66 89 46 34          	mov    %ax,0x34(%esi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  810ecc:	0f b7 c0             	movzwl %ax,%eax
  810ecf:	8d 04 80             	lea    (%eax,%eax,4),%eax
  810ed2:	01 c0                	add    %eax,%eax
  810ed4:	66 89 46 50          	mov    %ax,0x50(%esi)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  810ed8:	66 83 7e 4e 01       	cmpw   $0x1,0x4e(%esi)
  810edd:	75 08                	jne    810ee7 <tcp_input+0x777>
  810edf:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  810ee3:	01 c0                	add    %eax,%eax
  810ee5:	eb 04                	jmp    810eeb <tcp_input+0x77b>
  810ee7:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  810eeb:	66 89 46 4e          	mov    %ax,0x4e(%esi)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  810eef:	0f b7 46 70          	movzwl 0x70(%esi),%eax
  810ef3:	66 85 c0             	test   %ax,%ax
  810ef6:	75 1c                	jne    810f14 <tcp_input+0x7a4>
  810ef8:	c7 44 24 08 dd 4a 81 	movl   $0x814add,0x8(%esp)
  810eff:	00 
  810f00:	c7 44 24 04 35 02 00 	movl   $0x235,0x4(%esp)
  810f07:	00 
  810f08:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  810f0f:	e8 98 f9 fe ff       	call   8008ac <_panic>
      --pcb->snd_queuelen;
  810f14:	83 e8 01             	sub    $0x1,%eax
  810f17:	66 89 46 70          	mov    %ax,0x70(%esi)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  810f1b:	8b 56 78             	mov    0x78(%esi),%edx
      pcb->unacked = rseg->next;
  810f1e:	8b 02                	mov    (%edx),%eax
  810f20:	89 46 78             	mov    %eax,0x78(%esi)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  810f23:	85 c0                	test   %eax,%eax
  810f25:	75 08                	jne    810f2f <tcp_input+0x7bf>
        pcb->rtime = -1;
  810f27:	66 c7 46 32 ff ff    	movw   $0xffff,0x32(%esi)
  810f2d:	eb 0a                	jmp    810f39 <tcp_input+0x7c9>
      else {
        pcb->rtime = 0;
  810f2f:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)
        pcb->nrtx = 0;
  810f35:	c6 46 46 00          	movb   $0x0,0x46(%esi)
      }

      tcp_seg_free(rseg);
  810f39:	89 14 24             	mov    %edx,(%esp)
  810f3c:	e8 bd 76 ff ff       	call   8085fe <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  810f41:	8b 96 8c 00 00 00    	mov    0x8c(%esi),%edx
  810f47:	85 d2                	test   %edx,%edx
  810f49:	74 14                	je     810f5f <tcp_input+0x7ef>
  810f4b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810f52:	00 
  810f53:	89 74 24 04          	mov    %esi,0x4(%esp)
  810f57:	8b 46 18             	mov    0x18(%esi),%eax
  810f5a:	89 04 24             	mov    %eax,(%esp)
  810f5d:	ff d2                	call   *%edx
      tcp_ack_now(pcb);
  810f5f:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  810f63:	89 34 24             	mov    %esi,(%esp)
  810f66:	e8 ce 9f ff ff       	call   80af39 <tcp_output>
  810f6b:	e9 d5 05 00 00       	jmp    811545 <tcp_input+0xdd5>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  810f70:	f6 05 40 e5 b3 00 10 	testb  $0x10,0xb3e540
  810f77:	0f 84 c8 05 00 00    	je     811545 <tcp_input+0xdd5>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  810f7d:	8b 0d 30 e5 b3 00    	mov    0xb3e530,%ecx
  810f83:	8b 15 34 e5 b3 00    	mov    0xb3e534,%edx
  810f89:	0f b7 01             	movzwl (%ecx),%eax
  810f8c:	89 44 24 14          	mov    %eax,0x14(%esp)
  810f90:	0f b7 41 02          	movzwl 0x2(%ecx),%eax
  810f94:	89 44 24 10          	mov    %eax,0x10(%esp)
  810f98:	8d 42 0c             	lea    0xc(%edx),%eax
  810f9b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810f9f:	83 c2 10             	add    $0x10,%edx
  810fa2:	89 54 24 08          	mov    %edx,0x8(%esp)
  810fa6:	0f b7 05 42 e5 b3 00 	movzwl 0xb3e542,%eax
  810fad:	03 05 38 e5 b3 00    	add    0xb3e538,%eax
  810fb3:	89 44 24 04          	mov    %eax,0x4(%esp)
  810fb7:	a1 3c e5 b3 00       	mov    0xb3e53c,%eax
  810fbc:	89 04 24             	mov    %eax,(%esp)
  810fbf:	e8 18 9e ff ff       	call   80addc <tcp_rst>
  810fc4:	e9 7c 05 00 00       	jmp    811545 <tcp_input+0xdd5>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  810fc9:	89 d0                	mov    %edx,%eax
  810fcb:	83 e0 14             	and    $0x14,%eax
  810fce:	83 f8 10             	cmp    $0x10,%eax
  810fd1:	0f 85 6e 05 00 00    	jne    811545 <tcp_input+0xdd5>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  810fd7:	8b 1d 3c e5 b3 00    	mov    0xb3e53c,%ebx
  810fdd:	89 d8                	mov    %ebx,%eax
  810fdf:	2b 46 48             	sub    0x48(%esi),%eax
  810fe2:	83 e8 01             	sub    $0x1,%eax
  810fe5:	0f 88 b9 00 00 00    	js     8110a4 <tcp_input+0x934>
  810feb:	89 d8                	mov    %ebx,%eax
  810fed:	2b 46 54             	sub    0x54(%esi),%eax
  810ff0:	85 c0                	test   %eax,%eax
  810ff2:	0f 8f ac 00 00 00    	jg     8110a4 <tcp_input+0x934>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  810ff8:	c7 46 10 04 00 00 00 	movl   $0x4,0x10(%esi)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  810fff:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx
  811005:	85 d2                	test   %edx,%edx
  811007:	75 1c                	jne    811025 <tcp_input+0x8b5>
  811009:	c7 44 24 08 f3 4a 81 	movl   $0x814af3,0x8(%esp)
  811010:	00 
  811011:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
  811018:	00 
  811019:	c7 04 24 84 4a 81 00 	movl   $0x814a84,(%esp)
  811020:	e8 87 f8 fe ff       	call   8008ac <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  811025:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81102c:	00 
  81102d:	89 74 24 04          	mov    %esi,0x4(%esp)
  811031:	8b 46 18             	mov    0x18(%esi),%eax
  811034:	89 04 24             	mov    %eax,(%esp)
  811037:	ff d2                	call   *%edx
        if (err != ERR_OK) {
  811039:	84 c0                	test   %al,%al
  81103b:	74 17                	je     811054 <tcp_input+0x8e4>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  81103d:	89 34 24             	mov    %esi,(%esp)
  811040:	e8 79 7b ff ff       	call   808bbe <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  811045:	c7 05 e4 e5 b3 00 00 	movl   $0x0,0xb3e5e4
  81104c:	00 00 00 
  81104f:	e9 46 04 00 00       	jmp    81149a <tcp_input+0xd2a>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  811054:	0f b7 5e 4e          	movzwl 0x4e(%esi),%ebx
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  811058:	89 f0                	mov    %esi,%eax
  81105a:	e8 bf ea ff ff       	call   80fb1e <tcp_receive>
  81105f:	89 c2                	mov    %eax,%edx

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  811061:	66 83 fb 01          	cmp    $0x1,%bx
  811065:	75 08                	jne    81106f <tcp_input+0x8ff>
  811067:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  81106b:	01 c0                	add    %eax,%eax
  81106d:	eb 04                	jmp    811073 <tcp_input+0x903>
  81106f:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  811073:	66 89 46 4e          	mov    %ax,0x4e(%esi)

        if ((flags & TCP_FIN) && accepted_inseq) {
  811077:	f6 05 40 e5 b3 00 01 	testb  $0x1,0xb3e540
  81107e:	0f 84 c1 04 00 00    	je     811545 <tcp_input+0xdd5>
  811084:	84 d2                	test   %dl,%dl
  811086:	0f 84 b9 04 00 00    	je     811545 <tcp_input+0xdd5>
          tcp_ack_now(pcb);
  81108c:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  811090:	89 34 24             	mov    %esi,(%esp)
  811093:	e8 a1 9e ff ff       	call   80af39 <tcp_output>
          pcb->state = CLOSE_WAIT;
  811098:	c7 46 10 07 00 00 00 	movl   $0x7,0x10(%esi)
  81109f:	e9 a1 04 00 00       	jmp    811545 <tcp_input+0xdd5>
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  8110a4:	8b 0d 30 e5 b3 00    	mov    0xb3e530,%ecx
  8110aa:	8b 15 34 e5 b3 00    	mov    0xb3e534,%edx
  8110b0:	0f b7 01             	movzwl (%ecx),%eax
  8110b3:	89 44 24 14          	mov    %eax,0x14(%esp)
  8110b7:	0f b7 41 02          	movzwl 0x2(%ecx),%eax
  8110bb:	89 44 24 10          	mov    %eax,0x10(%esp)
  8110bf:	8d 42 0c             	lea    0xc(%edx),%eax
  8110c2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8110c6:	83 c2 10             	add    $0x10,%edx
  8110c9:	89 54 24 08          	mov    %edx,0x8(%esp)
  8110cd:	0f b7 05 42 e5 b3 00 	movzwl 0xb3e542,%eax
  8110d4:	03 05 38 e5 b3 00    	add    0xb3e538,%eax
  8110da:	89 44 24 04          	mov    %eax,0x4(%esp)
  8110de:	89 1c 24             	mov    %ebx,(%esp)
  8110e1:	e8 f6 9c ff ff       	call   80addc <tcp_rst>
  8110e6:	e9 5a 04 00 00       	jmp    811545 <tcp_input+0xdd5>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  8110eb:	89 f0                	mov    %esi,%eax
  8110ed:	e8 2c ea ff ff       	call   80fb1e <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  8110f2:	f6 05 40 e5 b3 00 01 	testb  $0x1,0xb3e540
  8110f9:	0f 84 46 04 00 00    	je     811545 <tcp_input+0xdd5>
  8110ff:	84 c0                	test   %al,%al
  811101:	0f 84 3e 04 00 00    	je     811545 <tcp_input+0xdd5>
      tcp_ack_now(pcb);
  811107:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  81110b:	89 34 24             	mov    %esi,(%esp)
  81110e:	e8 26 9e ff ff       	call   80af39 <tcp_output>
      pcb->state = CLOSE_WAIT;
  811113:	c7 46 10 07 00 00 00 	movl   $0x7,0x10(%esi)
  81111a:	e9 26 04 00 00       	jmp    811545 <tcp_input+0xdd5>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  81111f:	89 f0                	mov    %esi,%eax
  811121:	e8 f8 e9 ff ff       	call   80fb1e <tcp_receive>
    if (flags & TCP_FIN) {
  811126:	0f b6 15 40 e5 b3 00 	movzbl 0xb3e540,%edx
  81112d:	0f b6 c2             	movzbl %dl,%eax
  811130:	a8 01                	test   $0x1,%al
  811132:	0f 84 a3 00 00 00    	je     8111db <tcp_input+0xa6b>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  811138:	a8 10                	test   $0x10,%al
  81113a:	0f 84 83 00 00 00    	je     8111c3 <tcp_input+0xa53>
  811140:	8b 46 54             	mov    0x54(%esi),%eax
  811143:	3b 05 3c e5 b3 00    	cmp    0xb3e53c,%eax
  811149:	75 78                	jne    8111c3 <tcp_input+0xa53>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  81114b:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  81114f:	89 34 24             	mov    %esi,(%esp)
  811152:	e8 e2 9d ff ff       	call   80af39 <tcp_output>
        tcp_pcb_purge(pcb);
  811157:	89 34 24             	mov    %esi,(%esp)
  81115a:	e8 23 75 ff ff       	call   808682 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  81115f:	8b 15 c8 e5 b3 00    	mov    0xb3e5c8,%edx
  811165:	39 f2                	cmp    %esi,%edx
  811167:	75 0a                	jne    811173 <tcp_input+0xa03>
  811169:	8b 46 0c             	mov    0xc(%esi),%eax
  81116c:	a3 c8 e5 b3 00       	mov    %eax,0xb3e5c8
  811171:	eb 2a                	jmp    81119d <tcp_input+0xa2d>
  811173:	89 15 d4 e5 b3 00    	mov    %edx,0xb3e5d4
  811179:	85 d2                	test   %edx,%edx
  81117b:	74 20                	je     81119d <tcp_input+0xa2d>
  81117d:	8b 42 0c             	mov    0xc(%edx),%eax
  811180:	85 c0                	test   %eax,%eax
  811182:	0f 84 cd 03 00 00    	je     811555 <tcp_input+0xde5>
  811188:	39 f0                	cmp    %esi,%eax
  81118a:	75 08                	jne    811194 <tcp_input+0xa24>
  81118c:	8b 40 0c             	mov    0xc(%eax),%eax
  81118f:	89 42 0c             	mov    %eax,0xc(%edx)
  811192:	eb 09                	jmp    81119d <tcp_input+0xa2d>
  811194:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  811199:	89 c2                	mov    %eax,%edx
  81119b:	eb e0                	jmp    81117d <tcp_input+0xa0d>
  81119d:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
        pcb->state = TIME_WAIT;
  8111a4:	c7 46 10 0a 00 00 00 	movl   $0xa,0x10(%esi)
        TCP_REG(&tcp_tw_pcbs, pcb);
  8111ab:	a1 dc e5 b3 00       	mov    0xb3e5dc,%eax
  8111b0:	89 46 0c             	mov    %eax,0xc(%esi)
  8111b3:	89 35 dc e5 b3 00    	mov    %esi,0xb3e5dc
  8111b9:	e8 6f 39 ff ff       	call   804b2d <tcp_timer_needed>
  8111be:	e9 82 03 00 00       	jmp    811545 <tcp_input+0xdd5>
      } else {
        tcp_ack_now(pcb);
  8111c3:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  8111c7:	89 34 24             	mov    %esi,(%esp)
  8111ca:	e8 6a 9d ff ff       	call   80af39 <tcp_output>
        pcb->state = CLOSING;
  8111cf:	c7 46 10 08 00 00 00 	movl   $0x8,0x10(%esi)
  8111d6:	e9 6a 03 00 00       	jmp    811545 <tcp_input+0xdd5>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  8111db:	f6 c2 10             	test   $0x10,%dl
  8111de:	0f 84 61 03 00 00    	je     811545 <tcp_input+0xdd5>
  8111e4:	8b 46 54             	mov    0x54(%esi),%eax
  8111e7:	3b 05 3c e5 b3 00    	cmp    0xb3e53c,%eax
  8111ed:	0f 85 52 03 00 00    	jne    811545 <tcp_input+0xdd5>
      pcb->state = FIN_WAIT_2;
  8111f3:	c7 46 10 06 00 00 00 	movl   $0x6,0x10(%esi)
  8111fa:	e9 46 03 00 00       	jmp    811545 <tcp_input+0xdd5>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  8111ff:	89 f0                	mov    %esi,%eax
  811201:	e8 18 e9 ff ff       	call   80fb1e <tcp_receive>
    if (flags & TCP_FIN) {
  811206:	f6 05 40 e5 b3 00 01 	testb  $0x1,0xb3e540
  81120d:	0f 84 32 03 00 00    	je     811545 <tcp_input+0xdd5>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  811213:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  811217:	89 34 24             	mov    %esi,(%esp)
  81121a:	e8 1a 9d ff ff       	call   80af39 <tcp_output>
      tcp_pcb_purge(pcb);
  81121f:	89 34 24             	mov    %esi,(%esp)
  811222:	e8 5b 74 ff ff       	call   808682 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  811227:	8b 15 c8 e5 b3 00    	mov    0xb3e5c8,%edx
  81122d:	39 f2                	cmp    %esi,%edx
  81122f:	75 0a                	jne    81123b <tcp_input+0xacb>
  811231:	8b 46 0c             	mov    0xc(%esi),%eax
  811234:	a3 c8 e5 b3 00       	mov    %eax,0xb3e5c8
  811239:	eb 2a                	jmp    811265 <tcp_input+0xaf5>
  81123b:	89 15 d4 e5 b3 00    	mov    %edx,0xb3e5d4
  811241:	85 d2                	test   %edx,%edx
  811243:	74 20                	je     811265 <tcp_input+0xaf5>
  811245:	8b 42 0c             	mov    0xc(%edx),%eax
  811248:	85 c0                	test   %eax,%eax
  81124a:	0f 84 0f 03 00 00    	je     81155f <tcp_input+0xdef>
  811250:	39 f0                	cmp    %esi,%eax
  811252:	75 08                	jne    81125c <tcp_input+0xaec>
  811254:	8b 40 0c             	mov    0xc(%eax),%eax
  811257:	89 42 0c             	mov    %eax,0xc(%edx)
  81125a:	eb 09                	jmp    811265 <tcp_input+0xaf5>
  81125c:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  811261:	89 c2                	mov    %eax,%edx
  811263:	eb e0                	jmp    811245 <tcp_input+0xad5>
  811265:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
      pcb->state = TIME_WAIT;
  81126c:	c7 46 10 0a 00 00 00 	movl   $0xa,0x10(%esi)
      TCP_REG(&tcp_tw_pcbs, pcb);
  811273:	a1 dc e5 b3 00       	mov    0xb3e5dc,%eax
  811278:	89 46 0c             	mov    %eax,0xc(%esi)
  81127b:	89 35 dc e5 b3 00    	mov    %esi,0xb3e5dc
  811281:	e8 a7 38 ff ff       	call   804b2d <tcp_timer_needed>
  811286:	e9 ba 02 00 00       	jmp    811545 <tcp_input+0xdd5>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  81128b:	89 f0                	mov    %esi,%eax
  81128d:	e8 8c e8 ff ff       	call   80fb1e <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  811292:	f6 05 40 e5 b3 00 10 	testb  $0x10,0xb3e540
  811299:	0f 84 a6 02 00 00    	je     811545 <tcp_input+0xdd5>
  81129f:	8b 46 54             	mov    0x54(%esi),%eax
  8112a2:	3b 05 3c e5 b3 00    	cmp    0xb3e53c,%eax
  8112a8:	0f 85 97 02 00 00    	jne    811545 <tcp_input+0xdd5>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  8112ae:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  8112b2:	89 34 24             	mov    %esi,(%esp)
  8112b5:	e8 7f 9c ff ff       	call   80af39 <tcp_output>
      tcp_pcb_purge(pcb);
  8112ba:	89 34 24             	mov    %esi,(%esp)
  8112bd:	e8 c0 73 ff ff       	call   808682 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  8112c2:	8b 15 c8 e5 b3 00    	mov    0xb3e5c8,%edx
  8112c8:	39 f2                	cmp    %esi,%edx
  8112ca:	75 0a                	jne    8112d6 <tcp_input+0xb66>
  8112cc:	8b 46 0c             	mov    0xc(%esi),%eax
  8112cf:	a3 c8 e5 b3 00       	mov    %eax,0xb3e5c8
  8112d4:	eb 2a                	jmp    811300 <tcp_input+0xb90>
  8112d6:	89 15 d4 e5 b3 00    	mov    %edx,0xb3e5d4
  8112dc:	85 d2                	test   %edx,%edx
  8112de:	74 20                	je     811300 <tcp_input+0xb90>
  8112e0:	8b 42 0c             	mov    0xc(%edx),%eax
  8112e3:	85 c0                	test   %eax,%eax
  8112e5:	0f 84 7e 02 00 00    	je     811569 <tcp_input+0xdf9>
  8112eb:	39 f0                	cmp    %esi,%eax
  8112ed:	75 08                	jne    8112f7 <tcp_input+0xb87>
  8112ef:	8b 40 0c             	mov    0xc(%eax),%eax
  8112f2:	89 42 0c             	mov    %eax,0xc(%edx)
  8112f5:	eb 09                	jmp    811300 <tcp_input+0xb90>
  8112f7:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  8112fc:	89 c2                	mov    %eax,%edx
  8112fe:	eb e0                	jmp    8112e0 <tcp_input+0xb70>
  811300:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
      pcb->state = TIME_WAIT;
  811307:	c7 46 10 0a 00 00 00 	movl   $0xa,0x10(%esi)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81130e:	a1 dc e5 b3 00       	mov    0xb3e5dc,%eax
  811313:	89 46 0c             	mov    %eax,0xc(%esi)
  811316:	89 35 dc e5 b3 00    	mov    %esi,0xb3e5dc
  81131c:	e8 0c 38 ff ff       	call   804b2d <tcp_timer_needed>
  811321:	e9 1f 02 00 00       	jmp    811545 <tcp_input+0xdd5>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  811326:	89 f0                	mov    %esi,%eax
  811328:	e8 f1 e7 ff ff       	call   80fb1e <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81132d:	f6 05 40 e5 b3 00 10 	testb  $0x10,0xb3e540
  811334:	0f 84 0b 02 00 00    	je     811545 <tcp_input+0xdd5>
  81133a:	8b 46 54             	mov    0x54(%esi),%eax
  81133d:	3b 05 3c e5 b3 00    	cmp    0xb3e53c,%eax
  811343:	0f 85 fc 01 00 00    	jne    811545 <tcp_input+0xdd5>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  811349:	c6 05 44 e5 b3 00 10 	movb   $0x10,0xb3e544
  811350:	e9 f0 01 00 00       	jmp    811545 <tcp_input+0xdd5>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  811355:	c7 05 e4 e5 b3 00 00 	movl   $0x0,0xb3e5e4
  81135c:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  81135f:	0f b6 05 44 e5 b3 00 	movzbl 0xb3e544,%eax
  811366:	a8 08                	test   $0x8,%al
  811368:	74 3f                	je     8113a9 <tcp_input+0xc39>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  81136a:	8b 96 98 00 00 00    	mov    0x98(%esi),%edx
  811370:	85 d2                	test   %edx,%edx
  811372:	74 10                	je     811384 <tcp_input+0xc14>
  811374:	c7 44 24 04 fa ff ff 	movl   $0xfffffffa,0x4(%esp)
  81137b:	ff 
  81137c:	8b 46 18             	mov    0x18(%esi),%eax
  81137f:	89 04 24             	mov    %eax,(%esp)
  811382:	ff d2                	call   *%edx
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  811384:	89 74 24 04          	mov    %esi,0x4(%esp)
  811388:	c7 04 24 c8 e5 b3 00 	movl   $0xb3e5c8,(%esp)
  81138f:	e8 67 73 ff ff       	call   8086fb <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  811394:	89 74 24 04          	mov    %esi,0x4(%esp)
  811398:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  81139f:	e8 63 5f ff ff       	call   807307 <memp_free>
  8113a4:	e9 f1 00 00 00       	jmp    81149a <tcp_input+0xd2a>
      } else if (recv_flags & TF_CLOSED) {
  8113a9:	a8 10                	test   $0x10,%al
  8113ab:	74 25                	je     8113d2 <tcp_input+0xc62>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  8113ad:	89 74 24 04          	mov    %esi,0x4(%esp)
  8113b1:	c7 04 24 c8 e5 b3 00 	movl   $0xb3e5c8,(%esp)
  8113b8:	e8 3e 73 ff ff       	call   8086fb <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  8113bd:	89 74 24 04          	mov    %esi,0x4(%esp)
  8113c1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8113c8:	e8 3a 5f ff ff       	call   807307 <memp_free>
  8113cd:	e9 c8 00 00 00       	jmp    81149a <tcp_input+0xd2a>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  8113d2:	0f b7 46 6c          	movzwl 0x6c(%esi),%eax
  8113d6:	66 85 c0             	test   %ax,%ax
  8113d9:	74 21                	je     8113fc <tcp_input+0xc8c>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  8113db:	8b 96 84 00 00 00    	mov    0x84(%esi),%edx
  8113e1:	85 d2                	test   %edx,%edx
  8113e3:	74 17                	je     8113fc <tcp_input+0xc8c>
  8113e5:	0f b7 c0             	movzwl %ax,%eax
  8113e8:	89 44 24 08          	mov    %eax,0x8(%esp)
  8113ec:	89 74 24 04          	mov    %esi,0x4(%esp)
  8113f0:	8b 46 18             	mov    0x18(%esi),%eax
  8113f3:	89 04 24             	mov    %eax,(%esp)
  8113f6:	ff d2                	call   *%edx
  8113f8:	89 c2                	mov    %eax,%edx
  8113fa:	eb 05                	jmp    811401 <tcp_input+0xc91>
  8113fc:	ba 00 00 00 00       	mov    $0x0,%edx
        }
      
        if (recv_data != NULL) {
  811401:	a1 48 e5 b3 00       	mov    0xb3e548,%eax
  811406:	85 c0                	test   %eax,%eax
  811408:	74 53                	je     81145d <tcp_input+0xced>
          if(flags & TCP_PSH) {
  81140a:	f6 05 40 e5 b3 00 08 	testb  $0x8,0xb3e540
  811411:	74 04                	je     811417 <tcp_input+0xca7>
            recv_data->flags |= PBUF_FLAG_PUSH;
  811413:	80 48 0d 01          	orb    $0x1,0xd(%eax)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  811417:	8b 96 88 00 00 00    	mov    0x88(%esi),%edx
  81141d:	85 d2                	test   %edx,%edx
  81141f:	74 20                	je     811441 <tcp_input+0xcd1>
  811421:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  811428:	00 
  811429:	89 44 24 08          	mov    %eax,0x8(%esp)
  81142d:	89 74 24 04          	mov    %esi,0x4(%esp)
  811431:	8b 46 18             	mov    0x18(%esi),%eax
  811434:	89 04 24             	mov    %eax,(%esp)
  811437:	ff d2                	call   *%edx
  811439:	89 c2                	mov    %eax,%edx

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  81143b:	84 c0                	test   %al,%al
  81143d:	75 13                	jne    811452 <tcp_input+0xce2>
  81143f:	eb 1c                	jmp    81145d <tcp_input+0xced>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  811441:	89 04 24             	mov    %eax,(%esp)
  811444:	e8 2a 66 ff ff       	call   807a73 <pbuf_free>
  811449:	ba 00 00 00 00       	mov    $0x0,%edx
  81144e:	66 90                	xchg   %ax,%ax
  811450:	eb 0b                	jmp    81145d <tcp_input+0xced>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  811452:	a1 48 e5 b3 00       	mov    0xb3e548,%eax
  811457:	89 86 80 00 00 00    	mov    %eax,0x80(%esi)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  81145d:	f6 05 44 e5 b3 00 20 	testb  $0x20,0xb3e544
  811464:	74 28                	je     81148e <tcp_input+0xd1e>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  811466:	8b 96 88 00 00 00    	mov    0x88(%esi),%edx
  81146c:	85 d2                	test   %edx,%edx
  81146e:	74 22                	je     811492 <tcp_input+0xd22>
  811470:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  811477:	00 
  811478:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81147f:	00 
  811480:	89 74 24 04          	mov    %esi,0x4(%esp)
  811484:	8b 46 18             	mov    0x18(%esi),%eax
  811487:	89 04 24             	mov    %eax,(%esp)
  81148a:	ff d2                	call   *%edx
  81148c:	89 c2                	mov    %eax,%edx
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  81148e:	84 d2                	test   %dl,%dl
  811490:	75 08                	jne    81149a <tcp_input+0xd2a>
          tcp_output(pcb);
  811492:	89 34 24             	mov    %esi,(%esp)
  811495:	e8 9f 9a ff ff       	call   80af39 <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  81149a:	a1 20 e5 b3 00       	mov    0xb3e520,%eax
  81149f:	85 c0                	test   %eax,%eax
  8114a1:	0f 84 cc 00 00 00    	je     811573 <tcp_input+0xe03>
    {
      pbuf_free(inseg.p);
  8114a7:	89 04 24             	mov    %eax,(%esp)
  8114aa:	e8 c4 65 ff ff       	call   807a73 <pbuf_free>
      inseg.p = NULL;
  8114af:	c7 05 20 e5 b3 00 00 	movl   $0x0,0xb3e520
  8114b6:	00 00 00 
  8114b9:	e9 b5 00 00 00       	jmp    811573 <tcp_input+0xe03>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  8114be:	a1 30 e5 b3 00       	mov    0xb3e530,%eax
  8114c3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8114c7:	89 04 24             	mov    %eax,(%esp)
  8114ca:	e8 d6 93 ff ff       	call   80a8a5 <ntohs>
  8114cf:	a8 04                	test   $0x4,%al
  8114d1:	75 47                	jne    81151a <tcp_input+0xdaa>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  8114d3:	8b 0d 30 e5 b3 00    	mov    0xb3e530,%ecx
  8114d9:	8b 15 34 e5 b3 00    	mov    0xb3e534,%edx
  8114df:	0f b7 01             	movzwl (%ecx),%eax
  8114e2:	89 44 24 14          	mov    %eax,0x14(%esp)
  8114e6:	0f b7 41 02          	movzwl 0x2(%ecx),%eax
  8114ea:	89 44 24 10          	mov    %eax,0x10(%esp)
  8114ee:	8d 42 0c             	lea    0xc(%edx),%eax
  8114f1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8114f5:	83 c2 10             	add    $0x10,%edx
  8114f8:	89 54 24 08          	mov    %edx,0x8(%esp)
  8114fc:	0f b7 05 42 e5 b3 00 	movzwl 0xb3e542,%eax
  811503:	03 05 38 e5 b3 00    	add    0xb3e538,%eax
  811509:	89 44 24 04          	mov    %eax,0x4(%esp)
  81150d:	a1 3c e5 b3 00       	mov    0xb3e53c,%eax
  811512:	89 04 24             	mov    %eax,(%esp)
  811515:	e8 c2 98 ff ff       	call   80addc <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  81151a:	89 3c 24             	mov    %edi,(%esp)
  81151d:	e8 51 65 ff ff       	call   807a73 <pbuf_free>
  811522:	eb 4f                	jmp    811573 <tcp_input+0xe03>
      break;
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  811524:	85 f6                	test   %esi,%esi
  811526:	0f 85 fb f7 ff ff    	jne    810d27 <tcp_input+0x5b7>
  81152c:	8d 74 26 00          	lea    0x0(%esi),%esi
  811530:	e9 5f f5 ff ff       	jmp    810a94 <tcp_input+0x324>
      }
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  811535:	85 c9                	test   %ecx,%ecx
  811537:	0f 85 e2 f8 ff ff    	jne    810e1f <tcp_input+0x6af>
  81153d:	8d 76 00             	lea    0x0(%esi),%esi
  811540:	e9 be f8 ff ff       	jmp    810e03 <tcp_input+0x693>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  811545:	c7 05 e4 e5 b3 00 00 	movl   $0x0,0xb3e5e4
  81154c:	00 00 00 
  81154f:	90                   	nop    
  811550:	e9 0a fe ff ff       	jmp    81135f <tcp_input+0xbef>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
        tcp_pcb_purge(pcb);
        TCP_RMV(&tcp_active_pcbs, pcb);
  811555:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  81155a:	e9 3e fc ff ff       	jmp    81119d <tcp_input+0xa2d>
    tcp_receive(pcb);
    if (flags & TCP_FIN) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  81155f:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  811564:	e9 fc fc ff ff       	jmp    811265 <tcp_input+0xaf5>
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  811569:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  81156e:	e9 8d fd ff ff       	jmp    811300 <tcp_input+0xb90>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  811573:	83 c4 5c             	add    $0x5c,%esp
  811576:	5b                   	pop    %ebx
  811577:	5e                   	pop    %esi
  811578:	5f                   	pop    %edi
  811579:	5d                   	pop    %ebp
  81157a:	c3                   	ret    
  81157b:	00 00                	add    %al,(%eax)
  81157d:	00 00                	add    %al,(%eax)
	...

00811580 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  811580:	55                   	push   %ebp
  811581:	89 e5                	mov    %esp,%ebp
  811583:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->local_ip, ipaddr);
  811586:	ba 00 00 00 00       	mov    $0x0,%edx
  81158b:	85 c0                	test   %eax,%eax
  81158d:	74 02                	je     811591 <raw_bind+0x11>
  81158f:	8b 10                	mov    (%eax),%edx
  811591:	8b 45 08             	mov    0x8(%ebp),%eax
  811594:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
}
  811596:	b8 00 00 00 00       	mov    $0x0,%eax
  81159b:	5d                   	pop    %ebp
  81159c:	c3                   	ret    

0081159d <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81159d:	55                   	push   %ebp
  81159e:	89 e5                	mov    %esp,%ebp
  8115a0:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->remote_ip, ipaddr);
  8115a3:	ba 00 00 00 00       	mov    $0x0,%edx
  8115a8:	85 c0                	test   %eax,%eax
  8115aa:	74 02                	je     8115ae <raw_connect+0x11>
  8115ac:	8b 10                	mov    (%eax),%edx
  8115ae:	8b 45 08             	mov    0x8(%ebp),%eax
  8115b1:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
}
  8115b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8115b9:	5d                   	pop    %ebp
  8115ba:	c3                   	ret    

008115bb <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  8115bb:	55                   	push   %ebp
  8115bc:	89 e5                	mov    %esp,%ebp
  8115be:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  8115c1:	8b 55 0c             	mov    0xc(%ebp),%edx
  8115c4:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  8115c7:	8b 55 10             	mov    0x10(%ebp),%edx
  8115ca:	89 50 18             	mov    %edx,0x18(%eax)
}
  8115cd:	5d                   	pop    %ebp
  8115ce:	c3                   	ret    

008115cf <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  8115cf:	55                   	push   %ebp
  8115d0:	89 e5                	mov    %esp,%ebp
  8115d2:	83 ec 18             	sub    $0x18,%esp
  8115d5:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8115d8:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8115db:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  8115de:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8115e5:	e8 60 5d ff ff       	call   80734a <memp_malloc>
  8115ea:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  8115ec:	85 c0                	test   %eax,%eax
  8115ee:	74 2f                	je     81161f <raw_new+0x50>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  8115f0:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  8115f7:	00 
  8115f8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8115ff:	00 
  811600:	89 04 24             	mov    %eax,(%esp)
  811603:	e8 86 fb fe ff       	call   80118e <memset>
    pcb->protocol = proto;
  811608:	89 f0                	mov    %esi,%eax
  81160a:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  81160d:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  811611:	a1 4c e5 b3 00       	mov    0xb3e54c,%eax
  811616:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  811619:	89 1d 4c e5 b3 00    	mov    %ebx,0xb3e54c
  }
  return pcb;
}
  81161f:	89 d8                	mov    %ebx,%eax
  811621:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  811624:	8b 75 fc             	mov    -0x4(%ebp),%esi
  811627:	89 ec                	mov    %ebp,%esp
  811629:	5d                   	pop    %ebp
  81162a:	c3                   	ret    

0081162b <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  81162b:	55                   	push   %ebp
  81162c:	89 e5                	mov    %esp,%ebp
  81162e:	83 ec 08             	sub    $0x8,%esp
  811631:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  811634:	8b 15 4c e5 b3 00    	mov    0xb3e54c,%edx
  81163a:	39 ca                	cmp    %ecx,%edx
  81163c:	74 06                	je     811644 <raw_remove+0x19>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81163e:	85 d2                	test   %edx,%edx
  811640:	75 0e                	jne    811650 <raw_remove+0x25>
  811642:	eb 21                	jmp    811665 <raw_remove+0x3a>
{
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  811644:	8b 42 0c             	mov    0xc(%edx),%eax
  811647:	a3 4c e5 b3 00       	mov    %eax,0xb3e54c
  81164c:	eb 17                	jmp    811665 <raw_remove+0x3a>
  81164e:	89 c2                	mov    %eax,%edx
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  811650:	8b 42 0c             	mov    0xc(%edx),%eax
  811653:	85 c0                	test   %eax,%eax
  811655:	74 0e                	je     811665 <raw_remove+0x3a>
  811657:	39 c1                	cmp    %eax,%ecx
  811659:	75 f3                	jne    81164e <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  81165b:	8b 41 0c             	mov    0xc(%ecx),%eax
  81165e:	89 42 0c             	mov    %eax,0xc(%edx)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  811661:	85 c0                	test   %eax,%eax
  811663:	75 e9                	jne    81164e <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  811665:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  811669:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811670:	e8 92 5c ff ff       	call   807307 <memp_free>
}
  811675:	c9                   	leave  
  811676:	c3                   	ret    

00811677 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  811677:	55                   	push   %ebp
  811678:	89 e5                	mov    %esp,%ebp
  81167a:	57                   	push   %edi
  81167b:	56                   	push   %esi
  81167c:	53                   	push   %ebx
  81167d:	83 ec 1c             	sub    $0x1c,%esp
  811680:	8b 5d 08             	mov    0x8(%ebp),%ebx
  811683:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  811686:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  81168d:	00 
  81168e:	89 3c 24             	mov    %edi,(%esp)
  811691:	e8 72 60 ff ff       	call   807708 <pbuf_header>
  811696:	84 c0                	test   %al,%al
  811698:	74 39                	je     8116d3 <raw_sendto+0x5c>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  81169a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8116a1:	00 
  8116a2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8116a9:	00 
  8116aa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8116b1:	e8 80 66 ff ff       	call   807d36 <pbuf_alloc>
  8116b6:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  8116b8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8116bd:	85 f6                	test   %esi,%esi
  8116bf:	0f 84 b5 00 00 00    	je     81177a <raw_sendto+0x103>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  8116c5:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8116c9:	89 34 24             	mov    %esi,(%esp)
  8116cc:	e8 10 60 ff ff       	call   8076e1 <pbuf_chain>
  8116d1:	eb 32                	jmp    811705 <raw_sendto+0x8e>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  8116d3:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  8116da:	ff 
  8116db:	89 3c 24             	mov    %edi,(%esp)
  8116de:	e8 25 60 ff ff       	call   807708 <pbuf_header>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  8116e3:	89 fe                	mov    %edi,%esi
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  8116e5:	84 c0                	test   %al,%al
  8116e7:	74 1c                	je     811705 <raw_sendto+0x8e>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  8116e9:	c7 44 24 08 30 4b 81 	movl   $0x814b30,0x8(%esp)
  8116f0:	00 
  8116f1:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  8116f8:	00 
  8116f9:	c7 04 24 56 4b 81 00 	movl   $0x814b56,(%esp)
  811700:	e8 a7 f1 fe ff       	call   8008ac <_panic>
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  811705:	8b 45 10             	mov    0x10(%ebp),%eax
  811708:	89 04 24             	mov    %eax,(%esp)
  81170b:	e8 87 7f ff ff       	call   809697 <ip_route>
  811710:	85 c0                	test   %eax,%eax
  811712:	75 18                	jne    81172c <raw_sendto+0xb5>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  811714:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  811719:	39 fe                	cmp    %edi,%esi
  81171b:	74 5d                	je     81177a <raw_sendto+0x103>
      pbuf_free(q);
  81171d:	89 34 24             	mov    %esi,(%esp)
  811720:	e8 4e 63 ff ff       	call   807a73 <pbuf_free>
  811725:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  81172a:	eb 4e                	jmp    81177a <raw_sendto+0x103>
    }
    return ERR_RTE;
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  81172c:	89 da                	mov    %ebx,%edx
  81172e:	85 db                	test   %ebx,%ebx
  811730:	74 05                	je     811737 <raw_sendto+0xc0>
  811732:	83 3b 00             	cmpl   $0x0,(%ebx)
  811735:	75 03                	jne    81173a <raw_sendto+0xc3>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  811737:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  81173a:	89 44 24 18          	mov    %eax,0x18(%esp)
  81173e:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  811742:	89 44 24 14          	mov    %eax,0x14(%esp)
  811746:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  81174a:	89 44 24 10          	mov    %eax,0x10(%esp)
  81174e:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  811752:	89 44 24 0c          	mov    %eax,0xc(%esp)
  811756:	8b 45 10             	mov    0x10(%ebp),%eax
  811759:	89 44 24 08          	mov    %eax,0x8(%esp)
  81175d:	89 54 24 04          	mov    %edx,0x4(%esp)
  811761:	89 34 24             	mov    %esi,(%esp)
  811764:	e8 77 7d ff ff       	call   8094e0 <ip_output_if>
  811769:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  81176b:	39 fe                	cmp    %edi,%esi
  81176d:	74 08                	je     811777 <raw_sendto+0x100>
    /* free the header */
    pbuf_free(q);
  81176f:	89 34 24             	mov    %esi,(%esp)
  811772:	e8 fc 62 ff ff       	call   807a73 <pbuf_free>
  }
  return err;
  811777:	0f be c3             	movsbl %bl,%eax
}
  81177a:	83 c4 1c             	add    $0x1c,%esp
  81177d:	5b                   	pop    %ebx
  81177e:	5e                   	pop    %esi
  81177f:	5f                   	pop    %edi
  811780:	5d                   	pop    %ebp
  811781:	c3                   	ret    

00811782 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  811782:	55                   	push   %ebp
  811783:	89 e5                	mov    %esp,%ebp
  811785:	83 ec 18             	sub    $0x18,%esp
  811788:	8b 55 08             	mov    0x8(%ebp),%edx
  return raw_sendto(pcb, p, &pcb->remote_ip);
  81178b:	8d 42 04             	lea    0x4(%edx),%eax
  81178e:	89 44 24 08          	mov    %eax,0x8(%esp)
  811792:	8b 45 0c             	mov    0xc(%ebp),%eax
  811795:	89 44 24 04          	mov    %eax,0x4(%esp)
  811799:	89 14 24             	mov    %edx,(%esp)
  81179c:	e8 d6 fe ff ff       	call   811677 <raw_sendto>
  8117a1:	0f be c0             	movsbl %al,%eax
}
  8117a4:	c9                   	leave  
  8117a5:	c3                   	ret    

008117a6 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  8117a6:	55                   	push   %ebp
  8117a7:	89 e5                	mov    %esp,%ebp
  8117a9:	57                   	push   %edi
  8117aa:	56                   	push   %esi
  8117ab:	53                   	push   %ebx
  8117ac:	83 ec 1c             	sub    $0x1c,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  8117af:	8b 45 08             	mov    0x8(%ebp),%eax
  8117b2:	8b 40 04             	mov    0x4(%eax),%eax
  8117b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  proto = IPH_PROTO(iphdr);
  8117b8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8117bc:	89 04 24             	mov    %eax,(%esp)
  8117bf:	e8 e1 90 ff ff       	call   80a8a5 <ntohs>
  8117c4:	66 25 ff 00          	and    $0xff,%ax

  prev = NULL;
  pcb = raw_pcbs;
  8117c8:	8b 1d 4c e5 b3 00    	mov    0xb3e54c,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  8117ce:	85 db                	test   %ebx,%ebx
  8117d0:	74 6f                	je     811841 <raw_input+0x9b>
  8117d2:	bf 00 00 00 00       	mov    $0x0,%edi
    if (pcb->protocol == proto) {
  8117d7:	0f bf f0             	movswl %ax,%esi
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  8117da:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8117dd:	83 c2 0c             	add    $0xc,%edx
  8117e0:	89 55 ec             	mov    %edx,-0x14(%ebp)
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  8117e3:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  8117e7:	39 f0                	cmp    %esi,%eax
  8117e9:	75 49                	jne    811834 <raw_input+0x8e>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  8117eb:	8b 53 14             	mov    0x14(%ebx),%edx
  8117ee:	85 d2                	test   %edx,%edx
  8117f0:	74 42                	je     811834 <raw_input+0x8e>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  8117f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8117f5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8117f9:	8b 45 08             	mov    0x8(%ebp),%eax
  8117fc:	89 44 24 08          	mov    %eax,0x8(%esp)
  811800:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811804:	8b 43 18             	mov    0x18(%ebx),%eax
  811807:	89 04 24             	mov    %eax,(%esp)
  81180a:	ff d2                	call   *%edx
  81180c:	84 c0                	test   %al,%al
  81180e:	74 24                	je     811834 <raw_input+0x8e>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  811810:	b8 01 00 00 00       	mov    $0x1,%eax
  811815:	85 ff                	test   %edi,%edi
  811817:	74 2d                	je     811846 <raw_input+0xa0>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  811819:	8b 43 0c             	mov    0xc(%ebx),%eax
  81181c:	89 47 0c             	mov    %eax,0xc(%edi)
            pcb->next = raw_pcbs;
  81181f:	a1 4c e5 b3 00       	mov    0xb3e54c,%eax
  811824:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  811827:	89 1d 4c e5 b3 00    	mov    %ebx,0xb3e54c
  81182d:	b8 01 00 00 00       	mov    $0x1,%eax
  811832:	eb 12                	jmp    811846 <raw_input+0xa0>
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  811834:	8b 43 0c             	mov    0xc(%ebx),%eax
  811837:	89 df                	mov    %ebx,%edi

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  811839:	85 c0                	test   %eax,%eax
  81183b:	74 04                	je     811841 <raw_input+0x9b>
  81183d:	89 c3                	mov    %eax,%ebx
  81183f:	eb a2                	jmp    8117e3 <raw_input+0x3d>
  811841:	b8 00 00 00 00       	mov    $0x0,%eax
  811846:	0f b6 c0             	movzbl %al,%eax
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  811849:	83 c4 1c             	add    $0x1c,%esp
  81184c:	5b                   	pop    %ebx
  81184d:	5e                   	pop    %esi
  81184e:	5f                   	pop    %edi
  81184f:	5d                   	pop    %ebp
  811850:	c3                   	ret    
	...

00811860 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  811860:	55                   	push   %ebp
  811861:	89 e5                	mov    %esp,%ebp
  811863:	57                   	push   %edi
  811864:	56                   	push   %esi
  811865:	53                   	push   %ebx
  811866:	83 ec 1c             	sub    $0x1c,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  811869:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811870:	00 
  811871:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  811878:	00 
  811879:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811880:	e8 b1 64 ff ff       	call   807d36 <pbuf_alloc>
  811885:	89 c7                	mov    %eax,%edi
                 PBUF_RAM);
  if (q == NULL) {
  811887:	85 c0                	test   %eax,%eax
  811889:	0f 84 d8 00 00 00    	je     811967 <icmp_time_exceeded+0x107>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  81188f:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  811894:	77 1c                	ja     8118b2 <icmp_time_exceeded+0x52>
  811896:	c7 44 24 08 6c 4b 81 	movl   $0x814b6c,0x8(%esp)
  81189d:	00 
  81189e:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
  8118a5:	00 
  8118a6:	c7 04 24 60 4c 81 00 	movl   $0x814c60,(%esp)
  8118ad:	e8 fa ef fe ff       	call   8008ac <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  8118b2:	8b 45 08             	mov    0x8(%ebp),%eax
  8118b5:	8b 70 04             	mov    0x4(%eax),%esi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  8118b8:	8b 5f 04             	mov    0x4(%edi),%ebx
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  8118bb:	0f b7 03             	movzwl (%ebx),%eax
  8118be:	89 04 24             	mov    %eax,(%esp)
  8118c1:	e8 df 8f ff ff       	call   80a8a5 <ntohs>
  8118c6:	0f b6 c0             	movzbl %al,%eax
  8118c9:	80 cc 0b             	or     $0xb,%ah
  8118cc:	89 04 24             	mov    %eax,(%esp)
  8118cf:	e8 bb 8f ff ff       	call   80a88f <htons>
  8118d4:	66 89 03             	mov    %ax,(%ebx)
  ICMPH_CODE_SET(tehdr, t);
  8118d7:	0f b7 c0             	movzwl %ax,%eax
  8118da:	89 04 24             	mov    %eax,(%esp)
  8118dd:	e8 c3 8f ff ff       	call   80a8a5 <ntohs>
  8118e2:	b0 00                	mov    $0x0,%al
  8118e4:	66 0b 45 0c          	or     0xc(%ebp),%ax
  8118e8:	0f b7 c0             	movzwl %ax,%eax
  8118eb:	89 04 24             	mov    %eax,(%esp)
  8118ee:	e8 9c 8f ff ff       	call   80a88f <htons>
  8118f3:	66 89 03             	mov    %ax,(%ebx)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  8118f6:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  8118fd:	00 
  8118fe:	8b 55 08             	mov    0x8(%ebp),%edx
  811901:	8b 42 04             	mov    0x4(%edx),%eax
  811904:	89 44 24 04          	mov    %eax,0x4(%esp)
  811908:	8b 47 04             	mov    0x4(%edi),%eax
  81190b:	83 c0 08             	add    $0x8,%eax
  81190e:	89 04 24             	mov    %eax,(%esp)
  811911:	e8 52 f9 fe ff       	call   801268 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  811916:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  81191c:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
  811920:	89 44 24 04          	mov    %eax,0x4(%esp)
  811924:	89 1c 24             	mov    %ebx,(%esp)
  811927:	e8 4b 8c ff ff       	call   80a577 <inet_chksum>
  81192c:	66 89 43 02          	mov    %ax,0x2(%ebx)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  811930:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811937:	00 
  811938:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  81193f:	00 
  811940:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811947:	00 
  811948:	83 c6 0c             	add    $0xc,%esi
  81194b:	89 74 24 08          	mov    %esi,0x8(%esp)
  81194f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811956:	00 
  811957:	89 3c 24             	mov    %edi,(%esp)
  81195a:	e8 98 7d ff ff       	call   8096f7 <ip_output>
  pbuf_free(q);
  81195f:	89 3c 24             	mov    %edi,(%esp)
  811962:	e8 0c 61 ff ff       	call   807a73 <pbuf_free>
}
  811967:	83 c4 1c             	add    $0x1c,%esp
  81196a:	5b                   	pop    %ebx
  81196b:	5e                   	pop    %esi
  81196c:	5f                   	pop    %edi
  81196d:	5d                   	pop    %ebp
  81196e:	c3                   	ret    

0081196f <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  81196f:	55                   	push   %ebp
  811970:	89 e5                	mov    %esp,%ebp
  811972:	57                   	push   %edi
  811973:	56                   	push   %esi
  811974:	53                   	push   %ebx
  811975:	83 ec 1c             	sub    $0x1c,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  811978:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81197f:	00 
  811980:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  811987:	00 
  811988:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  81198f:	e8 a2 63 ff ff       	call   807d36 <pbuf_alloc>
  811994:	89 c7                	mov    %eax,%edi
                 PBUF_RAM);
  if (q == NULL) {
  811996:	85 c0                	test   %eax,%eax
  811998:	0f 84 d8 00 00 00    	je     811a76 <icmp_dest_unreach+0x107>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  81199e:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  8119a3:	77 1c                	ja     8119c1 <icmp_dest_unreach+0x52>
  8119a5:	c7 44 24 08 6c 4b 81 	movl   $0x814b6c,0x8(%esp)
  8119ac:	00 
  8119ad:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
  8119b4:	00 
  8119b5:	c7 04 24 60 4c 81 00 	movl   $0x814c60,(%esp)
  8119bc:	e8 eb ee fe ff       	call   8008ac <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  8119c1:	8b 45 08             	mov    0x8(%ebp),%eax
  8119c4:	8b 70 04             	mov    0x4(%eax),%esi

  idur = q->payload;
  8119c7:	8b 5f 04             	mov    0x4(%edi),%ebx
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  8119ca:	0f b7 03             	movzwl (%ebx),%eax
  8119cd:	89 04 24             	mov    %eax,(%esp)
  8119d0:	e8 d0 8e ff ff       	call   80a8a5 <ntohs>
  8119d5:	0f b6 c0             	movzbl %al,%eax
  8119d8:	80 cc 03             	or     $0x3,%ah
  8119db:	89 04 24             	mov    %eax,(%esp)
  8119de:	e8 ac 8e ff ff       	call   80a88f <htons>
  8119e3:	66 89 03             	mov    %ax,(%ebx)
  ICMPH_CODE_SET(idur, t);
  8119e6:	0f b7 c0             	movzwl %ax,%eax
  8119e9:	89 04 24             	mov    %eax,(%esp)
  8119ec:	e8 b4 8e ff ff       	call   80a8a5 <ntohs>
  8119f1:	b0 00                	mov    $0x0,%al
  8119f3:	66 0b 45 0c          	or     0xc(%ebp),%ax
  8119f7:	0f b7 c0             	movzwl %ax,%eax
  8119fa:	89 04 24             	mov    %eax,(%esp)
  8119fd:	e8 8d 8e ff ff       	call   80a88f <htons>
  811a02:	66 89 03             	mov    %ax,(%ebx)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  811a05:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  811a0c:	00 
  811a0d:	8b 55 08             	mov    0x8(%ebp),%edx
  811a10:	8b 42 04             	mov    0x4(%edx),%eax
  811a13:	89 44 24 04          	mov    %eax,0x4(%esp)
  811a17:	8b 47 04             	mov    0x4(%edi),%eax
  811a1a:	83 c0 08             	add    $0x8,%eax
  811a1d:	89 04 24             	mov    %eax,(%esp)
  811a20:	e8 43 f8 fe ff       	call   801268 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  811a25:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
  idur->chksum = inet_chksum(idur, q->len);
  811a2b:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
  811a2f:	89 44 24 04          	mov    %eax,0x4(%esp)
  811a33:	89 1c 24             	mov    %ebx,(%esp)
  811a36:	e8 3c 8b ff ff       	call   80a577 <inet_chksum>
  811a3b:	66 89 43 02          	mov    %ax,0x2(%ebx)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  811a3f:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811a46:	00 
  811a47:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  811a4e:	00 
  811a4f:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811a56:	00 
  811a57:	83 c6 0c             	add    $0xc,%esi
  811a5a:	89 74 24 08          	mov    %esi,0x8(%esp)
  811a5e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811a65:	00 
  811a66:	89 3c 24             	mov    %edi,(%esp)
  811a69:	e8 89 7c ff ff       	call   8096f7 <ip_output>
  pbuf_free(q);
  811a6e:	89 3c 24             	mov    %edi,(%esp)
  811a71:	e8 fd 5f ff ff       	call   807a73 <pbuf_free>
}
  811a76:	83 c4 1c             	add    $0x1c,%esp
  811a79:	5b                   	pop    %ebx
  811a7a:	5e                   	pop    %esi
  811a7b:	5f                   	pop    %edi
  811a7c:	5d                   	pop    %ebp
  811a7d:	c3                   	ret    

00811a7e <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  811a7e:	55                   	push   %ebp
  811a7f:	89 e5                	mov    %esp,%ebp
  811a81:	83 ec 48             	sub    $0x48,%esp
  811a84:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  811a87:	89 75 f8             	mov    %esi,-0x8(%ebp)
  811a8a:	89 7d fc             	mov    %edi,-0x4(%ebp)
  811a8d:	8b 75 08             	mov    0x8(%ebp),%esi

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  811a90:	8b 7e 04             	mov    0x4(%esi),%edi
  hlen = IPH_HL(iphdr) * 4;
  811a93:	0f b7 07             	movzwl (%edi),%eax
  811a96:	89 04 24             	mov    %eax,(%esp)
  811a99:	e8 07 8e ff ff       	call   80a8a5 <ntohs>
  811a9e:	c1 e8 06             	shr    $0x6,%eax
  811aa1:	83 e0 3c             	and    $0x3c,%eax
  811aa4:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  811aa8:	f7 d8                	neg    %eax
  811aaa:	0f bf d8             	movswl %ax,%ebx
  811aad:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811ab1:	89 34 24             	mov    %esi,(%esp)
  811ab4:	e8 4f 5c ff ff       	call   807708 <pbuf_header>
  811ab9:	84 c0                	test   %al,%al
  811abb:	0f 85 00 03 00 00    	jne    811dc1 <icmp_input+0x343>
  811ac1:	66 83 7e 08 03       	cmpw   $0x3,0x8(%esi)
  811ac6:	0f 86 f5 02 00 00    	jbe    811dc1 <icmp_input+0x343>

  type = *((u8_t *)p->payload);
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  811acc:	8b 46 04             	mov    0x4(%esi),%eax
  811acf:	80 38 08             	cmpb   $0x8,(%eax)
  811ad2:	0f 85 df 02 00 00    	jne    811db7 <icmp_input+0x339>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  811ad8:	8b 45 0c             	mov    0xc(%ebp),%eax
  811adb:	89 44 24 04          	mov    %eax,0x4(%esp)
  811adf:	8d 47 10             	lea    0x10(%edi),%eax
  811ae2:	89 04 24             	mov    %eax,(%esp)
  811ae5:	e8 a2 79 ff ff       	call   80948c <ip_addr_isbroadcast>
  811aea:	84 c0                	test   %al,%al
  811aec:	75 2b                	jne    811b19 <icmp_input+0x9b>
  811aee:	8b 57 10             	mov    0x10(%edi),%edx
  811af1:	89 55 d8             	mov    %edx,-0x28(%ebp)
  811af4:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  811afb:	e8 f0 8f ff ff       	call   80aaf0 <ntohl>
  811b00:	89 45 dc             	mov    %eax,-0x24(%ebp)
  811b03:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  811b0a:	e8 e1 8f ff ff       	call   80aaf0 <ntohl>
  811b0f:	8b 55 dc             	mov    -0x24(%ebp),%edx
  811b12:	23 55 d8             	and    -0x28(%ebp),%edx
  811b15:	39 c2                	cmp    %eax,%edx
  811b17:	75 0d                	jne    811b26 <icmp_input+0xa8>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  811b19:	89 34 24             	mov    %esi,(%esp)
  811b1c:	e8 52 5f ff ff       	call   807a73 <pbuf_free>
  811b21:	e9 ad 02 00 00       	jmp    811dd3 <icmp_input+0x355>
      return;
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  811b26:	66 83 7e 08 07       	cmpw   $0x7,0x8(%esi)
  811b2b:	0f 86 90 02 00 00    	jbe    811dc1 <icmp_input+0x343>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  811b31:	89 34 24             	mov    %esi,(%esp)
  811b34:	e8 b5 89 ff ff       	call   80a4ee <inet_chksum_pbuf>
  811b39:	66 85 c0             	test   %ax,%ax
  811b3c:	74 0d                	je     811b4b <icmp_input+0xcd>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  811b3e:	89 34 24             	mov    %esi,(%esp)
  811b41:	e8 2d 5f ff ff       	call   807a73 <pbuf_free>
  811b46:	e9 88 02 00 00       	jmp    811dd3 <icmp_input+0x355>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  811b4b:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  811b52:	00 
  811b53:	89 34 24             	mov    %esi,(%esp)
  811b56:	e8 ad 5b ff ff       	call   807708 <pbuf_header>
  811b5b:	84 c0                	test   %al,%al
  811b5d:	0f 84 f0 00 00 00    	je     811c53 <icmp_input+0x1d5>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  811b63:	0f bf 45 ea          	movswl -0x16(%ebp),%eax
  811b67:	89 44 24 04          	mov    %eax,0x4(%esp)
  811b6b:	89 34 24             	mov    %esi,(%esp)
  811b6e:	e8 95 5b ff ff       	call   807708 <pbuf_header>
  811b73:	84 c0                	test   %al,%al
  811b75:	74 1c                	je     811b93 <icmp_input+0x115>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  811b77:	c7 44 24 08 98 4b 81 	movl   $0x814b98,0x8(%esp)
  811b7e:	00 
  811b7f:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  811b86:	00 
  811b87:	c7 04 24 60 4c 81 00 	movl   $0x814c60,(%esp)
  811b8e:	e8 19 ed fe ff       	call   8008ac <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  811b93:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811b9a:	00 
  811b9b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811b9f:	89 44 24 04          	mov    %eax,0x4(%esp)
  811ba3:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  811baa:	e8 87 61 ff ff       	call   807d36 <pbuf_alloc>
  811baf:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if (r == NULL) {
  811bb2:	85 c0                	test   %eax,%eax
  811bb4:	0f 84 11 02 00 00    	je     811dcb <icmp_input+0x34d>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  811bba:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  811bbe:	0f bf 45 ea          	movswl -0x16(%ebp),%eax
  811bc2:	83 c0 08             	add    $0x8,%eax
  811bc5:	39 c2                	cmp    %eax,%edx
  811bc7:	73 1c                	jae    811be5 <icmp_input+0x167>
  811bc9:	c7 44 24 08 cc 4b 81 	movl   $0x814bcc,0x8(%esp)
  811bd0:	00 
  811bd1:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  811bd8:	00 
  811bd9:	c7 04 24 60 4c 81 00 	movl   $0x814c60,(%esp)
  811be0:	e8 c7 ec fe ff       	call   8008ac <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  811be5:	89 74 24 04          	mov    %esi,0x4(%esp)
  811be9:	8b 45 ec             	mov    -0x14(%ebp),%eax
  811bec:	89 04 24             	mov    %eax,(%esp)
  811bef:	e8 d8 5c ff ff       	call   8078cc <pbuf_copy>
  811bf4:	84 c0                	test   %al,%al
  811bf6:	74 1c                	je     811c14 <icmp_input+0x196>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  811bf8:	c7 44 24 08 04 4c 81 	movl   $0x814c04,0x8(%esp)
  811bff:	00 
  811c00:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
  811c07:	00 
  811c08:	c7 04 24 60 4c 81 00 	movl   $0x814c60,(%esp)
  811c0f:	e8 98 ec fe ff       	call   8008ac <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  811c14:	8b 55 ec             	mov    -0x14(%ebp),%edx
  811c17:	8b 7a 04             	mov    0x4(%edx),%edi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  811c1a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811c1e:	89 14 24             	mov    %edx,(%esp)
  811c21:	e8 e2 5a ff ff       	call   807708 <pbuf_header>
  811c26:	84 c0                	test   %al,%al
  811c28:	74 1c                	je     811c46 <icmp_input+0x1c8>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  811c2a:	c7 44 24 08 2c 4c 81 	movl   $0x814c2c,0x8(%esp)
  811c31:	00 
  811c32:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  811c39:	00 
  811c3a:	c7 04 24 60 4c 81 00 	movl   $0x814c60,(%esp)
  811c41:	e8 66 ec fe ff       	call   8008ac <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  811c46:	89 34 24             	mov    %esi,(%esp)
  811c49:	e8 25 5e ff ff       	call   807a73 <pbuf_free>
  811c4e:	8b 75 ec             	mov    -0x14(%ebp),%esi
  811c51:	eb 30                	jmp    811c83 <icmp_input+0x205>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  811c53:	c7 44 24 04 de ff ff 	movl   $0xffffffde,0x4(%esp)
  811c5a:	ff 
  811c5b:	89 34 24             	mov    %esi,(%esp)
  811c5e:	e8 a5 5a ff ff       	call   807708 <pbuf_header>
  811c63:	84 c0                	test   %al,%al
  811c65:	74 1c                	je     811c83 <icmp_input+0x205>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  811c67:	c7 44 24 08 2c 4c 81 	movl   $0x814c2c,0x8(%esp)
  811c6e:	00 
  811c6f:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  811c76:	00 
  811c77:	c7 04 24 60 4c 81 00 	movl   $0x814c60,(%esp)
  811c7e:	e8 29 ec fe ff       	call   8008ac <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  811c83:	8b 46 04             	mov    0x4(%esi),%eax
  811c86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tmpaddr.addr = iphdr->src.addr;
  811c89:	8b 57 0c             	mov    0xc(%edi),%edx
    iphdr->src.addr = iphdr->dest.addr;
  811c8c:	8b 47 10             	mov    0x10(%edi),%eax
  811c8f:	89 47 0c             	mov    %eax,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  811c92:	89 57 10             	mov    %edx,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  811c95:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  811c98:	0f b7 02             	movzwl (%edx),%eax
  811c9b:	89 04 24             	mov    %eax,(%esp)
  811c9e:	e8 02 8c ff ff       	call   80a8a5 <ntohs>
  811ca3:	0f b6 c0             	movzbl %al,%eax
  811ca6:	89 04 24             	mov    %eax,(%esp)
  811ca9:	e8 e1 8b ff ff       	call   80a88f <htons>
  811cae:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  811cb1:	66 89 02             	mov    %ax,(%edx)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  811cb4:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  811cb8:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  811cbc:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  811cc3:	e8 c7 8b ff ff       	call   80a88f <htons>
  811cc8:	66 39 45 e2          	cmp    %ax,-0x1e(%ebp)
  811ccc:	72 28                	jb     811cf6 <icmp_input+0x278>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  811cce:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  811cd1:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  811cd5:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
  811cd9:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  811ce0:	e8 aa 8b ff ff       	call   80a88f <htons>
  811ce5:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
  811ce9:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  811ced:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  811cf0:	66 89 42 02          	mov    %ax,0x2(%edx)
  811cf4:	eb 22                	jmp    811d18 <icmp_input+0x29a>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  811cf6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  811cf9:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  811cfd:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  811d01:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  811d08:	e8 82 8b ff ff       	call   80a88f <htons>
  811d0d:	66 03 45 f2          	add    -0xe(%ebp),%ax
  811d11:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  811d14:	66 89 42 02          	mov    %ax,0x2(%edx)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  811d18:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  811d1c:	89 04 24             	mov    %eax,(%esp)
  811d1f:	e8 81 8b ff ff       	call   80a8a5 <ntohs>
  811d24:	66 0d 00 ff          	or     $0xff00,%ax
  811d28:	0f b7 c0             	movzwl %ax,%eax
  811d2b:	89 04 24             	mov    %eax,(%esp)
  811d2e:	e8 5c 8b ff ff       	call   80a88f <htons>
  811d33:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  811d37:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  811d3d:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  811d44:	00 
  811d45:	89 3c 24             	mov    %edi,(%esp)
  811d48:	e8 2a 88 ff ff       	call   80a577 <inet_chksum>
  811d4d:	66 89 47 0a          	mov    %ax,0xa(%edi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  811d51:	0f bf 45 ea          	movswl -0x16(%ebp),%eax
  811d55:	89 44 24 04          	mov    %eax,0x4(%esp)
  811d59:	89 34 24             	mov    %esi,(%esp)
  811d5c:	e8 a7 59 ff ff       	call   807708 <pbuf_header>
  811d61:	84 c0                	test   %al,%al
  811d63:	74 1c                	je     811d81 <icmp_input+0x303>
      LWIP_ASSERT("Can't move over header in packet", 0);
  811d65:	c7 44 24 08 70 3c 81 	movl   $0x813c70,0x8(%esp)
  811d6c:	00 
  811d6d:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  811d74:	00 
  811d75:	c7 04 24 60 4c 81 00 	movl   $0x814c60,(%esp)
  811d7c:	e8 2b eb fe ff       	call   8008ac <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  811d81:	8b 45 0c             	mov    0xc(%ebp),%eax
  811d84:	89 44 24 18          	mov    %eax,0x18(%esp)
  811d88:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811d8f:	00 
  811d90:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  811d97:	00 
  811d98:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811d9f:	00 
  811da0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811da7:	00 
  811da8:	8d 47 0c             	lea    0xc(%edi),%eax
  811dab:	89 44 24 04          	mov    %eax,0x4(%esp)
  811daf:	89 34 24             	mov    %esi,(%esp)
  811db2:	e8 29 77 ff ff       	call   8094e0 <ip_output_if>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  811db7:	89 34 24             	mov    %esi,(%esp)
  811dba:	e8 b4 5c ff ff       	call   807a73 <pbuf_free>
  811dbf:	eb 12                	jmp    811dd3 <icmp_input+0x355>
  return;
lenerr:
  pbuf_free(p);
  811dc1:	89 34 24             	mov    %esi,(%esp)
  811dc4:	e8 aa 5c ff ff       	call   807a73 <pbuf_free>
  811dc9:	eb 08                	jmp    811dd3 <icmp_input+0x355>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
memerr:
  pbuf_free(p);
  811dcb:	89 34 24             	mov    %esi,(%esp)
  811dce:	e8 a0 5c ff ff       	call   807a73 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  811dd3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  811dd6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  811dd9:	8b 7d fc             	mov    -0x4(%ebp),%edi
  811ddc:	89 ec                	mov    %ebp,%esp
  811dde:	5d                   	pop    %ebp
  811ddf:	c3                   	ret    

00811de0 <__udivdi3>:
  811de0:	55                   	push   %ebp
  811de1:	89 e5                	mov    %esp,%ebp
  811de3:	57                   	push   %edi
  811de4:	56                   	push   %esi
  811de5:	83 ec 18             	sub    $0x18,%esp
  811de8:	8b 45 10             	mov    0x10(%ebp),%eax
  811deb:	8b 55 14             	mov    0x14(%ebp),%edx
  811dee:	8b 75 0c             	mov    0xc(%ebp),%esi
  811df1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  811df4:	89 c1                	mov    %eax,%ecx
  811df6:	8b 45 08             	mov    0x8(%ebp),%eax
  811df9:	85 d2                	test   %edx,%edx
  811dfb:	89 d7                	mov    %edx,%edi
  811dfd:	89 45 ec             	mov    %eax,-0x14(%ebp)
  811e00:	75 1e                	jne    811e20 <__udivdi3+0x40>
  811e02:	39 f1                	cmp    %esi,%ecx
  811e04:	0f 86 8d 00 00 00    	jbe    811e97 <__udivdi3+0xb7>
  811e0a:	89 f2                	mov    %esi,%edx
  811e0c:	31 f6                	xor    %esi,%esi
  811e0e:	f7 f1                	div    %ecx
  811e10:	89 c1                	mov    %eax,%ecx
  811e12:	89 c8                	mov    %ecx,%eax
  811e14:	89 f2                	mov    %esi,%edx
  811e16:	83 c4 18             	add    $0x18,%esp
  811e19:	5e                   	pop    %esi
  811e1a:	5f                   	pop    %edi
  811e1b:	5d                   	pop    %ebp
  811e1c:	c3                   	ret    
  811e1d:	8d 76 00             	lea    0x0(%esi),%esi
  811e20:	39 f2                	cmp    %esi,%edx
  811e22:	0f 87 a8 00 00 00    	ja     811ed0 <__udivdi3+0xf0>
  811e28:	0f bd c2             	bsr    %edx,%eax
  811e2b:	83 f0 1f             	xor    $0x1f,%eax
  811e2e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  811e31:	0f 84 89 00 00 00    	je     811ec0 <__udivdi3+0xe0>
  811e37:	b8 20 00 00 00       	mov    $0x20,%eax
  811e3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  811e3f:	2b 45 e8             	sub    -0x18(%ebp),%eax
  811e42:	89 c1                	mov    %eax,%ecx
  811e44:	d3 ea                	shr    %cl,%edx
  811e46:	0f b6 4d e8          	movzbl -0x18(%ebp),%ecx
  811e4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  811e4d:	89 f8                	mov    %edi,%eax
  811e4f:	8b 7d f4             	mov    -0xc(%ebp),%edi
  811e52:	d3 e0                	shl    %cl,%eax
  811e54:	09 c2                	or     %eax,%edx
  811e56:	8b 45 ec             	mov    -0x14(%ebp),%eax
  811e59:	d3 e7                	shl    %cl,%edi
  811e5b:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811e5f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  811e62:	89 f2                	mov    %esi,%edx
  811e64:	d3 e8                	shr    %cl,%eax
  811e66:	0f b6 4d e8          	movzbl -0x18(%ebp),%ecx
  811e6a:	d3 e2                	shl    %cl,%edx
  811e6c:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811e70:	09 d0                	or     %edx,%eax
  811e72:	d3 ee                	shr    %cl,%esi
  811e74:	89 f2                	mov    %esi,%edx
  811e76:	f7 75 e4             	divl   -0x1c(%ebp)
  811e79:	89 d1                	mov    %edx,%ecx
  811e7b:	89 75 e0             	mov    %esi,-0x20(%ebp)
  811e7e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  811e81:	f7 e7                	mul    %edi
  811e83:	39 d1                	cmp    %edx,%ecx
  811e85:	89 c6                	mov    %eax,%esi
  811e87:	72 70                	jb     811ef9 <__udivdi3+0x119>
  811e89:	39 ca                	cmp    %ecx,%edx
  811e8b:	74 5f                	je     811eec <__udivdi3+0x10c>
  811e8d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  811e90:	31 f6                	xor    %esi,%esi
  811e92:	e9 7b ff ff ff       	jmp    811e12 <__udivdi3+0x32>
  811e97:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811e9a:	85 c0                	test   %eax,%eax
  811e9c:	75 0c                	jne    811eaa <__udivdi3+0xca>
  811e9e:	b8 01 00 00 00       	mov    $0x1,%eax
  811ea3:	31 d2                	xor    %edx,%edx
  811ea5:	f7 75 f4             	divl   -0xc(%ebp)
  811ea8:	89 c1                	mov    %eax,%ecx
  811eaa:	89 f0                	mov    %esi,%eax
  811eac:	89 fa                	mov    %edi,%edx
  811eae:	f7 f1                	div    %ecx
  811eb0:	89 c6                	mov    %eax,%esi
  811eb2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  811eb5:	f7 f1                	div    %ecx
  811eb7:	89 c1                	mov    %eax,%ecx
  811eb9:	e9 54 ff ff ff       	jmp    811e12 <__udivdi3+0x32>
  811ebe:	66 90                	xchg   %ax,%ax
  811ec0:	39 d6                	cmp    %edx,%esi
  811ec2:	77 1c                	ja     811ee0 <__udivdi3+0x100>
  811ec4:	8b 55 f4             	mov    -0xc(%ebp),%edx
  811ec7:	39 55 ec             	cmp    %edx,-0x14(%ebp)
  811eca:	73 14                	jae    811ee0 <__udivdi3+0x100>
  811ecc:	8d 74 26 00          	lea    0x0(%esi),%esi
  811ed0:	31 c9                	xor    %ecx,%ecx
  811ed2:	31 f6                	xor    %esi,%esi
  811ed4:	e9 39 ff ff ff       	jmp    811e12 <__udivdi3+0x32>
  811ed9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  811ee0:	b9 01 00 00 00       	mov    $0x1,%ecx
  811ee5:	31 f6                	xor    %esi,%esi
  811ee7:	e9 26 ff ff ff       	jmp    811e12 <__udivdi3+0x32>
  811eec:	8b 45 ec             	mov    -0x14(%ebp),%eax
  811eef:	0f b6 4d e8          	movzbl -0x18(%ebp),%ecx
  811ef3:	d3 e0                	shl    %cl,%eax
  811ef5:	39 c6                	cmp    %eax,%esi
  811ef7:	76 94                	jbe    811e8d <__udivdi3+0xad>
  811ef9:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  811efc:	31 f6                	xor    %esi,%esi
  811efe:	83 e9 01             	sub    $0x1,%ecx
  811f01:	e9 0c ff ff ff       	jmp    811e12 <__udivdi3+0x32>
	...

00811f10 <__umoddi3>:
  811f10:	55                   	push   %ebp
  811f11:	89 e5                	mov    %esp,%ebp
  811f13:	57                   	push   %edi
  811f14:	56                   	push   %esi
  811f15:	83 ec 30             	sub    $0x30,%esp
  811f18:	8b 45 10             	mov    0x10(%ebp),%eax
  811f1b:	8b 55 14             	mov    0x14(%ebp),%edx
  811f1e:	8b 75 08             	mov    0x8(%ebp),%esi
  811f21:	8b 7d 0c             	mov    0xc(%ebp),%edi
  811f24:	89 45 ec             	mov    %eax,-0x14(%ebp)
  811f27:	89 c1                	mov    %eax,%ecx
  811f29:	89 55 e8             	mov    %edx,-0x18(%ebp)
  811f2c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  811f2f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  811f36:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  811f3d:	89 fa                	mov    %edi,%edx
  811f3f:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  811f42:	85 c0                	test   %eax,%eax
  811f44:	89 75 f0             	mov    %esi,-0x10(%ebp)
  811f47:	89 7d e0             	mov    %edi,-0x20(%ebp)
  811f4a:	75 14                	jne    811f60 <__umoddi3+0x50>
  811f4c:	39 f9                	cmp    %edi,%ecx
  811f4e:	76 60                	jbe    811fb0 <__umoddi3+0xa0>
  811f50:	89 f0                	mov    %esi,%eax
  811f52:	f7 f1                	div    %ecx
  811f54:	89 55 d0             	mov    %edx,-0x30(%ebp)
  811f57:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  811f5e:	eb 10                	jmp    811f70 <__umoddi3+0x60>
  811f60:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  811f63:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
  811f66:	76 18                	jbe    811f80 <__umoddi3+0x70>
  811f68:	89 75 d0             	mov    %esi,-0x30(%ebp)
  811f6b:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  811f6e:	66 90                	xchg   %ax,%ax
  811f70:	8b 45 d0             	mov    -0x30(%ebp),%eax
  811f73:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  811f76:	83 c4 30             	add    $0x30,%esp
  811f79:	5e                   	pop    %esi
  811f7a:	5f                   	pop    %edi
  811f7b:	5d                   	pop    %ebp
  811f7c:	c3                   	ret    
  811f7d:	8d 76 00             	lea    0x0(%esi),%esi
  811f80:	0f bd 45 e8          	bsr    -0x18(%ebp),%eax
  811f84:	83 f0 1f             	xor    $0x1f,%eax
  811f87:	89 45 d8             	mov    %eax,-0x28(%ebp)
  811f8a:	75 46                	jne    811fd2 <__umoddi3+0xc2>
  811f8c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  811f8f:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  811f92:	0f 87 c9 00 00 00    	ja     812061 <__umoddi3+0x151>
  811f98:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  811f9b:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  811f9e:	0f 83 bd 00 00 00    	jae    812061 <__umoddi3+0x151>
  811fa4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  811fa7:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  811faa:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  811fad:	eb c1                	jmp    811f70 <__umoddi3+0x60>
  811faf:	90                   	nop    
  811fb0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  811fb3:	85 c0                	test   %eax,%eax
  811fb5:	75 0c                	jne    811fc3 <__umoddi3+0xb3>
  811fb7:	b8 01 00 00 00       	mov    $0x1,%eax
  811fbc:	31 d2                	xor    %edx,%edx
  811fbe:	f7 75 ec             	divl   -0x14(%ebp)
  811fc1:	89 c1                	mov    %eax,%ecx
  811fc3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  811fc6:	8b 55 e8             	mov    -0x18(%ebp),%edx
  811fc9:	f7 f1                	div    %ecx
  811fcb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  811fce:	f7 f1                	div    %ecx
  811fd0:	eb 82                	jmp    811f54 <__umoddi3+0x44>
  811fd2:	b8 20 00 00 00       	mov    $0x20,%eax
  811fd7:	8b 55 ec             	mov    -0x14(%ebp),%edx
  811fda:	2b 45 d8             	sub    -0x28(%ebp),%eax
  811fdd:	8b 75 ec             	mov    -0x14(%ebp),%esi
  811fe0:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  811fe3:	89 c1                	mov    %eax,%ecx
  811fe5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  811fe8:	d3 ea                	shr    %cl,%edx
  811fea:	8b 45 e8             	mov    -0x18(%ebp),%eax
  811fed:	0f b6 4d d8          	movzbl -0x28(%ebp),%ecx
  811ff1:	d3 e0                	shl    %cl,%eax
  811ff3:	09 c2                	or     %eax,%edx
  811ff5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  811ff8:	d3 e6                	shl    %cl,%esi
  811ffa:	0f b6 4d dc          	movzbl -0x24(%ebp),%ecx
  811ffe:	89 55 f4             	mov    %edx,-0xc(%ebp)
  812001:	8b 55 e0             	mov    -0x20(%ebp),%edx
  812004:	d3 e8                	shr    %cl,%eax
  812006:	0f b6 4d d8          	movzbl -0x28(%ebp),%ecx
  81200a:	d3 e2                	shl    %cl,%edx
  81200c:	09 d0                	or     %edx,%eax
  81200e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  812011:	d3 e7                	shl    %cl,%edi
  812013:	0f b6 4d dc          	movzbl -0x24(%ebp),%ecx
  812017:	d3 ea                	shr    %cl,%edx
  812019:	f7 75 f4             	divl   -0xc(%ebp)
  81201c:	89 55 cc             	mov    %edx,-0x34(%ebp)
  81201f:	f7 e6                	mul    %esi
  812021:	39 55 cc             	cmp    %edx,-0x34(%ebp)
  812024:	72 53                	jb     812079 <__umoddi3+0x169>
  812026:	3b 55 cc             	cmp    -0x34(%ebp),%edx
  812029:	74 4a                	je     812075 <__umoddi3+0x165>
  81202b:	90                   	nop    
  81202c:	8d 74 26 00          	lea    0x0(%esi),%esi
  812030:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  812033:	29 c7                	sub    %eax,%edi
  812035:	19 d1                	sbb    %edx,%ecx
  812037:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  81203a:	0f b6 4d d8          	movzbl -0x28(%ebp),%ecx
  81203e:	89 fa                	mov    %edi,%edx
  812040:	8b 45 cc             	mov    -0x34(%ebp),%eax
  812043:	d3 ea                	shr    %cl,%edx
  812045:	0f b6 4d dc          	movzbl -0x24(%ebp),%ecx
  812049:	d3 e0                	shl    %cl,%eax
  81204b:	0f b6 4d d8          	movzbl -0x28(%ebp),%ecx
  81204f:	09 c2                	or     %eax,%edx
  812051:	8b 45 cc             	mov    -0x34(%ebp),%eax
  812054:	89 55 d0             	mov    %edx,-0x30(%ebp)
  812057:	d3 e8                	shr    %cl,%eax
  812059:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  81205c:	e9 0f ff ff ff       	jmp    811f70 <__umoddi3+0x60>
  812061:	8b 55 e0             	mov    -0x20(%ebp),%edx
  812064:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  812067:	2b 45 ec             	sub    -0x14(%ebp),%eax
  81206a:	1b 55 e8             	sbb    -0x18(%ebp),%edx
  81206d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  812070:	e9 2f ff ff ff       	jmp    811fa4 <__umoddi3+0x94>
  812075:	39 f8                	cmp    %edi,%eax
  812077:	76 b7                	jbe    812030 <__umoddi3+0x120>
  812079:	29 f0                	sub    %esi,%eax
  81207b:	1b 55 f4             	sbb    -0xc(%ebp),%edx
  81207e:	eb b0                	jmp    812030 <__umoddi3+0x120>
